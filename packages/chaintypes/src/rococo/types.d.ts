// Generated by @dedot/codegen

import type {
  Phase,
  H256,
  DispatchInfo,
  DispatchError,
  AccountId32,
  FixedBytes,
  Bytes,
  FixedArray,
  BytesLike,
  Header,
  MultiAddress,
  MultiAddressLike,
  AccountId32Like,
  EthereumAddress,
  EthereumAddressLike,
  Data,
  FixedU128,
  Perquintill,
  Perbill,
  BitSequence,
  Result,
  FixedI64,
  Era,
  UncheckedExtrinsic,
} from '@dedot/codecs';

export type FrameSystemAccountInfo = {
  nonce: number;
  consumers: number;
  providers: number;
  sufficients: number;
  data: PalletBalancesAccountData;
};

export type PalletBalancesAccountData = {
  free: bigint;
  reserved: bigint;
  frozen: bigint;
  flags: PalletBalancesExtraFlags;
};

export type PalletBalancesExtraFlags = bigint;

export type FrameSupportDispatchPerDispatchClass = {
  normal: SpWeightsWeightV2Weight;
  operational: SpWeightsWeightV2Weight;
  mandatory: SpWeightsWeightV2Weight;
};

export type SpWeightsWeightV2Weight = { refTime: bigint; proofSize: bigint };

export type FrameSystemEventRecord = { phase: Phase; event: RococoRuntimeRuntimeEvent; topics: Array<H256> };

export type RococoRuntimeRuntimeEvent =
  | { pallet: 'System'; palletEvent: FrameSystemEvent }
  | { pallet: 'Indices'; palletEvent: PalletIndicesEvent }
  | { pallet: 'Balances'; palletEvent: PalletBalancesEvent }
  | { pallet: 'TransactionPayment'; palletEvent: PalletTransactionPaymentEvent }
  | { pallet: 'Offences'; palletEvent: PalletOffencesEvent }
  | { pallet: 'Session'; palletEvent: PalletSessionEvent }
  | { pallet: 'Grandpa'; palletEvent: PalletGrandpaEvent }
  | { pallet: 'Treasury'; palletEvent: PalletTreasuryEvent }
  | { pallet: 'ConvictionVoting'; palletEvent: PalletConvictionVotingEvent }
  | { pallet: 'Referenda'; palletEvent: PalletReferendaEvent }
  | { pallet: 'FellowshipCollective'; palletEvent: PalletRankedCollectiveEvent }
  | { pallet: 'FellowshipReferenda'; palletEvent: PalletReferendaEvent002 }
  | { pallet: 'Whitelist'; palletEvent: PalletWhitelistEvent }
  | { pallet: 'Claims'; palletEvent: PolkadotRuntimeCommonClaimsPalletEvent }
  | { pallet: 'Utility'; palletEvent: PalletUtilityEvent }
  | { pallet: 'Identity'; palletEvent: PalletIdentityEvent }
  | { pallet: 'Society'; palletEvent: PalletSocietyEvent }
  | { pallet: 'Recovery'; palletEvent: PalletRecoveryEvent }
  | { pallet: 'Vesting'; palletEvent: PalletVestingEvent }
  | { pallet: 'Scheduler'; palletEvent: PalletSchedulerEvent }
  | { pallet: 'Proxy'; palletEvent: PalletProxyEvent }
  | { pallet: 'Multisig'; palletEvent: PalletMultisigEvent }
  | { pallet: 'Preimage'; palletEvent: PalletPreimageEvent }
  | { pallet: 'AssetRate'; palletEvent: PalletAssetRateEvent }
  | { pallet: 'Bounties'; palletEvent: PalletBountiesEvent }
  | { pallet: 'ChildBounties'; palletEvent: PalletChildBountiesEvent }
  | { pallet: 'Nis'; palletEvent: PalletNisEvent }
  | { pallet: 'NisCounterpartBalances'; palletEvent: PalletBalancesEvent }
  | { pallet: 'ParaInclusion'; palletEvent: PolkadotRuntimeParachainsInclusionPalletEvent }
  | { pallet: 'Paras'; palletEvent: PolkadotRuntimeParachainsParasPalletEvent }
  | { pallet: 'Hrmp'; palletEvent: PolkadotRuntimeParachainsHrmpPalletEvent }
  | { pallet: 'ParasDisputes'; palletEvent: PolkadotRuntimeParachainsDisputesPalletEvent }
  | { pallet: 'MessageQueue'; palletEvent: PalletMessageQueueEvent }
  | { pallet: 'OnDemandAssignmentProvider'; palletEvent: PolkadotRuntimeParachainsAssignerOnDemandPalletEvent }
  | { pallet: 'Registrar'; palletEvent: PolkadotRuntimeCommonParasRegistrarPalletEvent }
  | { pallet: 'Slots'; palletEvent: PolkadotRuntimeCommonSlotsPalletEvent }
  | { pallet: 'Auctions'; palletEvent: PolkadotRuntimeCommonAuctionsPalletEvent }
  | { pallet: 'Crowdloan'; palletEvent: PolkadotRuntimeCommonCrowdloanPalletEvent }
  | { pallet: 'Coretime'; palletEvent: PolkadotRuntimeParachainsCoretimePalletEvent }
  | { pallet: 'XcmPallet'; palletEvent: PalletXcmEvent }
  | { pallet: 'IdentityMigrator'; palletEvent: PolkadotRuntimeCommonIdentityMigratorPalletEvent }
  | { pallet: 'AssignedSlots'; palletEvent: PolkadotRuntimeCommonAssignedSlotsPalletEvent }
  | { pallet: 'ValidatorManager'; palletEvent: RococoRuntimeValidatorManagerPalletEvent }
  | { pallet: 'StateTrieMigration'; palletEvent: PalletStateTrieMigrationEvent }
  | { pallet: 'RootTesting'; palletEvent: PalletRootTestingEvent }
  | { pallet: 'Sudo'; palletEvent: PalletSudoEvent };

/**
 * Event for the System pallet.
 **/
export type FrameSystemEvent =
  /**
   * An extrinsic completed successfully.
   **/
  | { name: 'ExtrinsicSuccess'; data: { dispatchInfo: DispatchInfo } }
  /**
   * An extrinsic failed.
   **/
  | { name: 'ExtrinsicFailed'; data: { dispatchError: DispatchError; dispatchInfo: DispatchInfo } }
  /**
   * `:code` was updated.
   **/
  | { name: 'CodeUpdated' }
  /**
   * A new account was created.
   **/
  | { name: 'NewAccount'; data: { account: AccountId32 } }
  /**
   * An account was reaped.
   **/
  | { name: 'KilledAccount'; data: { account: AccountId32 } }
  /**
   * On on-chain remark happened.
   **/
  | { name: 'Remarked'; data: { sender: AccountId32; hash: H256 } }
  /**
   * An upgrade was authorized.
   **/
  | { name: 'UpgradeAuthorized'; data: { codeHash: H256; checkVersion: boolean } };

export type FrameSupportDispatchDispatchClass = 'Normal' | 'Operational' | 'Mandatory';

export type FrameSupportDispatchPays = 'Yes' | 'No';

/**
 * The `Event` enum of this pallet
 **/
export type PalletIndicesEvent =
  /**
   * A account index was assigned.
   **/
  | { name: 'IndexAssigned'; data: { who: AccountId32; index: number } }
  /**
   * A account index has been freed up (unassigned).
   **/
  | { name: 'IndexFreed'; data: { index: number } }
  /**
   * A account index has been frozen to its current account ID.
   **/
  | { name: 'IndexFrozen'; data: { index: number; who: AccountId32 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletBalancesEvent =
  /**
   * An account was created with some free balance.
   **/
  | { name: 'Endowed'; data: { account: AccountId32; freeBalance: bigint } }
  /**
   * An account was removed whose balance was non-zero but below ExistentialDeposit,
   * resulting in an outright loss.
   **/
  | { name: 'DustLost'; data: { account: AccountId32; amount: bigint } }
  /**
   * Transfer succeeded.
   **/
  | { name: 'Transfer'; data: { from: AccountId32; to: AccountId32; amount: bigint } }
  /**
   * A balance was set by root.
   **/
  | { name: 'BalanceSet'; data: { who: AccountId32; free: bigint } }
  /**
   * Some balance was reserved (moved from free to reserved).
   **/
  | { name: 'Reserved'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was unreserved (moved from reserved to free).
   **/
  | { name: 'Unreserved'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was moved from the reserve of the first account to the second account.
   * Final argument indicates the destination balance type.
   **/
  | {
      name: 'ReserveRepatriated';
      data: {
        from: AccountId32;
        to: AccountId32;
        amount: bigint;
        destinationStatus: FrameSupportTokensMiscBalanceStatus;
      };
    }
  /**
   * Some amount was deposited (e.g. for transaction fees).
   **/
  | { name: 'Deposit'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was withdrawn from the account (e.g. for transaction fees).
   **/
  | { name: 'Withdraw'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was removed from the account (e.g. for misbehavior).
   **/
  | { name: 'Slashed'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was minted into an account.
   **/
  | { name: 'Minted'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was burned from an account.
   **/
  | { name: 'Burned'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was suspended from an account (it can be restored later).
   **/
  | { name: 'Suspended'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was restored into an account.
   **/
  | { name: 'Restored'; data: { who: AccountId32; amount: bigint } }
  /**
   * An account was upgraded.
   **/
  | { name: 'Upgraded'; data: { who: AccountId32 } }
  /**
   * Total issuance was increased by `amount`, creating a credit to be balanced.
   **/
  | { name: 'Issued'; data: { amount: bigint } }
  /**
   * Total issuance was decreased by `amount`, creating a debt to be balanced.
   **/
  | { name: 'Rescinded'; data: { amount: bigint } }
  /**
   * Some balance was locked.
   **/
  | { name: 'Locked'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was unlocked.
   **/
  | { name: 'Unlocked'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was frozen.
   **/
  | { name: 'Frozen'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was thawed.
   **/
  | { name: 'Thawed'; data: { who: AccountId32; amount: bigint } }
  /**
   * The `TotalIssuance` was forcefully changed.
   **/
  | { name: 'TotalIssuanceForced'; data: { old: bigint; new: bigint } };

export type FrameSupportTokensMiscBalanceStatus = 'Free' | 'Reserved';

/**
 * The `Event` enum of this pallet
 **/
export type PalletTransactionPaymentEvent =
  /**
   * A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,
   * has been paid by `who`.
   **/
  { name: 'TransactionFeePaid'; data: { who: AccountId32; actualFee: bigint; tip: bigint } };

/**
 * Events type.
 **/
export type PalletOffencesEvent =
  /**
   * There is an offence reported of the given `kind` happened at the `session_index` and
   * (kind-specific) time slot. This event is not deposited for duplicate slashes.
   * \[kind, timeslot\].
   **/
  { name: 'Offence'; data: { kind: FixedBytes<16>; timeslot: Bytes } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletSessionEvent =
  /**
   * New session has happened. Note that the argument is the session index, not the
   * block number as the type might suggest.
   **/
  { name: 'NewSession'; data: { sessionIndex: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletGrandpaEvent =
  /**
   * New authority set has been applied.
   **/
  | { name: 'NewAuthorities'; data: { authoritySet: Array<[SpConsensusGrandpaAppPublic, bigint]> } }
  /**
   * Current authority set has been paused.
   **/
  | { name: 'Paused' }
  /**
   * Current authority set has been resumed.
   **/
  | { name: 'Resumed' };

export type SpConsensusGrandpaAppPublic = SpCoreEd25519Public;

export type SpCoreEd25519Public = FixedBytes<32>;

/**
 * The `Event` enum of this pallet
 **/
export type PalletTreasuryEvent =
  /**
   * New proposal.
   **/
  | { name: 'Proposed'; data: { proposalIndex: number } }
  /**
   * We have ended a spend period and will now allocate funds.
   **/
  | { name: 'Spending'; data: { budgetRemaining: bigint } }
  /**
   * Some funds have been allocated.
   **/
  | { name: 'Awarded'; data: { proposalIndex: number; award: bigint; account: AccountId32 } }
  /**
   * A proposal was rejected; funds were slashed.
   **/
  | { name: 'Rejected'; data: { proposalIndex: number; slashed: bigint } }
  /**
   * Some of our funds have been burnt.
   **/
  | { name: 'Burnt'; data: { burntFunds: bigint } }
  /**
   * Spending has finished; this is the amount that rolls over until next spend.
   **/
  | { name: 'Rollover'; data: { rolloverBalance: bigint } }
  /**
   * Some funds have been deposited.
   **/
  | { name: 'Deposit'; data: { value: bigint } }
  /**
   * A new spend proposal has been approved.
   **/
  | { name: 'SpendApproved'; data: { proposalIndex: number; amount: bigint; beneficiary: AccountId32 } }
  /**
   * The inactive funds of the pallet have been updated.
   **/
  | { name: 'UpdatedInactive'; data: { reactivated: bigint; deactivated: bigint } }
  /**
   * A new asset spend proposal has been approved.
   **/
  | {
      name: 'AssetSpendApproved';
      data: {
        index: number;
        assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset;
        amount: bigint;
        beneficiary: XcmVersionedLocation;
        validFrom: number;
        expireAt: number;
      };
    }
  /**
   * An approved spend was voided.
   **/
  | { name: 'AssetSpendVoided'; data: { index: number } }
  /**
   * A payment happened.
   **/
  | { name: 'Paid'; data: { index: number; paymentId: bigint } }
  /**
   * A payment failed and can be retried.
   **/
  | { name: 'PaymentFailed'; data: { index: number; paymentId: bigint } }
  /**
   * A spend was processed and removed from the storage. It might have been successfully
   * paid or it may have expired.
   **/
  | { name: 'SpendProcessed'; data: { index: number } };

export type PolkadotRuntimeCommonImplsVersionedLocatableAsset =
  | { tag: 'V3'; value: { location: StagingXcmV3MultilocationMultiLocation; assetId: XcmV3MultiassetAssetId } }
  | { tag: 'V4'; value: { location: StagingXcmV4Location; assetId: StagingXcmV4AssetAssetId } };

export type StagingXcmV3MultilocationMultiLocation = { parents: number; interior: XcmV3Junctions };

export type XcmV3Junctions =
  | { tag: 'Here' }
  | { tag: 'X1'; value: XcmV3Junction }
  | { tag: 'X2'; value: [XcmV3Junction, XcmV3Junction] }
  | { tag: 'X3'; value: [XcmV3Junction, XcmV3Junction, XcmV3Junction] }
  | { tag: 'X4'; value: [XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction] }
  | { tag: 'X5'; value: [XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction] }
  | { tag: 'X6'; value: [XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction] }
  | {
      tag: 'X7';
      value: [XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction];
    }
  | {
      tag: 'X8';
      value: [
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
      ];
    };

export type XcmV3Junction =
  | { tag: 'Parachain'; value: number }
  | { tag: 'AccountId32'; value: { network?: XcmV3JunctionNetworkId | undefined; id: FixedBytes<32> } }
  | { tag: 'AccountIndex64'; value: { network?: XcmV3JunctionNetworkId | undefined; index: bigint } }
  | { tag: 'AccountKey20'; value: { network?: XcmV3JunctionNetworkId | undefined; key: FixedBytes<20> } }
  | { tag: 'PalletInstance'; value: number }
  | { tag: 'GeneralIndex'; value: bigint }
  | { tag: 'GeneralKey'; value: { length: number; data: FixedBytes<32> } }
  | { tag: 'OnlyChild' }
  | { tag: 'Plurality'; value: { id: XcmV3JunctionBodyId; part: XcmV3JunctionBodyPart } }
  | { tag: 'GlobalConsensus'; value: XcmV3JunctionNetworkId };

export type XcmV3JunctionNetworkId =
  | { tag: 'ByGenesis'; value: FixedBytes<32> }
  | { tag: 'ByFork'; value: { blockNumber: bigint; blockHash: FixedBytes<32> } }
  | { tag: 'Polkadot' }
  | { tag: 'Kusama' }
  | { tag: 'Westend' }
  | { tag: 'Rococo' }
  | { tag: 'Wococo' }
  | { tag: 'Ethereum'; value: { chainId: bigint } }
  | { tag: 'BitcoinCore' }
  | { tag: 'BitcoinCash' }
  | { tag: 'PolkadotBulletin' };

export type XcmV3JunctionBodyId =
  | { tag: 'Unit' }
  | { tag: 'Moniker'; value: FixedBytes<4> }
  | { tag: 'Index'; value: number }
  | { tag: 'Executive' }
  | { tag: 'Technical' }
  | { tag: 'Legislative' }
  | { tag: 'Judicial' }
  | { tag: 'Defense' }
  | { tag: 'Administration' }
  | { tag: 'Treasury' };

export type XcmV3JunctionBodyPart =
  | { tag: 'Voice' }
  | { tag: 'Members'; value: { count: number } }
  | { tag: 'Fraction'; value: { nom: number; denom: number } }
  | { tag: 'AtLeastProportion'; value: { nom: number; denom: number } }
  | { tag: 'MoreThanProportion'; value: { nom: number; denom: number } };

export type XcmV3MultiassetAssetId =
  | { tag: 'Concrete'; value: StagingXcmV3MultilocationMultiLocation }
  | { tag: 'Abstract'; value: FixedBytes<32> };

export type StagingXcmV4Location = { parents: number; interior: StagingXcmV4Junctions };

export type StagingXcmV4Junctions =
  | { tag: 'Here' }
  | { tag: 'X1'; value: FixedArray<StagingXcmV4Junction, 1> }
  | { tag: 'X2'; value: FixedArray<StagingXcmV4Junction, 2> }
  | { tag: 'X3'; value: FixedArray<StagingXcmV4Junction, 3> }
  | { tag: 'X4'; value: FixedArray<StagingXcmV4Junction, 4> }
  | { tag: 'X5'; value: FixedArray<StagingXcmV4Junction, 5> }
  | { tag: 'X6'; value: FixedArray<StagingXcmV4Junction, 6> }
  | { tag: 'X7'; value: FixedArray<StagingXcmV4Junction, 7> }
  | { tag: 'X8'; value: FixedArray<StagingXcmV4Junction, 8> };

export type StagingXcmV4Junction =
  | { tag: 'Parachain'; value: number }
  | { tag: 'AccountId32'; value: { network?: StagingXcmV4JunctionNetworkId | undefined; id: FixedBytes<32> } }
  | { tag: 'AccountIndex64'; value: { network?: StagingXcmV4JunctionNetworkId | undefined; index: bigint } }
  | { tag: 'AccountKey20'; value: { network?: StagingXcmV4JunctionNetworkId | undefined; key: FixedBytes<20> } }
  | { tag: 'PalletInstance'; value: number }
  | { tag: 'GeneralIndex'; value: bigint }
  | { tag: 'GeneralKey'; value: { length: number; data: FixedBytes<32> } }
  | { tag: 'OnlyChild' }
  | { tag: 'Plurality'; value: { id: XcmV3JunctionBodyId; part: XcmV3JunctionBodyPart } }
  | { tag: 'GlobalConsensus'; value: StagingXcmV4JunctionNetworkId };

export type StagingXcmV4JunctionNetworkId =
  | { tag: 'ByGenesis'; value: FixedBytes<32> }
  | { tag: 'ByFork'; value: { blockNumber: bigint; blockHash: FixedBytes<32> } }
  | { tag: 'Polkadot' }
  | { tag: 'Kusama' }
  | { tag: 'Westend' }
  | { tag: 'Rococo' }
  | { tag: 'Wococo' }
  | { tag: 'Ethereum'; value: { chainId: bigint } }
  | { tag: 'BitcoinCore' }
  | { tag: 'BitcoinCash' }
  | { tag: 'PolkadotBulletin' };

export type StagingXcmV4AssetAssetId = StagingXcmV4Location;

export type XcmVersionedLocation =
  | { tag: 'V2'; value: XcmV2MultilocationMultiLocation }
  | { tag: 'V3'; value: StagingXcmV3MultilocationMultiLocation }
  | { tag: 'V4'; value: StagingXcmV4Location };

export type XcmV2MultilocationMultiLocation = { parents: number; interior: XcmV2MultilocationJunctions };

export type XcmV2MultilocationJunctions =
  | { tag: 'Here' }
  | { tag: 'X1'; value: XcmV2Junction }
  | { tag: 'X2'; value: [XcmV2Junction, XcmV2Junction] }
  | { tag: 'X3'; value: [XcmV2Junction, XcmV2Junction, XcmV2Junction] }
  | { tag: 'X4'; value: [XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction] }
  | { tag: 'X5'; value: [XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction] }
  | { tag: 'X6'; value: [XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction] }
  | {
      tag: 'X7';
      value: [XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction];
    }
  | {
      tag: 'X8';
      value: [
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
      ];
    };

export type XcmV2Junction =
  | { tag: 'Parachain'; value: number }
  | { tag: 'AccountId32'; value: { network: XcmV2NetworkId; id: FixedBytes<32> } }
  | { tag: 'AccountIndex64'; value: { network: XcmV2NetworkId; index: bigint } }
  | { tag: 'AccountKey20'; value: { network: XcmV2NetworkId; key: FixedBytes<20> } }
  | { tag: 'PalletInstance'; value: number }
  | { tag: 'GeneralIndex'; value: bigint }
  | { tag: 'GeneralKey'; value: Bytes }
  | { tag: 'OnlyChild' }
  | { tag: 'Plurality'; value: { id: XcmV2BodyId; part: XcmV2BodyPart } };

export type XcmV2NetworkId = { tag: 'Any' } | { tag: 'Named'; value: Bytes } | { tag: 'Polkadot' } | { tag: 'Kusama' };

export type XcmV2BodyId =
  | { tag: 'Unit' }
  | { tag: 'Named'; value: Bytes }
  | { tag: 'Index'; value: number }
  | { tag: 'Executive' }
  | { tag: 'Technical' }
  | { tag: 'Legislative' }
  | { tag: 'Judicial' }
  | { tag: 'Defense' }
  | { tag: 'Administration' }
  | { tag: 'Treasury' };

export type XcmV2BodyPart =
  | { tag: 'Voice' }
  | { tag: 'Members'; value: { count: number } }
  | { tag: 'Fraction'; value: { nom: number; denom: number } }
  | { tag: 'AtLeastProportion'; value: { nom: number; denom: number } }
  | { tag: 'MoreThanProportion'; value: { nom: number; denom: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletConvictionVotingEvent =
  /**
   * An account has delegated their vote to another account. \[who, target\]
   **/
  | { name: 'Delegated'; data: [AccountId32, AccountId32] }
  /**
   * An \[account\] has cancelled a previous delegation operation.
   **/
  | { name: 'Undelegated'; data: AccountId32 };

/**
 * The `Event` enum of this pallet
 **/
export type PalletReferendaEvent =
  /**
   * A referendum has been submitted.
   **/
  | {
      name: 'Submitted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The track (and by extension proposal dispatch origin) of this referendum.
         **/
        track: number;

        /**
         * The proposal for the referendum.
         **/
        proposal: FrameSupportPreimagesBounded;
      };
    }
  /**
   * The decision deposit has been placed.
   **/
  | {
      name: 'DecisionDepositPlaced';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * The decision deposit has been refunded.
   **/
  | {
      name: 'DecisionDepositRefunded';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * A deposit has been slashed.
   **/
  | {
      name: 'DepositSlashed';
      data: {
        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * A referendum has moved into the deciding phase.
   **/
  | {
      name: 'DecisionStarted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The track (and by extension proposal dispatch origin) of this referendum.
         **/
        track: number;

        /**
         * The proposal for the referendum.
         **/
        proposal: FrameSupportPreimagesBounded;

        /**
         * The current tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  | {
      name: 'ConfirmStarted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  | {
      name: 'ConfirmAborted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  /**
   * A referendum has ended its confirmation phase and is ready for approval.
   **/
  | {
      name: 'Confirmed';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  /**
   * A referendum has been approved and its proposal has been scheduled.
   **/
  | {
      name: 'Approved';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  /**
   * A proposal has been rejected by referendum.
   **/
  | {
      name: 'Rejected';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  /**
   * A referendum has been timed out without being decided.
   **/
  | {
      name: 'TimedOut';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  /**
   * A referendum has been cancelled.
   **/
  | {
      name: 'Cancelled';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  /**
   * A referendum has been killed.
   **/
  | {
      name: 'Killed';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  /**
   * The submission deposit has been refunded.
   **/
  | {
      name: 'SubmissionDepositRefunded';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * Metadata for a referendum has been set.
   **/
  | {
      name: 'MetadataSet';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    }
  /**
   * Metadata for a referendum has been cleared.
   **/
  | {
      name: 'MetadataCleared';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    };

export type FrameSupportPreimagesBounded =
  | { tag: 'Legacy'; value: { hash: H256 } }
  | { tag: 'Inline'; value: Bytes }
  | { tag: 'Lookup'; value: { hash: H256; len: number } };

export type RococoRuntimeRuntimeCall =
  | { pallet: 'System'; palletCall: FrameSystemCall }
  | { pallet: 'Babe'; palletCall: PalletBabeCall }
  | { pallet: 'Timestamp'; palletCall: PalletTimestampCall }
  | { pallet: 'Indices'; palletCall: PalletIndicesCall }
  | { pallet: 'Balances'; palletCall: PalletBalancesCall }
  | { pallet: 'Session'; palletCall: PalletSessionCall }
  | { pallet: 'Grandpa'; palletCall: PalletGrandpaCall }
  | { pallet: 'Treasury'; palletCall: PalletTreasuryCall }
  | { pallet: 'ConvictionVoting'; palletCall: PalletConvictionVotingCall }
  | { pallet: 'Referenda'; palletCall: PalletReferendaCall }
  | { pallet: 'FellowshipCollective'; palletCall: PalletRankedCollectiveCall }
  | { pallet: 'FellowshipReferenda'; palletCall: PalletReferendaCall }
  | { pallet: 'Whitelist'; palletCall: PalletWhitelistCall }
  | { pallet: 'Claims'; palletCall: PolkadotRuntimeCommonClaimsPalletCall }
  | { pallet: 'Utility'; palletCall: PalletUtilityCall }
  | { pallet: 'Identity'; palletCall: PalletIdentityCall }
  | { pallet: 'Society'; palletCall: PalletSocietyCall }
  | { pallet: 'Recovery'; palletCall: PalletRecoveryCall }
  | { pallet: 'Vesting'; palletCall: PalletVestingCall }
  | { pallet: 'Scheduler'; palletCall: PalletSchedulerCall }
  | { pallet: 'Proxy'; palletCall: PalletProxyCall }
  | { pallet: 'Multisig'; palletCall: PalletMultisigCall }
  | { pallet: 'Preimage'; palletCall: PalletPreimageCall }
  | { pallet: 'AssetRate'; palletCall: PalletAssetRateCall }
  | { pallet: 'Bounties'; palletCall: PalletBountiesCall }
  | { pallet: 'ChildBounties'; palletCall: PalletChildBountiesCall }
  | { pallet: 'Nis'; palletCall: PalletNisCall }
  | { pallet: 'NisCounterpartBalances'; palletCall: PalletBalancesCall }
  | { pallet: 'Configuration'; palletCall: PolkadotRuntimeParachainsConfigurationPalletCall }
  | { pallet: 'ParasShared'; palletCall: PolkadotRuntimeParachainsSharedPalletCall }
  | { pallet: 'ParaInclusion'; palletCall: PolkadotRuntimeParachainsInclusionPalletCall }
  | { pallet: 'ParaInherent'; palletCall: PolkadotRuntimeParachainsParasInherentPalletCall }
  | { pallet: 'Paras'; palletCall: PolkadotRuntimeParachainsParasPalletCall }
  | { pallet: 'Initializer'; palletCall: PolkadotRuntimeParachainsInitializerPalletCall }
  | { pallet: 'Hrmp'; palletCall: PolkadotRuntimeParachainsHrmpPalletCall }
  | { pallet: 'ParasDisputes'; palletCall: PolkadotRuntimeParachainsDisputesPalletCall }
  | { pallet: 'ParasSlashing'; palletCall: PolkadotRuntimeParachainsDisputesSlashingPalletCall }
  | { pallet: 'MessageQueue'; palletCall: PalletMessageQueueCall }
  | { pallet: 'OnDemandAssignmentProvider'; palletCall: PolkadotRuntimeParachainsAssignerOnDemandPalletCall }
  | { pallet: 'Registrar'; palletCall: PolkadotRuntimeCommonParasRegistrarPalletCall }
  | { pallet: 'Slots'; palletCall: PolkadotRuntimeCommonSlotsPalletCall }
  | { pallet: 'Auctions'; palletCall: PolkadotRuntimeCommonAuctionsPalletCall }
  | { pallet: 'Crowdloan'; palletCall: PolkadotRuntimeCommonCrowdloanPalletCall }
  | { pallet: 'Coretime'; palletCall: PolkadotRuntimeParachainsCoretimePalletCall }
  | { pallet: 'XcmPallet'; palletCall: PalletXcmCall }
  | { pallet: 'Beefy'; palletCall: PalletBeefyCall }
  | { pallet: 'IdentityMigrator'; palletCall: PolkadotRuntimeCommonIdentityMigratorPalletCall }
  | { pallet: 'ParasSudoWrapper'; palletCall: PolkadotRuntimeCommonParasSudoWrapperPalletCall }
  | { pallet: 'AssignedSlots'; palletCall: PolkadotRuntimeCommonAssignedSlotsPalletCall }
  | { pallet: 'ValidatorManager'; palletCall: RococoRuntimeValidatorManagerPalletCall }
  | { pallet: 'StateTrieMigration'; palletCall: PalletStateTrieMigrationCall }
  | { pallet: 'RootTesting'; palletCall: PalletRootTestingCall }
  | { pallet: 'Sudo'; palletCall: PalletSudoCall };

export type RococoRuntimeRuntimeCallLike =
  | { pallet: 'System'; palletCall: FrameSystemCallLike }
  | { pallet: 'Babe'; palletCall: PalletBabeCallLike }
  | { pallet: 'Timestamp'; palletCall: PalletTimestampCallLike }
  | { pallet: 'Indices'; palletCall: PalletIndicesCallLike }
  | { pallet: 'Balances'; palletCall: PalletBalancesCallLike }
  | { pallet: 'Session'; palletCall: PalletSessionCallLike }
  | { pallet: 'Grandpa'; palletCall: PalletGrandpaCallLike }
  | { pallet: 'Treasury'; palletCall: PalletTreasuryCallLike }
  | { pallet: 'ConvictionVoting'; palletCall: PalletConvictionVotingCallLike }
  | { pallet: 'Referenda'; palletCall: PalletReferendaCallLike }
  | { pallet: 'FellowshipCollective'; palletCall: PalletRankedCollectiveCallLike }
  | { pallet: 'FellowshipReferenda'; palletCall: PalletReferendaCallLike }
  | { pallet: 'Whitelist'; palletCall: PalletWhitelistCallLike }
  | { pallet: 'Claims'; palletCall: PolkadotRuntimeCommonClaimsPalletCallLike }
  | { pallet: 'Utility'; palletCall: PalletUtilityCallLike }
  | { pallet: 'Identity'; palletCall: PalletIdentityCallLike }
  | { pallet: 'Society'; palletCall: PalletSocietyCallLike }
  | { pallet: 'Recovery'; palletCall: PalletRecoveryCallLike }
  | { pallet: 'Vesting'; palletCall: PalletVestingCallLike }
  | { pallet: 'Scheduler'; palletCall: PalletSchedulerCallLike }
  | { pallet: 'Proxy'; palletCall: PalletProxyCallLike }
  | { pallet: 'Multisig'; palletCall: PalletMultisigCallLike }
  | { pallet: 'Preimage'; palletCall: PalletPreimageCallLike }
  | { pallet: 'AssetRate'; palletCall: PalletAssetRateCallLike }
  | { pallet: 'Bounties'; palletCall: PalletBountiesCallLike }
  | { pallet: 'ChildBounties'; palletCall: PalletChildBountiesCallLike }
  | { pallet: 'Nis'; palletCall: PalletNisCallLike }
  | { pallet: 'NisCounterpartBalances'; palletCall: PalletBalancesCallLike }
  | { pallet: 'Configuration'; palletCall: PolkadotRuntimeParachainsConfigurationPalletCallLike }
  | { pallet: 'ParasShared'; palletCall: PolkadotRuntimeParachainsSharedPalletCallLike }
  | { pallet: 'ParaInclusion'; palletCall: PolkadotRuntimeParachainsInclusionPalletCallLike }
  | { pallet: 'ParaInherent'; palletCall: PolkadotRuntimeParachainsParasInherentPalletCallLike }
  | { pallet: 'Paras'; palletCall: PolkadotRuntimeParachainsParasPalletCallLike }
  | { pallet: 'Initializer'; palletCall: PolkadotRuntimeParachainsInitializerPalletCallLike }
  | { pallet: 'Hrmp'; palletCall: PolkadotRuntimeParachainsHrmpPalletCallLike }
  | { pallet: 'ParasDisputes'; palletCall: PolkadotRuntimeParachainsDisputesPalletCallLike }
  | { pallet: 'ParasSlashing'; palletCall: PolkadotRuntimeParachainsDisputesSlashingPalletCallLike }
  | { pallet: 'MessageQueue'; palletCall: PalletMessageQueueCallLike }
  | { pallet: 'OnDemandAssignmentProvider'; palletCall: PolkadotRuntimeParachainsAssignerOnDemandPalletCallLike }
  | { pallet: 'Registrar'; palletCall: PolkadotRuntimeCommonParasRegistrarPalletCallLike }
  | { pallet: 'Slots'; palletCall: PolkadotRuntimeCommonSlotsPalletCallLike }
  | { pallet: 'Auctions'; palletCall: PolkadotRuntimeCommonAuctionsPalletCallLike }
  | { pallet: 'Crowdloan'; palletCall: PolkadotRuntimeCommonCrowdloanPalletCallLike }
  | { pallet: 'Coretime'; palletCall: PolkadotRuntimeParachainsCoretimePalletCallLike }
  | { pallet: 'XcmPallet'; palletCall: PalletXcmCallLike }
  | { pallet: 'Beefy'; palletCall: PalletBeefyCallLike }
  | { pallet: 'IdentityMigrator'; palletCall: PolkadotRuntimeCommonIdentityMigratorPalletCallLike }
  | { pallet: 'ParasSudoWrapper'; palletCall: PolkadotRuntimeCommonParasSudoWrapperPalletCallLike }
  | { pallet: 'AssignedSlots'; palletCall: PolkadotRuntimeCommonAssignedSlotsPalletCallLike }
  | { pallet: 'ValidatorManager'; palletCall: RococoRuntimeValidatorManagerPalletCallLike }
  | { pallet: 'StateTrieMigration'; palletCall: PalletStateTrieMigrationCallLike }
  | { pallet: 'RootTesting'; palletCall: PalletRootTestingCallLike }
  | { pallet: 'Sudo'; palletCall: PalletSudoCallLike };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type FrameSystemCall =
  /**
   * Make some on-chain remark.
   *
   * Can be executed by every `origin`.
   **/
  | { name: 'Remark'; params: { remark: Bytes } }
  /**
   * Set the number of pages in the WebAssembly environment's heap.
   **/
  | { name: 'SetHeapPages'; params: { pages: bigint } }
  /**
   * Set the new runtime code.
   **/
  | { name: 'SetCode'; params: { code: Bytes } }
  /**
   * Set the new runtime code without doing any checks of the given `code`.
   *
   * Note that runtime upgrades will not run if this is called with a not-increasing spec
   * version!
   **/
  | { name: 'SetCodeWithoutChecks'; params: { code: Bytes } }
  /**
   * Set some items of storage.
   **/
  | { name: 'SetStorage'; params: { items: Array<[Bytes, Bytes]> } }
  /**
   * Kill some items from storage.
   **/
  | { name: 'KillStorage'; params: { keys: Array<Bytes> } }
  /**
   * Kill all storage items with a key that starts with the given prefix.
   *
   * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
   * the prefix we are removing to accurately calculate the weight of this function.
   **/
  | { name: 'KillPrefix'; params: { prefix: Bytes; subkeys: number } }
  /**
   * Make some on-chain remark and emit event.
   **/
  | { name: 'RemarkWithEvent'; params: { remark: Bytes } }
  /**
   * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
   * later.
   *
   * This call requires Root origin.
   **/
  | { name: 'AuthorizeUpgrade'; params: { codeHash: H256 } }
  /**
   * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
   * later.
   *
   * WARNING: This authorizes an upgrade that will take place without any safety checks, for
   * example that the spec name remains the same and that the version number increases. Not
   * recommended for normal use. Use `authorize_upgrade` instead.
   *
   * This call requires Root origin.
   **/
  | { name: 'AuthorizeUpgradeWithoutChecks'; params: { codeHash: H256 } }
  /**
   * Provide the preimage (runtime binary) `code` for an upgrade that has been authorized.
   *
   * If the authorization required a version check, this call will ensure the spec name
   * remains unchanged and that the spec version has increased.
   *
   * Depending on the runtime's `OnSetCode` configuration, this function may directly apply
   * the new `code` in the same block or attempt to schedule the upgrade.
   *
   * All origins are allowed.
   **/
  | { name: 'ApplyAuthorizedUpgrade'; params: { code: Bytes } };

export type FrameSystemCallLike =
  /**
   * Make some on-chain remark.
   *
   * Can be executed by every `origin`.
   **/
  | { name: 'Remark'; params: { remark: BytesLike } }
  /**
   * Set the number of pages in the WebAssembly environment's heap.
   **/
  | { name: 'SetHeapPages'; params: { pages: bigint } }
  /**
   * Set the new runtime code.
   **/
  | { name: 'SetCode'; params: { code: BytesLike } }
  /**
   * Set the new runtime code without doing any checks of the given `code`.
   *
   * Note that runtime upgrades will not run if this is called with a not-increasing spec
   * version!
   **/
  | { name: 'SetCodeWithoutChecks'; params: { code: BytesLike } }
  /**
   * Set some items of storage.
   **/
  | { name: 'SetStorage'; params: { items: Array<[BytesLike, BytesLike]> } }
  /**
   * Kill some items from storage.
   **/
  | { name: 'KillStorage'; params: { keys: Array<BytesLike> } }
  /**
   * Kill all storage items with a key that starts with the given prefix.
   *
   * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
   * the prefix we are removing to accurately calculate the weight of this function.
   **/
  | { name: 'KillPrefix'; params: { prefix: BytesLike; subkeys: number } }
  /**
   * Make some on-chain remark and emit event.
   **/
  | { name: 'RemarkWithEvent'; params: { remark: BytesLike } }
  /**
   * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
   * later.
   *
   * This call requires Root origin.
   **/
  | { name: 'AuthorizeUpgrade'; params: { codeHash: H256 } }
  /**
   * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
   * later.
   *
   * WARNING: This authorizes an upgrade that will take place without any safety checks, for
   * example that the spec name remains the same and that the version number increases. Not
   * recommended for normal use. Use `authorize_upgrade` instead.
   *
   * This call requires Root origin.
   **/
  | { name: 'AuthorizeUpgradeWithoutChecks'; params: { codeHash: H256 } }
  /**
   * Provide the preimage (runtime binary) `code` for an upgrade that has been authorized.
   *
   * If the authorization required a version check, this call will ensure the spec name
   * remains unchanged and that the spec version has increased.
   *
   * Depending on the runtime's `OnSetCode` configuration, this function may directly apply
   * the new `code` in the same block or attempt to schedule the upgrade.
   *
   * All origins are allowed.
   **/
  | { name: 'ApplyAuthorizedUpgrade'; params: { code: BytesLike } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBabeCall =
  /**
   * Report authority equivocation/misbehavior. This method will verify
   * the equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence will
   * be reported.
   **/
  | {
      name: 'ReportEquivocation';
      params: { equivocationProof: SpConsensusSlotsEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * Report authority equivocation/misbehavior. This method will verify
   * the equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence will
   * be reported.
   * This extrinsic must be called unsigned and it is expected that only
   * block authors will call it (validated in `ValidateUnsigned`), as such
   * if the block author is defined it will be defined as the equivocation
   * reporter.
   **/
  | {
      name: 'ReportEquivocationUnsigned';
      params: { equivocationProof: SpConsensusSlotsEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * Plan an epoch config change. The epoch config change is recorded and will be enacted on
   * the next call to `enact_epoch_change`. The config will be activated one epoch after.
   * Multiple calls to this method will replace any existing planned config change that had
   * not been enacted yet.
   **/
  | { name: 'PlanConfigChange'; params: { config: SpConsensusBabeDigestsNextConfigDescriptor } };

export type PalletBabeCallLike =
  /**
   * Report authority equivocation/misbehavior. This method will verify
   * the equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence will
   * be reported.
   **/
  | {
      name: 'ReportEquivocation';
      params: { equivocationProof: SpConsensusSlotsEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * Report authority equivocation/misbehavior. This method will verify
   * the equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence will
   * be reported.
   * This extrinsic must be called unsigned and it is expected that only
   * block authors will call it (validated in `ValidateUnsigned`), as such
   * if the block author is defined it will be defined as the equivocation
   * reporter.
   **/
  | {
      name: 'ReportEquivocationUnsigned';
      params: { equivocationProof: SpConsensusSlotsEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * Plan an epoch config change. The epoch config change is recorded and will be enacted on
   * the next call to `enact_epoch_change`. The config will be activated one epoch after.
   * Multiple calls to this method will replace any existing planned config change that had
   * not been enacted yet.
   **/
  | { name: 'PlanConfigChange'; params: { config: SpConsensusBabeDigestsNextConfigDescriptor } };

export type SpConsensusSlotsEquivocationProof = {
  offender: SpConsensusBabeAppPublic;
  slot: SpConsensusSlotsSlot;
  firstHeader: Header;
  secondHeader: Header;
};

export type SpConsensusBabeAppPublic = SpCoreSr25519Public;

export type SpCoreSr25519Public = FixedBytes<32>;

export type SpConsensusSlotsSlot = bigint;

export type SpSessionMembershipProof = { session: number; trieNodes: Array<Bytes>; validatorCount: number };

export type SpConsensusBabeDigestsNextConfigDescriptor = {
  tag: 'V1';
  value: { c: [bigint, bigint]; allowedSlots: SpConsensusBabeAllowedSlots };
};

export type SpConsensusBabeAllowedSlots =
  | 'PrimarySlots'
  | 'PrimaryAndSecondaryPlainSlots'
  | 'PrimaryAndSecondaryVRFSlots';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTimestampCall =
  /**
   * Set the current time.
   *
   * This call should be invoked exactly once per block. It will panic at the finalization
   * phase, if this call hasn't been invoked by that time.
   *
   * The timestamp should be greater than the previous one by the amount specified by
   * [`Config::MinimumPeriod`].
   *
   * The dispatch origin for this call must be _None_.
   *
   * This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware
   * that changing the complexity of this call could result exhausting the resources in a
   * block to execute any other calls.
   *
   * ## Complexity
   * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
   * - 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in
   * `on_finalize`)
   * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
   **/
  { name: 'Set'; params: { now: bigint } };

export type PalletTimestampCallLike =
  /**
   * Set the current time.
   *
   * This call should be invoked exactly once per block. It will panic at the finalization
   * phase, if this call hasn't been invoked by that time.
   *
   * The timestamp should be greater than the previous one by the amount specified by
   * [`Config::MinimumPeriod`].
   *
   * The dispatch origin for this call must be _None_.
   *
   * This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware
   * that changing the complexity of this call could result exhausting the resources in a
   * block to execute any other calls.
   *
   * ## Complexity
   * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
   * - 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in
   * `on_finalize`)
   * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
   **/
  { name: 'Set'; params: { now: bigint } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletIndicesCall =
  /**
   * Assign an previously unassigned index.
   *
   * Payment: `Deposit` is reserved from the sender account.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `index`: the index to be claimed. This must not be in use.
   *
   * Emits `IndexAssigned` if successful.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'Claim'; params: { index: number } }
  /**
   * Assign an index already owned by the sender to another account. The balance reservation
   * is effectively transferred to the new account.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `index`: the index to be re-assigned. This must be owned by the sender.
   * - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
   *
   * Emits `IndexAssigned` if successful.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'Transfer'; params: { new: MultiAddress; index: number } }
  /**
   * Free up an index owned by the sender.
   *
   * Payment: Any previous deposit placed for the index is unreserved in the sender account.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must own the index.
   *
   * - `index`: the index to be freed. This must be owned by the sender.
   *
   * Emits `IndexFreed` if successful.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'Free'; params: { index: number } }
  /**
   * Force an index to an account. This doesn't require a deposit. If the index is already
   * held, then any deposit is reimbursed to its current owner.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * - `index`: the index to be (re-)assigned.
   * - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
   * - `freeze`: if set to `true`, will freeze the index so it cannot be transferred.
   *
   * Emits `IndexAssigned` if successful.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'ForceTransfer'; params: { new: MultiAddress; index: number; freeze: boolean } }
  /**
   * Freeze an index so it will always point to the sender account. This consumes the
   * deposit.
   *
   * The dispatch origin for this call must be _Signed_ and the signing account must have a
   * non-frozen account `index`.
   *
   * - `index`: the index to be frozen in place.
   *
   * Emits `IndexFrozen` if successful.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'Freeze'; params: { index: number } };

export type PalletIndicesCallLike =
  /**
   * Assign an previously unassigned index.
   *
   * Payment: `Deposit` is reserved from the sender account.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `index`: the index to be claimed. This must not be in use.
   *
   * Emits `IndexAssigned` if successful.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'Claim'; params: { index: number } }
  /**
   * Assign an index already owned by the sender to another account. The balance reservation
   * is effectively transferred to the new account.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `index`: the index to be re-assigned. This must be owned by the sender.
   * - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
   *
   * Emits `IndexAssigned` if successful.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'Transfer'; params: { new: MultiAddressLike; index: number } }
  /**
   * Free up an index owned by the sender.
   *
   * Payment: Any previous deposit placed for the index is unreserved in the sender account.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must own the index.
   *
   * - `index`: the index to be freed. This must be owned by the sender.
   *
   * Emits `IndexFreed` if successful.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'Free'; params: { index: number } }
  /**
   * Force an index to an account. This doesn't require a deposit. If the index is already
   * held, then any deposit is reimbursed to its current owner.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * - `index`: the index to be (re-)assigned.
   * - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
   * - `freeze`: if set to `true`, will freeze the index so it cannot be transferred.
   *
   * Emits `IndexAssigned` if successful.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'ForceTransfer'; params: { new: MultiAddressLike; index: number; freeze: boolean } }
  /**
   * Freeze an index so it will always point to the sender account. This consumes the
   * deposit.
   *
   * The dispatch origin for this call must be _Signed_ and the signing account must have a
   * non-frozen account `index`.
   *
   * - `index`: the index to be frozen in place.
   *
   * Emits `IndexFrozen` if successful.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'Freeze'; params: { index: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBalancesCall =
  /**
   * Transfer some liquid free balance to another account.
   *
   * `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
   * If the sender's account is below the existential deposit as a result
   * of the transfer, the account will be reaped.
   *
   * The dispatch origin for this call must be `Signed` by the transactor.
   **/
  | { name: 'TransferAllowDeath'; params: { dest: MultiAddress; value: bigint } }
  /**
   * Exactly as `transfer_allow_death`, except the origin must be root and the source account
   * may be specified.
   **/
  | { name: 'ForceTransfer'; params: { source: MultiAddress; dest: MultiAddress; value: bigint } }
  /**
   * Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
   * kill the origin account.
   *
   * 99% of the time you want [`transfer_allow_death`] instead.
   *
   * [`transfer_allow_death`]: struct.Pallet.html#method.transfer
   **/
  | { name: 'TransferKeepAlive'; params: { dest: MultiAddress; value: bigint } }
  /**
   * Transfer the entire transferable balance from the caller account.
   *
   * NOTE: This function only attempts to transfer _transferable_ balances. This means that
   * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
   * transferred by this function. To ensure that this function results in a killed account,
   * you might need to prepare the account by removing any reference counters, storage
   * deposits, etc...
   *
   * The dispatch origin of this call must be Signed.
   *
   * - `dest`: The recipient of the transfer.
   * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
   * of the funds the account has, causing the sender account to be killed (false), or
   * transfer everything except at least the existential deposit, which will guarantee to
   * keep the sender account alive (true).
   **/
  | { name: 'TransferAll'; params: { dest: MultiAddress; keepAlive: boolean } }
  /**
   * Unreserve some balance from a user by force.
   *
   * Can only be called by ROOT.
   **/
  | { name: 'ForceUnreserve'; params: { who: MultiAddress; amount: bigint } }
  /**
   * Upgrade a specified account.
   *
   * - `origin`: Must be `Signed`.
   * - `who`: The account to be upgraded.
   *
   * This will waive the transaction fee if at least all but 10% of the accounts needed to
   * be upgraded. (We let some not have to be upgraded just in order to allow for the
   * possibililty of churn).
   **/
  | { name: 'UpgradeAccounts'; params: { who: Array<AccountId32> } }
  /**
   * Set the regular balance of a given account.
   *
   * The dispatch origin for this call is `root`.
   **/
  | { name: 'ForceSetBalance'; params: { who: MultiAddress; newFree: bigint } }
  /**
   * Adjust the total issuance in a saturating way.
   *
   * Can only be called by root and always needs a positive `delta`.
   *
   * # Example
   **/
  | { name: 'ForceAdjustTotalIssuance'; params: { direction: PalletBalancesAdjustmentDirection; delta: bigint } };

export type PalletBalancesCallLike =
  /**
   * Transfer some liquid free balance to another account.
   *
   * `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
   * If the sender's account is below the existential deposit as a result
   * of the transfer, the account will be reaped.
   *
   * The dispatch origin for this call must be `Signed` by the transactor.
   **/
  | { name: 'TransferAllowDeath'; params: { dest: MultiAddressLike; value: bigint } }
  /**
   * Exactly as `transfer_allow_death`, except the origin must be root and the source account
   * may be specified.
   **/
  | { name: 'ForceTransfer'; params: { source: MultiAddressLike; dest: MultiAddressLike; value: bigint } }
  /**
   * Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
   * kill the origin account.
   *
   * 99% of the time you want [`transfer_allow_death`] instead.
   *
   * [`transfer_allow_death`]: struct.Pallet.html#method.transfer
   **/
  | { name: 'TransferKeepAlive'; params: { dest: MultiAddressLike; value: bigint } }
  /**
   * Transfer the entire transferable balance from the caller account.
   *
   * NOTE: This function only attempts to transfer _transferable_ balances. This means that
   * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
   * transferred by this function. To ensure that this function results in a killed account,
   * you might need to prepare the account by removing any reference counters, storage
   * deposits, etc...
   *
   * The dispatch origin of this call must be Signed.
   *
   * - `dest`: The recipient of the transfer.
   * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
   * of the funds the account has, causing the sender account to be killed (false), or
   * transfer everything except at least the existential deposit, which will guarantee to
   * keep the sender account alive (true).
   **/
  | { name: 'TransferAll'; params: { dest: MultiAddressLike; keepAlive: boolean } }
  /**
   * Unreserve some balance from a user by force.
   *
   * Can only be called by ROOT.
   **/
  | { name: 'ForceUnreserve'; params: { who: MultiAddressLike; amount: bigint } }
  /**
   * Upgrade a specified account.
   *
   * - `origin`: Must be `Signed`.
   * - `who`: The account to be upgraded.
   *
   * This will waive the transaction fee if at least all but 10% of the accounts needed to
   * be upgraded. (We let some not have to be upgraded just in order to allow for the
   * possibililty of churn).
   **/
  | { name: 'UpgradeAccounts'; params: { who: Array<AccountId32Like> } }
  /**
   * Set the regular balance of a given account.
   *
   * The dispatch origin for this call is `root`.
   **/
  | { name: 'ForceSetBalance'; params: { who: MultiAddressLike; newFree: bigint } }
  /**
   * Adjust the total issuance in a saturating way.
   *
   * Can only be called by root and always needs a positive `delta`.
   *
   * # Example
   **/
  | { name: 'ForceAdjustTotalIssuance'; params: { direction: PalletBalancesAdjustmentDirection; delta: bigint } };

export type PalletBalancesAdjustmentDirection = 'Increase' | 'Decrease';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSessionCall =
  /**
   * Sets the session key(s) of the function caller to `keys`.
   * Allows an account to set its session key prior to becoming a validator.
   * This doesn't take effect until the next session.
   *
   * The dispatch origin of this function must be signed.
   *
   * ## Complexity
   * - `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is
   * fixed.
   **/
  | { name: 'SetKeys'; params: { keys: RococoRuntimeSessionKeys; proof: Bytes } }
  /**
   * Removes any session key(s) of the function caller.
   *
   * This doesn't take effect until the next session.
   *
   * The dispatch origin of this function must be Signed and the account must be either be
   * convertible to a validator ID using the chain's typical addressing system (this usually
   * means being a controller account) or directly convertible into a validator ID (which
   * usually means being a stash account).
   *
   * ## Complexity
   * - `O(1)` in number of key types. Actual cost depends on the number of length of
   * `T::Keys::key_ids()` which is fixed.
   **/
  | { name: 'PurgeKeys' };

export type PalletSessionCallLike =
  /**
   * Sets the session key(s) of the function caller to `keys`.
   * Allows an account to set its session key prior to becoming a validator.
   * This doesn't take effect until the next session.
   *
   * The dispatch origin of this function must be signed.
   *
   * ## Complexity
   * - `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is
   * fixed.
   **/
  | { name: 'SetKeys'; params: { keys: RococoRuntimeSessionKeys; proof: BytesLike } }
  /**
   * Removes any session key(s) of the function caller.
   *
   * This doesn't take effect until the next session.
   *
   * The dispatch origin of this function must be Signed and the account must be either be
   * convertible to a validator ID using the chain's typical addressing system (this usually
   * means being a controller account) or directly convertible into a validator ID (which
   * usually means being a stash account).
   *
   * ## Complexity
   * - `O(1)` in number of key types. Actual cost depends on the number of length of
   * `T::Keys::key_ids()` which is fixed.
   **/
  | { name: 'PurgeKeys' };

export type RococoRuntimeSessionKeys = {
  grandpa: SpConsensusGrandpaAppPublic;
  babe: SpConsensusBabeAppPublic;
  paraValidator: PolkadotPrimitivesV6ValidatorAppPublic;
  paraAssignment: PolkadotPrimitivesV6AssignmentAppPublic;
  authorityDiscovery: SpAuthorityDiscoveryAppPublic;
  beefy: SpConsensusBeefyEcdsaCryptoPublic;
};

export type PolkadotPrimitivesV6ValidatorAppPublic = SpCoreSr25519Public;

export type PolkadotPrimitivesV6AssignmentAppPublic = SpCoreSr25519Public;

export type SpAuthorityDiscoveryAppPublic = SpCoreSr25519Public;

export type SpConsensusBeefyEcdsaCryptoPublic = SpCoreEcdsaPublic;

export type SpCoreEcdsaPublic = FixedBytes<33>;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletGrandpaCall =
  /**
   * Report voter equivocation/misbehavior. This method will verify the
   * equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence
   * will be reported.
   **/
  | {
      name: 'ReportEquivocation';
      params: { equivocationProof: SpConsensusGrandpaEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * Report voter equivocation/misbehavior. This method will verify the
   * equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence
   * will be reported.
   *
   * This extrinsic must be called unsigned and it is expected that only
   * block authors will call it (validated in `ValidateUnsigned`), as such
   * if the block author is defined it will be defined as the equivocation
   * reporter.
   **/
  | {
      name: 'ReportEquivocationUnsigned';
      params: { equivocationProof: SpConsensusGrandpaEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * Note that the current authority set of the GRANDPA finality gadget has stalled.
   *
   * This will trigger a forced authority set change at the beginning of the next session, to
   * be enacted `delay` blocks after that. The `delay` should be high enough to safely assume
   * that the block signalling the forced change will not be re-orged e.g. 1000 blocks.
   * The block production rate (which may be slowed down because of finality lagging) should
   * be taken into account when choosing the `delay`. The GRANDPA voters based on the new
   * authority will start voting on top of `best_finalized_block_number` for new finalized
   * blocks. `best_finalized_block_number` should be the highest of the latest finalized
   * block of all validators of the new authority set.
   *
   * Only callable by root.
   **/
  | { name: 'NoteStalled'; params: { delay: number; bestFinalizedBlockNumber: number } };

export type PalletGrandpaCallLike =
  /**
   * Report voter equivocation/misbehavior. This method will verify the
   * equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence
   * will be reported.
   **/
  | {
      name: 'ReportEquivocation';
      params: { equivocationProof: SpConsensusGrandpaEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * Report voter equivocation/misbehavior. This method will verify the
   * equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence
   * will be reported.
   *
   * This extrinsic must be called unsigned and it is expected that only
   * block authors will call it (validated in `ValidateUnsigned`), as such
   * if the block author is defined it will be defined as the equivocation
   * reporter.
   **/
  | {
      name: 'ReportEquivocationUnsigned';
      params: { equivocationProof: SpConsensusGrandpaEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * Note that the current authority set of the GRANDPA finality gadget has stalled.
   *
   * This will trigger a forced authority set change at the beginning of the next session, to
   * be enacted `delay` blocks after that. The `delay` should be high enough to safely assume
   * that the block signalling the forced change will not be re-orged e.g. 1000 blocks.
   * The block production rate (which may be slowed down because of finality lagging) should
   * be taken into account when choosing the `delay`. The GRANDPA voters based on the new
   * authority will start voting on top of `best_finalized_block_number` for new finalized
   * blocks. `best_finalized_block_number` should be the highest of the latest finalized
   * block of all validators of the new authority set.
   *
   * Only callable by root.
   **/
  | { name: 'NoteStalled'; params: { delay: number; bestFinalizedBlockNumber: number } };

export type SpConsensusGrandpaEquivocationProof = { setId: bigint; equivocation: SpConsensusGrandpaEquivocation };

export type SpConsensusGrandpaEquivocation =
  | { tag: 'Prevote'; value: FinalityGrandpaEquivocation }
  | { tag: 'Precommit'; value: FinalityGrandpaEquivocationPrecommit };

export type FinalityGrandpaEquivocation = {
  roundNumber: bigint;
  identity: SpConsensusGrandpaAppPublic;
  first: [FinalityGrandpaPrevote, SpConsensusGrandpaAppSignature];
  second: [FinalityGrandpaPrevote, SpConsensusGrandpaAppSignature];
};

export type FinalityGrandpaPrevote = { targetHash: H256; targetNumber: number };

export type SpConsensusGrandpaAppSignature = SpCoreEd25519Signature;

export type SpCoreEd25519Signature = FixedBytes<64>;

export type FinalityGrandpaEquivocationPrecommit = {
  roundNumber: bigint;
  identity: SpConsensusGrandpaAppPublic;
  first: [FinalityGrandpaPrecommit, SpConsensusGrandpaAppSignature];
  second: [FinalityGrandpaPrecommit, SpConsensusGrandpaAppSignature];
};

export type FinalityGrandpaPrecommit = { targetHash: H256; targetNumber: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTreasuryCall =
  /**
   * Put forward a suggestion for spending.
   *
   * ## Dispatch Origin
   *
   * Must be signed.
   *
   * ## Details
   * A deposit proportional to the value is reserved and slashed if the proposal is rejected.
   * It is returned once the proposal is awarded.
   *
   * ### Complexity
   * - O(1)
   *
   * ## Events
   *
   * Emits [`Event::Proposed`] if successful.
   **/
  | { name: 'ProposeSpend'; params: { value: bigint; beneficiary: MultiAddress } }
  /**
   * Reject a proposed spend.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::RejectOrigin`].
   *
   * ## Details
   * The original deposit will be slashed.
   *
   * ### Complexity
   * - O(1)
   *
   * ## Events
   *
   * Emits [`Event::Rejected`] if successful.
   **/
  | { name: 'RejectProposal'; params: { proposalId: number } }
  /**
   * Approve a proposal.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::ApproveOrigin`].
   *
   * ## Details
   *
   * At a later time, the proposal will be allocated to the beneficiary and the original
   * deposit will be returned.
   *
   * ### Complexity
   * - O(1).
   *
   * ## Events
   *
   * No events are emitted from this dispatch.
   **/
  | { name: 'ApproveProposal'; params: { proposalId: number } }
  /**
   * Propose and approve a spend of treasury funds.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::SpendOrigin`] with the `Success` value being at least `amount`.
   *
   * ### Details
   * NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
   * beneficiary.
   *
   * ### Parameters
   * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
   * - `beneficiary`: The destination account for the transfer.
   *
   * ## Events
   *
   * Emits [`Event::SpendApproved`] if successful.
   **/
  | { name: 'SpendLocal'; params: { amount: bigint; beneficiary: MultiAddress } }
  /**
   * Force a previously approved proposal to be removed from the approval queue.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::RejectOrigin`].
   *
   * ## Details
   *
   * The original deposit will no longer be returned.
   *
   * ### Parameters
   * - `proposal_id`: The index of a proposal
   *
   * ### Complexity
   * - O(A) where `A` is the number of approvals
   *
   * ### Errors
   * - [`Error::ProposalNotApproved`]: The `proposal_id` supplied was not found in the
   * approval queue, i.e., the proposal has not been approved. This could also mean the
   * proposal does not exist altogether, thus there is no way it would have been approved
   * in the first place.
   **/
  | { name: 'RemoveApproval'; params: { proposalId: number } }
  /**
   * Propose and approve a spend of treasury funds.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::SpendOrigin`] with the `Success` value being at least
   * `amount` of `asset_kind` in the native asset. The amount of `asset_kind` is converted
   * for assertion using the [`Config::BalanceConverter`].
   *
   * ## Details
   *
   * Create an approved spend for transferring a specific `amount` of `asset_kind` to a
   * designated beneficiary. The spend must be claimed using the `payout` dispatchable within
   * the [`Config::PayoutPeriod`].
   *
   * ### Parameters
   * - `asset_kind`: An indicator of the specific asset class to be spent.
   * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
   * - `beneficiary`: The beneficiary of the spend.
   * - `valid_from`: The block number from which the spend can be claimed. It can refer to
   * the past if the resulting spend has not yet expired according to the
   * [`Config::PayoutPeriod`]. If `None`, the spend can be claimed immediately after
   * approval.
   *
   * ## Events
   *
   * Emits [`Event::AssetSpendApproved`] if successful.
   **/
  | {
      name: 'Spend';
      params: {
        assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset;
        amount: bigint;
        beneficiary: XcmVersionedLocation;
        validFrom?: number | undefined;
      };
    }
  /**
   * Claim a spend.
   *
   * ## Dispatch Origin
   *
   * Must be signed.
   *
   * ## Details
   *
   * Spends must be claimed within some temporal bounds. A spend may be claimed within one
   * [`Config::PayoutPeriod`] from the `valid_from` block.
   * In case of a payout failure, the spend status must be updated with the `check_status`
   * dispatchable before retrying with the current function.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::Paid`] if successful.
   **/
  | { name: 'Payout'; params: { index: number } }
  /**
   * Check the status of the spend and remove it from the storage if processed.
   *
   * ## Dispatch Origin
   *
   * Must be signed.
   *
   * ## Details
   *
   * The status check is a prerequisite for retrying a failed payout.
   * If a spend has either succeeded or expired, it is removed from the storage by this
   * function. In such instances, transaction fees are refunded.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::PaymentFailed`] if the spend payout has failed.
   * Emits [`Event::SpendProcessed`] if the spend payout has succeed.
   **/
  | { name: 'CheckStatus'; params: { index: number } }
  /**
   * Void previously approved spend.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::RejectOrigin`].
   *
   * ## Details
   *
   * A spend void is only possible if the payout has not been attempted yet.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::AssetSpendVoided`] if successful.
   **/
  | { name: 'VoidSpend'; params: { index: number } };

export type PalletTreasuryCallLike =
  /**
   * Put forward a suggestion for spending.
   *
   * ## Dispatch Origin
   *
   * Must be signed.
   *
   * ## Details
   * A deposit proportional to the value is reserved and slashed if the proposal is rejected.
   * It is returned once the proposal is awarded.
   *
   * ### Complexity
   * - O(1)
   *
   * ## Events
   *
   * Emits [`Event::Proposed`] if successful.
   **/
  | { name: 'ProposeSpend'; params: { value: bigint; beneficiary: MultiAddressLike } }
  /**
   * Reject a proposed spend.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::RejectOrigin`].
   *
   * ## Details
   * The original deposit will be slashed.
   *
   * ### Complexity
   * - O(1)
   *
   * ## Events
   *
   * Emits [`Event::Rejected`] if successful.
   **/
  | { name: 'RejectProposal'; params: { proposalId: number } }
  /**
   * Approve a proposal.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::ApproveOrigin`].
   *
   * ## Details
   *
   * At a later time, the proposal will be allocated to the beneficiary and the original
   * deposit will be returned.
   *
   * ### Complexity
   * - O(1).
   *
   * ## Events
   *
   * No events are emitted from this dispatch.
   **/
  | { name: 'ApproveProposal'; params: { proposalId: number } }
  /**
   * Propose and approve a spend of treasury funds.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::SpendOrigin`] with the `Success` value being at least `amount`.
   *
   * ### Details
   * NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
   * beneficiary.
   *
   * ### Parameters
   * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
   * - `beneficiary`: The destination account for the transfer.
   *
   * ## Events
   *
   * Emits [`Event::SpendApproved`] if successful.
   **/
  | { name: 'SpendLocal'; params: { amount: bigint; beneficiary: MultiAddressLike } }
  /**
   * Force a previously approved proposal to be removed from the approval queue.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::RejectOrigin`].
   *
   * ## Details
   *
   * The original deposit will no longer be returned.
   *
   * ### Parameters
   * - `proposal_id`: The index of a proposal
   *
   * ### Complexity
   * - O(A) where `A` is the number of approvals
   *
   * ### Errors
   * - [`Error::ProposalNotApproved`]: The `proposal_id` supplied was not found in the
   * approval queue, i.e., the proposal has not been approved. This could also mean the
   * proposal does not exist altogether, thus there is no way it would have been approved
   * in the first place.
   **/
  | { name: 'RemoveApproval'; params: { proposalId: number } }
  /**
   * Propose and approve a spend of treasury funds.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::SpendOrigin`] with the `Success` value being at least
   * `amount` of `asset_kind` in the native asset. The amount of `asset_kind` is converted
   * for assertion using the [`Config::BalanceConverter`].
   *
   * ## Details
   *
   * Create an approved spend for transferring a specific `amount` of `asset_kind` to a
   * designated beneficiary. The spend must be claimed using the `payout` dispatchable within
   * the [`Config::PayoutPeriod`].
   *
   * ### Parameters
   * - `asset_kind`: An indicator of the specific asset class to be spent.
   * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
   * - `beneficiary`: The beneficiary of the spend.
   * - `valid_from`: The block number from which the spend can be claimed. It can refer to
   * the past if the resulting spend has not yet expired according to the
   * [`Config::PayoutPeriod`]. If `None`, the spend can be claimed immediately after
   * approval.
   *
   * ## Events
   *
   * Emits [`Event::AssetSpendApproved`] if successful.
   **/
  | {
      name: 'Spend';
      params: {
        assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset;
        amount: bigint;
        beneficiary: XcmVersionedLocation;
        validFrom?: number | undefined;
      };
    }
  /**
   * Claim a spend.
   *
   * ## Dispatch Origin
   *
   * Must be signed.
   *
   * ## Details
   *
   * Spends must be claimed within some temporal bounds. A spend may be claimed within one
   * [`Config::PayoutPeriod`] from the `valid_from` block.
   * In case of a payout failure, the spend status must be updated with the `check_status`
   * dispatchable before retrying with the current function.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::Paid`] if successful.
   **/
  | { name: 'Payout'; params: { index: number } }
  /**
   * Check the status of the spend and remove it from the storage if processed.
   *
   * ## Dispatch Origin
   *
   * Must be signed.
   *
   * ## Details
   *
   * The status check is a prerequisite for retrying a failed payout.
   * If a spend has either succeeded or expired, it is removed from the storage by this
   * function. In such instances, transaction fees are refunded.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::PaymentFailed`] if the spend payout has failed.
   * Emits [`Event::SpendProcessed`] if the spend payout has succeed.
   **/
  | { name: 'CheckStatus'; params: { index: number } }
  /**
   * Void previously approved spend.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::RejectOrigin`].
   *
   * ## Details
   *
   * A spend void is only possible if the payout has not been attempted yet.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::AssetSpendVoided`] if successful.
   **/
  | { name: 'VoidSpend'; params: { index: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletConvictionVotingCall =
  /**
   * Vote in a poll. If `vote.is_aye()`, the vote is to enact the proposal;
   * otherwise it is a vote to keep the status quo.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `poll_index`: The index of the poll to vote for.
   * - `vote`: The vote configuration.
   *
   * Weight: `O(R)` where R is the number of polls the voter has voted on.
   **/
  | { name: 'Vote'; params: { pollIndex: number; vote: PalletConvictionVotingVoteAccountVote } }
  /**
   * Delegate the voting power (with some given conviction) of the sending account for a
   * particular class of polls.
   *
   * The balance delegated is locked for as long as it's delegated, and thereafter for the
   * time appropriate for the conviction's lock period.
   *
   * The dispatch origin of this call must be _Signed_, and the signing account must either:
   * - be delegating already; or
   * - have no voting activity (if there is, then it will need to be removed through
   * `remove_vote`).
   *
   * - `to`: The account whose voting the `target` account's voting power will follow.
   * - `class`: The class of polls to delegate. To delegate multiple classes, multiple calls
   * to this function are required.
   * - `conviction`: The conviction that will be attached to the delegated votes. When the
   * account is undelegated, the funds will be locked for the corresponding period.
   * - `balance`: The amount of the account's balance to be used in delegating. This must not
   * be more than the account's current balance.
   *
   * Emits `Delegated`.
   *
   * Weight: `O(R)` where R is the number of polls the voter delegating to has
   * voted on. Weight is initially charged as if maximum votes, but is refunded later.
   **/
  | {
      name: 'Delegate';
      params: { class: number; to: MultiAddress; conviction: PalletConvictionVotingConviction; balance: bigint };
    }
  /**
   * Undelegate the voting power of the sending account for a particular class of polls.
   *
   * Tokens may be unlocked following once an amount of time consistent with the lock period
   * of the conviction with which the delegation was issued has passed.
   *
   * The dispatch origin of this call must be _Signed_ and the signing account must be
   * currently delegating.
   *
   * - `class`: The class of polls to remove the delegation from.
   *
   * Emits `Undelegated`.
   *
   * Weight: `O(R)` where R is the number of polls the voter delegating to has
   * voted on. Weight is initially charged as if maximum votes, but is refunded later.
   **/
  | { name: 'Undelegate'; params: { class: number } }
  /**
   * Remove the lock caused by prior voting/delegating which has expired within a particular
   * class.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `class`: The class of polls to unlock.
   * - `target`: The account to remove the lock on.
   *
   * Weight: `O(R)` with R number of vote of target.
   **/
  | { name: 'Unlock'; params: { class: number; target: MultiAddress } }
  /**
   * Remove a vote for a poll.
   *
   * If:
   * - the poll was cancelled, or
   * - the poll is ongoing, or
   * - the poll has ended such that
   * - the vote of the account was in opposition to the result; or
   * - there was no conviction to the account's vote; or
   * - the account made a split vote
   * ...then the vote is removed cleanly and a following call to `unlock` may result in more
   * funds being available.
   *
   * If, however, the poll has ended and:
   * - it finished corresponding to the vote of the account, and
   * - the account made a standard vote with conviction, and
   * - the lock period of the conviction is not over
   * ...then the lock will be aggregated into the overall account's lock, which may involve
   * *overlocking* (where the two locks are combined into a single lock that is the maximum
   * of both the amount locked and the time is it locked for).
   *
   * The dispatch origin of this call must be _Signed_, and the signer must have a vote
   * registered for poll `index`.
   *
   * - `index`: The index of poll of the vote to be removed.
   * - `class`: Optional parameter, if given it indicates the class of the poll. For polls
   * which have finished or are cancelled, this must be `Some`.
   *
   * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: 'RemoveVote'; params: { class?: number | undefined; index: number } }
  /**
   * Remove a vote for a poll.
   *
   * If the `target` is equal to the signer, then this function is exactly equivalent to
   * `remove_vote`. If not equal to the signer, then the vote must have expired,
   * either because the poll was cancelled, because the voter lost the poll or
   * because the conviction period is over.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `target`: The account of the vote to be removed; this account must have voted for poll
   * `index`.
   * - `index`: The index of poll of the vote to be removed.
   * - `class`: The class of the poll.
   *
   * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: 'RemoveOtherVote'; params: { target: MultiAddress; class: number; index: number } };

export type PalletConvictionVotingCallLike =
  /**
   * Vote in a poll. If `vote.is_aye()`, the vote is to enact the proposal;
   * otherwise it is a vote to keep the status quo.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `poll_index`: The index of the poll to vote for.
   * - `vote`: The vote configuration.
   *
   * Weight: `O(R)` where R is the number of polls the voter has voted on.
   **/
  | { name: 'Vote'; params: { pollIndex: number; vote: PalletConvictionVotingVoteAccountVote } }
  /**
   * Delegate the voting power (with some given conviction) of the sending account for a
   * particular class of polls.
   *
   * The balance delegated is locked for as long as it's delegated, and thereafter for the
   * time appropriate for the conviction's lock period.
   *
   * The dispatch origin of this call must be _Signed_, and the signing account must either:
   * - be delegating already; or
   * - have no voting activity (if there is, then it will need to be removed through
   * `remove_vote`).
   *
   * - `to`: The account whose voting the `target` account's voting power will follow.
   * - `class`: The class of polls to delegate. To delegate multiple classes, multiple calls
   * to this function are required.
   * - `conviction`: The conviction that will be attached to the delegated votes. When the
   * account is undelegated, the funds will be locked for the corresponding period.
   * - `balance`: The amount of the account's balance to be used in delegating. This must not
   * be more than the account's current balance.
   *
   * Emits `Delegated`.
   *
   * Weight: `O(R)` where R is the number of polls the voter delegating to has
   * voted on. Weight is initially charged as if maximum votes, but is refunded later.
   **/
  | {
      name: 'Delegate';
      params: { class: number; to: MultiAddressLike; conviction: PalletConvictionVotingConviction; balance: bigint };
    }
  /**
   * Undelegate the voting power of the sending account for a particular class of polls.
   *
   * Tokens may be unlocked following once an amount of time consistent with the lock period
   * of the conviction with which the delegation was issued has passed.
   *
   * The dispatch origin of this call must be _Signed_ and the signing account must be
   * currently delegating.
   *
   * - `class`: The class of polls to remove the delegation from.
   *
   * Emits `Undelegated`.
   *
   * Weight: `O(R)` where R is the number of polls the voter delegating to has
   * voted on. Weight is initially charged as if maximum votes, but is refunded later.
   **/
  | { name: 'Undelegate'; params: { class: number } }
  /**
   * Remove the lock caused by prior voting/delegating which has expired within a particular
   * class.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `class`: The class of polls to unlock.
   * - `target`: The account to remove the lock on.
   *
   * Weight: `O(R)` with R number of vote of target.
   **/
  | { name: 'Unlock'; params: { class: number; target: MultiAddressLike } }
  /**
   * Remove a vote for a poll.
   *
   * If:
   * - the poll was cancelled, or
   * - the poll is ongoing, or
   * - the poll has ended such that
   * - the vote of the account was in opposition to the result; or
   * - there was no conviction to the account's vote; or
   * - the account made a split vote
   * ...then the vote is removed cleanly and a following call to `unlock` may result in more
   * funds being available.
   *
   * If, however, the poll has ended and:
   * - it finished corresponding to the vote of the account, and
   * - the account made a standard vote with conviction, and
   * - the lock period of the conviction is not over
   * ...then the lock will be aggregated into the overall account's lock, which may involve
   * *overlocking* (where the two locks are combined into a single lock that is the maximum
   * of both the amount locked and the time is it locked for).
   *
   * The dispatch origin of this call must be _Signed_, and the signer must have a vote
   * registered for poll `index`.
   *
   * - `index`: The index of poll of the vote to be removed.
   * - `class`: Optional parameter, if given it indicates the class of the poll. For polls
   * which have finished or are cancelled, this must be `Some`.
   *
   * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: 'RemoveVote'; params: { class?: number | undefined; index: number } }
  /**
   * Remove a vote for a poll.
   *
   * If the `target` is equal to the signer, then this function is exactly equivalent to
   * `remove_vote`. If not equal to the signer, then the vote must have expired,
   * either because the poll was cancelled, because the voter lost the poll or
   * because the conviction period is over.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `target`: The account of the vote to be removed; this account must have voted for poll
   * `index`.
   * - `index`: The index of poll of the vote to be removed.
   * - `class`: The class of the poll.
   *
   * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: 'RemoveOtherVote'; params: { target: MultiAddressLike; class: number; index: number } };

export type PalletConvictionVotingVoteAccountVote =
  | { tag: 'Standard'; value: { vote: PalletConvictionVotingVote; balance: bigint } }
  | { tag: 'Split'; value: { aye: bigint; nay: bigint } }
  | { tag: 'SplitAbstain'; value: { aye: bigint; nay: bigint; abstain: bigint } };

export type PalletConvictionVotingVote = number;

export type PalletConvictionVotingConviction =
  | 'None'
  | 'Locked1x'
  | 'Locked2x'
  | 'Locked3x'
  | 'Locked4x'
  | 'Locked5x'
  | 'Locked6x';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletReferendaCall =
  /**
   * Propose a referendum on a privileged action.
   *
   * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
   * available.
   * - `proposal_origin`: The origin from which the proposal should be executed.
   * - `proposal`: The proposal.
   * - `enactment_moment`: The moment that the proposal should be enacted.
   *
   * Emits `Submitted`.
   **/
  | {
      name: 'Submit';
      params: {
        proposalOrigin: RococoRuntimeOriginCaller;
        proposal: FrameSupportPreimagesBounded;
        enactmentMoment: FrameSupportScheduleDispatchTime;
      };
    }
  /**
   * Post the Decision Deposit for a referendum.
   *
   * - `origin`: must be `Signed` and the account must have funds available for the
   * referendum's track's Decision Deposit.
   * - `index`: The index of the submitted referendum whose Decision Deposit is yet to be
   * posted.
   *
   * Emits `DecisionDepositPlaced`.
   **/
  | { name: 'PlaceDecisionDeposit'; params: { index: number } }
  /**
   * Refund the Decision Deposit for a closed referendum back to the depositor.
   *
   * - `origin`: must be `Signed` or `Root`.
   * - `index`: The index of a closed referendum whose Decision Deposit has not yet been
   * refunded.
   *
   * Emits `DecisionDepositRefunded`.
   **/
  | { name: 'RefundDecisionDeposit'; params: { index: number } }
  /**
   * Cancel an ongoing referendum.
   *
   * - `origin`: must be the `CancelOrigin`.
   * - `index`: The index of the referendum to be cancelled.
   *
   * Emits `Cancelled`.
   **/
  | { name: 'Cancel'; params: { index: number } }
  /**
   * Cancel an ongoing referendum and slash the deposits.
   *
   * - `origin`: must be the `KillOrigin`.
   * - `index`: The index of the referendum to be cancelled.
   *
   * Emits `Killed` and `DepositSlashed`.
   **/
  | { name: 'Kill'; params: { index: number } }
  /**
   * Advance a referendum onto its next logical state. Only used internally.
   *
   * - `origin`: must be `Root`.
   * - `index`: the referendum to be advanced.
   **/
  | { name: 'NudgeReferendum'; params: { index: number } }
  /**
   * Advance a track onto its next logical state. Only used internally.
   *
   * - `origin`: must be `Root`.
   * - `track`: the track to be advanced.
   *
   * Action item for when there is now one fewer referendum in the deciding phase and the
   * `DecidingCount` is not yet updated. This means that we should either:
   * - begin deciding another referendum (and leave `DecidingCount` alone); or
   * - decrement `DecidingCount`.
   **/
  | { name: 'OneFewerDeciding'; params: { track: number } }
  /**
   * Refund the Submission Deposit for a closed referendum back to the depositor.
   *
   * - `origin`: must be `Signed` or `Root`.
   * - `index`: The index of a closed referendum whose Submission Deposit has not yet been
   * refunded.
   *
   * Emits `SubmissionDepositRefunded`.
   **/
  | { name: 'RefundSubmissionDeposit'; params: { index: number } }
  /**
   * Set or clear metadata of a referendum.
   *
   * Parameters:
   * - `origin`: Must be `Signed` by a creator of a referendum or by anyone to clear a
   * metadata of a finished referendum.
   * - `index`: The index of a referendum to set or clear metadata for.
   * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
   **/
  | { name: 'SetMetadata'; params: { index: number; maybeHash?: H256 | undefined } };

export type PalletReferendaCallLike =
  /**
   * Propose a referendum on a privileged action.
   *
   * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
   * available.
   * - `proposal_origin`: The origin from which the proposal should be executed.
   * - `proposal`: The proposal.
   * - `enactment_moment`: The moment that the proposal should be enacted.
   *
   * Emits `Submitted`.
   **/
  | {
      name: 'Submit';
      params: {
        proposalOrigin: RococoRuntimeOriginCaller;
        proposal: FrameSupportPreimagesBounded;
        enactmentMoment: FrameSupportScheduleDispatchTime;
      };
    }
  /**
   * Post the Decision Deposit for a referendum.
   *
   * - `origin`: must be `Signed` and the account must have funds available for the
   * referendum's track's Decision Deposit.
   * - `index`: The index of the submitted referendum whose Decision Deposit is yet to be
   * posted.
   *
   * Emits `DecisionDepositPlaced`.
   **/
  | { name: 'PlaceDecisionDeposit'; params: { index: number } }
  /**
   * Refund the Decision Deposit for a closed referendum back to the depositor.
   *
   * - `origin`: must be `Signed` or `Root`.
   * - `index`: The index of a closed referendum whose Decision Deposit has not yet been
   * refunded.
   *
   * Emits `DecisionDepositRefunded`.
   **/
  | { name: 'RefundDecisionDeposit'; params: { index: number } }
  /**
   * Cancel an ongoing referendum.
   *
   * - `origin`: must be the `CancelOrigin`.
   * - `index`: The index of the referendum to be cancelled.
   *
   * Emits `Cancelled`.
   **/
  | { name: 'Cancel'; params: { index: number } }
  /**
   * Cancel an ongoing referendum and slash the deposits.
   *
   * - `origin`: must be the `KillOrigin`.
   * - `index`: The index of the referendum to be cancelled.
   *
   * Emits `Killed` and `DepositSlashed`.
   **/
  | { name: 'Kill'; params: { index: number } }
  /**
   * Advance a referendum onto its next logical state. Only used internally.
   *
   * - `origin`: must be `Root`.
   * - `index`: the referendum to be advanced.
   **/
  | { name: 'NudgeReferendum'; params: { index: number } }
  /**
   * Advance a track onto its next logical state. Only used internally.
   *
   * - `origin`: must be `Root`.
   * - `track`: the track to be advanced.
   *
   * Action item for when there is now one fewer referendum in the deciding phase and the
   * `DecidingCount` is not yet updated. This means that we should either:
   * - begin deciding another referendum (and leave `DecidingCount` alone); or
   * - decrement `DecidingCount`.
   **/
  | { name: 'OneFewerDeciding'; params: { track: number } }
  /**
   * Refund the Submission Deposit for a closed referendum back to the depositor.
   *
   * - `origin`: must be `Signed` or `Root`.
   * - `index`: The index of a closed referendum whose Submission Deposit has not yet been
   * refunded.
   *
   * Emits `SubmissionDepositRefunded`.
   **/
  | { name: 'RefundSubmissionDeposit'; params: { index: number } }
  /**
   * Set or clear metadata of a referendum.
   *
   * Parameters:
   * - `origin`: Must be `Signed` by a creator of a referendum or by anyone to clear a
   * metadata of a finished referendum.
   * - `index`: The index of a referendum to set or clear metadata for.
   * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
   **/
  | { name: 'SetMetadata'; params: { index: number; maybeHash?: H256 | undefined } };

export type RococoRuntimeOriginCaller =
  | { tag: 'System'; value: FrameSupportDispatchRawOrigin }
  | { tag: 'Origins'; value: RococoRuntimeGovernanceOriginsPalletCustomOriginsOrigin }
  | { tag: 'ParachainsOrigin'; value: PolkadotRuntimeParachainsOriginPalletOrigin }
  | { tag: 'XcmPallet'; value: PalletXcmOrigin }
  | { tag: 'Void'; value: SpCoreVoid };

export type FrameSupportDispatchRawOrigin = { tag: 'Root' } | { tag: 'Signed'; value: AccountId32 } | { tag: 'None' };

export type RococoRuntimeGovernanceOriginsPalletCustomOriginsOrigin =
  | 'StakingAdmin'
  | 'Treasurer'
  | 'FellowshipAdmin'
  | 'GeneralAdmin'
  | 'AuctionAdmin'
  | 'LeaseAdmin'
  | 'ReferendumCanceller'
  | 'ReferendumKiller'
  | 'SmallTipper'
  | 'BigTipper'
  | 'SmallSpender'
  | 'MediumSpender'
  | 'BigSpender'
  | 'WhitelistedCaller'
  | 'FellowshipInitiates'
  | 'Fellows'
  | 'FellowshipExperts'
  | 'FellowshipMasters'
  | 'Fellowship1Dan'
  | 'Fellowship2Dan'
  | 'Fellowship3Dan'
  | 'Fellowship4Dan'
  | 'Fellowship5Dan'
  | 'Fellowship6Dan'
  | 'Fellowship7Dan'
  | 'Fellowship8Dan'
  | 'Fellowship9Dan';

export type PolkadotRuntimeParachainsOriginPalletOrigin = {
  tag: 'Parachain';
  value: PolkadotParachainPrimitivesPrimitivesId;
};

export type PolkadotParachainPrimitivesPrimitivesId = number;

export type PalletXcmOrigin =
  | { tag: 'Xcm'; value: StagingXcmV4Location }
  | { tag: 'Response'; value: StagingXcmV4Location };

export type SpCoreVoid = null;

export type FrameSupportScheduleDispatchTime = { tag: 'At'; value: number } | { tag: 'After'; value: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletRankedCollectiveCall =
  /**
   * Introduce a new member.
   *
   * - `origin`: Must be the `AddOrigin`.
   * - `who`: Account of non-member which will become a member.
   *
   * Weight: `O(1)`
   **/
  | { name: 'AddMember'; params: { who: MultiAddress } }
  /**
   * Increment the rank of an existing member by one.
   *
   * - `origin`: Must be the `PromoteOrigin`.
   * - `who`: Account of existing member.
   *
   * Weight: `O(1)`
   **/
  | { name: 'PromoteMember'; params: { who: MultiAddress } }
  /**
   * Decrement the rank of an existing member by one. If the member is already at rank zero,
   * then they are removed entirely.
   *
   * - `origin`: Must be the `DemoteOrigin`.
   * - `who`: Account of existing member of rank greater than zero.
   *
   * Weight: `O(1)`, less if the member's index is highest in its rank.
   **/
  | { name: 'DemoteMember'; params: { who: MultiAddress } }
  /**
   * Remove the member entirely.
   *
   * - `origin`: Must be the `RemoveOrigin`.
   * - `who`: Account of existing member of rank greater than zero.
   * - `min_rank`: The rank of the member or greater.
   *
   * Weight: `O(min_rank)`.
   **/
  | { name: 'RemoveMember'; params: { who: MultiAddress; minRank: number } }
  /**
   * Add an aye or nay vote for the sender to the given proposal.
   *
   * - `origin`: Must be `Signed` by a member account.
   * - `poll`: Index of a poll which is ongoing.
   * - `aye`: `true` if the vote is to approve the proposal, `false` otherwise.
   *
   * Transaction fees are be waived if the member is voting on any particular proposal
   * for the first time and the call is successful. Subsequent vote changes will charge a
   * fee.
   *
   * Weight: `O(1)`, less if there was no previous vote on the poll by the member.
   **/
  | { name: 'Vote'; params: { poll: number; aye: boolean } }
  /**
   * Remove votes from the given poll. It must have ended.
   *
   * - `origin`: Must be `Signed` by any account.
   * - `poll_index`: Index of a poll which is completed and for which votes continue to
   * exist.
   * - `max`: Maximum number of vote items from remove in this call.
   *
   * Transaction fees are waived if the operation is successful.
   *
   * Weight `O(max)` (less if there are fewer items to remove than `max`).
   **/
  | { name: 'CleanupPoll'; params: { pollIndex: number; max: number } }
  /**
   * Exchanges a member with a new account and the same existing rank.
   *
   * - `origin`: Must be the `ExchangeOrigin`.
   * - `who`: Account of existing member of rank greater than zero to be exchanged.
   * - `new_who`: New Account of existing member of rank greater than zero to exchanged to.
   **/
  | { name: 'ExchangeMember'; params: { who: MultiAddress; newWho: MultiAddress } };

export type PalletRankedCollectiveCallLike =
  /**
   * Introduce a new member.
   *
   * - `origin`: Must be the `AddOrigin`.
   * - `who`: Account of non-member which will become a member.
   *
   * Weight: `O(1)`
   **/
  | { name: 'AddMember'; params: { who: MultiAddressLike } }
  /**
   * Increment the rank of an existing member by one.
   *
   * - `origin`: Must be the `PromoteOrigin`.
   * - `who`: Account of existing member.
   *
   * Weight: `O(1)`
   **/
  | { name: 'PromoteMember'; params: { who: MultiAddressLike } }
  /**
   * Decrement the rank of an existing member by one. If the member is already at rank zero,
   * then they are removed entirely.
   *
   * - `origin`: Must be the `DemoteOrigin`.
   * - `who`: Account of existing member of rank greater than zero.
   *
   * Weight: `O(1)`, less if the member's index is highest in its rank.
   **/
  | { name: 'DemoteMember'; params: { who: MultiAddressLike } }
  /**
   * Remove the member entirely.
   *
   * - `origin`: Must be the `RemoveOrigin`.
   * - `who`: Account of existing member of rank greater than zero.
   * - `min_rank`: The rank of the member or greater.
   *
   * Weight: `O(min_rank)`.
   **/
  | { name: 'RemoveMember'; params: { who: MultiAddressLike; minRank: number } }
  /**
   * Add an aye or nay vote for the sender to the given proposal.
   *
   * - `origin`: Must be `Signed` by a member account.
   * - `poll`: Index of a poll which is ongoing.
   * - `aye`: `true` if the vote is to approve the proposal, `false` otherwise.
   *
   * Transaction fees are be waived if the member is voting on any particular proposal
   * for the first time and the call is successful. Subsequent vote changes will charge a
   * fee.
   *
   * Weight: `O(1)`, less if there was no previous vote on the poll by the member.
   **/
  | { name: 'Vote'; params: { poll: number; aye: boolean } }
  /**
   * Remove votes from the given poll. It must have ended.
   *
   * - `origin`: Must be `Signed` by any account.
   * - `poll_index`: Index of a poll which is completed and for which votes continue to
   * exist.
   * - `max`: Maximum number of vote items from remove in this call.
   *
   * Transaction fees are waived if the operation is successful.
   *
   * Weight `O(max)` (less if there are fewer items to remove than `max`).
   **/
  | { name: 'CleanupPoll'; params: { pollIndex: number; max: number } }
  /**
   * Exchanges a member with a new account and the same existing rank.
   *
   * - `origin`: Must be the `ExchangeOrigin`.
   * - `who`: Account of existing member of rank greater than zero to be exchanged.
   * - `new_who`: New Account of existing member of rank greater than zero to exchanged to.
   **/
  | { name: 'ExchangeMember'; params: { who: MultiAddressLike; newWho: MultiAddressLike } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletWhitelistCall =
  | { name: 'WhitelistCall'; params: { callHash: H256 } }
  | { name: 'RemoveWhitelistedCall'; params: { callHash: H256 } }
  | {
      name: 'DispatchWhitelistedCall';
      params: { callHash: H256; callEncodedLen: number; callWeightWitness: SpWeightsWeightV2Weight };
    }
  | { name: 'DispatchWhitelistedCallWithPreimage'; params: { call: RococoRuntimeRuntimeCall } };

export type PalletWhitelistCallLike =
  | { name: 'WhitelistCall'; params: { callHash: H256 } }
  | { name: 'RemoveWhitelistedCall'; params: { callHash: H256 } }
  | {
      name: 'DispatchWhitelistedCall';
      params: { callHash: H256; callEncodedLen: number; callWeightWitness: SpWeightsWeightV2Weight };
    }
  | { name: 'DispatchWhitelistedCallWithPreimage'; params: { call: RococoRuntimeRuntimeCallLike } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeCommonClaimsPalletCall =
  /**
   * Make a claim to collect your DOTs.
   *
   * The dispatch origin for this call must be _None_.
   *
   * Unsigned Validation:
   * A call to claim is deemed valid if the signature provided matches
   * the expected signed message of:
   *
   * > Ethereum Signed Message:
   * > (configured prefix string)(address)
   *
   * and `address` matches the `dest` account.
   *
   * Parameters:
   * - `dest`: The destination account to payout the claim.
   * - `ethereum_signature`: The signature of an ethereum signed message matching the format
   * described above.
   *
   * <weight>
   * The weight of this call is invariant over the input parameters.
   * Weight includes logic to validate unsigned `claim` call.
   *
   * Total Complexity: O(1)
   * </weight>
   **/
  | { name: 'Claim'; params: { dest: AccountId32; ethereumSignature: PolkadotRuntimeCommonClaimsEcdsaSignature } }
  /**
   * Mint a new claim to collect DOTs.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * Parameters:
   * - `who`: The Ethereum address allowed to collect this claim.
   * - `value`: The number of DOTs that will be claimed.
   * - `vesting_schedule`: An optional vesting schedule for these DOTs.
   *
   * <weight>
   * The weight of this call is invariant over the input parameters.
   * We assume worst case that both vesting and statement is being inserted.
   *
   * Total Complexity: O(1)
   * </weight>
   **/
  | {
      name: 'MintClaim';
      params: {
        who: EthereumAddress;
        value: bigint;
        vestingSchedule?: [bigint, bigint, number] | undefined;
        statement?: PolkadotRuntimeCommonClaimsStatementKind | undefined;
      };
    }
  /**
   * Make a claim to collect your DOTs by signing a statement.
   *
   * The dispatch origin for this call must be _None_.
   *
   * Unsigned Validation:
   * A call to `claim_attest` is deemed valid if the signature provided matches
   * the expected signed message of:
   *
   * > Ethereum Signed Message:
   * > (configured prefix string)(address)(statement)
   *
   * and `address` matches the `dest` account; the `statement` must match that which is
   * expected according to your purchase arrangement.
   *
   * Parameters:
   * - `dest`: The destination account to payout the claim.
   * - `ethereum_signature`: The signature of an ethereum signed message matching the format
   * described above.
   * - `statement`: The identity of the statement which is being attested to in the
   * signature.
   *
   * <weight>
   * The weight of this call is invariant over the input parameters.
   * Weight includes logic to validate unsigned `claim_attest` call.
   *
   * Total Complexity: O(1)
   * </weight>
   **/
  | {
      name: 'ClaimAttest';
      params: { dest: AccountId32; ethereumSignature: PolkadotRuntimeCommonClaimsEcdsaSignature; statement: Bytes };
    }
  /**
   * Attest to a statement, needed to finalize the claims process.
   *
   * WARNING: Insecure unless your chain includes `PrevalidateAttests` as a
   * `SignedExtension`.
   *
   * Unsigned Validation:
   * A call to attest is deemed valid if the sender has a `Preclaim` registered
   * and provides a `statement` which is expected for the account.
   *
   * Parameters:
   * - `statement`: The identity of the statement which is being attested to in the
   * signature.
   *
   * <weight>
   * The weight of this call is invariant over the input parameters.
   * Weight includes logic to do pre-validation on `attest` call.
   *
   * Total Complexity: O(1)
   * </weight>
   **/
  | { name: 'Attest'; params: { statement: Bytes } }
  | {
      name: 'MoveClaim';
      params: { old: EthereumAddress; new: EthereumAddress; maybePreclaim?: AccountId32 | undefined };
    };

export type PolkadotRuntimeCommonClaimsPalletCallLike =
  /**
   * Make a claim to collect your DOTs.
   *
   * The dispatch origin for this call must be _None_.
   *
   * Unsigned Validation:
   * A call to claim is deemed valid if the signature provided matches
   * the expected signed message of:
   *
   * > Ethereum Signed Message:
   * > (configured prefix string)(address)
   *
   * and `address` matches the `dest` account.
   *
   * Parameters:
   * - `dest`: The destination account to payout the claim.
   * - `ethereum_signature`: The signature of an ethereum signed message matching the format
   * described above.
   *
   * <weight>
   * The weight of this call is invariant over the input parameters.
   * Weight includes logic to validate unsigned `claim` call.
   *
   * Total Complexity: O(1)
   * </weight>
   **/
  | { name: 'Claim'; params: { dest: AccountId32Like; ethereumSignature: PolkadotRuntimeCommonClaimsEcdsaSignature } }
  /**
   * Mint a new claim to collect DOTs.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * Parameters:
   * - `who`: The Ethereum address allowed to collect this claim.
   * - `value`: The number of DOTs that will be claimed.
   * - `vesting_schedule`: An optional vesting schedule for these DOTs.
   *
   * <weight>
   * The weight of this call is invariant over the input parameters.
   * We assume worst case that both vesting and statement is being inserted.
   *
   * Total Complexity: O(1)
   * </weight>
   **/
  | {
      name: 'MintClaim';
      params: {
        who: EthereumAddressLike;
        value: bigint;
        vestingSchedule?: [bigint, bigint, number] | undefined;
        statement?: PolkadotRuntimeCommonClaimsStatementKind | undefined;
      };
    }
  /**
   * Make a claim to collect your DOTs by signing a statement.
   *
   * The dispatch origin for this call must be _None_.
   *
   * Unsigned Validation:
   * A call to `claim_attest` is deemed valid if the signature provided matches
   * the expected signed message of:
   *
   * > Ethereum Signed Message:
   * > (configured prefix string)(address)(statement)
   *
   * and `address` matches the `dest` account; the `statement` must match that which is
   * expected according to your purchase arrangement.
   *
   * Parameters:
   * - `dest`: The destination account to payout the claim.
   * - `ethereum_signature`: The signature of an ethereum signed message matching the format
   * described above.
   * - `statement`: The identity of the statement which is being attested to in the
   * signature.
   *
   * <weight>
   * The weight of this call is invariant over the input parameters.
   * Weight includes logic to validate unsigned `claim_attest` call.
   *
   * Total Complexity: O(1)
   * </weight>
   **/
  | {
      name: 'ClaimAttest';
      params: {
        dest: AccountId32Like;
        ethereumSignature: PolkadotRuntimeCommonClaimsEcdsaSignature;
        statement: BytesLike;
      };
    }
  /**
   * Attest to a statement, needed to finalize the claims process.
   *
   * WARNING: Insecure unless your chain includes `PrevalidateAttests` as a
   * `SignedExtension`.
   *
   * Unsigned Validation:
   * A call to attest is deemed valid if the sender has a `Preclaim` registered
   * and provides a `statement` which is expected for the account.
   *
   * Parameters:
   * - `statement`: The identity of the statement which is being attested to in the
   * signature.
   *
   * <weight>
   * The weight of this call is invariant over the input parameters.
   * Weight includes logic to do pre-validation on `attest` call.
   *
   * Total Complexity: O(1)
   * </weight>
   **/
  | { name: 'Attest'; params: { statement: BytesLike } }
  | {
      name: 'MoveClaim';
      params: { old: EthereumAddressLike; new: EthereumAddressLike; maybePreclaim?: AccountId32Like | undefined };
    };

export type PolkadotRuntimeCommonClaimsEcdsaSignature = FixedBytes<65>;

export type PolkadotRuntimeCommonClaimsStatementKind = 'Regular' | 'Saft';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletUtilityCall =
  /**
   * Send a batch of dispatch calls.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatched without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   *
   * This will return `Ok` in all circumstances. To determine the success of the batch, an
   * event is deposited. If a call failed and the batch was interrupted, then the
   * `BatchInterrupted` event is deposited, along with the number of successful calls made
   * and the error of the failed call. If all were successful, then the `BatchCompleted`
   * event is deposited.
   **/
  | { name: 'Batch'; params: { calls: Array<RococoRuntimeRuntimeCall> } }
  /**
   * Send a call through an indexed pseudonym of the sender.
   *
   * Filter from origin are passed along. The call will be dispatched with an origin which
   * use the same filter as the origin of this call.
   *
   * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
   * because you expect `proxy` to have been used prior in the call stack and you do not want
   * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
   * in the Multisig pallet instead.
   *
   * NOTE: Prior to version *12, this was called `as_limited_sub`.
   *
   * The dispatch origin for this call must be _Signed_.
   **/
  | { name: 'AsDerivative'; params: { index: number; call: RococoRuntimeRuntimeCall } }
  /**
   * Send a batch of dispatch calls and atomically execute them.
   * The whole transaction will rollback and fail if any of the calls failed.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatched without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   **/
  | { name: 'BatchAll'; params: { calls: Array<RococoRuntimeRuntimeCall> } }
  /**
   * Dispatches a function call with a provided origin.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'DispatchAs'; params: { asOrigin: RococoRuntimeOriginCaller; call: RococoRuntimeRuntimeCall } }
  /**
   * Send a batch of dispatch calls.
   * Unlike `batch`, it allows errors and won't interrupt.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatch without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   **/
  | { name: 'ForceBatch'; params: { calls: Array<RococoRuntimeRuntimeCall> } }
  /**
   * Dispatch a function call with a specified weight.
   *
   * This function does not check the weight of the call, and instead allows the
   * Root origin to specify the weight of the call.
   *
   * The dispatch origin for this call must be _Root_.
   **/
  | { name: 'WithWeight'; params: { call: RococoRuntimeRuntimeCall; weight: SpWeightsWeightV2Weight } };

export type PalletUtilityCallLike =
  /**
   * Send a batch of dispatch calls.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatched without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   *
   * This will return `Ok` in all circumstances. To determine the success of the batch, an
   * event is deposited. If a call failed and the batch was interrupted, then the
   * `BatchInterrupted` event is deposited, along with the number of successful calls made
   * and the error of the failed call. If all were successful, then the `BatchCompleted`
   * event is deposited.
   **/
  | { name: 'Batch'; params: { calls: Array<RococoRuntimeRuntimeCallLike> } }
  /**
   * Send a call through an indexed pseudonym of the sender.
   *
   * Filter from origin are passed along. The call will be dispatched with an origin which
   * use the same filter as the origin of this call.
   *
   * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
   * because you expect `proxy` to have been used prior in the call stack and you do not want
   * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
   * in the Multisig pallet instead.
   *
   * NOTE: Prior to version *12, this was called `as_limited_sub`.
   *
   * The dispatch origin for this call must be _Signed_.
   **/
  | { name: 'AsDerivative'; params: { index: number; call: RococoRuntimeRuntimeCallLike } }
  /**
   * Send a batch of dispatch calls and atomically execute them.
   * The whole transaction will rollback and fail if any of the calls failed.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatched without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   **/
  | { name: 'BatchAll'; params: { calls: Array<RococoRuntimeRuntimeCallLike> } }
  /**
   * Dispatches a function call with a provided origin.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'DispatchAs'; params: { asOrigin: RococoRuntimeOriginCaller; call: RococoRuntimeRuntimeCallLike } }
  /**
   * Send a batch of dispatch calls.
   * Unlike `batch`, it allows errors and won't interrupt.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatch without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   **/
  | { name: 'ForceBatch'; params: { calls: Array<RococoRuntimeRuntimeCallLike> } }
  /**
   * Dispatch a function call with a specified weight.
   *
   * This function does not check the weight of the call, and instead allows the
   * Root origin to specify the weight of the call.
   *
   * The dispatch origin for this call must be _Root_.
   **/
  | { name: 'WithWeight'; params: { call: RococoRuntimeRuntimeCallLike; weight: SpWeightsWeightV2Weight } };

/**
 * Identity pallet declaration.
 **/
export type PalletIdentityCall =
  /**
   * Add a registrar to the system.
   *
   * The dispatch origin for this call must be `T::RegistrarOrigin`.
   *
   * - `account`: the account of the registrar.
   *
   * Emits `RegistrarAdded` if successful.
   **/
  | { name: 'AddRegistrar'; params: { account: MultiAddress } }
  /**
   * Set an account's identity information and reserve the appropriate deposit.
   *
   * If the account already has identity information, the deposit is taken as part payment
   * for the new deposit.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `info`: The identity information.
   *
   * Emits `IdentitySet` if successful.
   **/
  | { name: 'SetIdentity'; params: { info: PalletIdentityLegacyIdentityInfo } }
  /**
   * Set the sub-accounts of the sender.
   *
   * Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
   * and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * identity.
   *
   * - `subs`: The identity's (new) sub-accounts.
   **/
  | { name: 'SetSubs'; params: { subs: Array<[AccountId32, Data]> } }
  /**
   * Clear an account's identity info and all sub-accounts and return all deposits.
   *
   * Payment: All reserved balances on the account are returned.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * identity.
   *
   * Emits `IdentityCleared` if successful.
   **/
  | { name: 'ClearIdentity' }
  /**
   * Request a judgement from a registrar.
   *
   * Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
   * given.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a
   * registered identity.
   *
   * - `reg_index`: The index of the registrar whose judgement is requested.
   * - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
   *
   * ```nocompile
   * Self::registrars().get(reg_index).unwrap().fee
   * ```
   *
   * Emits `JudgementRequested` if successful.
   **/
  | { name: 'RequestJudgement'; params: { regIndex: number; maxFee: bigint } }
  /**
   * Cancel a previous request.
   *
   * Payment: A previously reserved deposit is returned on success.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a
   * registered identity.
   *
   * - `reg_index`: The index of the registrar whose judgement is no longer requested.
   *
   * Emits `JudgementUnrequested` if successful.
   **/
  | { name: 'CancelRequest'; params: { regIndex: number } }
  /**
   * Set the fee required for a judgement to be requested from a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `fee`: the new fee.
   **/
  | { name: 'SetFee'; params: { index: number; fee: bigint } }
  /**
   * Change the account associated with a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `new`: the new account ID.
   **/
  | { name: 'SetAccountId'; params: { index: number; new: MultiAddress } }
  /**
   * Set the field information for a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `fields`: the fields that the registrar concerns themselves with.
   **/
  | { name: 'SetFields'; params: { index: number; fields: bigint } }
  /**
   * Provide a judgement for an account's identity.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `reg_index`.
   *
   * - `reg_index`: the index of the registrar whose judgement is being made.
   * - `target`: the account whose identity the judgement is upon. This must be an account
   * with a registered identity.
   * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
   * - `identity`: The hash of the [`IdentityInformationProvider`] for that the judgement is
   * provided.
   *
   * Note: Judgements do not apply to a username.
   *
   * Emits `JudgementGiven` if successful.
   **/
  | {
      name: 'ProvideJudgement';
      params: { regIndex: number; target: MultiAddress; judgement: PalletIdentityJudgement; identity: H256 };
    }
  /**
   * Remove an account's identity and sub-account information and slash the deposits.
   *
   * Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
   * `Slash`. Verification request deposits are not returned; they should be cancelled
   * manually using `cancel_request`.
   *
   * The dispatch origin for this call must match `T::ForceOrigin`.
   *
   * - `target`: the account whose identity the judgement is upon. This must be an account
   * with a registered identity.
   *
   * Emits `IdentityKilled` if successful.
   **/
  | { name: 'KillIdentity'; params: { target: MultiAddress } }
  /**
   * Add the given account to the sender's subs.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'AddSub'; params: { sub: MultiAddress; data: Data } }
  /**
   * Alter the associated name of the given sub-account.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'RenameSub'; params: { sub: MultiAddress; data: Data } }
  /**
   * Remove the given account from the sender's subs.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'RemoveSub'; params: { sub: MultiAddress } }
  /**
   * Remove the sender as a sub-account.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender (*not* the original depositor).
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * super-identity.
   *
   * NOTE: This should not normally be used, but is provided in the case that the non-
   * controller of an account is maliciously registered as a sub-account.
   **/
  | { name: 'QuitSub' }
  /**
   * Add an `AccountId` with permission to grant usernames with a given `suffix` appended.
   *
   * The authority can grant up to `allocation` usernames. To top up their allocation, they
   * should just issue (or request via governance) a new `add_username_authority` call.
   **/
  | { name: 'AddUsernameAuthority'; params: { authority: MultiAddress; suffix: Bytes; allocation: number } }
  /**
   * Remove `authority` from the username authorities.
   **/
  | { name: 'RemoveUsernameAuthority'; params: { authority: MultiAddress } }
  /**
   * Set the username for `who`. Must be called by a username authority.
   *
   * The authority must have an `allocation`. Users can either pre-sign their usernames or
   * accept them later.
   *
   * Usernames must:
   * - Only contain lowercase ASCII characters or digits.
   * - When combined with the suffix of the issuing authority be _less than_ the
   * `MaxUsernameLength`.
   **/
  | {
      name: 'SetUsernameFor';
      params: { who: MultiAddress; username: Bytes; signature?: SpRuntimeMultiSignature | undefined };
    }
  /**
   * Accept a given username that an `authority` granted. The call must include the full
   * username, as in `username.suffix`.
   **/
  | { name: 'AcceptUsername'; params: { username: Bytes } }
  /**
   * Remove an expired username approval. The username was approved by an authority but never
   * accepted by the user and must now be beyond its expiration. The call must include the
   * full username, as in `username.suffix`.
   **/
  | { name: 'RemoveExpiredApproval'; params: { username: Bytes } }
  /**
   * Set a given username as the primary. The username should include the suffix.
   **/
  | { name: 'SetPrimaryUsername'; params: { username: Bytes } }
  /**
   * Remove a username that corresponds to an account with no identity. Exists when a user
   * gets a username but then calls `clear_identity`.
   **/
  | { name: 'RemoveDanglingUsername'; params: { username: Bytes } };

export type PalletIdentityCallLike =
  /**
   * Add a registrar to the system.
   *
   * The dispatch origin for this call must be `T::RegistrarOrigin`.
   *
   * - `account`: the account of the registrar.
   *
   * Emits `RegistrarAdded` if successful.
   **/
  | { name: 'AddRegistrar'; params: { account: MultiAddressLike } }
  /**
   * Set an account's identity information and reserve the appropriate deposit.
   *
   * If the account already has identity information, the deposit is taken as part payment
   * for the new deposit.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `info`: The identity information.
   *
   * Emits `IdentitySet` if successful.
   **/
  | { name: 'SetIdentity'; params: { info: PalletIdentityLegacyIdentityInfo } }
  /**
   * Set the sub-accounts of the sender.
   *
   * Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
   * and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * identity.
   *
   * - `subs`: The identity's (new) sub-accounts.
   **/
  | { name: 'SetSubs'; params: { subs: Array<[AccountId32Like, Data]> } }
  /**
   * Clear an account's identity info and all sub-accounts and return all deposits.
   *
   * Payment: All reserved balances on the account are returned.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * identity.
   *
   * Emits `IdentityCleared` if successful.
   **/
  | { name: 'ClearIdentity' }
  /**
   * Request a judgement from a registrar.
   *
   * Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
   * given.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a
   * registered identity.
   *
   * - `reg_index`: The index of the registrar whose judgement is requested.
   * - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
   *
   * ```nocompile
   * Self::registrars().get(reg_index).unwrap().fee
   * ```
   *
   * Emits `JudgementRequested` if successful.
   **/
  | { name: 'RequestJudgement'; params: { regIndex: number; maxFee: bigint } }
  /**
   * Cancel a previous request.
   *
   * Payment: A previously reserved deposit is returned on success.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a
   * registered identity.
   *
   * - `reg_index`: The index of the registrar whose judgement is no longer requested.
   *
   * Emits `JudgementUnrequested` if successful.
   **/
  | { name: 'CancelRequest'; params: { regIndex: number } }
  /**
   * Set the fee required for a judgement to be requested from a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `fee`: the new fee.
   **/
  | { name: 'SetFee'; params: { index: number; fee: bigint } }
  /**
   * Change the account associated with a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `new`: the new account ID.
   **/
  | { name: 'SetAccountId'; params: { index: number; new: MultiAddressLike } }
  /**
   * Set the field information for a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `fields`: the fields that the registrar concerns themselves with.
   **/
  | { name: 'SetFields'; params: { index: number; fields: bigint } }
  /**
   * Provide a judgement for an account's identity.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `reg_index`.
   *
   * - `reg_index`: the index of the registrar whose judgement is being made.
   * - `target`: the account whose identity the judgement is upon. This must be an account
   * with a registered identity.
   * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
   * - `identity`: The hash of the [`IdentityInformationProvider`] for that the judgement is
   * provided.
   *
   * Note: Judgements do not apply to a username.
   *
   * Emits `JudgementGiven` if successful.
   **/
  | {
      name: 'ProvideJudgement';
      params: { regIndex: number; target: MultiAddressLike; judgement: PalletIdentityJudgement; identity: H256 };
    }
  /**
   * Remove an account's identity and sub-account information and slash the deposits.
   *
   * Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
   * `Slash`. Verification request deposits are not returned; they should be cancelled
   * manually using `cancel_request`.
   *
   * The dispatch origin for this call must match `T::ForceOrigin`.
   *
   * - `target`: the account whose identity the judgement is upon. This must be an account
   * with a registered identity.
   *
   * Emits `IdentityKilled` if successful.
   **/
  | { name: 'KillIdentity'; params: { target: MultiAddressLike } }
  /**
   * Add the given account to the sender's subs.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'AddSub'; params: { sub: MultiAddressLike; data: Data } }
  /**
   * Alter the associated name of the given sub-account.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'RenameSub'; params: { sub: MultiAddressLike; data: Data } }
  /**
   * Remove the given account from the sender's subs.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'RemoveSub'; params: { sub: MultiAddressLike } }
  /**
   * Remove the sender as a sub-account.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender (*not* the original depositor).
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * super-identity.
   *
   * NOTE: This should not normally be used, but is provided in the case that the non-
   * controller of an account is maliciously registered as a sub-account.
   **/
  | { name: 'QuitSub' }
  /**
   * Add an `AccountId` with permission to grant usernames with a given `suffix` appended.
   *
   * The authority can grant up to `allocation` usernames. To top up their allocation, they
   * should just issue (or request via governance) a new `add_username_authority` call.
   **/
  | { name: 'AddUsernameAuthority'; params: { authority: MultiAddressLike; suffix: BytesLike; allocation: number } }
  /**
   * Remove `authority` from the username authorities.
   **/
  | { name: 'RemoveUsernameAuthority'; params: { authority: MultiAddressLike } }
  /**
   * Set the username for `who`. Must be called by a username authority.
   *
   * The authority must have an `allocation`. Users can either pre-sign their usernames or
   * accept them later.
   *
   * Usernames must:
   * - Only contain lowercase ASCII characters or digits.
   * - When combined with the suffix of the issuing authority be _less than_ the
   * `MaxUsernameLength`.
   **/
  | {
      name: 'SetUsernameFor';
      params: { who: MultiAddressLike; username: BytesLike; signature?: SpRuntimeMultiSignature | undefined };
    }
  /**
   * Accept a given username that an `authority` granted. The call must include the full
   * username, as in `username.suffix`.
   **/
  | { name: 'AcceptUsername'; params: { username: BytesLike } }
  /**
   * Remove an expired username approval. The username was approved by an authority but never
   * accepted by the user and must now be beyond its expiration. The call must include the
   * full username, as in `username.suffix`.
   **/
  | { name: 'RemoveExpiredApproval'; params: { username: BytesLike } }
  /**
   * Set a given username as the primary. The username should include the suffix.
   **/
  | { name: 'SetPrimaryUsername'; params: { username: BytesLike } }
  /**
   * Remove a username that corresponds to an account with no identity. Exists when a user
   * gets a username but then calls `clear_identity`.
   **/
  | { name: 'RemoveDanglingUsername'; params: { username: BytesLike } };

export type PalletIdentityLegacyIdentityInfo = {
  additional: Array<[Data, Data]>;
  display: Data;
  legal: Data;
  web: Data;
  riot: Data;
  email: Data;
  pgpFingerprint?: FixedBytes<20> | undefined;
  image: Data;
  twitter: Data;
};

export type PalletIdentityJudgement =
  | { tag: 'Unknown' }
  | { tag: 'FeePaid'; value: bigint }
  | { tag: 'Reasonable' }
  | { tag: 'KnownGood' }
  | { tag: 'OutOfDate' }
  | { tag: 'LowQuality' }
  | { tag: 'Erroneous' };

export type SpRuntimeMultiSignature =
  | { tag: 'Ed25519'; value: SpCoreEd25519Signature }
  | { tag: 'Sr25519'; value: SpCoreSr25519Signature }
  | { tag: 'Ecdsa'; value: SpCoreEcdsaSignature };

export type SpCoreSr25519Signature = FixedBytes<64>;

export type SpCoreEcdsaSignature = FixedBytes<65>;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSocietyCall =
  /**
   * A user outside of the society can make a bid for entry.
   *
   * Payment: The group's Candidate Deposit will be reserved for making a bid. It is returned
   * when the bid becomes a member, or if the bid calls `unbid`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `value`: A one time payment the bid would like to receive when joining the society.
   **/
  | { name: 'Bid'; params: { value: bigint } }
  /**
   * A bidder can remove their bid for entry into society.
   * By doing so, they will have their candidate deposit returned or
   * they will unvouch their voucher.
   *
   * Payment: The bid deposit is unreserved if the user made a bid.
   *
   * The dispatch origin for this call must be _Signed_ and a bidder.
   **/
  | { name: 'Unbid' }
  /**
   * As a member, vouch for someone to join society by placing a bid on their behalf.
   *
   * There is no deposit required to vouch for a new bid, but a member can only vouch for
   * one bid at a time. If the bid becomes a suspended candidate and ultimately rejected by
   * the suspension judgement origin, the member will be banned from vouching again.
   *
   * As a vouching member, you can claim a tip if the candidate is accepted. This tip will
   * be paid as a portion of the reward the member will receive for joining the society.
   *
   * The dispatch origin for this call must be _Signed_ and a member.
   *
   * Parameters:
   * - `who`: The user who you would like to vouch for.
   * - `value`: The total reward to be paid between you and the candidate if they become
   * a member in the society.
   * - `tip`: Your cut of the total `value` payout when the candidate is inducted into
   * the society. Tips larger than `value` will be saturated upon payout.
   **/
  | { name: 'Vouch'; params: { who: MultiAddress; value: bigint; tip: bigint } }
  /**
   * As a vouching member, unvouch a bid. This only works while vouched user is
   * only a bidder (and not a candidate).
   *
   * The dispatch origin for this call must be _Signed_ and a vouching member.
   *
   * Parameters:
   * - `pos`: Position in the `Bids` vector of the bid who should be unvouched.
   **/
  | { name: 'Unvouch' }
  /**
   * As a member, vote on a candidate.
   *
   * The dispatch origin for this call must be _Signed_ and a member.
   *
   * Parameters:
   * - `candidate`: The candidate that the member would like to bid on.
   * - `approve`: A boolean which says if the candidate should be approved (`true`) or
   * rejected (`false`).
   **/
  | { name: 'Vote'; params: { candidate: MultiAddress; approve: boolean } }
  /**
   * As a member, vote on the defender.
   *
   * The dispatch origin for this call must be _Signed_ and a member.
   *
   * Parameters:
   * - `approve`: A boolean which says if the candidate should be
   * approved (`true`) or rejected (`false`).
   **/
  | { name: 'DefenderVote'; params: { approve: boolean } }
  /**
   * Transfer the first matured payout for the sender and remove it from the records.
   *
   * NOTE: This extrinsic needs to be called multiple times to claim multiple matured
   * payouts.
   *
   * Payment: The member will receive a payment equal to their first matured
   * payout to their free balance.
   *
   * The dispatch origin for this call must be _Signed_ and a member with
   * payouts remaining.
   **/
  | { name: 'Payout' }
  /**
   * Repay the payment previously given to the member with the signed origin, remove any
   * pending payments, and elevate them from rank 0 to rank 1.
   **/
  | { name: 'WaiveRepay'; params: { amount: bigint } }
  /**
   * Found the society.
   *
   * This is done as a discrete action in order to allow for the
   * pallet to be included into a running chain and can only be done once.
   *
   * The dispatch origin for this call must be from the _FounderSetOrigin_.
   *
   * Parameters:
   * - `founder` - The first member and head of the newly founded society.
   * - `max_members` - The initial max number of members for the society.
   * - `max_intake` - The maximum number of candidates per intake period.
   * - `max_strikes`: The maximum number of strikes a member may get before they become
   * suspended and may only be reinstated by the founder.
   * - `candidate_deposit`: The deposit required to make a bid for membership of the group.
   * - `rules` - The rules of this society concerning membership.
   *
   * Complexity: O(1)
   **/
  | {
      name: 'FoundSociety';
      params: {
        founder: MultiAddress;
        maxMembers: number;
        maxIntake: number;
        maxStrikes: number;
        candidateDeposit: bigint;
        rules: Bytes;
      };
    }
  /**
   * Dissolve the society and remove all members.
   *
   * The dispatch origin for this call must be Signed, and the signing account must be both
   * the `Founder` and the `Head`. This implies that it may only be done when there is one
   * member.
   **/
  | { name: 'Dissolve' }
  /**
   * Allow suspension judgement origin to make judgement on a suspended member.
   *
   * If a suspended member is forgiven, we simply add them back as a member, not affecting
   * any of the existing storage items for that member.
   *
   * If a suspended member is rejected, remove all associated storage items, including
   * their payouts, and remove any vouched bids they currently have.
   *
   * The dispatch origin for this call must be Signed from the Founder.
   *
   * Parameters:
   * - `who` - The suspended member to be judged.
   * - `forgive` - A boolean representing whether the suspension judgement origin forgives
   * (`true`) or rejects (`false`) a suspended member.
   **/
  | { name: 'JudgeSuspendedMember'; params: { who: MultiAddress; forgive: boolean } }
  /**
   * Change the maximum number of members in society and the maximum number of new candidates
   * in a single intake period.
   *
   * The dispatch origin for this call must be Signed by the Founder.
   *
   * Parameters:
   * - `max_members` - The maximum number of members for the society. This must be no less
   * than the current number of members.
   * - `max_intake` - The maximum number of candidates per intake period.
   * - `max_strikes`: The maximum number of strikes a member may get before they become
   * suspended and may only be reinstated by the founder.
   * - `candidate_deposit`: The deposit required to make a bid for membership of the group.
   **/
  | {
      name: 'SetParameters';
      params: { maxMembers: number; maxIntake: number; maxStrikes: number; candidateDeposit: bigint };
    }
  /**
   * Punish the skeptic with a strike if they did not vote on a candidate. Callable by the
   * candidate.
   **/
  | { name: 'PunishSkeptic' }
  /**
   * Transform an approved candidate into a member. Callable only by the
   * the candidate, and only after the period for voting has ended.
   **/
  | { name: 'ClaimMembership' }
  /**
   * Transform an approved candidate into a member. Callable only by the Signed origin of the
   * Founder, only after the period for voting has ended and only when the candidate is not
   * clearly rejected.
   **/
  | { name: 'BestowMembership'; params: { candidate: AccountId32 } }
  /**
   * Remove the candidate's application from the society. Callable only by the Signed origin
   * of the Founder, only after the period for voting has ended, and only when they do not
   * have a clear approval.
   *
   * Any bid deposit is lost and voucher is banned.
   **/
  | { name: 'KickCandidate'; params: { candidate: AccountId32 } }
  /**
   * Remove the candidate's application from the society. Callable only by the candidate.
   *
   * Any bid deposit is lost and voucher is banned.
   **/
  | { name: 'ResignCandidacy' }
  /**
   * Remove a `candidate`'s failed application from the society. Callable by any
   * signed origin but only at the end of the subsequent round and only for
   * a candidate with more rejections than approvals.
   *
   * The bid deposit is lost and the voucher is banned.
   **/
  | { name: 'DropCandidate'; params: { candidate: AccountId32 } }
  /**
   * Remove up to `max` stale votes for the given `candidate`.
   *
   * May be called by any Signed origin, but only after the candidate's candidacy is ended.
   **/
  | { name: 'CleanupCandidacy'; params: { candidate: AccountId32; max: number } }
  /**
   * Remove up to `max` stale votes for the defender in the given `challenge_round`.
   *
   * May be called by any Signed origin, but only after the challenge round is ended.
   **/
  | { name: 'CleanupChallenge'; params: { challengeRound: number; max: number } };

export type PalletSocietyCallLike =
  /**
   * A user outside of the society can make a bid for entry.
   *
   * Payment: The group's Candidate Deposit will be reserved for making a bid. It is returned
   * when the bid becomes a member, or if the bid calls `unbid`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `value`: A one time payment the bid would like to receive when joining the society.
   **/
  | { name: 'Bid'; params: { value: bigint } }
  /**
   * A bidder can remove their bid for entry into society.
   * By doing so, they will have their candidate deposit returned or
   * they will unvouch their voucher.
   *
   * Payment: The bid deposit is unreserved if the user made a bid.
   *
   * The dispatch origin for this call must be _Signed_ and a bidder.
   **/
  | { name: 'Unbid' }
  /**
   * As a member, vouch for someone to join society by placing a bid on their behalf.
   *
   * There is no deposit required to vouch for a new bid, but a member can only vouch for
   * one bid at a time. If the bid becomes a suspended candidate and ultimately rejected by
   * the suspension judgement origin, the member will be banned from vouching again.
   *
   * As a vouching member, you can claim a tip if the candidate is accepted. This tip will
   * be paid as a portion of the reward the member will receive for joining the society.
   *
   * The dispatch origin for this call must be _Signed_ and a member.
   *
   * Parameters:
   * - `who`: The user who you would like to vouch for.
   * - `value`: The total reward to be paid between you and the candidate if they become
   * a member in the society.
   * - `tip`: Your cut of the total `value` payout when the candidate is inducted into
   * the society. Tips larger than `value` will be saturated upon payout.
   **/
  | { name: 'Vouch'; params: { who: MultiAddressLike; value: bigint; tip: bigint } }
  /**
   * As a vouching member, unvouch a bid. This only works while vouched user is
   * only a bidder (and not a candidate).
   *
   * The dispatch origin for this call must be _Signed_ and a vouching member.
   *
   * Parameters:
   * - `pos`: Position in the `Bids` vector of the bid who should be unvouched.
   **/
  | { name: 'Unvouch' }
  /**
   * As a member, vote on a candidate.
   *
   * The dispatch origin for this call must be _Signed_ and a member.
   *
   * Parameters:
   * - `candidate`: The candidate that the member would like to bid on.
   * - `approve`: A boolean which says if the candidate should be approved (`true`) or
   * rejected (`false`).
   **/
  | { name: 'Vote'; params: { candidate: MultiAddressLike; approve: boolean } }
  /**
   * As a member, vote on the defender.
   *
   * The dispatch origin for this call must be _Signed_ and a member.
   *
   * Parameters:
   * - `approve`: A boolean which says if the candidate should be
   * approved (`true`) or rejected (`false`).
   **/
  | { name: 'DefenderVote'; params: { approve: boolean } }
  /**
   * Transfer the first matured payout for the sender and remove it from the records.
   *
   * NOTE: This extrinsic needs to be called multiple times to claim multiple matured
   * payouts.
   *
   * Payment: The member will receive a payment equal to their first matured
   * payout to their free balance.
   *
   * The dispatch origin for this call must be _Signed_ and a member with
   * payouts remaining.
   **/
  | { name: 'Payout' }
  /**
   * Repay the payment previously given to the member with the signed origin, remove any
   * pending payments, and elevate them from rank 0 to rank 1.
   **/
  | { name: 'WaiveRepay'; params: { amount: bigint } }
  /**
   * Found the society.
   *
   * This is done as a discrete action in order to allow for the
   * pallet to be included into a running chain and can only be done once.
   *
   * The dispatch origin for this call must be from the _FounderSetOrigin_.
   *
   * Parameters:
   * - `founder` - The first member and head of the newly founded society.
   * - `max_members` - The initial max number of members for the society.
   * - `max_intake` - The maximum number of candidates per intake period.
   * - `max_strikes`: The maximum number of strikes a member may get before they become
   * suspended and may only be reinstated by the founder.
   * - `candidate_deposit`: The deposit required to make a bid for membership of the group.
   * - `rules` - The rules of this society concerning membership.
   *
   * Complexity: O(1)
   **/
  | {
      name: 'FoundSociety';
      params: {
        founder: MultiAddressLike;
        maxMembers: number;
        maxIntake: number;
        maxStrikes: number;
        candidateDeposit: bigint;
        rules: BytesLike;
      };
    }
  /**
   * Dissolve the society and remove all members.
   *
   * The dispatch origin for this call must be Signed, and the signing account must be both
   * the `Founder` and the `Head`. This implies that it may only be done when there is one
   * member.
   **/
  | { name: 'Dissolve' }
  /**
   * Allow suspension judgement origin to make judgement on a suspended member.
   *
   * If a suspended member is forgiven, we simply add them back as a member, not affecting
   * any of the existing storage items for that member.
   *
   * If a suspended member is rejected, remove all associated storage items, including
   * their payouts, and remove any vouched bids they currently have.
   *
   * The dispatch origin for this call must be Signed from the Founder.
   *
   * Parameters:
   * - `who` - The suspended member to be judged.
   * - `forgive` - A boolean representing whether the suspension judgement origin forgives
   * (`true`) or rejects (`false`) a suspended member.
   **/
  | { name: 'JudgeSuspendedMember'; params: { who: MultiAddressLike; forgive: boolean } }
  /**
   * Change the maximum number of members in society and the maximum number of new candidates
   * in a single intake period.
   *
   * The dispatch origin for this call must be Signed by the Founder.
   *
   * Parameters:
   * - `max_members` - The maximum number of members for the society. This must be no less
   * than the current number of members.
   * - `max_intake` - The maximum number of candidates per intake period.
   * - `max_strikes`: The maximum number of strikes a member may get before they become
   * suspended and may only be reinstated by the founder.
   * - `candidate_deposit`: The deposit required to make a bid for membership of the group.
   **/
  | {
      name: 'SetParameters';
      params: { maxMembers: number; maxIntake: number; maxStrikes: number; candidateDeposit: bigint };
    }
  /**
   * Punish the skeptic with a strike if they did not vote on a candidate. Callable by the
   * candidate.
   **/
  | { name: 'PunishSkeptic' }
  /**
   * Transform an approved candidate into a member. Callable only by the
   * the candidate, and only after the period for voting has ended.
   **/
  | { name: 'ClaimMembership' }
  /**
   * Transform an approved candidate into a member. Callable only by the Signed origin of the
   * Founder, only after the period for voting has ended and only when the candidate is not
   * clearly rejected.
   **/
  | { name: 'BestowMembership'; params: { candidate: AccountId32Like } }
  /**
   * Remove the candidate's application from the society. Callable only by the Signed origin
   * of the Founder, only after the period for voting has ended, and only when they do not
   * have a clear approval.
   *
   * Any bid deposit is lost and voucher is banned.
   **/
  | { name: 'KickCandidate'; params: { candidate: AccountId32Like } }
  /**
   * Remove the candidate's application from the society. Callable only by the candidate.
   *
   * Any bid deposit is lost and voucher is banned.
   **/
  | { name: 'ResignCandidacy' }
  /**
   * Remove a `candidate`'s failed application from the society. Callable by any
   * signed origin but only at the end of the subsequent round and only for
   * a candidate with more rejections than approvals.
   *
   * The bid deposit is lost and the voucher is banned.
   **/
  | { name: 'DropCandidate'; params: { candidate: AccountId32Like } }
  /**
   * Remove up to `max` stale votes for the given `candidate`.
   *
   * May be called by any Signed origin, but only after the candidate's candidacy is ended.
   **/
  | { name: 'CleanupCandidacy'; params: { candidate: AccountId32Like; max: number } }
  /**
   * Remove up to `max` stale votes for the defender in the given `challenge_round`.
   *
   * May be called by any Signed origin, but only after the challenge round is ended.
   **/
  | { name: 'CleanupChallenge'; params: { challengeRound: number; max: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletRecoveryCall =
  /**
   * Send a call through a recovered account.
   *
   * The dispatch origin for this call must be _Signed_ and registered to
   * be able to make calls on behalf of the recovered account.
   *
   * Parameters:
   * - `account`: The recovered account you want to make a call on-behalf-of.
   * - `call`: The call you want to make with the recovered account.
   **/
  | { name: 'AsRecovered'; params: { account: MultiAddress; call: RococoRuntimeRuntimeCall } }
  /**
   * Allow ROOT to bypass the recovery process and set an a rescuer account
   * for a lost account directly.
   *
   * The dispatch origin for this call must be _ROOT_.
   *
   * Parameters:
   * - `lost`: The "lost account" to be recovered.
   * - `rescuer`: The "rescuer account" which can call as the lost account.
   **/
  | { name: 'SetRecovered'; params: { lost: MultiAddress; rescuer: MultiAddress } }
  /**
   * Create a recovery configuration for your account. This makes your account recoverable.
   *
   * Payment: `ConfigDepositBase` + `FriendDepositFactor` * #_of_friends balance
   * will be reserved for storing the recovery configuration. This deposit is returned
   * in full when the user calls `remove_recovery`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `friends`: A list of friends you trust to vouch for recovery attempts. Should be
   * ordered and contain no duplicate values.
   * - `threshold`: The number of friends that must vouch for a recovery attempt before the
   * account can be recovered. Should be less than or equal to the length of the list of
   * friends.
   * - `delay_period`: The number of blocks after a recovery attempt is initialized that
   * needs to pass before the account can be recovered.
   **/
  | { name: 'CreateRecovery'; params: { friends: Array<AccountId32>; threshold: number; delayPeriod: number } }
  /**
   * Initiate the process for recovering a recoverable account.
   *
   * Payment: `RecoveryDeposit` balance will be reserved for initiating the
   * recovery process. This deposit will always be repatriated to the account
   * trying to be recovered. See `close_recovery`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `account`: The lost account that you want to recover. This account needs to be
   * recoverable (i.e. have a recovery configuration).
   **/
  | { name: 'InitiateRecovery'; params: { account: MultiAddress } }
  /**
   * Allow a "friend" of a recoverable account to vouch for an active recovery
   * process for that account.
   *
   * The dispatch origin for this call must be _Signed_ and must be a "friend"
   * for the recoverable account.
   *
   * Parameters:
   * - `lost`: The lost account that you want to recover.
   * - `rescuer`: The account trying to rescue the lost account that you want to vouch for.
   *
   * The combination of these two parameters must point to an active recovery
   * process.
   **/
  | { name: 'VouchRecovery'; params: { lost: MultiAddress; rescuer: MultiAddress } }
  /**
   * Allow a successful rescuer to claim their recovered account.
   *
   * The dispatch origin for this call must be _Signed_ and must be a "rescuer"
   * who has successfully completed the account recovery process: collected
   * `threshold` or more vouches, waited `delay_period` blocks since initiation.
   *
   * Parameters:
   * - `account`: The lost account that you want to claim has been successfully recovered by
   * you.
   **/
  | { name: 'ClaimRecovery'; params: { account: MultiAddress } }
  /**
   * As the controller of a recoverable account, close an active recovery
   * process for your account.
   *
   * Payment: By calling this function, the recoverable account will receive
   * the recovery deposit `RecoveryDeposit` placed by the rescuer.
   *
   * The dispatch origin for this call must be _Signed_ and must be a
   * recoverable account with an active recovery process for it.
   *
   * Parameters:
   * - `rescuer`: The account trying to rescue this recoverable account.
   **/
  | { name: 'CloseRecovery'; params: { rescuer: MultiAddress } }
  /**
   * Remove the recovery process for your account. Recovered accounts are still accessible.
   *
   * NOTE: The user must make sure to call `close_recovery` on all active
   * recovery attempts before calling this function else it will fail.
   *
   * Payment: By calling this function the recoverable account will unreserve
   * their recovery configuration deposit.
   * (`ConfigDepositBase` + `FriendDepositFactor` * #_of_friends)
   *
   * The dispatch origin for this call must be _Signed_ and must be a
   * recoverable account (i.e. has a recovery configuration).
   **/
  | { name: 'RemoveRecovery' }
  /**
   * Cancel the ability to use `as_recovered` for `account`.
   *
   * The dispatch origin for this call must be _Signed_ and registered to
   * be able to make calls on behalf of the recovered account.
   *
   * Parameters:
   * - `account`: The recovered account you are able to call on-behalf-of.
   **/
  | { name: 'CancelRecovered'; params: { account: MultiAddress } };

export type PalletRecoveryCallLike =
  /**
   * Send a call through a recovered account.
   *
   * The dispatch origin for this call must be _Signed_ and registered to
   * be able to make calls on behalf of the recovered account.
   *
   * Parameters:
   * - `account`: The recovered account you want to make a call on-behalf-of.
   * - `call`: The call you want to make with the recovered account.
   **/
  | { name: 'AsRecovered'; params: { account: MultiAddressLike; call: RococoRuntimeRuntimeCallLike } }
  /**
   * Allow ROOT to bypass the recovery process and set an a rescuer account
   * for a lost account directly.
   *
   * The dispatch origin for this call must be _ROOT_.
   *
   * Parameters:
   * - `lost`: The "lost account" to be recovered.
   * - `rescuer`: The "rescuer account" which can call as the lost account.
   **/
  | { name: 'SetRecovered'; params: { lost: MultiAddressLike; rescuer: MultiAddressLike } }
  /**
   * Create a recovery configuration for your account. This makes your account recoverable.
   *
   * Payment: `ConfigDepositBase` + `FriendDepositFactor` * #_of_friends balance
   * will be reserved for storing the recovery configuration. This deposit is returned
   * in full when the user calls `remove_recovery`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `friends`: A list of friends you trust to vouch for recovery attempts. Should be
   * ordered and contain no duplicate values.
   * - `threshold`: The number of friends that must vouch for a recovery attempt before the
   * account can be recovered. Should be less than or equal to the length of the list of
   * friends.
   * - `delay_period`: The number of blocks after a recovery attempt is initialized that
   * needs to pass before the account can be recovered.
   **/
  | { name: 'CreateRecovery'; params: { friends: Array<AccountId32Like>; threshold: number; delayPeriod: number } }
  /**
   * Initiate the process for recovering a recoverable account.
   *
   * Payment: `RecoveryDeposit` balance will be reserved for initiating the
   * recovery process. This deposit will always be repatriated to the account
   * trying to be recovered. See `close_recovery`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `account`: The lost account that you want to recover. This account needs to be
   * recoverable (i.e. have a recovery configuration).
   **/
  | { name: 'InitiateRecovery'; params: { account: MultiAddressLike } }
  /**
   * Allow a "friend" of a recoverable account to vouch for an active recovery
   * process for that account.
   *
   * The dispatch origin for this call must be _Signed_ and must be a "friend"
   * for the recoverable account.
   *
   * Parameters:
   * - `lost`: The lost account that you want to recover.
   * - `rescuer`: The account trying to rescue the lost account that you want to vouch for.
   *
   * The combination of these two parameters must point to an active recovery
   * process.
   **/
  | { name: 'VouchRecovery'; params: { lost: MultiAddressLike; rescuer: MultiAddressLike } }
  /**
   * Allow a successful rescuer to claim their recovered account.
   *
   * The dispatch origin for this call must be _Signed_ and must be a "rescuer"
   * who has successfully completed the account recovery process: collected
   * `threshold` or more vouches, waited `delay_period` blocks since initiation.
   *
   * Parameters:
   * - `account`: The lost account that you want to claim has been successfully recovered by
   * you.
   **/
  | { name: 'ClaimRecovery'; params: { account: MultiAddressLike } }
  /**
   * As the controller of a recoverable account, close an active recovery
   * process for your account.
   *
   * Payment: By calling this function, the recoverable account will receive
   * the recovery deposit `RecoveryDeposit` placed by the rescuer.
   *
   * The dispatch origin for this call must be _Signed_ and must be a
   * recoverable account with an active recovery process for it.
   *
   * Parameters:
   * - `rescuer`: The account trying to rescue this recoverable account.
   **/
  | { name: 'CloseRecovery'; params: { rescuer: MultiAddressLike } }
  /**
   * Remove the recovery process for your account. Recovered accounts are still accessible.
   *
   * NOTE: The user must make sure to call `close_recovery` on all active
   * recovery attempts before calling this function else it will fail.
   *
   * Payment: By calling this function the recoverable account will unreserve
   * their recovery configuration deposit.
   * (`ConfigDepositBase` + `FriendDepositFactor` * #_of_friends)
   *
   * The dispatch origin for this call must be _Signed_ and must be a
   * recoverable account (i.e. has a recovery configuration).
   **/
  | { name: 'RemoveRecovery' }
  /**
   * Cancel the ability to use `as_recovered` for `account`.
   *
   * The dispatch origin for this call must be _Signed_ and registered to
   * be able to make calls on behalf of the recovered account.
   *
   * Parameters:
   * - `account`: The recovered account you are able to call on-behalf-of.
   **/
  | { name: 'CancelRecovered'; params: { account: MultiAddressLike } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletVestingCall =
  /**
   * Unlock any vested funds of the sender account.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have funds still
   * locked under this pallet.
   *
   * Emits either `VestingCompleted` or `VestingUpdated`.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'Vest' }
  /**
   * Unlock any vested funds of a `target` account.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `target`: The account whose vested funds should be unlocked. Must have funds still
   * locked under this pallet.
   *
   * Emits either `VestingCompleted` or `VestingUpdated`.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'VestOther'; params: { target: MultiAddress } }
  /**
   * Create a vested transfer.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `target`: The account receiving the vested funds.
   * - `schedule`: The vesting schedule attached to the transfer.
   *
   * Emits `VestingCreated`.
   *
   * NOTE: This will unlock all schedules through the current block.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'VestedTransfer'; params: { target: MultiAddress; schedule: PalletVestingVestingInfo } }
  /**
   * Force a vested transfer.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * - `source`: The account whose funds should be transferred.
   * - `target`: The account that should be transferred the vested funds.
   * - `schedule`: The vesting schedule attached to the transfer.
   *
   * Emits `VestingCreated`.
   *
   * NOTE: This will unlock all schedules through the current block.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | {
      name: 'ForceVestedTransfer';
      params: { source: MultiAddress; target: MultiAddress; schedule: PalletVestingVestingInfo };
    }
  /**
   * Merge two vesting schedules together, creating a new vesting schedule that unlocks over
   * the highest possible start and end blocks. If both schedules have already started the
   * current block will be used as the schedule start; with the caveat that if one schedule
   * is finished by the current block, the other will be treated as the new merged schedule,
   * unmodified.
   *
   * NOTE: If `schedule1_index == schedule2_index` this is a no-op.
   * NOTE: This will unlock all schedules through the current block prior to merging.
   * NOTE: If both schedules have ended by the current block, no new schedule will be created
   * and both will be removed.
   *
   * Merged schedule attributes:
   * - `starting_block`: `MAX(schedule1.starting_block, scheduled2.starting_block,
   * current_block)`.
   * - `ending_block`: `MAX(schedule1.ending_block, schedule2.ending_block)`.
   * - `locked`: `schedule1.locked_at(current_block) + schedule2.locked_at(current_block)`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `schedule1_index`: index of the first schedule to merge.
   * - `schedule2_index`: index of the second schedule to merge.
   **/
  | { name: 'MergeSchedules'; params: { schedule1Index: number; schedule2Index: number } }
  /**
   * Force remove a vesting schedule
   *
   * The dispatch origin for this call must be _Root_.
   *
   * - `target`: An account that has a vesting schedule
   * - `schedule_index`: The vesting schedule index that should be removed
   **/
  | { name: 'ForceRemoveVestingSchedule'; params: { target: MultiAddress; scheduleIndex: number } };

export type PalletVestingCallLike =
  /**
   * Unlock any vested funds of the sender account.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have funds still
   * locked under this pallet.
   *
   * Emits either `VestingCompleted` or `VestingUpdated`.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'Vest' }
  /**
   * Unlock any vested funds of a `target` account.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `target`: The account whose vested funds should be unlocked. Must have funds still
   * locked under this pallet.
   *
   * Emits either `VestingCompleted` or `VestingUpdated`.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'VestOther'; params: { target: MultiAddressLike } }
  /**
   * Create a vested transfer.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `target`: The account receiving the vested funds.
   * - `schedule`: The vesting schedule attached to the transfer.
   *
   * Emits `VestingCreated`.
   *
   * NOTE: This will unlock all schedules through the current block.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'VestedTransfer'; params: { target: MultiAddressLike; schedule: PalletVestingVestingInfo } }
  /**
   * Force a vested transfer.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * - `source`: The account whose funds should be transferred.
   * - `target`: The account that should be transferred the vested funds.
   * - `schedule`: The vesting schedule attached to the transfer.
   *
   * Emits `VestingCreated`.
   *
   * NOTE: This will unlock all schedules through the current block.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | {
      name: 'ForceVestedTransfer';
      params: { source: MultiAddressLike; target: MultiAddressLike; schedule: PalletVestingVestingInfo };
    }
  /**
   * Merge two vesting schedules together, creating a new vesting schedule that unlocks over
   * the highest possible start and end blocks. If both schedules have already started the
   * current block will be used as the schedule start; with the caveat that if one schedule
   * is finished by the current block, the other will be treated as the new merged schedule,
   * unmodified.
   *
   * NOTE: If `schedule1_index == schedule2_index` this is a no-op.
   * NOTE: This will unlock all schedules through the current block prior to merging.
   * NOTE: If both schedules have ended by the current block, no new schedule will be created
   * and both will be removed.
   *
   * Merged schedule attributes:
   * - `starting_block`: `MAX(schedule1.starting_block, scheduled2.starting_block,
   * current_block)`.
   * - `ending_block`: `MAX(schedule1.ending_block, schedule2.ending_block)`.
   * - `locked`: `schedule1.locked_at(current_block) + schedule2.locked_at(current_block)`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `schedule1_index`: index of the first schedule to merge.
   * - `schedule2_index`: index of the second schedule to merge.
   **/
  | { name: 'MergeSchedules'; params: { schedule1Index: number; schedule2Index: number } }
  /**
   * Force remove a vesting schedule
   *
   * The dispatch origin for this call must be _Root_.
   *
   * - `target`: An account that has a vesting schedule
   * - `schedule_index`: The vesting schedule index that should be removed
   **/
  | { name: 'ForceRemoveVestingSchedule'; params: { target: MultiAddressLike; scheduleIndex: number } };

export type PalletVestingVestingInfo = { locked: bigint; perBlock: bigint; startingBlock: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSchedulerCall =
  /**
   * Anonymously schedule a task.
   **/
  | {
      name: 'Schedule';
      params: {
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: RococoRuntimeRuntimeCall;
      };
    }
  /**
   * Cancel an anonymously scheduled task.
   **/
  | { name: 'Cancel'; params: { when: number; index: number } }
  /**
   * Schedule a named task.
   **/
  | {
      name: 'ScheduleNamed';
      params: {
        id: FixedBytes<32>;
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: RococoRuntimeRuntimeCall;
      };
    }
  /**
   * Cancel a named scheduled task.
   **/
  | { name: 'CancelNamed'; params: { id: FixedBytes<32> } }
  /**
   * Anonymously schedule a task after a delay.
   **/
  | {
      name: 'ScheduleAfter';
      params: {
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: RococoRuntimeRuntimeCall;
      };
    }
  /**
   * Schedule a named task after a delay.
   **/
  | {
      name: 'ScheduleNamedAfter';
      params: {
        id: FixedBytes<32>;
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: RococoRuntimeRuntimeCall;
      };
    }
  /**
   * Set a retry configuration for a task so that, in case its scheduled run fails, it will
   * be retried after `period` blocks, for a total amount of `retries` retries or until it
   * succeeds.
   *
   * Tasks which need to be scheduled for a retry are still subject to weight metering and
   * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
   * normally while the task is retrying.
   *
   * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
   * clones of the original task. Their retry configuration will be derived from the
   * original task's configuration, but will have a lower value for `remaining` than the
   * original `total_retries`.
   **/
  | { name: 'SetRetry'; params: { task: [number, number]; retries: number; period: number } }
  /**
   * Set a retry configuration for a named task so that, in case its scheduled run fails, it
   * will be retried after `period` blocks, for a total amount of `retries` retries or until
   * it succeeds.
   *
   * Tasks which need to be scheduled for a retry are still subject to weight metering and
   * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
   * normally while the task is retrying.
   *
   * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
   * clones of the original task. Their retry configuration will be derived from the
   * original task's configuration, but will have a lower value for `remaining` than the
   * original `total_retries`.
   **/
  | { name: 'SetRetryNamed'; params: { id: FixedBytes<32>; retries: number; period: number } }
  /**
   * Removes the retry configuration of a task.
   **/
  | { name: 'CancelRetry'; params: { task: [number, number] } }
  /**
   * Cancel the retry configuration of a named task.
   **/
  | { name: 'CancelRetryNamed'; params: { id: FixedBytes<32> } };

export type PalletSchedulerCallLike =
  /**
   * Anonymously schedule a task.
   **/
  | {
      name: 'Schedule';
      params: {
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: RococoRuntimeRuntimeCallLike;
      };
    }
  /**
   * Cancel an anonymously scheduled task.
   **/
  | { name: 'Cancel'; params: { when: number; index: number } }
  /**
   * Schedule a named task.
   **/
  | {
      name: 'ScheduleNamed';
      params: {
        id: FixedBytes<32>;
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: RococoRuntimeRuntimeCallLike;
      };
    }
  /**
   * Cancel a named scheduled task.
   **/
  | { name: 'CancelNamed'; params: { id: FixedBytes<32> } }
  /**
   * Anonymously schedule a task after a delay.
   **/
  | {
      name: 'ScheduleAfter';
      params: {
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: RococoRuntimeRuntimeCallLike;
      };
    }
  /**
   * Schedule a named task after a delay.
   **/
  | {
      name: 'ScheduleNamedAfter';
      params: {
        id: FixedBytes<32>;
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: RococoRuntimeRuntimeCallLike;
      };
    }
  /**
   * Set a retry configuration for a task so that, in case its scheduled run fails, it will
   * be retried after `period` blocks, for a total amount of `retries` retries or until it
   * succeeds.
   *
   * Tasks which need to be scheduled for a retry are still subject to weight metering and
   * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
   * normally while the task is retrying.
   *
   * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
   * clones of the original task. Their retry configuration will be derived from the
   * original task's configuration, but will have a lower value for `remaining` than the
   * original `total_retries`.
   **/
  | { name: 'SetRetry'; params: { task: [number, number]; retries: number; period: number } }
  /**
   * Set a retry configuration for a named task so that, in case its scheduled run fails, it
   * will be retried after `period` blocks, for a total amount of `retries` retries or until
   * it succeeds.
   *
   * Tasks which need to be scheduled for a retry are still subject to weight metering and
   * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
   * normally while the task is retrying.
   *
   * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
   * clones of the original task. Their retry configuration will be derived from the
   * original task's configuration, but will have a lower value for `remaining` than the
   * original `total_retries`.
   **/
  | { name: 'SetRetryNamed'; params: { id: FixedBytes<32>; retries: number; period: number } }
  /**
   * Removes the retry configuration of a task.
   **/
  | { name: 'CancelRetry'; params: { task: [number, number] } }
  /**
   * Cancel the retry configuration of a named task.
   **/
  | { name: 'CancelRetryNamed'; params: { id: FixedBytes<32> } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletProxyCall =
  /**
   * Dispatch the given `call` from an account that the sender is authorised for through
   * `add_proxy`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
   * - `call`: The call to be made by the `real` account.
   **/
  | {
      name: 'Proxy';
      params: {
        real: MultiAddress;
        forceProxyType?: RococoRuntimeProxyType | undefined;
        call: RococoRuntimeRuntimeCall;
      };
    }
  /**
   * Register a proxy account for the sender that is able to make calls on its behalf.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `proxy`: The account that the `caller` would like to make a proxy.
   * - `proxy_type`: The permissions allowed for this proxy account.
   * - `delay`: The announcement period required of the initial proxy. Will generally be
   * zero.
   **/
  | { name: 'AddProxy'; params: { delegate: MultiAddress; proxyType: RococoRuntimeProxyType; delay: number } }
  /**
   * Unregister a proxy account for the sender.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `proxy`: The account that the `caller` would like to remove as a proxy.
   * - `proxy_type`: The permissions currently enabled for the removed proxy account.
   **/
  | { name: 'RemoveProxy'; params: { delegate: MultiAddress; proxyType: RococoRuntimeProxyType; delay: number } }
  /**
   * Unregister all proxy accounts for the sender.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * WARNING: This may be called on accounts created by `pure`, however if done, then
   * the unreserved fees will be inaccessible. **All access to this account will be lost.**
   **/
  | { name: 'RemoveProxies' }
  /**
   * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
   * initialize it with a proxy of `proxy_type` for `origin` sender.
   *
   * Requires a `Signed` origin.
   *
   * - `proxy_type`: The type of the proxy that the sender will be registered as over the
   * new account. This will almost always be the most permissive `ProxyType` possible to
   * allow for maximum flexibility.
   * - `index`: A disambiguation index, in case this is called multiple times in the same
   * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
   * want to use `0`.
   * - `delay`: The announcement period required of the initial proxy. Will generally be
   * zero.
   *
   * Fails with `Duplicate` if this has already been called in this transaction, from the
   * same sender, with the same parameters.
   *
   * Fails if there are insufficient funds to pay for deposit.
   **/
  | { name: 'CreatePure'; params: { proxyType: RococoRuntimeProxyType; delay: number; index: number } }
  /**
   * Removes a previously spawned pure proxy.
   *
   * WARNING: **All access to this account will be lost.** Any funds held in it will be
   * inaccessible.
   *
   * Requires a `Signed` origin, and the sender account must have been created by a call to
   * `pure` with corresponding parameters.
   *
   * - `spawner`: The account that originally called `pure` to create this account.
   * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
   * - `proxy_type`: The proxy type originally passed to `pure`.
   * - `height`: The height of the chain when the call to `pure` was processed.
   * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
   *
   * Fails with `NoPermission` in case the caller is not a previously created pure
   * account whose `pure` call has corresponding parameters.
   **/
  | {
      name: 'KillPure';
      params: {
        spawner: MultiAddress;
        proxyType: RococoRuntimeProxyType;
        index: number;
        height: number;
        extIndex: number;
      };
    }
  /**
   * Publish the hash of a proxy-call that will be made in the future.
   *
   * This must be called some number of blocks before the corresponding `proxy` is attempted
   * if the delay associated with the proxy relationship is greater than zero.
   *
   * No more than `MaxPending` announcements may be made at any one time.
   *
   * This will take a deposit of `AnnouncementDepositFactor` as well as
   * `AnnouncementDepositBase` if there are no other pending announcements.
   *
   * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `call_hash`: The hash of the call to be made by the `real` account.
   **/
  | { name: 'Announce'; params: { real: MultiAddress; callHash: H256 } }
  /**
   * Remove a given announcement.
   *
   * May be called by a proxy account to remove a call they previously announced and return
   * the deposit.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `call_hash`: The hash of the call to be made by the `real` account.
   **/
  | { name: 'RemoveAnnouncement'; params: { real: MultiAddress; callHash: H256 } }
  /**
   * Remove the given announcement of a delegate.
   *
   * May be called by a target (proxied) account to remove a call that one of their delegates
   * (`delegate`) has announced they want to execute. The deposit is returned.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `delegate`: The account that previously announced the call.
   * - `call_hash`: The hash of the call to be made.
   **/
  | { name: 'RejectAnnouncement'; params: { delegate: MultiAddress; callHash: H256 } }
  /**
   * Dispatch the given `call` from an account that the sender is authorized for through
   * `add_proxy`.
   *
   * Removes any corresponding announcement(s).
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
   * - `call`: The call to be made by the `real` account.
   **/
  | {
      name: 'ProxyAnnounced';
      params: {
        delegate: MultiAddress;
        real: MultiAddress;
        forceProxyType?: RococoRuntimeProxyType | undefined;
        call: RococoRuntimeRuntimeCall;
      };
    };

export type PalletProxyCallLike =
  /**
   * Dispatch the given `call` from an account that the sender is authorised for through
   * `add_proxy`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
   * - `call`: The call to be made by the `real` account.
   **/
  | {
      name: 'Proxy';
      params: {
        real: MultiAddressLike;
        forceProxyType?: RococoRuntimeProxyType | undefined;
        call: RococoRuntimeRuntimeCallLike;
      };
    }
  /**
   * Register a proxy account for the sender that is able to make calls on its behalf.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `proxy`: The account that the `caller` would like to make a proxy.
   * - `proxy_type`: The permissions allowed for this proxy account.
   * - `delay`: The announcement period required of the initial proxy. Will generally be
   * zero.
   **/
  | { name: 'AddProxy'; params: { delegate: MultiAddressLike; proxyType: RococoRuntimeProxyType; delay: number } }
  /**
   * Unregister a proxy account for the sender.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `proxy`: The account that the `caller` would like to remove as a proxy.
   * - `proxy_type`: The permissions currently enabled for the removed proxy account.
   **/
  | { name: 'RemoveProxy'; params: { delegate: MultiAddressLike; proxyType: RococoRuntimeProxyType; delay: number } }
  /**
   * Unregister all proxy accounts for the sender.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * WARNING: This may be called on accounts created by `pure`, however if done, then
   * the unreserved fees will be inaccessible. **All access to this account will be lost.**
   **/
  | { name: 'RemoveProxies' }
  /**
   * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
   * initialize it with a proxy of `proxy_type` for `origin` sender.
   *
   * Requires a `Signed` origin.
   *
   * - `proxy_type`: The type of the proxy that the sender will be registered as over the
   * new account. This will almost always be the most permissive `ProxyType` possible to
   * allow for maximum flexibility.
   * - `index`: A disambiguation index, in case this is called multiple times in the same
   * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
   * want to use `0`.
   * - `delay`: The announcement period required of the initial proxy. Will generally be
   * zero.
   *
   * Fails with `Duplicate` if this has already been called in this transaction, from the
   * same sender, with the same parameters.
   *
   * Fails if there are insufficient funds to pay for deposit.
   **/
  | { name: 'CreatePure'; params: { proxyType: RococoRuntimeProxyType; delay: number; index: number } }
  /**
   * Removes a previously spawned pure proxy.
   *
   * WARNING: **All access to this account will be lost.** Any funds held in it will be
   * inaccessible.
   *
   * Requires a `Signed` origin, and the sender account must have been created by a call to
   * `pure` with corresponding parameters.
   *
   * - `spawner`: The account that originally called `pure` to create this account.
   * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
   * - `proxy_type`: The proxy type originally passed to `pure`.
   * - `height`: The height of the chain when the call to `pure` was processed.
   * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
   *
   * Fails with `NoPermission` in case the caller is not a previously created pure
   * account whose `pure` call has corresponding parameters.
   **/
  | {
      name: 'KillPure';
      params: {
        spawner: MultiAddressLike;
        proxyType: RococoRuntimeProxyType;
        index: number;
        height: number;
        extIndex: number;
      };
    }
  /**
   * Publish the hash of a proxy-call that will be made in the future.
   *
   * This must be called some number of blocks before the corresponding `proxy` is attempted
   * if the delay associated with the proxy relationship is greater than zero.
   *
   * No more than `MaxPending` announcements may be made at any one time.
   *
   * This will take a deposit of `AnnouncementDepositFactor` as well as
   * `AnnouncementDepositBase` if there are no other pending announcements.
   *
   * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `call_hash`: The hash of the call to be made by the `real` account.
   **/
  | { name: 'Announce'; params: { real: MultiAddressLike; callHash: H256 } }
  /**
   * Remove a given announcement.
   *
   * May be called by a proxy account to remove a call they previously announced and return
   * the deposit.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `call_hash`: The hash of the call to be made by the `real` account.
   **/
  | { name: 'RemoveAnnouncement'; params: { real: MultiAddressLike; callHash: H256 } }
  /**
   * Remove the given announcement of a delegate.
   *
   * May be called by a target (proxied) account to remove a call that one of their delegates
   * (`delegate`) has announced they want to execute. The deposit is returned.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `delegate`: The account that previously announced the call.
   * - `call_hash`: The hash of the call to be made.
   **/
  | { name: 'RejectAnnouncement'; params: { delegate: MultiAddressLike; callHash: H256 } }
  /**
   * Dispatch the given `call` from an account that the sender is authorized for through
   * `add_proxy`.
   *
   * Removes any corresponding announcement(s).
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
   * - `call`: The call to be made by the `real` account.
   **/
  | {
      name: 'ProxyAnnounced';
      params: {
        delegate: MultiAddressLike;
        real: MultiAddressLike;
        forceProxyType?: RococoRuntimeProxyType | undefined;
        call: RococoRuntimeRuntimeCallLike;
      };
    };

export type RococoRuntimeProxyType =
  | 'Any'
  | 'NonTransfer'
  | 'Governance'
  | 'IdentityJudgement'
  | 'CancelProxy'
  | 'Auction'
  | 'Society'
  | 'OnDemandOrdering';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMultisigCall =
  /**
   * Immediately dispatch a multi-signature call using a single approval from the caller.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `other_signatories`: The accounts (other than the sender) who are part of the
   * multi-signature, but do not participate in the approval process.
   * - `call`: The call to be executed.
   *
   * Result is equivalent to the dispatched result.
   *
   * ## Complexity
   * O(Z + C) where Z is the length of the call and C its execution weight.
   **/
  | { name: 'AsMultiThreshold1'; params: { otherSignatories: Array<AccountId32>; call: RococoRuntimeRuntimeCall } }
  /**
   * Register approval for a dispatch to be made from a deterministic composite account if
   * approved by a total of `threshold - 1` of `other_signatories`.
   *
   * If there are enough, then dispatch the call.
   *
   * Payment: `DepositBase` will be reserved if this is the first approval, plus
   * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
   * is cancelled.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
   * not the first approval, then it must be `Some`, with the timepoint (block number and
   * transaction index) of the first approval transaction.
   * - `call`: The call to be executed.
   *
   * NOTE: Unless this is the final approval, you will generally want to use
   * `approve_as_multi` instead, since it only requires a hash of the call.
   *
   * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
   * on success, result is `Ok` and the result from the interior call, if it was executed,
   * may be found in the deposited `MultisigExecuted` event.
   *
   * ## Complexity
   * - `O(S + Z + Call)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
   * - One encode & hash, both of complexity `O(S)`.
   * - Up to one binary search and insert (`O(logS + S)`).
   * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
   * - One event.
   * - The weight of the `call`.
   * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
   * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
   **/
  | {
      name: 'AsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        call: RococoRuntimeRuntimeCall;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Register approval for a dispatch to be made from a deterministic composite account if
   * approved by a total of `threshold - 1` of `other_signatories`.
   *
   * Payment: `DepositBase` will be reserved if this is the first approval, plus
   * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
   * is cancelled.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
   * not the first approval, then it must be `Some`, with the timepoint (block number and
   * transaction index) of the first approval transaction.
   * - `call_hash`: The hash of the call to be executed.
   *
   * NOTE: If this is the final approval, you will want to use `as_multi` instead.
   *
   * ## Complexity
   * - `O(S)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One encode & hash, both of complexity `O(S)`.
   * - Up to one binary search and insert (`O(logS + S)`).
   * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
   * - One event.
   * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
   * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
   **/
  | {
      name: 'ApproveAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        callHash: FixedBytes<32>;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
   * for this operation will be unreserved on success.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `timepoint`: The timepoint (block number and transaction index) of the first approval
   * transaction for this dispatch.
   * - `call_hash`: The hash of the call to be executed.
   *
   * ## Complexity
   * - `O(S)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One encode & hash, both of complexity `O(S)`.
   * - One event.
   * - I/O: 1 read `O(S)`, one remove.
   * - Storage: removes one item.
   **/
  | {
      name: 'CancelAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        timepoint: PalletMultisigTimepoint;
        callHash: FixedBytes<32>;
      };
    };

export type PalletMultisigCallLike =
  /**
   * Immediately dispatch a multi-signature call using a single approval from the caller.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `other_signatories`: The accounts (other than the sender) who are part of the
   * multi-signature, but do not participate in the approval process.
   * - `call`: The call to be executed.
   *
   * Result is equivalent to the dispatched result.
   *
   * ## Complexity
   * O(Z + C) where Z is the length of the call and C its execution weight.
   **/
  | {
      name: 'AsMultiThreshold1';
      params: { otherSignatories: Array<AccountId32Like>; call: RococoRuntimeRuntimeCallLike };
    }
  /**
   * Register approval for a dispatch to be made from a deterministic composite account if
   * approved by a total of `threshold - 1` of `other_signatories`.
   *
   * If there are enough, then dispatch the call.
   *
   * Payment: `DepositBase` will be reserved if this is the first approval, plus
   * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
   * is cancelled.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
   * not the first approval, then it must be `Some`, with the timepoint (block number and
   * transaction index) of the first approval transaction.
   * - `call`: The call to be executed.
   *
   * NOTE: Unless this is the final approval, you will generally want to use
   * `approve_as_multi` instead, since it only requires a hash of the call.
   *
   * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
   * on success, result is `Ok` and the result from the interior call, if it was executed,
   * may be found in the deposited `MultisigExecuted` event.
   *
   * ## Complexity
   * - `O(S + Z + Call)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
   * - One encode & hash, both of complexity `O(S)`.
   * - Up to one binary search and insert (`O(logS + S)`).
   * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
   * - One event.
   * - The weight of the `call`.
   * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
   * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
   **/
  | {
      name: 'AsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        call: RococoRuntimeRuntimeCallLike;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Register approval for a dispatch to be made from a deterministic composite account if
   * approved by a total of `threshold - 1` of `other_signatories`.
   *
   * Payment: `DepositBase` will be reserved if this is the first approval, plus
   * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
   * is cancelled.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
   * not the first approval, then it must be `Some`, with the timepoint (block number and
   * transaction index) of the first approval transaction.
   * - `call_hash`: The hash of the call to be executed.
   *
   * NOTE: If this is the final approval, you will want to use `as_multi` instead.
   *
   * ## Complexity
   * - `O(S)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One encode & hash, both of complexity `O(S)`.
   * - Up to one binary search and insert (`O(logS + S)`).
   * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
   * - One event.
   * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
   * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
   **/
  | {
      name: 'ApproveAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        callHash: FixedBytes<32>;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
   * for this operation will be unreserved on success.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `timepoint`: The timepoint (block number and transaction index) of the first approval
   * transaction for this dispatch.
   * - `call_hash`: The hash of the call to be executed.
   *
   * ## Complexity
   * - `O(S)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One encode & hash, both of complexity `O(S)`.
   * - One event.
   * - I/O: 1 read `O(S)`, one remove.
   * - Storage: removes one item.
   **/
  | {
      name: 'CancelAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        timepoint: PalletMultisigTimepoint;
        callHash: FixedBytes<32>;
      };
    };

export type PalletMultisigTimepoint = { height: number; index: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletPreimageCall =
  /**
   * Register a preimage on-chain.
   *
   * If the preimage was previously requested, no fees or deposits are taken for providing
   * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
   **/
  | { name: 'NotePreimage'; params: { bytes: Bytes } }
  /**
   * Clear an unrequested preimage from the runtime storage.
   *
   * If `len` is provided, then it will be a much cheaper operation.
   *
   * - `hash`: The hash of the preimage to be removed from the store.
   * - `len`: The length of the preimage of `hash`.
   **/
  | { name: 'UnnotePreimage'; params: { hash: H256 } }
  /**
   * Request a preimage be uploaded to the chain without paying any fees or deposits.
   *
   * If the preimage requests has already been provided on-chain, we unreserve any deposit
   * a user may have paid, and take the control of the preimage out of their hands.
   **/
  | { name: 'RequestPreimage'; params: { hash: H256 } }
  /**
   * Clear a previously made request for a preimage.
   *
   * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
   **/
  | { name: 'UnrequestPreimage'; params: { hash: H256 } }
  /**
   * Ensure that the a bulk of pre-images is upgraded.
   *
   * The caller pays no fee if at least 90% of pre-images were successfully updated.
   **/
  | { name: 'EnsureUpdated'; params: { hashes: Array<H256> } };

export type PalletPreimageCallLike =
  /**
   * Register a preimage on-chain.
   *
   * If the preimage was previously requested, no fees or deposits are taken for providing
   * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
   **/
  | { name: 'NotePreimage'; params: { bytes: BytesLike } }
  /**
   * Clear an unrequested preimage from the runtime storage.
   *
   * If `len` is provided, then it will be a much cheaper operation.
   *
   * - `hash`: The hash of the preimage to be removed from the store.
   * - `len`: The length of the preimage of `hash`.
   **/
  | { name: 'UnnotePreimage'; params: { hash: H256 } }
  /**
   * Request a preimage be uploaded to the chain without paying any fees or deposits.
   *
   * If the preimage requests has already been provided on-chain, we unreserve any deposit
   * a user may have paid, and take the control of the preimage out of their hands.
   **/
  | { name: 'RequestPreimage'; params: { hash: H256 } }
  /**
   * Clear a previously made request for a preimage.
   *
   * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
   **/
  | { name: 'UnrequestPreimage'; params: { hash: H256 } }
  /**
   * Ensure that the a bulk of pre-images is upgraded.
   *
   * The caller pays no fee if at least 90% of pre-images were successfully updated.
   **/
  | { name: 'EnsureUpdated'; params: { hashes: Array<H256> } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletAssetRateCall =
  /**
   * Initialize a conversion rate to native balance for the given asset.
   *
   * ## Complexity
   * - O(1)
   **/
  | { name: 'Create'; params: { assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset; rate: FixedU128 } }
  /**
   * Update the conversion rate to native balance for the given asset.
   *
   * ## Complexity
   * - O(1)
   **/
  | { name: 'Update'; params: { assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset; rate: FixedU128 } }
  /**
   * Remove an existing conversion rate to native balance for the given asset.
   *
   * ## Complexity
   * - O(1)
   **/
  | { name: 'Remove'; params: { assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset } };

export type PalletAssetRateCallLike =
  /**
   * Initialize a conversion rate to native balance for the given asset.
   *
   * ## Complexity
   * - O(1)
   **/
  | { name: 'Create'; params: { assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset; rate: FixedU128 } }
  /**
   * Update the conversion rate to native balance for the given asset.
   *
   * ## Complexity
   * - O(1)
   **/
  | { name: 'Update'; params: { assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset; rate: FixedU128 } }
  /**
   * Remove an existing conversion rate to native balance for the given asset.
   *
   * ## Complexity
   * - O(1)
   **/
  | { name: 'Remove'; params: { assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBountiesCall =
  /**
   * Propose a new bounty.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
   * `DataDepositPerByte` for each byte in `reason`. It will be unreserved upon approval,
   * or slashed when rejected.
   *
   * - `curator`: The curator account whom will manage this bounty.
   * - `fee`: The curator fee.
   * - `value`: The total payment amount of this bounty, curator fee included.
   * - `description`: The description of this bounty.
   **/
  | { name: 'ProposeBounty'; params: { value: bigint; description: Bytes } }
  /**
   * Approve a bounty proposal. At a later time, the bounty will be funded and become active
   * and the original deposit will be returned.
   *
   * May only be called from `T::SpendOrigin`.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'ApproveBounty'; params: { bountyId: number } }
  /**
   * Propose a curator to a funded bounty.
   *
   * May only be called from `T::SpendOrigin`.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'ProposeCurator'; params: { bountyId: number; curator: MultiAddress; fee: bigint } }
  /**
   * Unassign curator from a bounty.
   *
   * This function can only be called by the `RejectOrigin` a signed origin.
   *
   * If this function is called by the `RejectOrigin`, we assume that the curator is
   * malicious or inactive. As a result, we will slash the curator when possible.
   *
   * If the origin is the curator, we take this as a sign they are unable to do their job and
   * they willingly give up. We could slash them, but for now we allow them to recover their
   * deposit and exit without issue. (We may want to change this if it is abused.)
   *
   * Finally, the origin can be anyone if and only if the curator is "inactive". This allows
   * anyone in the community to call out that a curator is not doing their due diligence, and
   * we should pick a new curator. In this case the curator should also be slashed.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'UnassignCurator'; params: { bountyId: number } }
  /**
   * Accept the curator role for a bounty.
   * A deposit will be reserved from curator and refund upon successful payout.
   *
   * May only be called from the curator.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'AcceptCurator'; params: { bountyId: number } }
  /**
   * Award bounty to a beneficiary account. The beneficiary will be able to claim the funds
   * after a delay.
   *
   * The dispatch origin for this call must be the curator of this bounty.
   *
   * - `bounty_id`: Bounty ID to award.
   * - `beneficiary`: The beneficiary account whom will receive the payout.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'AwardBounty'; params: { bountyId: number; beneficiary: MultiAddress } }
  /**
   * Claim the payout from an awarded bounty after payout delay.
   *
   * The dispatch origin for this call must be the beneficiary of this bounty.
   *
   * - `bounty_id`: Bounty ID to claim.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'ClaimBounty'; params: { bountyId: number } }
  /**
   * Cancel a proposed or active bounty. All the funds will be sent to treasury and
   * the curator deposit will be unreserved if possible.
   *
   * Only `T::RejectOrigin` is able to cancel a bounty.
   *
   * - `bounty_id`: Bounty ID to cancel.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'CloseBounty'; params: { bountyId: number } }
  /**
   * Extend the expiry time of an active bounty.
   *
   * The dispatch origin for this call must be the curator of this bounty.
   *
   * - `bounty_id`: Bounty ID to extend.
   * - `remark`: additional information.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'ExtendBountyExpiry'; params: { bountyId: number; remark: Bytes } };

export type PalletBountiesCallLike =
  /**
   * Propose a new bounty.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
   * `DataDepositPerByte` for each byte in `reason`. It will be unreserved upon approval,
   * or slashed when rejected.
   *
   * - `curator`: The curator account whom will manage this bounty.
   * - `fee`: The curator fee.
   * - `value`: The total payment amount of this bounty, curator fee included.
   * - `description`: The description of this bounty.
   **/
  | { name: 'ProposeBounty'; params: { value: bigint; description: BytesLike } }
  /**
   * Approve a bounty proposal. At a later time, the bounty will be funded and become active
   * and the original deposit will be returned.
   *
   * May only be called from `T::SpendOrigin`.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'ApproveBounty'; params: { bountyId: number } }
  /**
   * Propose a curator to a funded bounty.
   *
   * May only be called from `T::SpendOrigin`.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'ProposeCurator'; params: { bountyId: number; curator: MultiAddressLike; fee: bigint } }
  /**
   * Unassign curator from a bounty.
   *
   * This function can only be called by the `RejectOrigin` a signed origin.
   *
   * If this function is called by the `RejectOrigin`, we assume that the curator is
   * malicious or inactive. As a result, we will slash the curator when possible.
   *
   * If the origin is the curator, we take this as a sign they are unable to do their job and
   * they willingly give up. We could slash them, but for now we allow them to recover their
   * deposit and exit without issue. (We may want to change this if it is abused.)
   *
   * Finally, the origin can be anyone if and only if the curator is "inactive". This allows
   * anyone in the community to call out that a curator is not doing their due diligence, and
   * we should pick a new curator. In this case the curator should also be slashed.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'UnassignCurator'; params: { bountyId: number } }
  /**
   * Accept the curator role for a bounty.
   * A deposit will be reserved from curator and refund upon successful payout.
   *
   * May only be called from the curator.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'AcceptCurator'; params: { bountyId: number } }
  /**
   * Award bounty to a beneficiary account. The beneficiary will be able to claim the funds
   * after a delay.
   *
   * The dispatch origin for this call must be the curator of this bounty.
   *
   * - `bounty_id`: Bounty ID to award.
   * - `beneficiary`: The beneficiary account whom will receive the payout.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'AwardBounty'; params: { bountyId: number; beneficiary: MultiAddressLike } }
  /**
   * Claim the payout from an awarded bounty after payout delay.
   *
   * The dispatch origin for this call must be the beneficiary of this bounty.
   *
   * - `bounty_id`: Bounty ID to claim.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'ClaimBounty'; params: { bountyId: number } }
  /**
   * Cancel a proposed or active bounty. All the funds will be sent to treasury and
   * the curator deposit will be unreserved if possible.
   *
   * Only `T::RejectOrigin` is able to cancel a bounty.
   *
   * - `bounty_id`: Bounty ID to cancel.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'CloseBounty'; params: { bountyId: number } }
  /**
   * Extend the expiry time of an active bounty.
   *
   * The dispatch origin for this call must be the curator of this bounty.
   *
   * - `bounty_id`: Bounty ID to extend.
   * - `remark`: additional information.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'ExtendBountyExpiry'; params: { bountyId: number; remark: BytesLike } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletChildBountiesCall =
  /**
   * Add a new child-bounty.
   *
   * The dispatch origin for this call must be the curator of parent
   * bounty and the parent bounty must be in "active" state.
   *
   * Child-bounty gets added successfully & fund gets transferred from
   * parent bounty to child-bounty account, if parent bounty has enough
   * funds, else the call fails.
   *
   * Upper bound to maximum number of active child bounties that can be
   * added are managed via runtime trait config
   * [`Config::MaxActiveChildBountyCount`].
   *
   * If the call is success, the status of child-bounty is updated to
   * "Added".
   *
   * - `parent_bounty_id`: Index of parent bounty for which child-bounty is being added.
   * - `value`: Value for executing the proposal.
   * - `description`: Text description for the child-bounty.
   **/
  | { name: 'AddChildBounty'; params: { parentBountyId: number; value: bigint; description: Bytes } }
  /**
   * Propose curator for funded child-bounty.
   *
   * The dispatch origin for this call must be curator of parent bounty.
   *
   * Parent bounty must be in active state, for this child-bounty call to
   * work.
   *
   * Child-bounty must be in "Added" state, for processing the call. And
   * state of child-bounty is moved to "CuratorProposed" on successful
   * call completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   * - `curator`: Address of child-bounty curator.
   * - `fee`: payment fee to child-bounty curator for execution.
   **/
  | {
      name: 'ProposeCurator';
      params: { parentBountyId: number; childBountyId: number; curator: MultiAddress; fee: bigint };
    }
  /**
   * Accept the curator role for the child-bounty.
   *
   * The dispatch origin for this call must be the curator of this
   * child-bounty.
   *
   * A deposit will be reserved from the curator and refund upon
   * successful payout or cancellation.
   *
   * Fee for curator is deducted from curator fee of parent bounty.
   *
   * Parent bounty must be in active state, for this child-bounty call to
   * work.
   *
   * Child-bounty must be in "CuratorProposed" state, for processing the
   * call. And state of child-bounty is moved to "Active" on successful
   * call completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   **/
  | { name: 'AcceptCurator'; params: { parentBountyId: number; childBountyId: number } }
  /**
   * Unassign curator from a child-bounty.
   *
   * The dispatch origin for this call can be either `RejectOrigin`, or
   * the curator of the parent bounty, or any signed origin.
   *
   * For the origin other than T::RejectOrigin and the child-bounty
   * curator, parent bounty must be in active state, for this call to
   * work. We allow child-bounty curator and T::RejectOrigin to execute
   * this call irrespective of the parent bounty state.
   *
   * If this function is called by the `RejectOrigin` or the
   * parent bounty curator, we assume that the child-bounty curator is
   * malicious or inactive. As a result, child-bounty curator deposit is
   * slashed.
   *
   * If the origin is the child-bounty curator, we take this as a sign
   * that they are unable to do their job, and are willingly giving up.
   * We could slash the deposit, but for now we allow them to unreserve
   * their deposit and exit without issue. (We may want to change this if
   * it is abused.)
   *
   * Finally, the origin can be anyone iff the child-bounty curator is
   * "inactive". Expiry update due of parent bounty is used to estimate
   * inactive state of child-bounty curator.
   *
   * This allows anyone in the community to call out that a child-bounty
   * curator is not doing their due diligence, and we should pick a new
   * one. In this case the child-bounty curator deposit is slashed.
   *
   * State of child-bounty is moved to Added state on successful call
   * completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   **/
  | { name: 'UnassignCurator'; params: { parentBountyId: number; childBountyId: number } }
  /**
   * Award child-bounty to a beneficiary.
   *
   * The beneficiary will be able to claim the funds after a delay.
   *
   * The dispatch origin for this call must be the parent curator or
   * curator of this child-bounty.
   *
   * Parent bounty must be in active state, for this child-bounty call to
   * work.
   *
   * Child-bounty must be in active state, for processing the call. And
   * state of child-bounty is moved to "PendingPayout" on successful call
   * completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   * - `beneficiary`: Beneficiary account.
   **/
  | { name: 'AwardChildBounty'; params: { parentBountyId: number; childBountyId: number; beneficiary: MultiAddress } }
  /**
   * Claim the payout from an awarded child-bounty after payout delay.
   *
   * The dispatch origin for this call may be any signed origin.
   *
   * Call works independent of parent bounty state, No need for parent
   * bounty to be in active state.
   *
   * The Beneficiary is paid out with agreed bounty value. Curator fee is
   * paid & curator deposit is unreserved.
   *
   * Child-bounty must be in "PendingPayout" state, for processing the
   * call. And instance of child-bounty is removed from the state on
   * successful call completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   **/
  | { name: 'ClaimChildBounty'; params: { parentBountyId: number; childBountyId: number } }
  /**
   * Cancel a proposed or active child-bounty. Child-bounty account funds
   * are transferred to parent bounty account. The child-bounty curator
   * deposit may be unreserved if possible.
   *
   * The dispatch origin for this call must be either parent curator or
   * `T::RejectOrigin`.
   *
   * If the state of child-bounty is `Active`, curator deposit is
   * unreserved.
   *
   * If the state of child-bounty is `PendingPayout`, call fails &
   * returns `PendingPayout` error.
   *
   * For the origin other than T::RejectOrigin, parent bounty must be in
   * active state, for this child-bounty call to work. For origin
   * T::RejectOrigin execution is forced.
   *
   * Instance of child-bounty is removed from the state on successful
   * call completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   **/
  | { name: 'CloseChildBounty'; params: { parentBountyId: number; childBountyId: number } };

export type PalletChildBountiesCallLike =
  /**
   * Add a new child-bounty.
   *
   * The dispatch origin for this call must be the curator of parent
   * bounty and the parent bounty must be in "active" state.
   *
   * Child-bounty gets added successfully & fund gets transferred from
   * parent bounty to child-bounty account, if parent bounty has enough
   * funds, else the call fails.
   *
   * Upper bound to maximum number of active child bounties that can be
   * added are managed via runtime trait config
   * [`Config::MaxActiveChildBountyCount`].
   *
   * If the call is success, the status of child-bounty is updated to
   * "Added".
   *
   * - `parent_bounty_id`: Index of parent bounty for which child-bounty is being added.
   * - `value`: Value for executing the proposal.
   * - `description`: Text description for the child-bounty.
   **/
  | { name: 'AddChildBounty'; params: { parentBountyId: number; value: bigint; description: BytesLike } }
  /**
   * Propose curator for funded child-bounty.
   *
   * The dispatch origin for this call must be curator of parent bounty.
   *
   * Parent bounty must be in active state, for this child-bounty call to
   * work.
   *
   * Child-bounty must be in "Added" state, for processing the call. And
   * state of child-bounty is moved to "CuratorProposed" on successful
   * call completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   * - `curator`: Address of child-bounty curator.
   * - `fee`: payment fee to child-bounty curator for execution.
   **/
  | {
      name: 'ProposeCurator';
      params: { parentBountyId: number; childBountyId: number; curator: MultiAddressLike; fee: bigint };
    }
  /**
   * Accept the curator role for the child-bounty.
   *
   * The dispatch origin for this call must be the curator of this
   * child-bounty.
   *
   * A deposit will be reserved from the curator and refund upon
   * successful payout or cancellation.
   *
   * Fee for curator is deducted from curator fee of parent bounty.
   *
   * Parent bounty must be in active state, for this child-bounty call to
   * work.
   *
   * Child-bounty must be in "CuratorProposed" state, for processing the
   * call. And state of child-bounty is moved to "Active" on successful
   * call completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   **/
  | { name: 'AcceptCurator'; params: { parentBountyId: number; childBountyId: number } }
  /**
   * Unassign curator from a child-bounty.
   *
   * The dispatch origin for this call can be either `RejectOrigin`, or
   * the curator of the parent bounty, or any signed origin.
   *
   * For the origin other than T::RejectOrigin and the child-bounty
   * curator, parent bounty must be in active state, for this call to
   * work. We allow child-bounty curator and T::RejectOrigin to execute
   * this call irrespective of the parent bounty state.
   *
   * If this function is called by the `RejectOrigin` or the
   * parent bounty curator, we assume that the child-bounty curator is
   * malicious or inactive. As a result, child-bounty curator deposit is
   * slashed.
   *
   * If the origin is the child-bounty curator, we take this as a sign
   * that they are unable to do their job, and are willingly giving up.
   * We could slash the deposit, but for now we allow them to unreserve
   * their deposit and exit without issue. (We may want to change this if
   * it is abused.)
   *
   * Finally, the origin can be anyone iff the child-bounty curator is
   * "inactive". Expiry update due of parent bounty is used to estimate
   * inactive state of child-bounty curator.
   *
   * This allows anyone in the community to call out that a child-bounty
   * curator is not doing their due diligence, and we should pick a new
   * one. In this case the child-bounty curator deposit is slashed.
   *
   * State of child-bounty is moved to Added state on successful call
   * completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   **/
  | { name: 'UnassignCurator'; params: { parentBountyId: number; childBountyId: number } }
  /**
   * Award child-bounty to a beneficiary.
   *
   * The beneficiary will be able to claim the funds after a delay.
   *
   * The dispatch origin for this call must be the parent curator or
   * curator of this child-bounty.
   *
   * Parent bounty must be in active state, for this child-bounty call to
   * work.
   *
   * Child-bounty must be in active state, for processing the call. And
   * state of child-bounty is moved to "PendingPayout" on successful call
   * completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   * - `beneficiary`: Beneficiary account.
   **/
  | {
      name: 'AwardChildBounty';
      params: { parentBountyId: number; childBountyId: number; beneficiary: MultiAddressLike };
    }
  /**
   * Claim the payout from an awarded child-bounty after payout delay.
   *
   * The dispatch origin for this call may be any signed origin.
   *
   * Call works independent of parent bounty state, No need for parent
   * bounty to be in active state.
   *
   * The Beneficiary is paid out with agreed bounty value. Curator fee is
   * paid & curator deposit is unreserved.
   *
   * Child-bounty must be in "PendingPayout" state, for processing the
   * call. And instance of child-bounty is removed from the state on
   * successful call completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   **/
  | { name: 'ClaimChildBounty'; params: { parentBountyId: number; childBountyId: number } }
  /**
   * Cancel a proposed or active child-bounty. Child-bounty account funds
   * are transferred to parent bounty account. The child-bounty curator
   * deposit may be unreserved if possible.
   *
   * The dispatch origin for this call must be either parent curator or
   * `T::RejectOrigin`.
   *
   * If the state of child-bounty is `Active`, curator deposit is
   * unreserved.
   *
   * If the state of child-bounty is `PendingPayout`, call fails &
   * returns `PendingPayout` error.
   *
   * For the origin other than T::RejectOrigin, parent bounty must be in
   * active state, for this child-bounty call to work. For origin
   * T::RejectOrigin execution is forced.
   *
   * Instance of child-bounty is removed from the state on successful
   * call completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   **/
  | { name: 'CloseChildBounty'; params: { parentBountyId: number; childBountyId: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletNisCall =
  /**
   * Place a bid.
   *
   * Origin must be Signed, and account must have at least `amount` in free balance.
   *
   * - `amount`: The amount of the bid; these funds will be reserved, and if/when
   * consolidated, removed. Must be at least `MinBid`.
   * - `duration`: The number of periods before which the newly consolidated bid may be
   * thawed. Must be greater than 1 and no more than `QueueCount`.
   *
   * Complexities:
   * - `Queues[duration].len()` (just take max).
   **/
  | { name: 'PlaceBid'; params: { amount: bigint; duration: number } }
  /**
   * Retract a previously placed bid.
   *
   * Origin must be Signed, and the account should have previously issued a still-active bid
   * of `amount` for `duration`.
   *
   * - `amount`: The amount of the previous bid.
   * - `duration`: The duration of the previous bid.
   **/
  | { name: 'RetractBid'; params: { amount: bigint; duration: number } }
  /**
   * Ensure we have sufficient funding for all potential payouts.
   *
   * - `origin`: Must be accepted by `FundOrigin`.
   **/
  | { name: 'FundDeficit' }
  /**
   * Reduce or remove an outstanding receipt, placing the according proportion of funds into
   * the account of the owner.
   *
   * - `origin`: Must be Signed and the account must be the owner of the receipt `index` as
   * well as any fungible counterpart.
   * - `index`: The index of the receipt.
   * - `portion`: If `Some`, then only the given portion of the receipt should be thawed. If
   * `None`, then all of it should be.
   **/
  | { name: 'ThawPrivate'; params: { index: number; maybeProportion?: Perquintill | undefined } }
  /**
   * Reduce or remove an outstanding receipt, placing the according proportion of funds into
   * the account of the owner.
   *
   * - `origin`: Must be Signed and the account must be the owner of the fungible counterpart
   * for receipt `index`.
   * - `index`: The index of the receipt.
   **/
  | { name: 'ThawCommunal'; params: { index: number } }
  /**
   * Make a private receipt communal and create fungible counterparts for its owner.
   **/
  | { name: 'Communify'; params: { index: number } }
  /**
   * Make a communal receipt private and burn fungible counterparts from its owner.
   **/
  | { name: 'Privatize'; params: { index: number } };

export type PalletNisCallLike =
  /**
   * Place a bid.
   *
   * Origin must be Signed, and account must have at least `amount` in free balance.
   *
   * - `amount`: The amount of the bid; these funds will be reserved, and if/when
   * consolidated, removed. Must be at least `MinBid`.
   * - `duration`: The number of periods before which the newly consolidated bid may be
   * thawed. Must be greater than 1 and no more than `QueueCount`.
   *
   * Complexities:
   * - `Queues[duration].len()` (just take max).
   **/
  | { name: 'PlaceBid'; params: { amount: bigint; duration: number } }
  /**
   * Retract a previously placed bid.
   *
   * Origin must be Signed, and the account should have previously issued a still-active bid
   * of `amount` for `duration`.
   *
   * - `amount`: The amount of the previous bid.
   * - `duration`: The duration of the previous bid.
   **/
  | { name: 'RetractBid'; params: { amount: bigint; duration: number } }
  /**
   * Ensure we have sufficient funding for all potential payouts.
   *
   * - `origin`: Must be accepted by `FundOrigin`.
   **/
  | { name: 'FundDeficit' }
  /**
   * Reduce or remove an outstanding receipt, placing the according proportion of funds into
   * the account of the owner.
   *
   * - `origin`: Must be Signed and the account must be the owner of the receipt `index` as
   * well as any fungible counterpart.
   * - `index`: The index of the receipt.
   * - `portion`: If `Some`, then only the given portion of the receipt should be thawed. If
   * `None`, then all of it should be.
   **/
  | { name: 'ThawPrivate'; params: { index: number; maybeProportion?: Perquintill | undefined } }
  /**
   * Reduce or remove an outstanding receipt, placing the according proportion of funds into
   * the account of the owner.
   *
   * - `origin`: Must be Signed and the account must be the owner of the fungible counterpart
   * for receipt `index`.
   * - `index`: The index of the receipt.
   **/
  | { name: 'ThawCommunal'; params: { index: number } }
  /**
   * Make a private receipt communal and create fungible counterparts for its owner.
   **/
  | { name: 'Communify'; params: { index: number } }
  /**
   * Make a communal receipt private and burn fungible counterparts from its owner.
   **/
  | { name: 'Privatize'; params: { index: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeParachainsConfigurationPalletCall =
  /**
   * Set the validation upgrade cooldown.
   **/
  | { name: 'SetValidationUpgradeCooldown'; params: { new: number } }
  /**
   * Set the validation upgrade delay.
   **/
  | { name: 'SetValidationUpgradeDelay'; params: { new: number } }
  /**
   * Set the acceptance period for an included candidate.
   **/
  | { name: 'SetCodeRetentionPeriod'; params: { new: number } }
  /**
   * Set the max validation code size for incoming upgrades.
   **/
  | { name: 'SetMaxCodeSize'; params: { new: number } }
  /**
   * Set the max POV block size for incoming upgrades.
   **/
  | { name: 'SetMaxPovSize'; params: { new: number } }
  /**
   * Set the max head data size for paras.
   **/
  | { name: 'SetMaxHeadDataSize'; params: { new: number } }
  /**
   * Set the number of coretime execution cores.
   *
   * Note that this configuration is managed by the coretime chain. Only manually change
   * this, if you really know what you are doing!
   **/
  | { name: 'SetCoretimeCores'; params: { new: number } }
  /**
   * Set the max number of times a claim may timeout on a core before it is abandoned
   **/
  | { name: 'SetMaxAvailabilityTimeouts'; params: { new: number } }
  /**
   * Set the parachain validator-group rotation frequency
   **/
  | { name: 'SetGroupRotationFrequency'; params: { new: number } }
  /**
   * Set the availability period for paras.
   **/
  | { name: 'SetParasAvailabilityPeriod'; params: { new: number } }
  /**
   * Set the scheduling lookahead, in expected number of blocks at peak throughput.
   **/
  | { name: 'SetSchedulingLookahead'; params: { new: number } }
  /**
   * Set the maximum number of validators to assign to any core.
   **/
  | { name: 'SetMaxValidatorsPerCore'; params: { new?: number | undefined } }
  /**
   * Set the maximum number of validators to use in parachain consensus.
   **/
  | { name: 'SetMaxValidators'; params: { new?: number | undefined } }
  /**
   * Set the dispute period, in number of sessions to keep for disputes.
   **/
  | { name: 'SetDisputePeriod'; params: { new: number } }
  /**
   * Set the dispute post conclusion acceptance period.
   **/
  | { name: 'SetDisputePostConclusionAcceptancePeriod'; params: { new: number } }
  /**
   * Set the no show slots, in number of number of consensus slots.
   * Must be at least 1.
   **/
  | { name: 'SetNoShowSlots'; params: { new: number } }
  /**
   * Set the total number of delay tranches.
   **/
  | { name: 'SetNDelayTranches'; params: { new: number } }
  /**
   * Set the zeroth delay tranche width.
   **/
  | { name: 'SetZerothDelayTrancheWidth'; params: { new: number } }
  /**
   * Set the number of validators needed to approve a block.
   **/
  | { name: 'SetNeededApprovals'; params: { new: number } }
  /**
   * Set the number of samples to do of the `RelayVRFModulo` approval assignment criterion.
   **/
  | { name: 'SetRelayVrfModuloSamples'; params: { new: number } }
  /**
   * Sets the maximum items that can present in a upward dispatch queue at once.
   **/
  | { name: 'SetMaxUpwardQueueCount'; params: { new: number } }
  /**
   * Sets the maximum total size of items that can present in a upward dispatch queue at
   * once.
   **/
  | { name: 'SetMaxUpwardQueueSize'; params: { new: number } }
  /**
   * Set the critical downward message size.
   **/
  | { name: 'SetMaxDownwardMessageSize'; params: { new: number } }
  /**
   * Sets the maximum size of an upward message that can be sent by a candidate.
   **/
  | { name: 'SetMaxUpwardMessageSize'; params: { new: number } }
  /**
   * Sets the maximum number of messages that a candidate can contain.
   **/
  | { name: 'SetMaxUpwardMessageNumPerCandidate'; params: { new: number } }
  /**
   * Sets the number of sessions after which an HRMP open channel request expires.
   **/
  | { name: 'SetHrmpOpenRequestTtl'; params: { new: number } }
  /**
   * Sets the amount of funds that the sender should provide for opening an HRMP channel.
   **/
  | { name: 'SetHrmpSenderDeposit'; params: { new: bigint } }
  /**
   * Sets the amount of funds that the recipient should provide for accepting opening an HRMP
   * channel.
   **/
  | { name: 'SetHrmpRecipientDeposit'; params: { new: bigint } }
  /**
   * Sets the maximum number of messages allowed in an HRMP channel at once.
   **/
  | { name: 'SetHrmpChannelMaxCapacity'; params: { new: number } }
  /**
   * Sets the maximum total size of messages in bytes allowed in an HRMP channel at once.
   **/
  | { name: 'SetHrmpChannelMaxTotalSize'; params: { new: number } }
  /**
   * Sets the maximum number of inbound HRMP channels a parachain is allowed to accept.
   **/
  | { name: 'SetHrmpMaxParachainInboundChannels'; params: { new: number } }
  /**
   * Sets the maximum size of a message that could ever be put into an HRMP channel.
   **/
  | { name: 'SetHrmpChannelMaxMessageSize'; params: { new: number } }
  /**
   * Sets the maximum number of outbound HRMP channels a parachain is allowed to open.
   **/
  | { name: 'SetHrmpMaxParachainOutboundChannels'; params: { new: number } }
  /**
   * Sets the maximum number of outbound HRMP messages can be sent by a candidate.
   **/
  | { name: 'SetHrmpMaxMessageNumPerCandidate'; params: { new: number } }
  /**
   * Set the number of session changes after which a PVF pre-checking voting is rejected.
   **/
  | { name: 'SetPvfVotingTtl'; params: { new: number } }
  /**
   * Sets the minimum delay between announcing the upgrade block for a parachain until the
   * upgrade taking place.
   *
   * See the field documentation for information and constraints for the new value.
   **/
  | { name: 'SetMinimumValidationUpgradeDelay'; params: { new: number } }
  /**
   * Setting this to true will disable consistency checks for the configuration setters.
   * Use with caution.
   **/
  | { name: 'SetBypassConsistencyCheck'; params: { new: boolean } }
  /**
   * Set the asynchronous backing parameters.
   **/
  | { name: 'SetAsyncBackingParams'; params: { new: PolkadotPrimitivesV6AsyncBackingAsyncBackingParams } }
  /**
   * Set PVF executor parameters.
   **/
  | { name: 'SetExecutorParams'; params: { new: PolkadotPrimitivesV6ExecutorParams } }
  /**
   * Set the on demand (parathreads) base fee.
   **/
  | { name: 'SetOnDemandBaseFee'; params: { new: bigint } }
  /**
   * Set the on demand (parathreads) fee variability.
   **/
  | { name: 'SetOnDemandFeeVariability'; params: { new: Perbill } }
  /**
   * Set the on demand (parathreads) queue max size.
   **/
  | { name: 'SetOnDemandQueueMaxSize'; params: { new: number } }
  /**
   * Set the on demand (parathreads) fee variability.
   **/
  | { name: 'SetOnDemandTargetQueueUtilization'; params: { new: Perbill } }
  /**
   * Set the on demand (parathreads) ttl in the claimqueue.
   **/
  | { name: 'SetOnDemandTtl'; params: { new: number } }
  /**
   * Set the minimum backing votes threshold.
   **/
  | { name: 'SetMinimumBackingVotes'; params: { new: number } }
  /**
   * Set/Unset a node feature.
   **/
  | { name: 'SetNodeFeature'; params: { index: number; value: boolean } }
  /**
   * Set approval-voting-params.
   **/
  | { name: 'SetApprovalVotingParams'; params: { new: PolkadotPrimitivesVstagingApprovalVotingParams } }
  /**
   * Set scheduler-params.
   **/
  | { name: 'SetSchedulerParams'; params: { new: PolkadotPrimitivesVstagingSchedulerParams } };

export type PolkadotRuntimeParachainsConfigurationPalletCallLike =
  /**
   * Set the validation upgrade cooldown.
   **/
  | { name: 'SetValidationUpgradeCooldown'; params: { new: number } }
  /**
   * Set the validation upgrade delay.
   **/
  | { name: 'SetValidationUpgradeDelay'; params: { new: number } }
  /**
   * Set the acceptance period for an included candidate.
   **/
  | { name: 'SetCodeRetentionPeriod'; params: { new: number } }
  /**
   * Set the max validation code size for incoming upgrades.
   **/
  | { name: 'SetMaxCodeSize'; params: { new: number } }
  /**
   * Set the max POV block size for incoming upgrades.
   **/
  | { name: 'SetMaxPovSize'; params: { new: number } }
  /**
   * Set the max head data size for paras.
   **/
  | { name: 'SetMaxHeadDataSize'; params: { new: number } }
  /**
   * Set the number of coretime execution cores.
   *
   * Note that this configuration is managed by the coretime chain. Only manually change
   * this, if you really know what you are doing!
   **/
  | { name: 'SetCoretimeCores'; params: { new: number } }
  /**
   * Set the max number of times a claim may timeout on a core before it is abandoned
   **/
  | { name: 'SetMaxAvailabilityTimeouts'; params: { new: number } }
  /**
   * Set the parachain validator-group rotation frequency
   **/
  | { name: 'SetGroupRotationFrequency'; params: { new: number } }
  /**
   * Set the availability period for paras.
   **/
  | { name: 'SetParasAvailabilityPeriod'; params: { new: number } }
  /**
   * Set the scheduling lookahead, in expected number of blocks at peak throughput.
   **/
  | { name: 'SetSchedulingLookahead'; params: { new: number } }
  /**
   * Set the maximum number of validators to assign to any core.
   **/
  | { name: 'SetMaxValidatorsPerCore'; params: { new?: number | undefined } }
  /**
   * Set the maximum number of validators to use in parachain consensus.
   **/
  | { name: 'SetMaxValidators'; params: { new?: number | undefined } }
  /**
   * Set the dispute period, in number of sessions to keep for disputes.
   **/
  | { name: 'SetDisputePeriod'; params: { new: number } }
  /**
   * Set the dispute post conclusion acceptance period.
   **/
  | { name: 'SetDisputePostConclusionAcceptancePeriod'; params: { new: number } }
  /**
   * Set the no show slots, in number of number of consensus slots.
   * Must be at least 1.
   **/
  | { name: 'SetNoShowSlots'; params: { new: number } }
  /**
   * Set the total number of delay tranches.
   **/
  | { name: 'SetNDelayTranches'; params: { new: number } }
  /**
   * Set the zeroth delay tranche width.
   **/
  | { name: 'SetZerothDelayTrancheWidth'; params: { new: number } }
  /**
   * Set the number of validators needed to approve a block.
   **/
  | { name: 'SetNeededApprovals'; params: { new: number } }
  /**
   * Set the number of samples to do of the `RelayVRFModulo` approval assignment criterion.
   **/
  | { name: 'SetRelayVrfModuloSamples'; params: { new: number } }
  /**
   * Sets the maximum items that can present in a upward dispatch queue at once.
   **/
  | { name: 'SetMaxUpwardQueueCount'; params: { new: number } }
  /**
   * Sets the maximum total size of items that can present in a upward dispatch queue at
   * once.
   **/
  | { name: 'SetMaxUpwardQueueSize'; params: { new: number } }
  /**
   * Set the critical downward message size.
   **/
  | { name: 'SetMaxDownwardMessageSize'; params: { new: number } }
  /**
   * Sets the maximum size of an upward message that can be sent by a candidate.
   **/
  | { name: 'SetMaxUpwardMessageSize'; params: { new: number } }
  /**
   * Sets the maximum number of messages that a candidate can contain.
   **/
  | { name: 'SetMaxUpwardMessageNumPerCandidate'; params: { new: number } }
  /**
   * Sets the number of sessions after which an HRMP open channel request expires.
   **/
  | { name: 'SetHrmpOpenRequestTtl'; params: { new: number } }
  /**
   * Sets the amount of funds that the sender should provide for opening an HRMP channel.
   **/
  | { name: 'SetHrmpSenderDeposit'; params: { new: bigint } }
  /**
   * Sets the amount of funds that the recipient should provide for accepting opening an HRMP
   * channel.
   **/
  | { name: 'SetHrmpRecipientDeposit'; params: { new: bigint } }
  /**
   * Sets the maximum number of messages allowed in an HRMP channel at once.
   **/
  | { name: 'SetHrmpChannelMaxCapacity'; params: { new: number } }
  /**
   * Sets the maximum total size of messages in bytes allowed in an HRMP channel at once.
   **/
  | { name: 'SetHrmpChannelMaxTotalSize'; params: { new: number } }
  /**
   * Sets the maximum number of inbound HRMP channels a parachain is allowed to accept.
   **/
  | { name: 'SetHrmpMaxParachainInboundChannels'; params: { new: number } }
  /**
   * Sets the maximum size of a message that could ever be put into an HRMP channel.
   **/
  | { name: 'SetHrmpChannelMaxMessageSize'; params: { new: number } }
  /**
   * Sets the maximum number of outbound HRMP channels a parachain is allowed to open.
   **/
  | { name: 'SetHrmpMaxParachainOutboundChannels'; params: { new: number } }
  /**
   * Sets the maximum number of outbound HRMP messages can be sent by a candidate.
   **/
  | { name: 'SetHrmpMaxMessageNumPerCandidate'; params: { new: number } }
  /**
   * Set the number of session changes after which a PVF pre-checking voting is rejected.
   **/
  | { name: 'SetPvfVotingTtl'; params: { new: number } }
  /**
   * Sets the minimum delay between announcing the upgrade block for a parachain until the
   * upgrade taking place.
   *
   * See the field documentation for information and constraints for the new value.
   **/
  | { name: 'SetMinimumValidationUpgradeDelay'; params: { new: number } }
  /**
   * Setting this to true will disable consistency checks for the configuration setters.
   * Use with caution.
   **/
  | { name: 'SetBypassConsistencyCheck'; params: { new: boolean } }
  /**
   * Set the asynchronous backing parameters.
   **/
  | { name: 'SetAsyncBackingParams'; params: { new: PolkadotPrimitivesV6AsyncBackingAsyncBackingParams } }
  /**
   * Set PVF executor parameters.
   **/
  | { name: 'SetExecutorParams'; params: { new: PolkadotPrimitivesV6ExecutorParams } }
  /**
   * Set the on demand (parathreads) base fee.
   **/
  | { name: 'SetOnDemandBaseFee'; params: { new: bigint } }
  /**
   * Set the on demand (parathreads) fee variability.
   **/
  | { name: 'SetOnDemandFeeVariability'; params: { new: Perbill } }
  /**
   * Set the on demand (parathreads) queue max size.
   **/
  | { name: 'SetOnDemandQueueMaxSize'; params: { new: number } }
  /**
   * Set the on demand (parathreads) fee variability.
   **/
  | { name: 'SetOnDemandTargetQueueUtilization'; params: { new: Perbill } }
  /**
   * Set the on demand (parathreads) ttl in the claimqueue.
   **/
  | { name: 'SetOnDemandTtl'; params: { new: number } }
  /**
   * Set the minimum backing votes threshold.
   **/
  | { name: 'SetMinimumBackingVotes'; params: { new: number } }
  /**
   * Set/Unset a node feature.
   **/
  | { name: 'SetNodeFeature'; params: { index: number; value: boolean } }
  /**
   * Set approval-voting-params.
   **/
  | { name: 'SetApprovalVotingParams'; params: { new: PolkadotPrimitivesVstagingApprovalVotingParams } }
  /**
   * Set scheduler-params.
   **/
  | { name: 'SetSchedulerParams'; params: { new: PolkadotPrimitivesVstagingSchedulerParams } };

export type PolkadotPrimitivesV6AsyncBackingAsyncBackingParams = {
  maxCandidateDepth: number;
  allowedAncestryLen: number;
};

export type PolkadotPrimitivesV6ExecutorParams = Array<PolkadotPrimitivesV6ExecutorParamsExecutorParam>;

export type PolkadotPrimitivesV6ExecutorParamsExecutorParam =
  | { tag: 'MaxMemoryPages'; value: number }
  | { tag: 'StackLogicalMax'; value: number }
  | { tag: 'StackNativeMax'; value: number }
  | { tag: 'PrecheckingMaxMemory'; value: bigint }
  | { tag: 'PvfPrepTimeout'; value: [PolkadotPrimitivesV6PvfPrepKind, bigint] }
  | { tag: 'PvfExecTimeout'; value: [PolkadotPrimitivesV6PvfExecKind, bigint] }
  | { tag: 'WasmExtBulkMemory' };

export type PolkadotPrimitivesV6PvfPrepKind = 'Precheck' | 'Prepare';

export type PolkadotPrimitivesV6PvfExecKind = 'Backing' | 'Approval';

export type PolkadotPrimitivesVstagingApprovalVotingParams = { maxApprovalCoalesceCount: number };

export type PolkadotPrimitivesVstagingSchedulerParams = {
  groupRotationFrequency: number;
  parasAvailabilityPeriod: number;
  maxValidatorsPerCore?: number | undefined;
  lookahead: number;
  numCores: number;
  maxAvailabilityTimeouts: number;
  onDemandQueueMaxSize: number;
  onDemandTargetQueueUtilization: Perbill;
  onDemandFeeVariability: Perbill;
  onDemandBaseFee: bigint;
  ttl: number;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeParachainsSharedPalletCall = null;

export type PolkadotRuntimeParachainsSharedPalletCallLike = null;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeParachainsInclusionPalletCall = null;

export type PolkadotRuntimeParachainsInclusionPalletCallLike = null;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeParachainsParasInherentPalletCall =
  /**
   * Enter the paras inherent. This will process bitfields and backed candidates.
   **/
  { name: 'Enter'; params: { data: PolkadotPrimitivesV6InherentData } };

export type PolkadotRuntimeParachainsParasInherentPalletCallLike =
  /**
   * Enter the paras inherent. This will process bitfields and backed candidates.
   **/
  { name: 'Enter'; params: { data: PolkadotPrimitivesV6InherentData } };

export type PolkadotPrimitivesV6InherentData = {
  bitfields: Array<PolkadotPrimitivesV6SignedUncheckedSigned>;
  backedCandidates: Array<PolkadotPrimitivesV6BackedCandidate>;
  disputes: Array<PolkadotPrimitivesV6DisputeStatementSet>;
  parentHeader: Header;
};

export type PolkadotPrimitivesV6SignedUncheckedSigned = {
  payload: PolkadotPrimitivesV6AvailabilityBitfield;
  validatorIndex: PolkadotPrimitivesV6ValidatorIndex;
  signature: PolkadotPrimitivesV6ValidatorAppSignature;
};

export type PolkadotPrimitivesV6AvailabilityBitfield = BitSequence;

export type BitvecOrderLsb0 = {};

export type PolkadotPrimitivesV6ValidatorIndex = number;

export type PolkadotPrimitivesV6ValidatorAppSignature = SpCoreSr25519Signature;

export type PolkadotPrimitivesV6BackedCandidate = {
  candidate: PolkadotPrimitivesV6CommittedCandidateReceipt;
  validityVotes: Array<PolkadotPrimitivesV6ValidityAttestation>;
  validatorIndices: BitSequence;
};

export type PolkadotPrimitivesV6CommittedCandidateReceipt = {
  descriptor: PolkadotPrimitivesV6CandidateDescriptor;
  commitments: PolkadotPrimitivesV6CandidateCommitments;
};

export type PolkadotPrimitivesV6CandidateDescriptor = {
  paraId: PolkadotParachainPrimitivesPrimitivesId;
  relayParent: H256;
  collator: PolkadotPrimitivesV6CollatorAppPublic;
  persistedValidationDataHash: H256;
  povHash: H256;
  erasureRoot: H256;
  signature: PolkadotPrimitivesV6CollatorAppSignature;
  paraHead: H256;
  validationCodeHash: PolkadotParachainPrimitivesPrimitivesValidationCodeHash;
};

export type PolkadotPrimitivesV6CollatorAppPublic = SpCoreSr25519Public;

export type PolkadotPrimitivesV6CollatorAppSignature = SpCoreSr25519Signature;

export type PolkadotParachainPrimitivesPrimitivesValidationCodeHash = H256;

export type PolkadotPrimitivesV6CandidateCommitments = {
  upwardMessages: Array<Bytes>;
  horizontalMessages: Array<PolkadotCorePrimitivesOutboundHrmpMessage>;
  newValidationCode?: PolkadotParachainPrimitivesPrimitivesValidationCode | undefined;
  headData: PolkadotParachainPrimitivesPrimitivesHeadData;
  processedDownwardMessages: number;
  hrmpWatermark: number;
};

export type PolkadotCorePrimitivesOutboundHrmpMessage = {
  recipient: PolkadotParachainPrimitivesPrimitivesId;
  data: Bytes;
};

export type PolkadotParachainPrimitivesPrimitivesValidationCode = Bytes;

export type PolkadotParachainPrimitivesPrimitivesHeadData = Bytes;

export type PolkadotPrimitivesV6ValidityAttestation =
  | { tag: 'Implicit'; value: PolkadotPrimitivesV6ValidatorAppSignature }
  | { tag: 'Explicit'; value: PolkadotPrimitivesV6ValidatorAppSignature };

export type PolkadotPrimitivesV6DisputeStatementSet = {
  candidateHash: PolkadotCorePrimitivesCandidateHash;
  session: number;
  statements: Array<
    [
      PolkadotPrimitivesV6DisputeStatement,
      PolkadotPrimitivesV6ValidatorIndex,
      PolkadotPrimitivesV6ValidatorAppSignature,
    ]
  >;
};

export type PolkadotCorePrimitivesCandidateHash = H256;

export type PolkadotPrimitivesV6DisputeStatement =
  | { tag: 'Valid'; value: PolkadotPrimitivesV6ValidDisputeStatementKind }
  | { tag: 'Invalid'; value: PolkadotPrimitivesV6InvalidDisputeStatementKind };

export type PolkadotPrimitivesV6ValidDisputeStatementKind =
  | { tag: 'Explicit' }
  | { tag: 'BackingSeconded'; value: H256 }
  | { tag: 'BackingValid'; value: H256 }
  | { tag: 'ApprovalChecking' }
  | { tag: 'ApprovalCheckingMultipleCandidates'; value: Array<PolkadotCorePrimitivesCandidateHash> };

export type PolkadotPrimitivesV6InvalidDisputeStatementKind = 'Explicit';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeParachainsParasPalletCall =
  /**
   * Set the storage for the parachain validation code immediately.
   **/
  | {
      name: 'ForceSetCurrentCode';
      params: {
        para: PolkadotParachainPrimitivesPrimitivesId;
        newCode: PolkadotParachainPrimitivesPrimitivesValidationCode;
      };
    }
  /**
   * Set the storage for the current parachain head data immediately.
   **/
  | {
      name: 'ForceSetCurrentHead';
      params: { para: PolkadotParachainPrimitivesPrimitivesId; newHead: PolkadotParachainPrimitivesPrimitivesHeadData };
    }
  /**
   * Schedule an upgrade as if it was scheduled in the given relay parent block.
   **/
  | {
      name: 'ForceScheduleCodeUpgrade';
      params: {
        para: PolkadotParachainPrimitivesPrimitivesId;
        newCode: PolkadotParachainPrimitivesPrimitivesValidationCode;
        relayParentNumber: number;
      };
    }
  /**
   * Note a new block head for para within the context of the current block.
   **/
  | {
      name: 'ForceNoteNewHead';
      params: { para: PolkadotParachainPrimitivesPrimitivesId; newHead: PolkadotParachainPrimitivesPrimitivesHeadData };
    }
  /**
   * Put a parachain directly into the next session's action queue.
   * We can't queue it any sooner than this without going into the
   * initializer...
   **/
  | { name: 'ForceQueueAction'; params: { para: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Adds the validation code to the storage.
   *
   * The code will not be added if it is already present. Additionally, if PVF pre-checking
   * is running for that code, it will be instantly accepted.
   *
   * Otherwise, the code will be added into the storage. Note that the code will be added
   * into storage with reference count 0. This is to account the fact that there are no users
   * for this code yet. The caller will have to make sure that this code eventually gets
   * used by some parachain or removed from the storage to avoid storage leaks. For the
   * latter prefer to use the `poke_unused_validation_code` dispatchable to raw storage
   * manipulation.
   *
   * This function is mainly meant to be used for upgrading parachains that do not follow
   * the go-ahead signal while the PVF pre-checking feature is enabled.
   **/
  | {
      name: 'AddTrustedValidationCode';
      params: { validationCode: PolkadotParachainPrimitivesPrimitivesValidationCode };
    }
  /**
   * Remove the validation code from the storage iff the reference count is 0.
   *
   * This is better than removing the storage directly, because it will not remove the code
   * that was suddenly got used by some parachain while this dispatchable was pending
   * dispatching.
   **/
  | {
      name: 'PokeUnusedValidationCode';
      params: { validationCodeHash: PolkadotParachainPrimitivesPrimitivesValidationCodeHash };
    }
  /**
   * Includes a statement for a PVF pre-checking vote. Potentially, finalizes the vote and
   * enacts the results if that was the last vote before achieving the supermajority.
   **/
  | {
      name: 'IncludePvfCheckStatement';
      params: { stmt: PolkadotPrimitivesV6PvfCheckStatement; signature: PolkadotPrimitivesV6ValidatorAppSignature };
    }
  /**
   * Set the storage for the current parachain head data immediately.
   **/
  | { name: 'ForceSetMostRecentContext'; params: { para: PolkadotParachainPrimitivesPrimitivesId; context: number } };

export type PolkadotRuntimeParachainsParasPalletCallLike =
  /**
   * Set the storage for the parachain validation code immediately.
   **/
  | {
      name: 'ForceSetCurrentCode';
      params: {
        para: PolkadotParachainPrimitivesPrimitivesId;
        newCode: PolkadotParachainPrimitivesPrimitivesValidationCode;
      };
    }
  /**
   * Set the storage for the current parachain head data immediately.
   **/
  | {
      name: 'ForceSetCurrentHead';
      params: { para: PolkadotParachainPrimitivesPrimitivesId; newHead: PolkadotParachainPrimitivesPrimitivesHeadData };
    }
  /**
   * Schedule an upgrade as if it was scheduled in the given relay parent block.
   **/
  | {
      name: 'ForceScheduleCodeUpgrade';
      params: {
        para: PolkadotParachainPrimitivesPrimitivesId;
        newCode: PolkadotParachainPrimitivesPrimitivesValidationCode;
        relayParentNumber: number;
      };
    }
  /**
   * Note a new block head for para within the context of the current block.
   **/
  | {
      name: 'ForceNoteNewHead';
      params: { para: PolkadotParachainPrimitivesPrimitivesId; newHead: PolkadotParachainPrimitivesPrimitivesHeadData };
    }
  /**
   * Put a parachain directly into the next session's action queue.
   * We can't queue it any sooner than this without going into the
   * initializer...
   **/
  | { name: 'ForceQueueAction'; params: { para: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Adds the validation code to the storage.
   *
   * The code will not be added if it is already present. Additionally, if PVF pre-checking
   * is running for that code, it will be instantly accepted.
   *
   * Otherwise, the code will be added into the storage. Note that the code will be added
   * into storage with reference count 0. This is to account the fact that there are no users
   * for this code yet. The caller will have to make sure that this code eventually gets
   * used by some parachain or removed from the storage to avoid storage leaks. For the
   * latter prefer to use the `poke_unused_validation_code` dispatchable to raw storage
   * manipulation.
   *
   * This function is mainly meant to be used for upgrading parachains that do not follow
   * the go-ahead signal while the PVF pre-checking feature is enabled.
   **/
  | {
      name: 'AddTrustedValidationCode';
      params: { validationCode: PolkadotParachainPrimitivesPrimitivesValidationCode };
    }
  /**
   * Remove the validation code from the storage iff the reference count is 0.
   *
   * This is better than removing the storage directly, because it will not remove the code
   * that was suddenly got used by some parachain while this dispatchable was pending
   * dispatching.
   **/
  | {
      name: 'PokeUnusedValidationCode';
      params: { validationCodeHash: PolkadotParachainPrimitivesPrimitivesValidationCodeHash };
    }
  /**
   * Includes a statement for a PVF pre-checking vote. Potentially, finalizes the vote and
   * enacts the results if that was the last vote before achieving the supermajority.
   **/
  | {
      name: 'IncludePvfCheckStatement';
      params: { stmt: PolkadotPrimitivesV6PvfCheckStatement; signature: PolkadotPrimitivesV6ValidatorAppSignature };
    }
  /**
   * Set the storage for the current parachain head data immediately.
   **/
  | { name: 'ForceSetMostRecentContext'; params: { para: PolkadotParachainPrimitivesPrimitivesId; context: number } };

export type PolkadotPrimitivesV6PvfCheckStatement = {
  accept: boolean;
  subject: PolkadotParachainPrimitivesPrimitivesValidationCodeHash;
  sessionIndex: number;
  validatorIndex: PolkadotPrimitivesV6ValidatorIndex;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeParachainsInitializerPalletCall =
  /**
   * Issue a signal to the consensus engine to forcibly act as though all parachain
   * blocks in all relay chain blocks up to and including the given number in the current
   * chain are valid and should be finalized.
   **/
  { name: 'ForceApprove'; params: { upTo: number } };

export type PolkadotRuntimeParachainsInitializerPalletCallLike =
  /**
   * Issue a signal to the consensus engine to forcibly act as though all parachain
   * blocks in all relay chain blocks up to and including the given number in the current
   * chain are valid and should be finalized.
   **/
  { name: 'ForceApprove'; params: { upTo: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeParachainsHrmpPalletCall =
  /**
   * Initiate opening a channel from a parachain to a given recipient with given channel
   * parameters.
   *
   * - `proposed_max_capacity` - specifies how many messages can be in the channel at once.
   * - `proposed_max_message_size` - specifies the maximum size of the messages.
   *
   * These numbers are a subject to the relay-chain configuration limits.
   *
   * The channel can be opened only after the recipient confirms it and only on a session
   * change.
   **/
  | {
      name: 'HrmpInitOpenChannel';
      params: {
        recipient: PolkadotParachainPrimitivesPrimitivesId;
        proposedMaxCapacity: number;
        proposedMaxMessageSize: number;
      };
    }
  /**
   * Accept a pending open channel request from the given sender.
   *
   * The channel will be opened only on the next session boundary.
   **/
  | { name: 'HrmpAcceptOpenChannel'; params: { sender: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Initiate unilateral closing of a channel. The origin must be either the sender or the
   * recipient in the channel being closed.
   *
   * The closure can only happen on a session change.
   **/
  | { name: 'HrmpCloseChannel'; params: { channelId: PolkadotParachainPrimitivesPrimitivesHrmpChannelId } }
  /**
   * This extrinsic triggers the cleanup of all the HRMP storage items that a para may have.
   * Normally this happens once per session, but this allows you to trigger the cleanup
   * immediately for a specific parachain.
   *
   * Number of inbound and outbound channels for `para` must be provided as witness data.
   *
   * Origin must be the `ChannelManager`.
   **/
  | {
      name: 'ForceCleanHrmp';
      params: { para: PolkadotParachainPrimitivesPrimitivesId; numInbound: number; numOutbound: number };
    }
  /**
   * Force process HRMP open channel requests.
   *
   * If there are pending HRMP open channel requests, you can use this function to process
   * all of those requests immediately.
   *
   * Total number of opening channels must be provided as witness data.
   *
   * Origin must be the `ChannelManager`.
   **/
  | { name: 'ForceProcessHrmpOpen'; params: { channels: number } }
  /**
   * Force process HRMP close channel requests.
   *
   * If there are pending HRMP close channel requests, you can use this function to process
   * all of those requests immediately.
   *
   * Total number of closing channels must be provided as witness data.
   *
   * Origin must be the `ChannelManager`.
   **/
  | { name: 'ForceProcessHrmpClose'; params: { channels: number } }
  /**
   * This cancels a pending open channel request. It can be canceled by either of the sender
   * or the recipient for that request. The origin must be either of those.
   *
   * The cancellation happens immediately. It is not possible to cancel the request if it is
   * already accepted.
   *
   * Total number of open requests (i.e. `HrmpOpenChannelRequestsList`) must be provided as
   * witness data.
   **/
  | {
      name: 'HrmpCancelOpenRequest';
      params: { channelId: PolkadotParachainPrimitivesPrimitivesHrmpChannelId; openRequests: number };
    }
  /**
   * Open a channel from a `sender` to a `recipient` `ParaId`. Although opened by governance,
   * the `max_capacity` and `max_message_size` are still subject to the Relay Chain's
   * configured limits.
   *
   * Expected use is when one (and only one) of the `ParaId`s involved in the channel is
   * governed by the system, e.g. a system parachain.
   *
   * Origin must be the `ChannelManager`.
   **/
  | {
      name: 'ForceOpenHrmpChannel';
      params: {
        sender: PolkadotParachainPrimitivesPrimitivesId;
        recipient: PolkadotParachainPrimitivesPrimitivesId;
        maxCapacity: number;
        maxMessageSize: number;
      };
    }
  /**
   * Establish an HRMP channel between two system chains. If the channel does not already
   * exist, the transaction fees will be refunded to the caller. The system does not take
   * deposits for channels between system chains, and automatically sets the message number
   * and size limits to the maximum allowed by the network's configuration.
   *
   * Arguments:
   *
   * - `sender`: A system chain, `ParaId`.
   * - `recipient`: A system chain, `ParaId`.
   *
   * Any signed origin can call this function, but _both_ inputs MUST be system chains. If
   * the channel does not exist yet, there is no fee.
   **/
  | {
      name: 'EstablishSystemChannel';
      params: { sender: PolkadotParachainPrimitivesPrimitivesId; recipient: PolkadotParachainPrimitivesPrimitivesId };
    }
  /**
   * Update the deposits held for an HRMP channel to the latest `Configuration`. Channels
   * with system chains do not require a deposit.
   *
   * Arguments:
   *
   * - `sender`: A chain, `ParaId`.
   * - `recipient`: A chain, `ParaId`.
   *
   * Any signed origin can call this function.
   **/
  | {
      name: 'PokeChannelDeposits';
      params: { sender: PolkadotParachainPrimitivesPrimitivesId; recipient: PolkadotParachainPrimitivesPrimitivesId };
    };

export type PolkadotRuntimeParachainsHrmpPalletCallLike =
  /**
   * Initiate opening a channel from a parachain to a given recipient with given channel
   * parameters.
   *
   * - `proposed_max_capacity` - specifies how many messages can be in the channel at once.
   * - `proposed_max_message_size` - specifies the maximum size of the messages.
   *
   * These numbers are a subject to the relay-chain configuration limits.
   *
   * The channel can be opened only after the recipient confirms it and only on a session
   * change.
   **/
  | {
      name: 'HrmpInitOpenChannel';
      params: {
        recipient: PolkadotParachainPrimitivesPrimitivesId;
        proposedMaxCapacity: number;
        proposedMaxMessageSize: number;
      };
    }
  /**
   * Accept a pending open channel request from the given sender.
   *
   * The channel will be opened only on the next session boundary.
   **/
  | { name: 'HrmpAcceptOpenChannel'; params: { sender: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Initiate unilateral closing of a channel. The origin must be either the sender or the
   * recipient in the channel being closed.
   *
   * The closure can only happen on a session change.
   **/
  | { name: 'HrmpCloseChannel'; params: { channelId: PolkadotParachainPrimitivesPrimitivesHrmpChannelId } }
  /**
   * This extrinsic triggers the cleanup of all the HRMP storage items that a para may have.
   * Normally this happens once per session, but this allows you to trigger the cleanup
   * immediately for a specific parachain.
   *
   * Number of inbound and outbound channels for `para` must be provided as witness data.
   *
   * Origin must be the `ChannelManager`.
   **/
  | {
      name: 'ForceCleanHrmp';
      params: { para: PolkadotParachainPrimitivesPrimitivesId; numInbound: number; numOutbound: number };
    }
  /**
   * Force process HRMP open channel requests.
   *
   * If there are pending HRMP open channel requests, you can use this function to process
   * all of those requests immediately.
   *
   * Total number of opening channels must be provided as witness data.
   *
   * Origin must be the `ChannelManager`.
   **/
  | { name: 'ForceProcessHrmpOpen'; params: { channels: number } }
  /**
   * Force process HRMP close channel requests.
   *
   * If there are pending HRMP close channel requests, you can use this function to process
   * all of those requests immediately.
   *
   * Total number of closing channels must be provided as witness data.
   *
   * Origin must be the `ChannelManager`.
   **/
  | { name: 'ForceProcessHrmpClose'; params: { channels: number } }
  /**
   * This cancels a pending open channel request. It can be canceled by either of the sender
   * or the recipient for that request. The origin must be either of those.
   *
   * The cancellation happens immediately. It is not possible to cancel the request if it is
   * already accepted.
   *
   * Total number of open requests (i.e. `HrmpOpenChannelRequestsList`) must be provided as
   * witness data.
   **/
  | {
      name: 'HrmpCancelOpenRequest';
      params: { channelId: PolkadotParachainPrimitivesPrimitivesHrmpChannelId; openRequests: number };
    }
  /**
   * Open a channel from a `sender` to a `recipient` `ParaId`. Although opened by governance,
   * the `max_capacity` and `max_message_size` are still subject to the Relay Chain's
   * configured limits.
   *
   * Expected use is when one (and only one) of the `ParaId`s involved in the channel is
   * governed by the system, e.g. a system parachain.
   *
   * Origin must be the `ChannelManager`.
   **/
  | {
      name: 'ForceOpenHrmpChannel';
      params: {
        sender: PolkadotParachainPrimitivesPrimitivesId;
        recipient: PolkadotParachainPrimitivesPrimitivesId;
        maxCapacity: number;
        maxMessageSize: number;
      };
    }
  /**
   * Establish an HRMP channel between two system chains. If the channel does not already
   * exist, the transaction fees will be refunded to the caller. The system does not take
   * deposits for channels between system chains, and automatically sets the message number
   * and size limits to the maximum allowed by the network's configuration.
   *
   * Arguments:
   *
   * - `sender`: A system chain, `ParaId`.
   * - `recipient`: A system chain, `ParaId`.
   *
   * Any signed origin can call this function, but _both_ inputs MUST be system chains. If
   * the channel does not exist yet, there is no fee.
   **/
  | {
      name: 'EstablishSystemChannel';
      params: { sender: PolkadotParachainPrimitivesPrimitivesId; recipient: PolkadotParachainPrimitivesPrimitivesId };
    }
  /**
   * Update the deposits held for an HRMP channel to the latest `Configuration`. Channels
   * with system chains do not require a deposit.
   *
   * Arguments:
   *
   * - `sender`: A chain, `ParaId`.
   * - `recipient`: A chain, `ParaId`.
   *
   * Any signed origin can call this function.
   **/
  | {
      name: 'PokeChannelDeposits';
      params: { sender: PolkadotParachainPrimitivesPrimitivesId; recipient: PolkadotParachainPrimitivesPrimitivesId };
    };

export type PolkadotParachainPrimitivesPrimitivesHrmpChannelId = {
  sender: PolkadotParachainPrimitivesPrimitivesId;
  recipient: PolkadotParachainPrimitivesPrimitivesId;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeParachainsDisputesPalletCall = 'ForceUnfreeze';

export type PolkadotRuntimeParachainsDisputesPalletCallLike = 'ForceUnfreeze';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeParachainsDisputesSlashingPalletCall = {
  name: 'ReportDisputeLostUnsigned';
  params: { disputeProof: PolkadotPrimitivesV6SlashingDisputeProof; keyOwnerProof: SpSessionMembershipProof };
};

export type PolkadotRuntimeParachainsDisputesSlashingPalletCallLike = {
  name: 'ReportDisputeLostUnsigned';
  params: { disputeProof: PolkadotPrimitivesV6SlashingDisputeProof; keyOwnerProof: SpSessionMembershipProof };
};

export type PolkadotPrimitivesV6SlashingDisputeProof = {
  timeSlot: PolkadotPrimitivesV6SlashingDisputesTimeSlot;
  kind: PolkadotPrimitivesV6SlashingSlashingOffenceKind;
  validatorIndex: PolkadotPrimitivesV6ValidatorIndex;
  validatorId: PolkadotPrimitivesV6ValidatorAppPublic;
};

export type PolkadotPrimitivesV6SlashingDisputesTimeSlot = {
  sessionIndex: number;
  candidateHash: PolkadotCorePrimitivesCandidateHash;
};

export type PolkadotPrimitivesV6SlashingSlashingOffenceKind = 'ForInvalid' | 'AgainstValid';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMessageQueueCall =
  /**
   * Remove a page which has no more messages remaining to be processed or is stale.
   **/
  | {
      name: 'ReapPage';
      params: { messageOrigin: PolkadotRuntimeParachainsInclusionAggregateMessageOrigin; pageIndex: number };
    }
  /**
   * Execute an overweight message.
   *
   * Temporary processing errors will be propagated whereas permanent errors are treated
   * as success condition.
   *
   * - `origin`: Must be `Signed`.
   * - `message_origin`: The origin from which the message to be executed arrived.
   * - `page`: The page in the queue in which the message to be executed is sitting.
   * - `index`: The index into the queue of the message to be executed.
   * - `weight_limit`: The maximum amount of weight allowed to be consumed in the execution
   * of the message.
   *
   * Benchmark complexity considerations: O(index + weight_limit).
   **/
  | {
      name: 'ExecuteOverweight';
      params: {
        messageOrigin: PolkadotRuntimeParachainsInclusionAggregateMessageOrigin;
        page: number;
        index: number;
        weightLimit: SpWeightsWeightV2Weight;
      };
    };

export type PalletMessageQueueCallLike =
  /**
   * Remove a page which has no more messages remaining to be processed or is stale.
   **/
  | {
      name: 'ReapPage';
      params: { messageOrigin: PolkadotRuntimeParachainsInclusionAggregateMessageOrigin; pageIndex: number };
    }
  /**
   * Execute an overweight message.
   *
   * Temporary processing errors will be propagated whereas permanent errors are treated
   * as success condition.
   *
   * - `origin`: Must be `Signed`.
   * - `message_origin`: The origin from which the message to be executed arrived.
   * - `page`: The page in the queue in which the message to be executed is sitting.
   * - `index`: The index into the queue of the message to be executed.
   * - `weight_limit`: The maximum amount of weight allowed to be consumed in the execution
   * of the message.
   *
   * Benchmark complexity considerations: O(index + weight_limit).
   **/
  | {
      name: 'ExecuteOverweight';
      params: {
        messageOrigin: PolkadotRuntimeParachainsInclusionAggregateMessageOrigin;
        page: number;
        index: number;
        weightLimit: SpWeightsWeightV2Weight;
      };
    };

export type PolkadotRuntimeParachainsInclusionAggregateMessageOrigin = {
  tag: 'Ump';
  value: PolkadotRuntimeParachainsInclusionUmpQueueId;
};

export type PolkadotRuntimeParachainsInclusionUmpQueueId = {
  tag: 'Para';
  value: PolkadotParachainPrimitivesPrimitivesId;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeParachainsAssignerOnDemandPalletCall =
  /**
   * Create a single on demand core order.
   * Will use the spot price for the current block and will reap the account if needed.
   *
   * Parameters:
   * - `origin`: The sender of the call, funds will be withdrawn from this account.
   * - `max_amount`: The maximum balance to withdraw from the origin to place an order.
   * - `para_id`: A `ParaId` the origin wants to provide blockspace for.
   *
   * Errors:
   * - `InsufficientBalance`: from the Currency implementation
   * - `InvalidParaId`
   * - `QueueFull`
   * - `SpotPriceHigherThanMaxAmount`
   *
   * Events:
   * - `SpotOrderPlaced`
   **/
  | { name: 'PlaceOrderAllowDeath'; params: { maxAmount: bigint; paraId: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Same as the [`place_order_allow_death`](Self::place_order_allow_death) call , but with a
   * check that placing the order will not reap the account.
   *
   * Parameters:
   * - `origin`: The sender of the call, funds will be withdrawn from this account.
   * - `max_amount`: The maximum balance to withdraw from the origin to place an order.
   * - `para_id`: A `ParaId` the origin wants to provide blockspace for.
   *
   * Errors:
   * - `InsufficientBalance`: from the Currency implementation
   * - `InvalidParaId`
   * - `QueueFull`
   * - `SpotPriceHigherThanMaxAmount`
   *
   * Events:
   * - `SpotOrderPlaced`
   **/
  | { name: 'PlaceOrderKeepAlive'; params: { maxAmount: bigint; paraId: PolkadotParachainPrimitivesPrimitivesId } };

export type PolkadotRuntimeParachainsAssignerOnDemandPalletCallLike =
  /**
   * Create a single on demand core order.
   * Will use the spot price for the current block and will reap the account if needed.
   *
   * Parameters:
   * - `origin`: The sender of the call, funds will be withdrawn from this account.
   * - `max_amount`: The maximum balance to withdraw from the origin to place an order.
   * - `para_id`: A `ParaId` the origin wants to provide blockspace for.
   *
   * Errors:
   * - `InsufficientBalance`: from the Currency implementation
   * - `InvalidParaId`
   * - `QueueFull`
   * - `SpotPriceHigherThanMaxAmount`
   *
   * Events:
   * - `SpotOrderPlaced`
   **/
  | { name: 'PlaceOrderAllowDeath'; params: { maxAmount: bigint; paraId: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Same as the [`place_order_allow_death`](Self::place_order_allow_death) call , but with a
   * check that placing the order will not reap the account.
   *
   * Parameters:
   * - `origin`: The sender of the call, funds will be withdrawn from this account.
   * - `max_amount`: The maximum balance to withdraw from the origin to place an order.
   * - `para_id`: A `ParaId` the origin wants to provide blockspace for.
   *
   * Errors:
   * - `InsufficientBalance`: from the Currency implementation
   * - `InvalidParaId`
   * - `QueueFull`
   * - `SpotPriceHigherThanMaxAmount`
   *
   * Events:
   * - `SpotOrderPlaced`
   **/
  | { name: 'PlaceOrderKeepAlive'; params: { maxAmount: bigint; paraId: PolkadotParachainPrimitivesPrimitivesId } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeCommonParasRegistrarPalletCall =
  /**
   * Register head data and validation code for a reserved Para Id.
   *
   * ## Arguments
   * - `origin`: Must be called by a `Signed` origin.
   * - `id`: The para ID. Must be owned/managed by the `origin` signing account.
   * - `genesis_head`: The genesis head data of the parachain/thread.
   * - `validation_code`: The initial validation code of the parachain/thread.
   *
   * ## Deposits/Fees
   * The account with the originating signature must reserve a deposit.
   *
   * The deposit is required to cover the costs associated with storing the genesis head
   * data and the validation code.
   * This accounts for the potential to store validation code of a size up to the
   * `max_code_size`, as defined in the configuration pallet
   *
   * Anything already reserved previously for this para ID is accounted for.
   *
   * ## Events
   * The `Registered` event is emitted in case of success.
   **/
  | {
      name: 'Register';
      params: {
        id: PolkadotParachainPrimitivesPrimitivesId;
        genesisHead: PolkadotParachainPrimitivesPrimitivesHeadData;
        validationCode: PolkadotParachainPrimitivesPrimitivesValidationCode;
      };
    }
  /**
   * Force the registration of a Para Id on the relay chain.
   *
   * This function must be called by a Root origin.
   *
   * The deposit taken can be specified for this registration. Any `ParaId`
   * can be registered, including sub-1000 IDs which are System Parachains.
   **/
  | {
      name: 'ForceRegister';
      params: {
        who: AccountId32;
        deposit: bigint;
        id: PolkadotParachainPrimitivesPrimitivesId;
        genesisHead: PolkadotParachainPrimitivesPrimitivesHeadData;
        validationCode: PolkadotParachainPrimitivesPrimitivesValidationCode;
      };
    }
  /**
   * Deregister a Para Id, freeing all data and returning any deposit.
   *
   * The caller must be Root, the `para` owner, or the `para` itself. The para must be an
   * on-demand parachain.
   **/
  | { name: 'Deregister'; params: { id: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Swap a lease holding parachain with another parachain, either on-demand or lease
   * holding.
   *
   * The origin must be Root, the `para` owner, or the `para` itself.
   *
   * The swap will happen only if there is already an opposite swap pending. If there is not,
   * the swap will be stored in the pending swaps map, ready for a later confirmatory swap.
   *
   * The `ParaId`s remain mapped to the same head data and code so external code can rely on
   * `ParaId` to be a long-term identifier of a notional "parachain". However, their
   * scheduling info (i.e. whether they're an on-demand parachain or lease holding
   * parachain), auction information and the auction deposit are switched.
   **/
  | {
      name: 'Swap';
      params: { id: PolkadotParachainPrimitivesPrimitivesId; other: PolkadotParachainPrimitivesPrimitivesId };
    }
  /**
   * Remove a manager lock from a para. This will allow the manager of a
   * previously locked para to deregister or swap a para without using governance.
   *
   * Can only be called by the Root origin or the parachain.
   **/
  | { name: 'RemoveLock'; params: { para: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Reserve a Para Id on the relay chain.
   *
   * This function will reserve a new Para Id to be owned/managed by the origin account.
   * The origin account is able to register head data and validation code using `register` to
   * create an on-demand parachain. Using the Slots pallet, an on-demand parachain can then
   * be upgraded to a lease holding parachain.
   *
   * ## Arguments
   * - `origin`: Must be called by a `Signed` origin. Becomes the manager/owner of the new
   * para ID.
   *
   * ## Deposits/Fees
   * The origin must reserve a deposit of `ParaDeposit` for the registration.
   *
   * ## Events
   * The `Reserved` event is emitted in case of success, which provides the ID reserved for
   * use.
   **/
  | { name: 'Reserve' }
  /**
   * Add a manager lock from a para. This will prevent the manager of a
   * para to deregister or swap a para.
   *
   * Can be called by Root, the parachain, or the parachain manager if the parachain is
   * unlocked.
   **/
  | { name: 'AddLock'; params: { para: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Schedule a parachain upgrade.
   *
   * Can be called by Root, the parachain, or the parachain manager if the parachain is
   * unlocked.
   **/
  | {
      name: 'ScheduleCodeUpgrade';
      params: {
        para: PolkadotParachainPrimitivesPrimitivesId;
        newCode: PolkadotParachainPrimitivesPrimitivesValidationCode;
      };
    }
  /**
   * Set the parachain's current head.
   *
   * Can be called by Root, the parachain, or the parachain manager if the parachain is
   * unlocked.
   **/
  | {
      name: 'SetCurrentHead';
      params: { para: PolkadotParachainPrimitivesPrimitivesId; newHead: PolkadotParachainPrimitivesPrimitivesHeadData };
    };

export type PolkadotRuntimeCommonParasRegistrarPalletCallLike =
  /**
   * Register head data and validation code for a reserved Para Id.
   *
   * ## Arguments
   * - `origin`: Must be called by a `Signed` origin.
   * - `id`: The para ID. Must be owned/managed by the `origin` signing account.
   * - `genesis_head`: The genesis head data of the parachain/thread.
   * - `validation_code`: The initial validation code of the parachain/thread.
   *
   * ## Deposits/Fees
   * The account with the originating signature must reserve a deposit.
   *
   * The deposit is required to cover the costs associated with storing the genesis head
   * data and the validation code.
   * This accounts for the potential to store validation code of a size up to the
   * `max_code_size`, as defined in the configuration pallet
   *
   * Anything already reserved previously for this para ID is accounted for.
   *
   * ## Events
   * The `Registered` event is emitted in case of success.
   **/
  | {
      name: 'Register';
      params: {
        id: PolkadotParachainPrimitivesPrimitivesId;
        genesisHead: PolkadotParachainPrimitivesPrimitivesHeadData;
        validationCode: PolkadotParachainPrimitivesPrimitivesValidationCode;
      };
    }
  /**
   * Force the registration of a Para Id on the relay chain.
   *
   * This function must be called by a Root origin.
   *
   * The deposit taken can be specified for this registration. Any `ParaId`
   * can be registered, including sub-1000 IDs which are System Parachains.
   **/
  | {
      name: 'ForceRegister';
      params: {
        who: AccountId32Like;
        deposit: bigint;
        id: PolkadotParachainPrimitivesPrimitivesId;
        genesisHead: PolkadotParachainPrimitivesPrimitivesHeadData;
        validationCode: PolkadotParachainPrimitivesPrimitivesValidationCode;
      };
    }
  /**
   * Deregister a Para Id, freeing all data and returning any deposit.
   *
   * The caller must be Root, the `para` owner, or the `para` itself. The para must be an
   * on-demand parachain.
   **/
  | { name: 'Deregister'; params: { id: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Swap a lease holding parachain with another parachain, either on-demand or lease
   * holding.
   *
   * The origin must be Root, the `para` owner, or the `para` itself.
   *
   * The swap will happen only if there is already an opposite swap pending. If there is not,
   * the swap will be stored in the pending swaps map, ready for a later confirmatory swap.
   *
   * The `ParaId`s remain mapped to the same head data and code so external code can rely on
   * `ParaId` to be a long-term identifier of a notional "parachain". However, their
   * scheduling info (i.e. whether they're an on-demand parachain or lease holding
   * parachain), auction information and the auction deposit are switched.
   **/
  | {
      name: 'Swap';
      params: { id: PolkadotParachainPrimitivesPrimitivesId; other: PolkadotParachainPrimitivesPrimitivesId };
    }
  /**
   * Remove a manager lock from a para. This will allow the manager of a
   * previously locked para to deregister or swap a para without using governance.
   *
   * Can only be called by the Root origin or the parachain.
   **/
  | { name: 'RemoveLock'; params: { para: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Reserve a Para Id on the relay chain.
   *
   * This function will reserve a new Para Id to be owned/managed by the origin account.
   * The origin account is able to register head data and validation code using `register` to
   * create an on-demand parachain. Using the Slots pallet, an on-demand parachain can then
   * be upgraded to a lease holding parachain.
   *
   * ## Arguments
   * - `origin`: Must be called by a `Signed` origin. Becomes the manager/owner of the new
   * para ID.
   *
   * ## Deposits/Fees
   * The origin must reserve a deposit of `ParaDeposit` for the registration.
   *
   * ## Events
   * The `Reserved` event is emitted in case of success, which provides the ID reserved for
   * use.
   **/
  | { name: 'Reserve' }
  /**
   * Add a manager lock from a para. This will prevent the manager of a
   * para to deregister or swap a para.
   *
   * Can be called by Root, the parachain, or the parachain manager if the parachain is
   * unlocked.
   **/
  | { name: 'AddLock'; params: { para: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Schedule a parachain upgrade.
   *
   * Can be called by Root, the parachain, or the parachain manager if the parachain is
   * unlocked.
   **/
  | {
      name: 'ScheduleCodeUpgrade';
      params: {
        para: PolkadotParachainPrimitivesPrimitivesId;
        newCode: PolkadotParachainPrimitivesPrimitivesValidationCode;
      };
    }
  /**
   * Set the parachain's current head.
   *
   * Can be called by Root, the parachain, or the parachain manager if the parachain is
   * unlocked.
   **/
  | {
      name: 'SetCurrentHead';
      params: { para: PolkadotParachainPrimitivesPrimitivesId; newHead: PolkadotParachainPrimitivesPrimitivesHeadData };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeCommonSlotsPalletCall =
  /**
   * Just a connect into the `lease_out` call, in case Root wants to force some lease to
   * happen independently of any other on-chain mechanism to use it.
   *
   * The dispatch origin for this call must match `T::ForceOrigin`.
   **/
  | {
      name: 'ForceLease';
      params: {
        para: PolkadotParachainPrimitivesPrimitivesId;
        leaser: AccountId32;
        amount: bigint;
        periodBegin: number;
        periodCount: number;
      };
    }
  /**
   * Clear all leases for a Para Id, refunding any deposits back to the original owners.
   *
   * The dispatch origin for this call must match `T::ForceOrigin`.
   **/
  | { name: 'ClearAllLeases'; params: { para: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Try to onboard a parachain that has a lease for the current lease period.
   *
   * This function can be useful if there was some state issue with a para that should
   * have onboarded, but was unable to. As long as they have a lease period, we can
   * let them onboard from here.
   *
   * Origin must be signed, but can be called by anyone.
   **/
  | { name: 'TriggerOnboard'; params: { para: PolkadotParachainPrimitivesPrimitivesId } };

export type PolkadotRuntimeCommonSlotsPalletCallLike =
  /**
   * Just a connect into the `lease_out` call, in case Root wants to force some lease to
   * happen independently of any other on-chain mechanism to use it.
   *
   * The dispatch origin for this call must match `T::ForceOrigin`.
   **/
  | {
      name: 'ForceLease';
      params: {
        para: PolkadotParachainPrimitivesPrimitivesId;
        leaser: AccountId32Like;
        amount: bigint;
        periodBegin: number;
        periodCount: number;
      };
    }
  /**
   * Clear all leases for a Para Id, refunding any deposits back to the original owners.
   *
   * The dispatch origin for this call must match `T::ForceOrigin`.
   **/
  | { name: 'ClearAllLeases'; params: { para: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Try to onboard a parachain that has a lease for the current lease period.
   *
   * This function can be useful if there was some state issue with a para that should
   * have onboarded, but was unable to. As long as they have a lease period, we can
   * let them onboard from here.
   *
   * Origin must be signed, but can be called by anyone.
   **/
  | { name: 'TriggerOnboard'; params: { para: PolkadotParachainPrimitivesPrimitivesId } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeCommonAuctionsPalletCall =
  /**
   * Create a new auction.
   *
   * This can only happen when there isn't already an auction in progress and may only be
   * called by the root origin. Accepts the `duration` of this auction and the
   * `lease_period_index` of the initial lease period of the four that are to be auctioned.
   **/
  | { name: 'NewAuction'; params: { duration: number; leasePeriodIndex: number } }
  /**
   * Make a new bid from an account (including a parachain account) for deploying a new
   * parachain.
   *
   * Multiple simultaneous bids from the same bidder are allowed only as long as all active
   * bids overlap each other (i.e. are mutually exclusive). Bids cannot be redacted.
   *
   * - `sub` is the sub-bidder ID, allowing for multiple competing bids to be made by (and
   * funded by) the same account.
   * - `auction_index` is the index of the auction to bid on. Should just be the present
   * value of `AuctionCounter`.
   * - `first_slot` is the first lease period index of the range to bid on. This is the
   * absolute lease period index value, not an auction-specific offset.
   * - `last_slot` is the last lease period index of the range to bid on. This is the
   * absolute lease period index value, not an auction-specific offset.
   * - `amount` is the amount to bid to be held as deposit for the parachain should the
   * bid win. This amount is held throughout the range.
   **/
  | {
      name: 'Bid';
      params: {
        para: PolkadotParachainPrimitivesPrimitivesId;
        auctionIndex: number;
        firstSlot: number;
        lastSlot: number;
        amount: bigint;
      };
    }
  /**
   * Cancel an in-progress auction.
   *
   * Can only be called by Root origin.
   **/
  | { name: 'CancelAuction' };

export type PolkadotRuntimeCommonAuctionsPalletCallLike =
  /**
   * Create a new auction.
   *
   * This can only happen when there isn't already an auction in progress and may only be
   * called by the root origin. Accepts the `duration` of this auction and the
   * `lease_period_index` of the initial lease period of the four that are to be auctioned.
   **/
  | { name: 'NewAuction'; params: { duration: number; leasePeriodIndex: number } }
  /**
   * Make a new bid from an account (including a parachain account) for deploying a new
   * parachain.
   *
   * Multiple simultaneous bids from the same bidder are allowed only as long as all active
   * bids overlap each other (i.e. are mutually exclusive). Bids cannot be redacted.
   *
   * - `sub` is the sub-bidder ID, allowing for multiple competing bids to be made by (and
   * funded by) the same account.
   * - `auction_index` is the index of the auction to bid on. Should just be the present
   * value of `AuctionCounter`.
   * - `first_slot` is the first lease period index of the range to bid on. This is the
   * absolute lease period index value, not an auction-specific offset.
   * - `last_slot` is the last lease period index of the range to bid on. This is the
   * absolute lease period index value, not an auction-specific offset.
   * - `amount` is the amount to bid to be held as deposit for the parachain should the
   * bid win. This amount is held throughout the range.
   **/
  | {
      name: 'Bid';
      params: {
        para: PolkadotParachainPrimitivesPrimitivesId;
        auctionIndex: number;
        firstSlot: number;
        lastSlot: number;
        amount: bigint;
      };
    }
  /**
   * Cancel an in-progress auction.
   *
   * Can only be called by Root origin.
   **/
  | { name: 'CancelAuction' };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeCommonCrowdloanPalletCall =
  /**
   * Create a new crowdloaning campaign for a parachain slot with the given lease period
   * range.
   *
   * This applies a lock to your parachain configuration, ensuring that it cannot be changed
   * by the parachain manager.
   **/
  | {
      name: 'Create';
      params: {
        index: PolkadotParachainPrimitivesPrimitivesId;
        cap: bigint;
        firstPeriod: number;
        lastPeriod: number;
        end: number;
        verifier?: SpRuntimeMultiSigner | undefined;
      };
    }
  /**
   * Contribute to a crowd sale. This will transfer some balance over to fund a parachain
   * slot. It will be withdrawable when the crowdloan has ended and the funds are unused.
   **/
  | {
      name: 'Contribute';
      params: {
        index: PolkadotParachainPrimitivesPrimitivesId;
        value: bigint;
        signature?: SpRuntimeMultiSignature | undefined;
      };
    }
  /**
   * Withdraw full balance of a specific contributor.
   *
   * Origin must be signed, but can come from anyone.
   *
   * The fund must be either in, or ready for, retirement. For a fund to be *in* retirement,
   * then the retirement flag must be set. For a fund to be ready for retirement, then:
   * - it must not already be in retirement;
   * - the amount of raised funds must be bigger than the _free_ balance of the account;
   * - and either:
   * - the block number must be at least `end`; or
   * - the current lease period must be greater than the fund's `last_period`.
   *
   * In this case, the fund's retirement flag is set and its `end` is reset to the current
   * block number.
   *
   * - `who`: The account whose contribution should be withdrawn.
   * - `index`: The parachain to whose crowdloan the contribution was made.
   **/
  | { name: 'Withdraw'; params: { who: AccountId32; index: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Automatically refund contributors of an ended crowdloan.
   * Due to weight restrictions, this function may need to be called multiple
   * times to fully refund all users. We will refund `RemoveKeysLimit` users at a time.
   *
   * Origin must be signed, but can come from anyone.
   **/
  | { name: 'Refund'; params: { index: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Remove a fund after the retirement period has ended and all funds have been returned.
   **/
  | { name: 'Dissolve'; params: { index: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Edit the configuration for an in-progress crowdloan.
   *
   * Can only be called by Root origin.
   **/
  | {
      name: 'Edit';
      params: {
        index: PolkadotParachainPrimitivesPrimitivesId;
        cap: bigint;
        firstPeriod: number;
        lastPeriod: number;
        end: number;
        verifier?: SpRuntimeMultiSigner | undefined;
      };
    }
  /**
   * Add an optional memo to an existing crowdloan contribution.
   *
   * Origin must be Signed, and the user must have contributed to the crowdloan.
   **/
  | { name: 'AddMemo'; params: { index: PolkadotParachainPrimitivesPrimitivesId; memo: Bytes } }
  /**
   * Poke the fund into `NewRaise`
   *
   * Origin must be Signed, and the fund has non-zero raise.
   **/
  | { name: 'Poke'; params: { index: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Contribute your entire balance to a crowd sale. This will transfer the entire balance of
   * a user over to fund a parachain slot. It will be withdrawable when the crowdloan has
   * ended and the funds are unused.
   **/
  | {
      name: 'ContributeAll';
      params: { index: PolkadotParachainPrimitivesPrimitivesId; signature?: SpRuntimeMultiSignature | undefined };
    };

export type PolkadotRuntimeCommonCrowdloanPalletCallLike =
  /**
   * Create a new crowdloaning campaign for a parachain slot with the given lease period
   * range.
   *
   * This applies a lock to your parachain configuration, ensuring that it cannot be changed
   * by the parachain manager.
   **/
  | {
      name: 'Create';
      params: {
        index: PolkadotParachainPrimitivesPrimitivesId;
        cap: bigint;
        firstPeriod: number;
        lastPeriod: number;
        end: number;
        verifier?: SpRuntimeMultiSigner | undefined;
      };
    }
  /**
   * Contribute to a crowd sale. This will transfer some balance over to fund a parachain
   * slot. It will be withdrawable when the crowdloan has ended and the funds are unused.
   **/
  | {
      name: 'Contribute';
      params: {
        index: PolkadotParachainPrimitivesPrimitivesId;
        value: bigint;
        signature?: SpRuntimeMultiSignature | undefined;
      };
    }
  /**
   * Withdraw full balance of a specific contributor.
   *
   * Origin must be signed, but can come from anyone.
   *
   * The fund must be either in, or ready for, retirement. For a fund to be *in* retirement,
   * then the retirement flag must be set. For a fund to be ready for retirement, then:
   * - it must not already be in retirement;
   * - the amount of raised funds must be bigger than the _free_ balance of the account;
   * - and either:
   * - the block number must be at least `end`; or
   * - the current lease period must be greater than the fund's `last_period`.
   *
   * In this case, the fund's retirement flag is set and its `end` is reset to the current
   * block number.
   *
   * - `who`: The account whose contribution should be withdrawn.
   * - `index`: The parachain to whose crowdloan the contribution was made.
   **/
  | { name: 'Withdraw'; params: { who: AccountId32Like; index: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Automatically refund contributors of an ended crowdloan.
   * Due to weight restrictions, this function may need to be called multiple
   * times to fully refund all users. We will refund `RemoveKeysLimit` users at a time.
   *
   * Origin must be signed, but can come from anyone.
   **/
  | { name: 'Refund'; params: { index: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Remove a fund after the retirement period has ended and all funds have been returned.
   **/
  | { name: 'Dissolve'; params: { index: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Edit the configuration for an in-progress crowdloan.
   *
   * Can only be called by Root origin.
   **/
  | {
      name: 'Edit';
      params: {
        index: PolkadotParachainPrimitivesPrimitivesId;
        cap: bigint;
        firstPeriod: number;
        lastPeriod: number;
        end: number;
        verifier?: SpRuntimeMultiSigner | undefined;
      };
    }
  /**
   * Add an optional memo to an existing crowdloan contribution.
   *
   * Origin must be Signed, and the user must have contributed to the crowdloan.
   **/
  | { name: 'AddMemo'; params: { index: PolkadotParachainPrimitivesPrimitivesId; memo: BytesLike } }
  /**
   * Poke the fund into `NewRaise`
   *
   * Origin must be Signed, and the fund has non-zero raise.
   **/
  | { name: 'Poke'; params: { index: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Contribute your entire balance to a crowd sale. This will transfer the entire balance of
   * a user over to fund a parachain slot. It will be withdrawable when the crowdloan has
   * ended and the funds are unused.
   **/
  | {
      name: 'ContributeAll';
      params: { index: PolkadotParachainPrimitivesPrimitivesId; signature?: SpRuntimeMultiSignature | undefined };
    };

export type SpRuntimeMultiSigner =
  | { tag: 'Ed25519'; value: SpCoreEd25519Public }
  | { tag: 'Sr25519'; value: SpCoreSr25519Public }
  | { tag: 'Ecdsa'; value: SpCoreEcdsaPublic };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeParachainsCoretimePalletCall =
  | { name: 'RequestCoreCount'; params: { count: number } }
  /**
   * Receive instructions from the `ExternalBrokerOrigin`, detailing how a specific core is
   * to be used.
   *
   * Parameters:
   * -`origin`: The `ExternalBrokerOrigin`, assumed to be the Broker system parachain.
   * -`core`: The core that should be scheduled.
   * -`begin`: The starting blockheight of the instruction.
   * -`assignment`: How the blockspace should be utilised.
   * -`end_hint`: An optional hint as to when this particular set of instructions will end.
   **/
  | {
      name: 'AssignCore';
      params: {
        core: number;
        begin: number;
        assignment: Array<
          [PalletBrokerCoretimeInterfaceCoreAssignment, PolkadotRuntimeParachainsAssignerCoretimePartsOf57600]
        >;
        endHint?: number | undefined;
      };
    };

export type PolkadotRuntimeParachainsCoretimePalletCallLike =
  | { name: 'RequestCoreCount'; params: { count: number } }
  /**
   * Receive instructions from the `ExternalBrokerOrigin`, detailing how a specific core is
   * to be used.
   *
   * Parameters:
   * -`origin`: The `ExternalBrokerOrigin`, assumed to be the Broker system parachain.
   * -`core`: The core that should be scheduled.
   * -`begin`: The starting blockheight of the instruction.
   * -`assignment`: How the blockspace should be utilised.
   * -`end_hint`: An optional hint as to when this particular set of instructions will end.
   **/
  | {
      name: 'AssignCore';
      params: {
        core: number;
        begin: number;
        assignment: Array<
          [PalletBrokerCoretimeInterfaceCoreAssignment, PolkadotRuntimeParachainsAssignerCoretimePartsOf57600]
        >;
        endHint?: number | undefined;
      };
    };

export type PalletBrokerCoretimeInterfaceCoreAssignment =
  | { tag: 'Idle' }
  | { tag: 'Pool' }
  | { tag: 'Task'; value: number };

export type PolkadotRuntimeParachainsAssignerCoretimePartsOf57600 = number;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletXcmCall =
  | { name: 'Send'; params: { dest: XcmVersionedLocation; message: XcmVersionedXcm } }
  /**
   * Teleport some assets from the local chain to some destination chain.
   *
   * **This function is deprecated: Use `limited_teleport_assets` instead.**
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
   * with all fees taken as needed from the asset.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` chain.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   **/
  | {
      name: 'TeleportAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
      };
    }
  /**
   * Transfer some assets from the local chain to the destination chain through their local,
   * destination or remote reserve.
   *
   * `assets` must have same reserve location and may not be teleportable to `dest`.
   * - `assets` have local reserve: transfer assets to sovereign account of destination
   * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
   * assets to `beneficiary`.
   * - `assets` have destination reserve: burn local assets and forward a notification to
   * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
   * deposit them to `beneficiary`.
   * - `assets` have remote reserve: burn local assets, forward XCM to reserve chain to move
   * reserves from this chain's SA to `dest` chain's SA, and forward another XCM to `dest`
   * to mint and deposit reserve-based assets to `beneficiary`.
   *
   * **This function is deprecated: Use `limited_reserve_transfer_assets` instead.**
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
   * with all fees taken as needed from the asset.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` (and possibly reserve) chains.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   **/
  | {
      name: 'ReserveTransferAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
      };
    }
  /**
   * Execute an XCM message from a local, signed, origin.
   *
   * An event is deposited indicating whether `msg` could be executed completely or only
   * partially.
   *
   * No more than `max_weight` will be used in its attempted execution. If this is less than
   * the maximum amount of weight that the message could take to be executed, then no
   * execution attempt will be made.
   **/
  | { name: 'Execute'; params: { message: XcmVersionedXcm; maxWeight: SpWeightsWeightV2Weight } }
  /**
   * Extoll that a particular destination can be communicated with through a particular
   * version of XCM.
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `location`: The destination that is being described.
   * - `xcm_version`: The latest version of XCM that `location` supports.
   **/
  | { name: 'ForceXcmVersion'; params: { location: StagingXcmV4Location; version: number } }
  /**
   * Set a safe XCM version (the version that XCM should be encoded with if the most recent
   * version a destination can accept is unknown).
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `maybe_xcm_version`: The default XCM encoding version, or `None` to disable.
   **/
  | { name: 'ForceDefaultXcmVersion'; params: { maybeXcmVersion?: number | undefined } }
  /**
   * Ask a location to notify us regarding their XCM version and any changes to it.
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `location`: The location to which we should subscribe for XCM version notifications.
   **/
  | { name: 'ForceSubscribeVersionNotify'; params: { location: XcmVersionedLocation } }
  /**
   * Require that a particular destination should no longer notify us regarding any XCM
   * version changes.
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `location`: The location to which we are currently subscribed for XCM version
   * notifications which we no longer desire.
   **/
  | { name: 'ForceUnsubscribeVersionNotify'; params: { location: XcmVersionedLocation } }
  /**
   * Transfer some assets from the local chain to the destination chain through their local,
   * destination or remote reserve.
   *
   * `assets` must have same reserve location and may not be teleportable to `dest`.
   * - `assets` have local reserve: transfer assets to sovereign account of destination
   * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
   * assets to `beneficiary`.
   * - `assets` have destination reserve: burn local assets and forward a notification to
   * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
   * deposit them to `beneficiary`.
   * - `assets` have remote reserve: burn local assets, forward XCM to reserve chain to move
   * reserves from this chain's SA to `dest` chain's SA, and forward another XCM to `dest`
   * to mint and deposit reserve-based assets to `beneficiary`.
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
   * is needed than `weight_limit`, then the operation will fail and the assets send may be
   * at risk.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` (and possibly reserve) chains.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
   **/
  | {
      name: 'LimitedReserveTransferAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * Teleport some assets from the local chain to some destination chain.
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
   * is needed than `weight_limit`, then the operation will fail and the assets send may be
   * at risk.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` chain.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
   **/
  | {
      name: 'LimitedTeleportAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * Set or unset the global suspension state of the XCM executor.
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `suspended`: `true` to suspend, `false` to resume.
   **/
  | { name: 'ForceSuspension'; params: { suspended: boolean } }
  /**
   * Transfer some assets from the local chain to the destination chain through their local,
   * destination or remote reserve, or through teleports.
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item` (hence referred to as `fees`), up to enough to pay for
   * `weight_limit` of weight. If more weight is needed than `weight_limit`, then the
   * operation will fail and the assets sent may be at risk.
   *
   * `assets` (excluding `fees`) must have same reserve location or otherwise be teleportable
   * to `dest`, no limitations imposed on `fees`.
   * - for local reserve: transfer assets to sovereign account of destination chain and
   * forward a notification XCM to `dest` to mint and deposit reserve-based assets to
   * `beneficiary`.
   * - for destination reserve: burn local assets and forward a notification to `dest` chain
   * to withdraw the reserve assets from this chain's sovereign account and deposit them
   * to `beneficiary`.
   * - for remote reserve: burn local assets, forward XCM to reserve chain to move reserves
   * from this chain's SA to `dest` chain's SA, and forward another XCM to `dest` to mint
   * and deposit reserve-based assets to `beneficiary`.
   * - for teleports: burn local assets and forward XCM to `dest` chain to mint/teleport
   * assets and deposit them to `beneficiary`.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `X2(Parent,
   * Parachain(..))` to send from parachain to parachain, or `X1(Parachain(..))` to send
   * from relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` (and possibly reserve) chains.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
   **/
  | {
      name: 'TransferAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * Claims assets trapped on this pallet because of leftover assets during XCM execution.
   *
   * - `origin`: Anyone can call this extrinsic.
   * - `assets`: The exact assets that were trapped. Use the version to specify what version
   * was the latest when they were trapped.
   * - `beneficiary`: The location/account where the claimed assets will be deposited.
   **/
  | { name: 'ClaimAssets'; params: { assets: XcmVersionedAssets; beneficiary: XcmVersionedLocation } };

export type PalletXcmCallLike =
  | { name: 'Send'; params: { dest: XcmVersionedLocation; message: XcmVersionedXcm } }
  /**
   * Teleport some assets from the local chain to some destination chain.
   *
   * **This function is deprecated: Use `limited_teleport_assets` instead.**
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
   * with all fees taken as needed from the asset.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` chain.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   **/
  | {
      name: 'TeleportAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
      };
    }
  /**
   * Transfer some assets from the local chain to the destination chain through their local,
   * destination or remote reserve.
   *
   * `assets` must have same reserve location and may not be teleportable to `dest`.
   * - `assets` have local reserve: transfer assets to sovereign account of destination
   * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
   * assets to `beneficiary`.
   * - `assets` have destination reserve: burn local assets and forward a notification to
   * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
   * deposit them to `beneficiary`.
   * - `assets` have remote reserve: burn local assets, forward XCM to reserve chain to move
   * reserves from this chain's SA to `dest` chain's SA, and forward another XCM to `dest`
   * to mint and deposit reserve-based assets to `beneficiary`.
   *
   * **This function is deprecated: Use `limited_reserve_transfer_assets` instead.**
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
   * with all fees taken as needed from the asset.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` (and possibly reserve) chains.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   **/
  | {
      name: 'ReserveTransferAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
      };
    }
  /**
   * Execute an XCM message from a local, signed, origin.
   *
   * An event is deposited indicating whether `msg` could be executed completely or only
   * partially.
   *
   * No more than `max_weight` will be used in its attempted execution. If this is less than
   * the maximum amount of weight that the message could take to be executed, then no
   * execution attempt will be made.
   **/
  | { name: 'Execute'; params: { message: XcmVersionedXcm; maxWeight: SpWeightsWeightV2Weight } }
  /**
   * Extoll that a particular destination can be communicated with through a particular
   * version of XCM.
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `location`: The destination that is being described.
   * - `xcm_version`: The latest version of XCM that `location` supports.
   **/
  | { name: 'ForceXcmVersion'; params: { location: StagingXcmV4Location; version: number } }
  /**
   * Set a safe XCM version (the version that XCM should be encoded with if the most recent
   * version a destination can accept is unknown).
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `maybe_xcm_version`: The default XCM encoding version, or `None` to disable.
   **/
  | { name: 'ForceDefaultXcmVersion'; params: { maybeXcmVersion?: number | undefined } }
  /**
   * Ask a location to notify us regarding their XCM version and any changes to it.
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `location`: The location to which we should subscribe for XCM version notifications.
   **/
  | { name: 'ForceSubscribeVersionNotify'; params: { location: XcmVersionedLocation } }
  /**
   * Require that a particular destination should no longer notify us regarding any XCM
   * version changes.
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `location`: The location to which we are currently subscribed for XCM version
   * notifications which we no longer desire.
   **/
  | { name: 'ForceUnsubscribeVersionNotify'; params: { location: XcmVersionedLocation } }
  /**
   * Transfer some assets from the local chain to the destination chain through their local,
   * destination or remote reserve.
   *
   * `assets` must have same reserve location and may not be teleportable to `dest`.
   * - `assets` have local reserve: transfer assets to sovereign account of destination
   * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
   * assets to `beneficiary`.
   * - `assets` have destination reserve: burn local assets and forward a notification to
   * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
   * deposit them to `beneficiary`.
   * - `assets` have remote reserve: burn local assets, forward XCM to reserve chain to move
   * reserves from this chain's SA to `dest` chain's SA, and forward another XCM to `dest`
   * to mint and deposit reserve-based assets to `beneficiary`.
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
   * is needed than `weight_limit`, then the operation will fail and the assets send may be
   * at risk.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` (and possibly reserve) chains.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
   **/
  | {
      name: 'LimitedReserveTransferAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * Teleport some assets from the local chain to some destination chain.
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
   * is needed than `weight_limit`, then the operation will fail and the assets send may be
   * at risk.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` chain.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
   **/
  | {
      name: 'LimitedTeleportAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * Set or unset the global suspension state of the XCM executor.
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `suspended`: `true` to suspend, `false` to resume.
   **/
  | { name: 'ForceSuspension'; params: { suspended: boolean } }
  /**
   * Transfer some assets from the local chain to the destination chain through their local,
   * destination or remote reserve, or through teleports.
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item` (hence referred to as `fees`), up to enough to pay for
   * `weight_limit` of weight. If more weight is needed than `weight_limit`, then the
   * operation will fail and the assets sent may be at risk.
   *
   * `assets` (excluding `fees`) must have same reserve location or otherwise be teleportable
   * to `dest`, no limitations imposed on `fees`.
   * - for local reserve: transfer assets to sovereign account of destination chain and
   * forward a notification XCM to `dest` to mint and deposit reserve-based assets to
   * `beneficiary`.
   * - for destination reserve: burn local assets and forward a notification to `dest` chain
   * to withdraw the reserve assets from this chain's sovereign account and deposit them
   * to `beneficiary`.
   * - for remote reserve: burn local assets, forward XCM to reserve chain to move reserves
   * from this chain's SA to `dest` chain's SA, and forward another XCM to `dest` to mint
   * and deposit reserve-based assets to `beneficiary`.
   * - for teleports: burn local assets and forward XCM to `dest` chain to mint/teleport
   * assets and deposit them to `beneficiary`.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `X2(Parent,
   * Parachain(..))` to send from parachain to parachain, or `X1(Parachain(..))` to send
   * from relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` (and possibly reserve) chains.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
   **/
  | {
      name: 'TransferAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * Claims assets trapped on this pallet because of leftover assets during XCM execution.
   *
   * - `origin`: Anyone can call this extrinsic.
   * - `assets`: The exact assets that were trapped. Use the version to specify what version
   * was the latest when they were trapped.
   * - `beneficiary`: The location/account where the claimed assets will be deposited.
   **/
  | { name: 'ClaimAssets'; params: { assets: XcmVersionedAssets; beneficiary: XcmVersionedLocation } };

export type XcmVersionedXcm =
  | { tag: 'V2'; value: XcmV2Xcm }
  | { tag: 'V3'; value: XcmV3Xcm }
  | { tag: 'V4'; value: StagingXcmV4Xcm };

export type XcmV2Xcm = Array<XcmV2Instruction>;

export type XcmV2Instruction =
  | { tag: 'WithdrawAsset'; value: XcmV2MultiassetMultiAssets }
  | { tag: 'ReserveAssetDeposited'; value: XcmV2MultiassetMultiAssets }
  | { tag: 'ReceiveTeleportedAsset'; value: XcmV2MultiassetMultiAssets }
  | { tag: 'QueryResponse'; value: { queryId: bigint; response: XcmV2Response; maxWeight: bigint } }
  | {
      tag: 'TransferAsset';
      value: { assets: XcmV2MultiassetMultiAssets; beneficiary: XcmV2MultilocationMultiLocation };
    }
  | {
      tag: 'TransferReserveAsset';
      value: { assets: XcmV2MultiassetMultiAssets; dest: XcmV2MultilocationMultiLocation; xcm: XcmV2Xcm };
    }
  | { tag: 'Transact'; value: { originType: XcmV2OriginKind; requireWeightAtMost: bigint; call: XcmDoubleEncoded } }
  | { tag: 'HrmpNewChannelOpenRequest'; value: { sender: number; maxMessageSize: number; maxCapacity: number } }
  | { tag: 'HrmpChannelAccepted'; value: { recipient: number } }
  | { tag: 'HrmpChannelClosing'; value: { initiator: number; sender: number; recipient: number } }
  | { tag: 'ClearOrigin' }
  | { tag: 'DescendOrigin'; value: XcmV2MultilocationJunctions }
  | { tag: 'ReportError'; value: { queryId: bigint; dest: XcmV2MultilocationMultiLocation; maxResponseWeight: bigint } }
  | {
      tag: 'DepositAsset';
      value: {
        assets: XcmV2MultiassetMultiAssetFilter;
        maxAssets: number;
        beneficiary: XcmV2MultilocationMultiLocation;
      };
    }
  | {
      tag: 'DepositReserveAsset';
      value: {
        assets: XcmV2MultiassetMultiAssetFilter;
        maxAssets: number;
        dest: XcmV2MultilocationMultiLocation;
        xcm: XcmV2Xcm;
      };
    }
  | { tag: 'ExchangeAsset'; value: { give: XcmV2MultiassetMultiAssetFilter; receive: XcmV2MultiassetMultiAssets } }
  | {
      tag: 'InitiateReserveWithdraw';
      value: { assets: XcmV2MultiassetMultiAssetFilter; reserve: XcmV2MultilocationMultiLocation; xcm: XcmV2Xcm };
    }
  | {
      tag: 'InitiateTeleport';
      value: { assets: XcmV2MultiassetMultiAssetFilter; dest: XcmV2MultilocationMultiLocation; xcm: XcmV2Xcm };
    }
  | {
      tag: 'QueryHolding';
      value: {
        queryId: bigint;
        dest: XcmV2MultilocationMultiLocation;
        assets: XcmV2MultiassetMultiAssetFilter;
        maxResponseWeight: bigint;
      };
    }
  | { tag: 'BuyExecution'; value: { fees: XcmV2MultiassetMultiAsset; weightLimit: XcmV2WeightLimit } }
  | { tag: 'RefundSurplus' }
  | { tag: 'SetErrorHandler'; value: XcmV2Xcm }
  | { tag: 'SetAppendix'; value: XcmV2Xcm }
  | { tag: 'ClearError' }
  | { tag: 'ClaimAsset'; value: { assets: XcmV2MultiassetMultiAssets; ticket: XcmV2MultilocationMultiLocation } }
  | { tag: 'Trap'; value: bigint }
  | { tag: 'SubscribeVersion'; value: { queryId: bigint; maxResponseWeight: bigint } }
  | { tag: 'UnsubscribeVersion' };

export type XcmV2MultiassetMultiAssets = Array<XcmV2MultiassetMultiAsset>;

export type XcmV2MultiassetMultiAsset = { id: XcmV2MultiassetAssetId; fun: XcmV2MultiassetFungibility };

export type XcmV2MultiassetAssetId =
  | { tag: 'Concrete'; value: XcmV2MultilocationMultiLocation }
  | { tag: 'Abstract'; value: Bytes };

export type XcmV2MultiassetFungibility =
  | { tag: 'Fungible'; value: bigint }
  | { tag: 'NonFungible'; value: XcmV2MultiassetAssetInstance };

export type XcmV2MultiassetAssetInstance =
  | { tag: 'Undefined' }
  | { tag: 'Index'; value: bigint }
  | { tag: 'Array4'; value: FixedBytes<4> }
  | { tag: 'Array8'; value: FixedBytes<8> }
  | { tag: 'Array16'; value: FixedBytes<16> }
  | { tag: 'Array32'; value: FixedBytes<32> }
  | { tag: 'Blob'; value: Bytes };

export type XcmV2Response =
  | { tag: 'Null' }
  | { tag: 'Assets'; value: XcmV2MultiassetMultiAssets }
  | { tag: 'ExecutionResult'; value?: [number, XcmV2TraitsError] | undefined }
  | { tag: 'Version'; value: number };

export type XcmV2TraitsError =
  | { tag: 'Overflow' }
  | { tag: 'Unimplemented' }
  | { tag: 'UntrustedReserveLocation' }
  | { tag: 'UntrustedTeleportLocation' }
  | { tag: 'MultiLocationFull' }
  | { tag: 'MultiLocationNotInvertible' }
  | { tag: 'BadOrigin' }
  | { tag: 'InvalidLocation' }
  | { tag: 'AssetNotFound' }
  | { tag: 'FailedToTransactAsset' }
  | { tag: 'NotWithdrawable' }
  | { tag: 'LocationCannotHold' }
  | { tag: 'ExceedsMaxMessageSize' }
  | { tag: 'DestinationUnsupported' }
  | { tag: 'Transport' }
  | { tag: 'Unroutable' }
  | { tag: 'UnknownClaim' }
  | { tag: 'FailedToDecode' }
  | { tag: 'MaxWeightInvalid' }
  | { tag: 'NotHoldingFees' }
  | { tag: 'TooExpensive' }
  | { tag: 'Trap'; value: bigint }
  | { tag: 'UnhandledXcmVersion' }
  | { tag: 'WeightLimitReached'; value: bigint }
  | { tag: 'Barrier' }
  | { tag: 'WeightNotComputable' };

export type XcmV2OriginKind = 'Native' | 'SovereignAccount' | 'Superuser' | 'Xcm';

export type XcmDoubleEncoded = { encoded: Bytes };

export type XcmV2MultiassetMultiAssetFilter =
  | { tag: 'Definite'; value: XcmV2MultiassetMultiAssets }
  | { tag: 'Wild'; value: XcmV2MultiassetWildMultiAsset };

export type XcmV2MultiassetWildMultiAsset =
  | { tag: 'All' }
  | { tag: 'AllOf'; value: { id: XcmV2MultiassetAssetId; fun: XcmV2MultiassetWildFungibility } };

export type XcmV2MultiassetWildFungibility = 'Fungible' | 'NonFungible';

export type XcmV2WeightLimit = { tag: 'Unlimited' } | { tag: 'Limited'; value: bigint };

export type XcmV3Xcm = Array<XcmV3Instruction>;

export type XcmV3Instruction =
  | { tag: 'WithdrawAsset'; value: XcmV3MultiassetMultiAssets }
  | { tag: 'ReserveAssetDeposited'; value: XcmV3MultiassetMultiAssets }
  | { tag: 'ReceiveTeleportedAsset'; value: XcmV3MultiassetMultiAssets }
  | {
      tag: 'QueryResponse';
      value: {
        queryId: bigint;
        response: XcmV3Response;
        maxWeight: SpWeightsWeightV2Weight;
        querier?: StagingXcmV3MultilocationMultiLocation | undefined;
      };
    }
  | {
      tag: 'TransferAsset';
      value: { assets: XcmV3MultiassetMultiAssets; beneficiary: StagingXcmV3MultilocationMultiLocation };
    }
  | {
      tag: 'TransferReserveAsset';
      value: { assets: XcmV3MultiassetMultiAssets; dest: StagingXcmV3MultilocationMultiLocation; xcm: XcmV3Xcm };
    }
  | {
      tag: 'Transact';
      value: { originKind: XcmV2OriginKind; requireWeightAtMost: SpWeightsWeightV2Weight; call: XcmDoubleEncoded };
    }
  | { tag: 'HrmpNewChannelOpenRequest'; value: { sender: number; maxMessageSize: number; maxCapacity: number } }
  | { tag: 'HrmpChannelAccepted'; value: { recipient: number } }
  | { tag: 'HrmpChannelClosing'; value: { initiator: number; sender: number; recipient: number } }
  | { tag: 'ClearOrigin' }
  | { tag: 'DescendOrigin'; value: XcmV3Junctions }
  | { tag: 'ReportError'; value: XcmV3QueryResponseInfo }
  | {
      tag: 'DepositAsset';
      value: { assets: XcmV3MultiassetMultiAssetFilter; beneficiary: StagingXcmV3MultilocationMultiLocation };
    }
  | {
      tag: 'DepositReserveAsset';
      value: { assets: XcmV3MultiassetMultiAssetFilter; dest: StagingXcmV3MultilocationMultiLocation; xcm: XcmV3Xcm };
    }
  | {
      tag: 'ExchangeAsset';
      value: { give: XcmV3MultiassetMultiAssetFilter; want: XcmV3MultiassetMultiAssets; maximal: boolean };
    }
  | {
      tag: 'InitiateReserveWithdraw';
      value: {
        assets: XcmV3MultiassetMultiAssetFilter;
        reserve: StagingXcmV3MultilocationMultiLocation;
        xcm: XcmV3Xcm;
      };
    }
  | {
      tag: 'InitiateTeleport';
      value: { assets: XcmV3MultiassetMultiAssetFilter; dest: StagingXcmV3MultilocationMultiLocation; xcm: XcmV3Xcm };
    }
  | { tag: 'ReportHolding'; value: { responseInfo: XcmV3QueryResponseInfo; assets: XcmV3MultiassetMultiAssetFilter } }
  | { tag: 'BuyExecution'; value: { fees: XcmV3MultiassetMultiAsset; weightLimit: XcmV3WeightLimit } }
  | { tag: 'RefundSurplus' }
  | { tag: 'SetErrorHandler'; value: XcmV3Xcm }
  | { tag: 'SetAppendix'; value: XcmV3Xcm }
  | { tag: 'ClearError' }
  | { tag: 'ClaimAsset'; value: { assets: XcmV3MultiassetMultiAssets; ticket: StagingXcmV3MultilocationMultiLocation } }
  | { tag: 'Trap'; value: bigint }
  | { tag: 'SubscribeVersion'; value: { queryId: bigint; maxResponseWeight: SpWeightsWeightV2Weight } }
  | { tag: 'UnsubscribeVersion' }
  | { tag: 'BurnAsset'; value: XcmV3MultiassetMultiAssets }
  | { tag: 'ExpectAsset'; value: XcmV3MultiassetMultiAssets }
  | { tag: 'ExpectOrigin'; value?: StagingXcmV3MultilocationMultiLocation | undefined }
  | { tag: 'ExpectError'; value?: [number, XcmV3TraitsError] | undefined }
  | { tag: 'ExpectTransactStatus'; value: XcmV3MaybeErrorCode }
  | { tag: 'QueryPallet'; value: { moduleName: Bytes; responseInfo: XcmV3QueryResponseInfo } }
  | {
      tag: 'ExpectPallet';
      value: { index: number; name: Bytes; moduleName: Bytes; crateMajor: number; minCrateMinor: number };
    }
  | { tag: 'ReportTransactStatus'; value: XcmV3QueryResponseInfo }
  | { tag: 'ClearTransactStatus' }
  | { tag: 'UniversalOrigin'; value: XcmV3Junction }
  | { tag: 'ExportMessage'; value: { network: XcmV3JunctionNetworkId; destination: XcmV3Junctions; xcm: XcmV3Xcm } }
  | { tag: 'LockAsset'; value: { asset: XcmV3MultiassetMultiAsset; unlocker: StagingXcmV3MultilocationMultiLocation } }
  | { tag: 'UnlockAsset'; value: { asset: XcmV3MultiassetMultiAsset; target: StagingXcmV3MultilocationMultiLocation } }
  | {
      tag: 'NoteUnlockable';
      value: { asset: XcmV3MultiassetMultiAsset; owner: StagingXcmV3MultilocationMultiLocation };
    }
  | {
      tag: 'RequestUnlock';
      value: { asset: XcmV3MultiassetMultiAsset; locker: StagingXcmV3MultilocationMultiLocation };
    }
  | { tag: 'SetFeesMode'; value: { jitWithdraw: boolean } }
  | { tag: 'SetTopic'; value: FixedBytes<32> }
  | { tag: 'ClearTopic' }
  | { tag: 'AliasOrigin'; value: StagingXcmV3MultilocationMultiLocation }
  | {
      tag: 'UnpaidExecution';
      value: { weightLimit: XcmV3WeightLimit; checkOrigin?: StagingXcmV3MultilocationMultiLocation | undefined };
    };

export type XcmV3MultiassetMultiAssets = Array<XcmV3MultiassetMultiAsset>;

export type XcmV3MultiassetMultiAsset = { id: XcmV3MultiassetAssetId; fun: XcmV3MultiassetFungibility };

export type XcmV3MultiassetFungibility =
  | { tag: 'Fungible'; value: bigint }
  | { tag: 'NonFungible'; value: XcmV3MultiassetAssetInstance };

export type XcmV3MultiassetAssetInstance =
  | { tag: 'Undefined' }
  | { tag: 'Index'; value: bigint }
  | { tag: 'Array4'; value: FixedBytes<4> }
  | { tag: 'Array8'; value: FixedBytes<8> }
  | { tag: 'Array16'; value: FixedBytes<16> }
  | { tag: 'Array32'; value: FixedBytes<32> };

export type XcmV3Response =
  | { tag: 'Null' }
  | { tag: 'Assets'; value: XcmV3MultiassetMultiAssets }
  | { tag: 'ExecutionResult'; value?: [number, XcmV3TraitsError] | undefined }
  | { tag: 'Version'; value: number }
  | { tag: 'PalletsInfo'; value: Array<XcmV3PalletInfo> }
  | { tag: 'DispatchResult'; value: XcmV3MaybeErrorCode };

export type XcmV3TraitsError =
  | { tag: 'Overflow' }
  | { tag: 'Unimplemented' }
  | { tag: 'UntrustedReserveLocation' }
  | { tag: 'UntrustedTeleportLocation' }
  | { tag: 'LocationFull' }
  | { tag: 'LocationNotInvertible' }
  | { tag: 'BadOrigin' }
  | { tag: 'InvalidLocation' }
  | { tag: 'AssetNotFound' }
  | { tag: 'FailedToTransactAsset' }
  | { tag: 'NotWithdrawable' }
  | { tag: 'LocationCannotHold' }
  | { tag: 'ExceedsMaxMessageSize' }
  | { tag: 'DestinationUnsupported' }
  | { tag: 'Transport' }
  | { tag: 'Unroutable' }
  | { tag: 'UnknownClaim' }
  | { tag: 'FailedToDecode' }
  | { tag: 'MaxWeightInvalid' }
  | { tag: 'NotHoldingFees' }
  | { tag: 'TooExpensive' }
  | { tag: 'Trap'; value: bigint }
  | { tag: 'ExpectationFalse' }
  | { tag: 'PalletNotFound' }
  | { tag: 'NameMismatch' }
  | { tag: 'VersionIncompatible' }
  | { tag: 'HoldingWouldOverflow' }
  | { tag: 'ExportError' }
  | { tag: 'ReanchorFailed' }
  | { tag: 'NoDeal' }
  | { tag: 'FeesNotMet' }
  | { tag: 'LockError' }
  | { tag: 'NoPermission' }
  | { tag: 'Unanchored' }
  | { tag: 'NotDepositable' }
  | { tag: 'UnhandledXcmVersion' }
  | { tag: 'WeightLimitReached'; value: SpWeightsWeightV2Weight }
  | { tag: 'Barrier' }
  | { tag: 'WeightNotComputable' }
  | { tag: 'ExceedsStackLimit' };

export type XcmV3PalletInfo = {
  index: number;
  name: Bytes;
  moduleName: Bytes;
  major: number;
  minor: number;
  patch: number;
};

export type XcmV3MaybeErrorCode =
  | { tag: 'Success' }
  | { tag: 'Error'; value: Bytes }
  | { tag: 'TruncatedError'; value: Bytes };

export type XcmV3QueryResponseInfo = {
  destination: StagingXcmV3MultilocationMultiLocation;
  queryId: bigint;
  maxWeight: SpWeightsWeightV2Weight;
};

export type XcmV3MultiassetMultiAssetFilter =
  | { tag: 'Definite'; value: XcmV3MultiassetMultiAssets }
  | { tag: 'Wild'; value: XcmV3MultiassetWildMultiAsset };

export type XcmV3MultiassetWildMultiAsset =
  | { tag: 'All' }
  | { tag: 'AllOf'; value: { id: XcmV3MultiassetAssetId; fun: XcmV3MultiassetWildFungibility } }
  | { tag: 'AllCounted'; value: number }
  | { tag: 'AllOfCounted'; value: { id: XcmV3MultiassetAssetId; fun: XcmV3MultiassetWildFungibility; count: number } };

export type XcmV3MultiassetWildFungibility = 'Fungible' | 'NonFungible';

export type XcmV3WeightLimit = { tag: 'Unlimited' } | { tag: 'Limited'; value: SpWeightsWeightV2Weight };

export type StagingXcmV4Xcm = Array<StagingXcmV4Instruction>;

export type StagingXcmV4Instruction =
  | { tag: 'WithdrawAsset'; value: StagingXcmV4AssetAssets }
  | { tag: 'ReserveAssetDeposited'; value: StagingXcmV4AssetAssets }
  | { tag: 'ReceiveTeleportedAsset'; value: StagingXcmV4AssetAssets }
  | {
      tag: 'QueryResponse';
      value: {
        queryId: bigint;
        response: StagingXcmV4Response;
        maxWeight: SpWeightsWeightV2Weight;
        querier?: StagingXcmV4Location | undefined;
      };
    }
  | { tag: 'TransferAsset'; value: { assets: StagingXcmV4AssetAssets; beneficiary: StagingXcmV4Location } }
  | {
      tag: 'TransferReserveAsset';
      value: { assets: StagingXcmV4AssetAssets; dest: StagingXcmV4Location; xcm: StagingXcmV4Xcm };
    }
  | {
      tag: 'Transact';
      value: { originKind: XcmV2OriginKind; requireWeightAtMost: SpWeightsWeightV2Weight; call: XcmDoubleEncoded };
    }
  | { tag: 'HrmpNewChannelOpenRequest'; value: { sender: number; maxMessageSize: number; maxCapacity: number } }
  | { tag: 'HrmpChannelAccepted'; value: { recipient: number } }
  | { tag: 'HrmpChannelClosing'; value: { initiator: number; sender: number; recipient: number } }
  | { tag: 'ClearOrigin' }
  | { tag: 'DescendOrigin'; value: StagingXcmV4Junctions }
  | { tag: 'ReportError'; value: StagingXcmV4QueryResponseInfo }
  | { tag: 'DepositAsset'; value: { assets: StagingXcmV4AssetAssetFilter; beneficiary: StagingXcmV4Location } }
  | {
      tag: 'DepositReserveAsset';
      value: { assets: StagingXcmV4AssetAssetFilter; dest: StagingXcmV4Location; xcm: StagingXcmV4Xcm };
    }
  | {
      tag: 'ExchangeAsset';
      value: { give: StagingXcmV4AssetAssetFilter; want: StagingXcmV4AssetAssets; maximal: boolean };
    }
  | {
      tag: 'InitiateReserveWithdraw';
      value: { assets: StagingXcmV4AssetAssetFilter; reserve: StagingXcmV4Location; xcm: StagingXcmV4Xcm };
    }
  | {
      tag: 'InitiateTeleport';
      value: { assets: StagingXcmV4AssetAssetFilter; dest: StagingXcmV4Location; xcm: StagingXcmV4Xcm };
    }
  | {
      tag: 'ReportHolding';
      value: { responseInfo: StagingXcmV4QueryResponseInfo; assets: StagingXcmV4AssetAssetFilter };
    }
  | { tag: 'BuyExecution'; value: { fees: StagingXcmV4Asset; weightLimit: XcmV3WeightLimit } }
  | { tag: 'RefundSurplus' }
  | { tag: 'SetErrorHandler'; value: StagingXcmV4Xcm }
  | { tag: 'SetAppendix'; value: StagingXcmV4Xcm }
  | { tag: 'ClearError' }
  | { tag: 'ClaimAsset'; value: { assets: StagingXcmV4AssetAssets; ticket: StagingXcmV4Location } }
  | { tag: 'Trap'; value: bigint }
  | { tag: 'SubscribeVersion'; value: { queryId: bigint; maxResponseWeight: SpWeightsWeightV2Weight } }
  | { tag: 'UnsubscribeVersion' }
  | { tag: 'BurnAsset'; value: StagingXcmV4AssetAssets }
  | { tag: 'ExpectAsset'; value: StagingXcmV4AssetAssets }
  | { tag: 'ExpectOrigin'; value?: StagingXcmV4Location | undefined }
  | { tag: 'ExpectError'; value?: [number, XcmV3TraitsError] | undefined }
  | { tag: 'ExpectTransactStatus'; value: XcmV3MaybeErrorCode }
  | { tag: 'QueryPallet'; value: { moduleName: Bytes; responseInfo: StagingXcmV4QueryResponseInfo } }
  | {
      tag: 'ExpectPallet';
      value: { index: number; name: Bytes; moduleName: Bytes; crateMajor: number; minCrateMinor: number };
    }
  | { tag: 'ReportTransactStatus'; value: StagingXcmV4QueryResponseInfo }
  | { tag: 'ClearTransactStatus' }
  | { tag: 'UniversalOrigin'; value: StagingXcmV4Junction }
  | {
      tag: 'ExportMessage';
      value: { network: StagingXcmV4JunctionNetworkId; destination: StagingXcmV4Junctions; xcm: StagingXcmV4Xcm };
    }
  | { tag: 'LockAsset'; value: { asset: StagingXcmV4Asset; unlocker: StagingXcmV4Location } }
  | { tag: 'UnlockAsset'; value: { asset: StagingXcmV4Asset; target: StagingXcmV4Location } }
  | { tag: 'NoteUnlockable'; value: { asset: StagingXcmV4Asset; owner: StagingXcmV4Location } }
  | { tag: 'RequestUnlock'; value: { asset: StagingXcmV4Asset; locker: StagingXcmV4Location } }
  | { tag: 'SetFeesMode'; value: { jitWithdraw: boolean } }
  | { tag: 'SetTopic'; value: FixedBytes<32> }
  | { tag: 'ClearTopic' }
  | { tag: 'AliasOrigin'; value: StagingXcmV4Location }
  | {
      tag: 'UnpaidExecution';
      value: { weightLimit: XcmV3WeightLimit; checkOrigin?: StagingXcmV4Location | undefined };
    };

export type StagingXcmV4AssetAssets = Array<StagingXcmV4Asset>;

export type StagingXcmV4Asset = { id: StagingXcmV4AssetAssetId; fun: StagingXcmV4AssetFungibility };

export type StagingXcmV4AssetFungibility =
  | { tag: 'Fungible'; value: bigint }
  | { tag: 'NonFungible'; value: StagingXcmV4AssetAssetInstance };

export type StagingXcmV4AssetAssetInstance =
  | { tag: 'Undefined' }
  | { tag: 'Index'; value: bigint }
  | { tag: 'Array4'; value: FixedBytes<4> }
  | { tag: 'Array8'; value: FixedBytes<8> }
  | { tag: 'Array16'; value: FixedBytes<16> }
  | { tag: 'Array32'; value: FixedBytes<32> };

export type StagingXcmV4Response =
  | { tag: 'Null' }
  | { tag: 'Assets'; value: StagingXcmV4AssetAssets }
  | { tag: 'ExecutionResult'; value?: [number, XcmV3TraitsError] | undefined }
  | { tag: 'Version'; value: number }
  | { tag: 'PalletsInfo'; value: Array<StagingXcmV4PalletInfo> }
  | { tag: 'DispatchResult'; value: XcmV3MaybeErrorCode };

export type StagingXcmV4PalletInfo = {
  index: number;
  name: Bytes;
  moduleName: Bytes;
  major: number;
  minor: number;
  patch: number;
};

export type StagingXcmV4QueryResponseInfo = {
  destination: StagingXcmV4Location;
  queryId: bigint;
  maxWeight: SpWeightsWeightV2Weight;
};

export type StagingXcmV4AssetAssetFilter =
  | { tag: 'Definite'; value: StagingXcmV4AssetAssets }
  | { tag: 'Wild'; value: StagingXcmV4AssetWildAsset };

export type StagingXcmV4AssetWildAsset =
  | { tag: 'All' }
  | { tag: 'AllOf'; value: { id: StagingXcmV4AssetAssetId; fun: StagingXcmV4AssetWildFungibility } }
  | { tag: 'AllCounted'; value: number }
  | {
      tag: 'AllOfCounted';
      value: { id: StagingXcmV4AssetAssetId; fun: StagingXcmV4AssetWildFungibility; count: number };
    };

export type StagingXcmV4AssetWildFungibility = 'Fungible' | 'NonFungible';

export type XcmVersionedAssets =
  | { tag: 'V2'; value: XcmV2MultiassetMultiAssets }
  | { tag: 'V3'; value: XcmV3MultiassetMultiAssets }
  | { tag: 'V4'; value: StagingXcmV4AssetAssets };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBeefyCall =
  /**
   * Report voter equivocation/misbehavior. This method will verify the
   * equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence
   * will be reported.
   **/
  | {
      name: 'ReportEquivocation';
      params: { equivocationProof: SpConsensusBeefyEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * Report voter equivocation/misbehavior. This method will verify the
   * equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence
   * will be reported.
   *
   * This extrinsic must be called unsigned and it is expected that only
   * block authors will call it (validated in `ValidateUnsigned`), as such
   * if the block author is defined it will be defined as the equivocation
   * reporter.
   **/
  | {
      name: 'ReportEquivocationUnsigned';
      params: { equivocationProof: SpConsensusBeefyEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * Reset BEEFY consensus by setting a new BEEFY genesis at `delay_in_blocks` blocks in the
   * future.
   *
   * Note: `delay_in_blocks` has to be at least 1.
   **/
  | { name: 'SetNewGenesis'; params: { delayInBlocks: number } };

export type PalletBeefyCallLike =
  /**
   * Report voter equivocation/misbehavior. This method will verify the
   * equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence
   * will be reported.
   **/
  | {
      name: 'ReportEquivocation';
      params: { equivocationProof: SpConsensusBeefyEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * Report voter equivocation/misbehavior. This method will verify the
   * equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence
   * will be reported.
   *
   * This extrinsic must be called unsigned and it is expected that only
   * block authors will call it (validated in `ValidateUnsigned`), as such
   * if the block author is defined it will be defined as the equivocation
   * reporter.
   **/
  | {
      name: 'ReportEquivocationUnsigned';
      params: { equivocationProof: SpConsensusBeefyEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * Reset BEEFY consensus by setting a new BEEFY genesis at `delay_in_blocks` blocks in the
   * future.
   *
   * Note: `delay_in_blocks` has to be at least 1.
   **/
  | { name: 'SetNewGenesis'; params: { delayInBlocks: number } };

export type SpConsensusBeefyEquivocationProof = {
  first: SpConsensusBeefyVoteMessage;
  second: SpConsensusBeefyVoteMessage;
};

export type SpConsensusBeefyEcdsaCryptoSignature = SpCoreEcdsaSignature;

export type SpConsensusBeefyVoteMessage = {
  commitment: SpConsensusBeefyCommitment;
  id: SpConsensusBeefyEcdsaCryptoPublic;
  signature: SpConsensusBeefyEcdsaCryptoSignature;
};

export type SpConsensusBeefyCommitment = {
  payload: SpConsensusBeefyPayload;
  blockNumber: number;
  validatorSetId: bigint;
};

export type SpConsensusBeefyPayload = Array<[FixedBytes<2>, Bytes]>;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeCommonIdentityMigratorPalletCall =
  /**
   * Reap the `IdentityInfo` of `who` from the Identity pallet of `T`, unreserving any
   * deposits held and removing storage items associated with `who`.
   **/
  | { name: 'ReapIdentity'; params: { who: AccountId32 } }
  /**
   * Update the deposit of `who`. Meant to be called by the system with an XCM `Transact`
   * Instruction.
   **/
  | { name: 'PokeDeposit'; params: { who: AccountId32 } };

export type PolkadotRuntimeCommonIdentityMigratorPalletCallLike =
  /**
   * Reap the `IdentityInfo` of `who` from the Identity pallet of `T`, unreserving any
   * deposits held and removing storage items associated with `who`.
   **/
  | { name: 'ReapIdentity'; params: { who: AccountId32Like } }
  /**
   * Update the deposit of `who`. Meant to be called by the system with an XCM `Transact`
   * Instruction.
   **/
  | { name: 'PokeDeposit'; params: { who: AccountId32Like } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeCommonParasSudoWrapperPalletCall =
  /**
   * Schedule a para to be initialized at the start of the next session.
   *
   * This should only be used for TESTING and not on PRODUCTION chains. It automatically
   * assigns Coretime to the chain and increases the number of cores. Thus, there is no
   * running coretime chain required.
   **/
  | {
      name: 'SudoScheduleParaInitialize';
      params: { id: PolkadotParachainPrimitivesPrimitivesId; genesis: PolkadotRuntimeParachainsParasParaGenesisArgs };
    }
  /**
   * Schedule a para to be cleaned up at the start of the next session.
   **/
  | { name: 'SudoScheduleParaCleanup'; params: { id: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Upgrade a parathread (on-demand parachain) to a lease holding parachain
   **/
  | { name: 'SudoScheduleParathreadUpgrade'; params: { id: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Downgrade a lease holding parachain to an on-demand parachain
   **/
  | { name: 'SudoScheduleParachainDowngrade'; params: { id: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Send a downward XCM to the given para.
   *
   * The given parachain should exist and the payload should not exceed the preconfigured
   * size `config.max_downward_message_size`.
   **/
  | { name: 'SudoQueueDownwardXcm'; params: { id: PolkadotParachainPrimitivesPrimitivesId; xcm: XcmVersionedXcm } }
  /**
   * Forcefully establish a channel from the sender to the recipient.
   *
   * This is equivalent to sending an `Hrmp::hrmp_init_open_channel` extrinsic followed by
   * `Hrmp::hrmp_accept_open_channel`.
   **/
  | {
      name: 'SudoEstablishHrmpChannel';
      params: {
        sender: PolkadotParachainPrimitivesPrimitivesId;
        recipient: PolkadotParachainPrimitivesPrimitivesId;
        maxCapacity: number;
        maxMessageSize: number;
      };
    };

export type PolkadotRuntimeCommonParasSudoWrapperPalletCallLike =
  /**
   * Schedule a para to be initialized at the start of the next session.
   *
   * This should only be used for TESTING and not on PRODUCTION chains. It automatically
   * assigns Coretime to the chain and increases the number of cores. Thus, there is no
   * running coretime chain required.
   **/
  | {
      name: 'SudoScheduleParaInitialize';
      params: { id: PolkadotParachainPrimitivesPrimitivesId; genesis: PolkadotRuntimeParachainsParasParaGenesisArgs };
    }
  /**
   * Schedule a para to be cleaned up at the start of the next session.
   **/
  | { name: 'SudoScheduleParaCleanup'; params: { id: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Upgrade a parathread (on-demand parachain) to a lease holding parachain
   **/
  | { name: 'SudoScheduleParathreadUpgrade'; params: { id: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Downgrade a lease holding parachain to an on-demand parachain
   **/
  | { name: 'SudoScheduleParachainDowngrade'; params: { id: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Send a downward XCM to the given para.
   *
   * The given parachain should exist and the payload should not exceed the preconfigured
   * size `config.max_downward_message_size`.
   **/
  | { name: 'SudoQueueDownwardXcm'; params: { id: PolkadotParachainPrimitivesPrimitivesId; xcm: XcmVersionedXcm } }
  /**
   * Forcefully establish a channel from the sender to the recipient.
   *
   * This is equivalent to sending an `Hrmp::hrmp_init_open_channel` extrinsic followed by
   * `Hrmp::hrmp_accept_open_channel`.
   **/
  | {
      name: 'SudoEstablishHrmpChannel';
      params: {
        sender: PolkadotParachainPrimitivesPrimitivesId;
        recipient: PolkadotParachainPrimitivesPrimitivesId;
        maxCapacity: number;
        maxMessageSize: number;
      };
    };

export type PolkadotRuntimeParachainsParasParaGenesisArgs = {
  genesisHead: PolkadotParachainPrimitivesPrimitivesHeadData;
  validationCode: PolkadotParachainPrimitivesPrimitivesValidationCode;
  paraKind: boolean;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PolkadotRuntimeCommonAssignedSlotsPalletCall =
  /**
   * Assign a permanent parachain slot and immediately create a lease for it.
   **/
  | { name: 'AssignPermParachainSlot'; params: { id: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Assign a temporary parachain slot. The function tries to create a lease for it
   * immediately if `SlotLeasePeriodStart::Current` is specified, and if the number
   * of currently active temporary slots is below `MaxTemporarySlotPerLeasePeriod`.
   **/
  | {
      name: 'AssignTempParachainSlot';
      params: {
        id: PolkadotParachainPrimitivesPrimitivesId;
        leasePeriodStart: PolkadotRuntimeCommonAssignedSlotsSlotLeasePeriodStart;
      };
    }
  /**
   * Unassign a permanent or temporary parachain slot
   **/
  | { name: 'UnassignParachainSlot'; params: { id: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Sets the storage value [`MaxPermanentSlots`].
   **/
  | { name: 'SetMaxPermanentSlots'; params: { slots: number } }
  /**
   * Sets the storage value [`MaxTemporarySlots`].
   **/
  | { name: 'SetMaxTemporarySlots'; params: { slots: number } };

export type PolkadotRuntimeCommonAssignedSlotsPalletCallLike =
  /**
   * Assign a permanent parachain slot and immediately create a lease for it.
   **/
  | { name: 'AssignPermParachainSlot'; params: { id: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Assign a temporary parachain slot. The function tries to create a lease for it
   * immediately if `SlotLeasePeriodStart::Current` is specified, and if the number
   * of currently active temporary slots is below `MaxTemporarySlotPerLeasePeriod`.
   **/
  | {
      name: 'AssignTempParachainSlot';
      params: {
        id: PolkadotParachainPrimitivesPrimitivesId;
        leasePeriodStart: PolkadotRuntimeCommonAssignedSlotsSlotLeasePeriodStart;
      };
    }
  /**
   * Unassign a permanent or temporary parachain slot
   **/
  | { name: 'UnassignParachainSlot'; params: { id: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Sets the storage value [`MaxPermanentSlots`].
   **/
  | { name: 'SetMaxPermanentSlots'; params: { slots: number } }
  /**
   * Sets the storage value [`MaxTemporarySlots`].
   **/
  | { name: 'SetMaxTemporarySlots'; params: { slots: number } };

export type PolkadotRuntimeCommonAssignedSlotsSlotLeasePeriodStart = 'Current' | 'Next';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type RococoRuntimeValidatorManagerPalletCall =
  /**
   * Add new validators to the set.
   *
   * The new validators will be active from current session + 2.
   **/
  | { name: 'RegisterValidators'; params: { validators: Array<AccountId32> } }
  /**
   * Remove validators from the set.
   *
   * The removed validators will be deactivated from current session + 2.
   **/
  | { name: 'DeregisterValidators'; params: { validators: Array<AccountId32> } };

export type RococoRuntimeValidatorManagerPalletCallLike =
  /**
   * Add new validators to the set.
   *
   * The new validators will be active from current session + 2.
   **/
  | { name: 'RegisterValidators'; params: { validators: Array<AccountId32Like> } }
  /**
   * Remove validators from the set.
   *
   * The removed validators will be deactivated from current session + 2.
   **/
  | { name: 'DeregisterValidators'; params: { validators: Array<AccountId32Like> } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletStateTrieMigrationCall =
  /**
   * Control the automatic migration.
   *
   * The dispatch origin of this call must be [`Config::ControlOrigin`].
   **/
  | { name: 'ControlAutoMigration'; params: { maybeConfig?: PalletStateTrieMigrationMigrationLimits | undefined } }
  /**
   * Continue the migration for the given `limits`.
   *
   * The dispatch origin of this call can be any signed account.
   *
   * This transaction has NO MONETARY INCENTIVES. calling it will not reward anyone. Albeit,
   * Upon successful execution, the transaction fee is returned.
   *
   * The (potentially over-estimated) of the byte length of all the data read must be
   * provided for up-front fee-payment and weighing. In essence, the caller is guaranteeing
   * that executing the current `MigrationTask` with the given `limits` will not exceed
   * `real_size_upper` bytes of read data.
   *
   * The `witness_task` is merely a helper to prevent the caller from being slashed or
   * generally trigger a migration that they do not intend. This parameter is just a message
   * from caller, saying that they believed `witness_task` was the last state of the
   * migration, and they only wish for their transaction to do anything, if this assumption
   * holds. In case `witness_task` does not match, the transaction fails.
   *
   * Based on the documentation of [`MigrationTask::migrate_until_exhaustion`], the
   * recommended way of doing this is to pass a `limit` that only bounds `count`, as the
   * `size` limit can always be overwritten.
   **/
  | {
      name: 'ContinueMigrate';
      params: {
        limits: PalletStateTrieMigrationMigrationLimits;
        realSizeUpper: number;
        witnessTask: PalletStateTrieMigrationMigrationTask;
      };
    }
  /**
   * Migrate the list of top keys by iterating each of them one by one.
   *
   * This does not affect the global migration process tracker ([`MigrationProcess`]), and
   * should only be used in case any keys are leftover due to a bug.
   **/
  | { name: 'MigrateCustomTop'; params: { keys: Array<Bytes>; witnessSize: number } }
  /**
   * Migrate the list of child keys by iterating each of them one by one.
   *
   * All of the given child keys must be present under one `child_root`.
   *
   * This does not affect the global migration process tracker ([`MigrationProcess`]), and
   * should only be used in case any keys are leftover due to a bug.
   **/
  | { name: 'MigrateCustomChild'; params: { root: Bytes; childKeys: Array<Bytes>; totalSize: number } }
  /**
   * Set the maximum limit of the signed migration.
   **/
  | { name: 'SetSignedMaxLimits'; params: { limits: PalletStateTrieMigrationMigrationLimits } }
  /**
   * Forcefully set the progress the running migration.
   *
   * This is only useful in one case: the next key to migrate is too big to be migrated with
   * a signed account, in a parachain context, and we simply want to skip it. A reasonable
   * example of this would be `:code:`, which is both very expensive to migrate, and commonly
   * used, so probably it is already migrated.
   *
   * In case you mess things up, you can also, in principle, use this to reset the migration
   * process.
   **/
  | {
      name: 'ForceSetProgress';
      params: { progressTop: PalletStateTrieMigrationProgress; progressChild: PalletStateTrieMigrationProgress };
    };

export type PalletStateTrieMigrationCallLike =
  /**
   * Control the automatic migration.
   *
   * The dispatch origin of this call must be [`Config::ControlOrigin`].
   **/
  | { name: 'ControlAutoMigration'; params: { maybeConfig?: PalletStateTrieMigrationMigrationLimits | undefined } }
  /**
   * Continue the migration for the given `limits`.
   *
   * The dispatch origin of this call can be any signed account.
   *
   * This transaction has NO MONETARY INCENTIVES. calling it will not reward anyone. Albeit,
   * Upon successful execution, the transaction fee is returned.
   *
   * The (potentially over-estimated) of the byte length of all the data read must be
   * provided for up-front fee-payment and weighing. In essence, the caller is guaranteeing
   * that executing the current `MigrationTask` with the given `limits` will not exceed
   * `real_size_upper` bytes of read data.
   *
   * The `witness_task` is merely a helper to prevent the caller from being slashed or
   * generally trigger a migration that they do not intend. This parameter is just a message
   * from caller, saying that they believed `witness_task` was the last state of the
   * migration, and they only wish for their transaction to do anything, if this assumption
   * holds. In case `witness_task` does not match, the transaction fails.
   *
   * Based on the documentation of [`MigrationTask::migrate_until_exhaustion`], the
   * recommended way of doing this is to pass a `limit` that only bounds `count`, as the
   * `size` limit can always be overwritten.
   **/
  | {
      name: 'ContinueMigrate';
      params: {
        limits: PalletStateTrieMigrationMigrationLimits;
        realSizeUpper: number;
        witnessTask: PalletStateTrieMigrationMigrationTask;
      };
    }
  /**
   * Migrate the list of top keys by iterating each of them one by one.
   *
   * This does not affect the global migration process tracker ([`MigrationProcess`]), and
   * should only be used in case any keys are leftover due to a bug.
   **/
  | { name: 'MigrateCustomTop'; params: { keys: Array<BytesLike>; witnessSize: number } }
  /**
   * Migrate the list of child keys by iterating each of them one by one.
   *
   * All of the given child keys must be present under one `child_root`.
   *
   * This does not affect the global migration process tracker ([`MigrationProcess`]), and
   * should only be used in case any keys are leftover due to a bug.
   **/
  | { name: 'MigrateCustomChild'; params: { root: BytesLike; childKeys: Array<BytesLike>; totalSize: number } }
  /**
   * Set the maximum limit of the signed migration.
   **/
  | { name: 'SetSignedMaxLimits'; params: { limits: PalletStateTrieMigrationMigrationLimits } }
  /**
   * Forcefully set the progress the running migration.
   *
   * This is only useful in one case: the next key to migrate is too big to be migrated with
   * a signed account, in a parachain context, and we simply want to skip it. A reasonable
   * example of this would be `:code:`, which is both very expensive to migrate, and commonly
   * used, so probably it is already migrated.
   *
   * In case you mess things up, you can also, in principle, use this to reset the migration
   * process.
   **/
  | {
      name: 'ForceSetProgress';
      params: { progressTop: PalletStateTrieMigrationProgress; progressChild: PalletStateTrieMigrationProgress };
    };

export type PalletStateTrieMigrationMigrationLimits = { size: number; item: number };

export type PalletStateTrieMigrationMigrationTask = {
  progressTop: PalletStateTrieMigrationProgress;
  progressChild: PalletStateTrieMigrationProgress;
  size: number;
  topItems: number;
  childItems: number;
};

export type PalletStateTrieMigrationProgress =
  | { tag: 'ToStart' }
  | { tag: 'LastKey'; value: Bytes }
  | { tag: 'Complete' };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletRootTestingCall =
  /**
   * A dispatch that will fill the block weight up to the given ratio.
   **/
  { name: 'FillBlock'; params: { ratio: Perbill } } | { name: 'TriggerDefensive' };

export type PalletRootTestingCallLike =
  /**
   * A dispatch that will fill the block weight up to the given ratio.
   **/
  { name: 'FillBlock'; params: { ratio: Perbill } } | { name: 'TriggerDefensive' };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSudoCall =
  /**
   * Authenticates the sudo key and dispatches a function call with `Root` origin.
   **/
  | { name: 'Sudo'; params: { call: RococoRuntimeRuntimeCall } }
  /**
   * Authenticates the sudo key and dispatches a function call with `Root` origin.
   * This function does not check the weight of the call, and instead allows the
   * Sudo user to specify the weight of the call.
   *
   * The dispatch origin for this call must be _Signed_.
   **/
  | { name: 'SudoUncheckedWeight'; params: { call: RococoRuntimeRuntimeCall; weight: SpWeightsWeightV2Weight } }
  /**
   * Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo
   * key.
   **/
  | { name: 'SetKey'; params: { new: MultiAddress } }
  /**
   * Authenticates the sudo key and dispatches a function call with `Signed` origin from
   * a given account.
   *
   * The dispatch origin for this call must be _Signed_.
   **/
  | { name: 'SudoAs'; params: { who: MultiAddress; call: RococoRuntimeRuntimeCall } }
  /**
   * Permanently removes the sudo key.
   *
   * **This cannot be un-done.**
   **/
  | { name: 'RemoveKey' };

export type PalletSudoCallLike =
  /**
   * Authenticates the sudo key and dispatches a function call with `Root` origin.
   **/
  | { name: 'Sudo'; params: { call: RococoRuntimeRuntimeCallLike } }
  /**
   * Authenticates the sudo key and dispatches a function call with `Root` origin.
   * This function does not check the weight of the call, and instead allows the
   * Sudo user to specify the weight of the call.
   *
   * The dispatch origin for this call must be _Signed_.
   **/
  | { name: 'SudoUncheckedWeight'; params: { call: RococoRuntimeRuntimeCallLike; weight: SpWeightsWeightV2Weight } }
  /**
   * Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo
   * key.
   **/
  | { name: 'SetKey'; params: { new: MultiAddressLike } }
  /**
   * Authenticates the sudo key and dispatches a function call with `Signed` origin from
   * a given account.
   *
   * The dispatch origin for this call must be _Signed_.
   **/
  | { name: 'SudoAs'; params: { who: MultiAddressLike; call: RococoRuntimeRuntimeCallLike } }
  /**
   * Permanently removes the sudo key.
   *
   * **This cannot be un-done.**
   **/
  | { name: 'RemoveKey' };

export type SpRuntimeBlakeTwo256 = {};

export type PalletConvictionVotingTally = { ayes: bigint; nays: bigint; support: bigint };

/**
 * The `Event` enum of this pallet
 **/
export type PalletRankedCollectiveEvent =
  /**
   * A member `who` has been added.
   **/
  | { name: 'MemberAdded'; data: { who: AccountId32 } }
  /**
   * The member `who`se rank has been changed to the given `rank`.
   **/
  | { name: 'RankChanged'; data: { who: AccountId32; rank: number } }
  /**
   * The member `who` of given `rank` has been removed from the collective.
   **/
  | { name: 'MemberRemoved'; data: { who: AccountId32; rank: number } }
  /**
   * The member `who` has voted for the `poll` with the given `vote` leading to an updated
   * `tally`.
   **/
  | {
      name: 'Voted';
      data: {
        who: AccountId32;
        poll: number;
        vote: PalletRankedCollectiveVoteRecord;
        tally: PalletRankedCollectiveTally;
      };
    }
  /**
   * The member `who` had their `AccountId` changed to `new_who`.
   **/
  | { name: 'MemberExchanged'; data: { who: AccountId32; newWho: AccountId32 } };

export type PalletRankedCollectiveVoteRecord = { tag: 'Aye'; value: number } | { tag: 'Nay'; value: number };

export type PalletRankedCollectiveTally = { bareAyes: number; ayes: number; nays: number };

/**
 * The `Event` enum of this pallet
 **/
export type PalletReferendaEvent002 =
  /**
   * A referendum has been submitted.
   **/
  | {
      name: 'Submitted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The track (and by extension proposal dispatch origin) of this referendum.
         **/
        track: number;

        /**
         * The proposal for the referendum.
         **/
        proposal: FrameSupportPreimagesBounded;
      };
    }
  /**
   * The decision deposit has been placed.
   **/
  | {
      name: 'DecisionDepositPlaced';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * The decision deposit has been refunded.
   **/
  | {
      name: 'DecisionDepositRefunded';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * A deposit has been slashed.
   **/
  | {
      name: 'DepositSlashed';
      data: {
        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * A referendum has moved into the deciding phase.
   **/
  | {
      name: 'DecisionStarted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The track (and by extension proposal dispatch origin) of this referendum.
         **/
        track: number;

        /**
         * The proposal for the referendum.
         **/
        proposal: FrameSupportPreimagesBounded;

        /**
         * The current tally of votes in this referendum.
         **/
        tally: PalletRankedCollectiveTally;
      };
    }
  | {
      name: 'ConfirmStarted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  | {
      name: 'ConfirmAborted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  /**
   * A referendum has ended its confirmation phase and is ready for approval.
   **/
  | {
      name: 'Confirmed';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletRankedCollectiveTally;
      };
    }
  /**
   * A referendum has been approved and its proposal has been scheduled.
   **/
  | {
      name: 'Approved';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  /**
   * A proposal has been rejected by referendum.
   **/
  | {
      name: 'Rejected';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletRankedCollectiveTally;
      };
    }
  /**
   * A referendum has been timed out without being decided.
   **/
  | {
      name: 'TimedOut';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletRankedCollectiveTally;
      };
    }
  /**
   * A referendum has been cancelled.
   **/
  | {
      name: 'Cancelled';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletRankedCollectiveTally;
      };
    }
  /**
   * A referendum has been killed.
   **/
  | {
      name: 'Killed';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletRankedCollectiveTally;
      };
    }
  /**
   * The submission deposit has been refunded.
   **/
  | {
      name: 'SubmissionDepositRefunded';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * Metadata for a referendum has been set.
   **/
  | {
      name: 'MetadataSet';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    }
  /**
   * Metadata for a referendum has been cleared.
   **/
  | {
      name: 'MetadataCleared';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletWhitelistEvent =
  | { name: 'CallWhitelisted'; data: { callHash: H256 } }
  | { name: 'WhitelistedCallRemoved'; data: { callHash: H256 } }
  | {
      name: 'WhitelistedCallDispatched';
      data: {
        callHash: H256;
        result: Result<FrameSupportDispatchPostDispatchInfo, SpRuntimeDispatchErrorWithPostInfo>;
      };
    };

export type FrameSupportDispatchPostDispatchInfo = {
  actualWeight?: SpWeightsWeightV2Weight | undefined;
  paysFee: FrameSupportDispatchPays;
};

export type SpRuntimeDispatchErrorWithPostInfo = {
  postInfo: FrameSupportDispatchPostDispatchInfo;
  error: DispatchError;
};

/**
 * The `Event` enum of this pallet
 **/
export type PolkadotRuntimeCommonClaimsPalletEvent =
  /**
   * Someone claimed some DOTs.
   **/
  { name: 'Claimed'; data: { who: AccountId32; ethereumAddress: EthereumAddress; amount: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletUtilityEvent =
  /**
   * Batch of dispatches did not complete fully. Index of first failing dispatch given, as
   * well as the error.
   **/
  | { name: 'BatchInterrupted'; data: { index: number; error: DispatchError } }
  /**
   * Batch of dispatches completed fully with no error.
   **/
  | { name: 'BatchCompleted' }
  /**
   * Batch of dispatches completed but has errors.
   **/
  | { name: 'BatchCompletedWithErrors' }
  /**
   * A single item within a Batch of dispatches has completed with no error.
   **/
  | { name: 'ItemCompleted' }
  /**
   * A single item within a Batch of dispatches has completed with error.
   **/
  | { name: 'ItemFailed'; data: { error: DispatchError } }
  /**
   * A call was dispatched.
   **/
  | { name: 'DispatchedAs'; data: { result: Result<[], DispatchError> } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletIdentityEvent =
  /**
   * A name was set or reset (which will remove all judgements).
   **/
  | { name: 'IdentitySet'; data: { who: AccountId32 } }
  /**
   * A name was cleared, and the given balance returned.
   **/
  | { name: 'IdentityCleared'; data: { who: AccountId32; deposit: bigint } }
  /**
   * A name was removed and the given balance slashed.
   **/
  | { name: 'IdentityKilled'; data: { who: AccountId32; deposit: bigint } }
  /**
   * A judgement was asked from a registrar.
   **/
  | { name: 'JudgementRequested'; data: { who: AccountId32; registrarIndex: number } }
  /**
   * A judgement request was retracted.
   **/
  | { name: 'JudgementUnrequested'; data: { who: AccountId32; registrarIndex: number } }
  /**
   * A judgement was given by a registrar.
   **/
  | { name: 'JudgementGiven'; data: { target: AccountId32; registrarIndex: number } }
  /**
   * A registrar was added.
   **/
  | { name: 'RegistrarAdded'; data: { registrarIndex: number } }
  /**
   * A sub-identity was added to an identity and the deposit paid.
   **/
  | { name: 'SubIdentityAdded'; data: { sub: AccountId32; main: AccountId32; deposit: bigint } }
  /**
   * A sub-identity was removed from an identity and the deposit freed.
   **/
  | { name: 'SubIdentityRemoved'; data: { sub: AccountId32; main: AccountId32; deposit: bigint } }
  /**
   * A sub-identity was cleared, and the given deposit repatriated from the
   * main identity account to the sub-identity account.
   **/
  | { name: 'SubIdentityRevoked'; data: { sub: AccountId32; main: AccountId32; deposit: bigint } }
  /**
   * A username authority was added.
   **/
  | { name: 'AuthorityAdded'; data: { authority: AccountId32 } }
  /**
   * A username authority was removed.
   **/
  | { name: 'AuthorityRemoved'; data: { authority: AccountId32 } }
  /**
   * A username was set for `who`.
   **/
  | { name: 'UsernameSet'; data: { who: AccountId32; username: Bytes } }
  /**
   * A username was queued, but `who` must accept it prior to `expiration`.
   **/
  | { name: 'UsernameQueued'; data: { who: AccountId32; username: Bytes; expiration: number } }
  /**
   * A queued username passed its expiration without being claimed and was removed.
   **/
  | { name: 'PreapprovalExpired'; data: { whose: AccountId32 } }
  /**
   * A username was set as a primary and can be looked up from `who`.
   **/
  | { name: 'PrimaryUsernameSet'; data: { who: AccountId32; username: Bytes } }
  /**
   * A dangling username (as in, a username corresponding to an account that has removed its
   * identity) has been removed.
   **/
  | { name: 'DanglingUsernameRemoved'; data: { who: AccountId32; username: Bytes } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletSocietyEvent =
  /**
   * The society is founded by the given identity.
   **/
  | { name: 'Founded'; data: { founder: AccountId32 } }
  /**
   * A membership bid just happened. The given account is the candidate's ID and their offer
   * is the second.
   **/
  | { name: 'Bid'; data: { candidateId: AccountId32; offer: bigint } }
  /**
   * A membership bid just happened by vouching. The given account is the candidate's ID and
   * their offer is the second. The vouching party is the third.
   **/
  | { name: 'Vouch'; data: { candidateId: AccountId32; offer: bigint; vouching: AccountId32 } }
  /**
   * A candidate was dropped (due to an excess of bids in the system).
   **/
  | { name: 'AutoUnbid'; data: { candidate: AccountId32 } }
  /**
   * A candidate was dropped (by their request).
   **/
  | { name: 'Unbid'; data: { candidate: AccountId32 } }
  /**
   * A candidate was dropped (by request of who vouched for them).
   **/
  | { name: 'Unvouch'; data: { candidate: AccountId32 } }
  /**
   * A group of candidates have been inducted. The batch's primary is the first value, the
   * batch in full is the second.
   **/
  | { name: 'Inducted'; data: { primary: AccountId32; candidates: Array<AccountId32> } }
  /**
   * A suspended member has been judged.
   **/
  | { name: 'SuspendedMemberJudgement'; data: { who: AccountId32; judged: boolean } }
  /**
   * A candidate has been suspended
   **/
  | { name: 'CandidateSuspended'; data: { candidate: AccountId32 } }
  /**
   * A member has been suspended
   **/
  | { name: 'MemberSuspended'; data: { member: AccountId32 } }
  /**
   * A member has been challenged
   **/
  | { name: 'Challenged'; data: { member: AccountId32 } }
  /**
   * A vote has been placed
   **/
  | { name: 'Vote'; data: { candidate: AccountId32; voter: AccountId32; vote: boolean } }
  /**
   * A vote has been placed for a defending member
   **/
  | { name: 'DefenderVote'; data: { voter: AccountId32; vote: boolean } }
  /**
   * A new set of \[params\] has been set for the group.
   **/
  | { name: 'NewParams'; data: { params: PalletSocietyGroupParams } }
  /**
   * Society is unfounded.
   **/
  | { name: 'Unfounded'; data: { founder: AccountId32 } }
  /**
   * Some funds were deposited into the society account.
   **/
  | { name: 'Deposit'; data: { value: bigint } }
  /**
   * A \[member\] got elevated to \[rank\].
   **/
  | { name: 'Elevated'; data: { member: AccountId32; rank: number } };

export type PalletSocietyGroupParams = {
  maxMembers: number;
  maxIntake: number;
  maxStrikes: number;
  candidateDeposit: bigint;
};

/**
 * Events type.
 **/
export type PalletRecoveryEvent =
  /**
   * A recovery process has been set up for an account.
   **/
  | { name: 'RecoveryCreated'; data: { account: AccountId32 } }
  /**
   * A recovery process has been initiated for lost account by rescuer account.
   **/
  | { name: 'RecoveryInitiated'; data: { lostAccount: AccountId32; rescuerAccount: AccountId32 } }
  /**
   * A recovery process for lost account by rescuer account has been vouched for by sender.
   **/
  | { name: 'RecoveryVouched'; data: { lostAccount: AccountId32; rescuerAccount: AccountId32; sender: AccountId32 } }
  /**
   * A recovery process for lost account by rescuer account has been closed.
   **/
  | { name: 'RecoveryClosed'; data: { lostAccount: AccountId32; rescuerAccount: AccountId32 } }
  /**
   * Lost account has been successfully recovered by rescuer account.
   **/
  | { name: 'AccountRecovered'; data: { lostAccount: AccountId32; rescuerAccount: AccountId32 } }
  /**
   * A recovery process has been removed for an account.
   **/
  | { name: 'RecoveryRemoved'; data: { lostAccount: AccountId32 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletVestingEvent =
  /**
   * The amount vested has been updated. This could indicate a change in funds available.
   * The balance given is the amount which is left unvested (and thus locked).
   **/
  | { name: 'VestingUpdated'; data: { account: AccountId32; unvested: bigint } }
  /**
   * An \[account\] has become fully vested.
   **/
  | { name: 'VestingCompleted'; data: { account: AccountId32 } };

/**
 * Events type.
 **/
export type PalletSchedulerEvent =
  /**
   * Scheduled some task.
   **/
  | { name: 'Scheduled'; data: { when: number; index: number } }
  /**
   * Canceled some task.
   **/
  | { name: 'Canceled'; data: { when: number; index: number } }
  /**
   * Dispatched some task.
   **/
  | {
      name: 'Dispatched';
      data: { task: [number, number]; id?: FixedBytes<32> | undefined; result: Result<[], DispatchError> };
    }
  /**
   * Set a retry configuration for some task.
   **/
  | {
      name: 'RetrySet';
      data: { task: [number, number]; id?: FixedBytes<32> | undefined; period: number; retries: number };
    }
  /**
   * Cancel a retry configuration for some task.
   **/
  | { name: 'RetryCancelled'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } }
  /**
   * The call for the provided hash was not found so the task has been aborted.
   **/
  | { name: 'CallUnavailable'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } }
  /**
   * The given task was unable to be renewed since the agenda is full at that block.
   **/
  | { name: 'PeriodicFailed'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } }
  /**
   * The given task was unable to be retried since the agenda is full at that block or there
   * was not enough weight to reschedule it.
   **/
  | { name: 'RetryFailed'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } }
  /**
   * The given task can never be executed since it is overweight.
   **/
  | { name: 'PermanentlyOverweight'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletProxyEvent =
  /**
   * A proxy was executed correctly, with the given.
   **/
  | { name: 'ProxyExecuted'; data: { result: Result<[], DispatchError> } }
  /**
   * A pure account has been created by new proxy with given
   * disambiguation index and proxy type.
   **/
  | {
      name: 'PureCreated';
      data: { pure: AccountId32; who: AccountId32; proxyType: RococoRuntimeProxyType; disambiguationIndex: number };
    }
  /**
   * An announcement was placed to make a call in the future.
   **/
  | { name: 'Announced'; data: { real: AccountId32; proxy: AccountId32; callHash: H256 } }
  /**
   * A proxy was added.
   **/
  | {
      name: 'ProxyAdded';
      data: { delegator: AccountId32; delegatee: AccountId32; proxyType: RococoRuntimeProxyType; delay: number };
    }
  /**
   * A proxy was removed.
   **/
  | {
      name: 'ProxyRemoved';
      data: { delegator: AccountId32; delegatee: AccountId32; proxyType: RococoRuntimeProxyType; delay: number };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletMultisigEvent =
  /**
   * A new multisig operation has begun.
   **/
  | { name: 'NewMultisig'; data: { approving: AccountId32; multisig: AccountId32; callHash: FixedBytes<32> } }
  /**
   * A multisig operation has been approved by someone.
   **/
  | {
      name: 'MultisigApproval';
      data: {
        approving: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
      };
    }
  /**
   * A multisig operation has been executed.
   **/
  | {
      name: 'MultisigExecuted';
      data: {
        approving: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
        result: Result<[], DispatchError>;
      };
    }
  /**
   * A multisig operation has been cancelled.
   **/
  | {
      name: 'MultisigCancelled';
      data: {
        cancelling: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
      };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletPreimageEvent =
  /**
   * A preimage has been noted.
   **/
  | { name: 'Noted'; data: { hash: H256 } }
  /**
   * A preimage has been requested.
   **/
  | { name: 'Requested'; data: { hash: H256 } }
  /**
   * A preimage has ben cleared.
   **/
  | { name: 'Cleared'; data: { hash: H256 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletAssetRateEvent =
  | {
      name: 'AssetRateCreated';
      data: { assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset; rate: FixedU128 };
    }
  | { name: 'AssetRateRemoved'; data: { assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset } }
  | {
      name: 'AssetRateUpdated';
      data: { assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset; old: FixedU128; new: FixedU128 };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletBountiesEvent =
  /**
   * New bounty proposal.
   **/
  | { name: 'BountyProposed'; data: { index: number } }
  /**
   * A bounty proposal was rejected; funds were slashed.
   **/
  | { name: 'BountyRejected'; data: { index: number; bond: bigint } }
  /**
   * A bounty proposal is funded and became active.
   **/
  | { name: 'BountyBecameActive'; data: { index: number } }
  /**
   * A bounty is awarded to a beneficiary.
   **/
  | { name: 'BountyAwarded'; data: { index: number; beneficiary: AccountId32 } }
  /**
   * A bounty is claimed by beneficiary.
   **/
  | { name: 'BountyClaimed'; data: { index: number; payout: bigint; beneficiary: AccountId32 } }
  /**
   * A bounty is cancelled.
   **/
  | { name: 'BountyCanceled'; data: { index: number } }
  /**
   * A bounty expiry is extended.
   **/
  | { name: 'BountyExtended'; data: { index: number } }
  /**
   * A bounty is approved.
   **/
  | { name: 'BountyApproved'; data: { index: number } }
  /**
   * A bounty curator is proposed.
   **/
  | { name: 'CuratorProposed'; data: { bountyId: number; curator: AccountId32 } }
  /**
   * A bounty curator is unassigned.
   **/
  | { name: 'CuratorUnassigned'; data: { bountyId: number } }
  /**
   * A bounty curator is accepted.
   **/
  | { name: 'CuratorAccepted'; data: { bountyId: number; curator: AccountId32 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletChildBountiesEvent =
  /**
   * A child-bounty is added.
   **/
  | { name: 'Added'; data: { index: number; childIndex: number } }
  /**
   * A child-bounty is awarded to a beneficiary.
   **/
  | { name: 'Awarded'; data: { index: number; childIndex: number; beneficiary: AccountId32 } }
  /**
   * A child-bounty is claimed by beneficiary.
   **/
  | { name: 'Claimed'; data: { index: number; childIndex: number; payout: bigint; beneficiary: AccountId32 } }
  /**
   * A child-bounty is cancelled.
   **/
  | { name: 'Canceled'; data: { index: number; childIndex: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletNisEvent =
  /**
   * A bid was successfully placed.
   **/
  | { name: 'BidPlaced'; data: { who: AccountId32; amount: bigint; duration: number } }
  /**
   * A bid was successfully removed (before being accepted).
   **/
  | { name: 'BidRetracted'; data: { who: AccountId32; amount: bigint; duration: number } }
  /**
   * A bid was dropped from a queue because of another, more substantial, bid was present.
   **/
  | { name: 'BidDropped'; data: { who: AccountId32; amount: bigint; duration: number } }
  /**
   * A bid was accepted. The balance may not be released until expiry.
   **/
  | {
      name: 'Issued';
      data: {
        /**
         * The identity of the receipt.
         **/
        index: number;

        /**
         * The block number at which the receipt may be thawed.
         **/
        expiry: number;

        /**
         * The owner of the receipt.
         **/
        who: AccountId32;

        /**
         * The proportion of the effective total issuance which the receipt represents.
         **/
        proportion: Perquintill;

        /**
         * The amount of funds which were debited from the owner.
         **/
        amount: bigint;
      };
    }
  /**
   * An receipt has been (at least partially) thawed.
   **/
  | {
      name: 'Thawed';
      data: {
        /**
         * The identity of the receipt.
         **/
        index: number;

        /**
         * The owner.
         **/
        who: AccountId32;

        /**
         * The proportion of the effective total issuance by which the owner was debited.
         **/
        proportion: Perquintill;

        /**
         * The amount by which the owner was credited.
         **/
        amount: bigint;

        /**
         * If `true` then the receipt is done.
         **/
        dropped: boolean;
      };
    }
  /**
   * An automatic funding of the deficit was made.
   **/
  | { name: 'Funded'; data: { deficit: bigint } }
  /**
   * A receipt was transfered.
   **/
  | { name: 'Transferred'; data: { from: AccountId32; to: AccountId32; index: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PolkadotRuntimeParachainsInclusionPalletEvent =
  /**
   * A candidate was backed. `[candidate, head_data]`
   **/
  | {
      name: 'CandidateBacked';
      data: [
        PolkadotPrimitivesV6CandidateReceipt,
        PolkadotParachainPrimitivesPrimitivesHeadData,
        PolkadotPrimitivesV6CoreIndex,
        PolkadotPrimitivesV6GroupIndex,
      ];
    }
  /**
   * A candidate was included. `[candidate, head_data]`
   **/
  | {
      name: 'CandidateIncluded';
      data: [
        PolkadotPrimitivesV6CandidateReceipt,
        PolkadotParachainPrimitivesPrimitivesHeadData,
        PolkadotPrimitivesV6CoreIndex,
        PolkadotPrimitivesV6GroupIndex,
      ];
    }
  /**
   * A candidate timed out. `[candidate, head_data]`
   **/
  | {
      name: 'CandidateTimedOut';
      data: [
        PolkadotPrimitivesV6CandidateReceipt,
        PolkadotParachainPrimitivesPrimitivesHeadData,
        PolkadotPrimitivesV6CoreIndex,
      ];
    }
  /**
   * Some upward messages have been received and will be processed.
   **/
  | { name: 'UpwardMessagesReceived'; data: { from: PolkadotParachainPrimitivesPrimitivesId; count: number } };

export type PolkadotPrimitivesV6CandidateReceipt = {
  descriptor: PolkadotPrimitivesV6CandidateDescriptor;
  commitmentsHash: H256;
};

export type PolkadotPrimitivesV6CoreIndex = number;

export type PolkadotPrimitivesV6GroupIndex = number;

/**
 * The `Event` enum of this pallet
 **/
export type PolkadotRuntimeParachainsParasPalletEvent =
  /**
   * Current code has been updated for a Para. `para_id`
   **/
  | { name: 'CurrentCodeUpdated'; data: PolkadotParachainPrimitivesPrimitivesId }
  /**
   * Current head has been updated for a Para. `para_id`
   **/
  | { name: 'CurrentHeadUpdated'; data: PolkadotParachainPrimitivesPrimitivesId }
  /**
   * A code upgrade has been scheduled for a Para. `para_id`
   **/
  | { name: 'CodeUpgradeScheduled'; data: PolkadotParachainPrimitivesPrimitivesId }
  /**
   * A new head has been noted for a Para. `para_id`
   **/
  | { name: 'NewHeadNoted'; data: PolkadotParachainPrimitivesPrimitivesId }
  /**
   * A para has been queued to execute pending actions. `para_id`
   **/
  | { name: 'ActionQueued'; data: [PolkadotParachainPrimitivesPrimitivesId, number] }
  /**
   * The given para either initiated or subscribed to a PVF check for the given validation
   * code. `code_hash` `para_id`
   **/
  | {
      name: 'PvfCheckStarted';
      data: [PolkadotParachainPrimitivesPrimitivesValidationCodeHash, PolkadotParachainPrimitivesPrimitivesId];
    }
  /**
   * The given validation code was accepted by the PVF pre-checking vote.
   * `code_hash` `para_id`
   **/
  | {
      name: 'PvfCheckAccepted';
      data: [PolkadotParachainPrimitivesPrimitivesValidationCodeHash, PolkadotParachainPrimitivesPrimitivesId];
    }
  /**
   * The given validation code was rejected by the PVF pre-checking vote.
   * `code_hash` `para_id`
   **/
  | {
      name: 'PvfCheckRejected';
      data: [PolkadotParachainPrimitivesPrimitivesValidationCodeHash, PolkadotParachainPrimitivesPrimitivesId];
    };

/**
 * The `Event` enum of this pallet
 **/
export type PolkadotRuntimeParachainsHrmpPalletEvent =
  /**
   * Open HRMP channel requested.
   **/
  | {
      name: 'OpenChannelRequested';
      data: {
        sender: PolkadotParachainPrimitivesPrimitivesId;
        recipient: PolkadotParachainPrimitivesPrimitivesId;
        proposedMaxCapacity: number;
        proposedMaxMessageSize: number;
      };
    }
  /**
   * An HRMP channel request sent by the receiver was canceled by either party.
   **/
  | {
      name: 'OpenChannelCanceled';
      data: {
        byParachain: PolkadotParachainPrimitivesPrimitivesId;
        channelId: PolkadotParachainPrimitivesPrimitivesHrmpChannelId;
      };
    }
  /**
   * Open HRMP channel accepted.
   **/
  | {
      name: 'OpenChannelAccepted';
      data: { sender: PolkadotParachainPrimitivesPrimitivesId; recipient: PolkadotParachainPrimitivesPrimitivesId };
    }
  /**
   * HRMP channel closed.
   **/
  | {
      name: 'ChannelClosed';
      data: {
        byParachain: PolkadotParachainPrimitivesPrimitivesId;
        channelId: PolkadotParachainPrimitivesPrimitivesHrmpChannelId;
      };
    }
  /**
   * An HRMP channel was opened via Root origin.
   **/
  | {
      name: 'HrmpChannelForceOpened';
      data: {
        sender: PolkadotParachainPrimitivesPrimitivesId;
        recipient: PolkadotParachainPrimitivesPrimitivesId;
        proposedMaxCapacity: number;
        proposedMaxMessageSize: number;
      };
    }
  /**
   * An HRMP channel was opened between two system chains.
   **/
  | {
      name: 'HrmpSystemChannelOpened';
      data: {
        sender: PolkadotParachainPrimitivesPrimitivesId;
        recipient: PolkadotParachainPrimitivesPrimitivesId;
        proposedMaxCapacity: number;
        proposedMaxMessageSize: number;
      };
    }
  /**
   * An HRMP channel's deposits were updated.
   **/
  | {
      name: 'OpenChannelDepositsUpdated';
      data: { sender: PolkadotParachainPrimitivesPrimitivesId; recipient: PolkadotParachainPrimitivesPrimitivesId };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PolkadotRuntimeParachainsDisputesPalletEvent =
  /**
   * A dispute has been initiated. \[candidate hash, dispute location\]
   **/
  | {
      name: 'DisputeInitiated';
      data: [PolkadotCorePrimitivesCandidateHash, PolkadotRuntimeParachainsDisputesDisputeLocation];
    }
  /**
   * A dispute has concluded for or against a candidate.
   * `\[para id, candidate hash, dispute result\]`
   **/
  | {
      name: 'DisputeConcluded';
      data: [PolkadotCorePrimitivesCandidateHash, PolkadotRuntimeParachainsDisputesDisputeResult];
    }
  /**
   * A dispute has concluded with supermajority against a candidate.
   * Block authors should no longer build on top of this head and should
   * instead revert the block at the given height. This should be the
   * number of the child of the last known valid block in the chain.
   **/
  | { name: 'Revert'; data: number };

export type PolkadotRuntimeParachainsDisputesDisputeLocation = 'Local' | 'Remote';

export type PolkadotRuntimeParachainsDisputesDisputeResult = 'Valid' | 'Invalid';

/**
 * The `Event` enum of this pallet
 **/
export type PalletMessageQueueEvent =
  /**
   * Message discarded due to an error in the `MessageProcessor` (usually a format error).
   **/
  | {
      name: 'ProcessingFailed';
      data: {
        /**
         * The `blake2_256` hash of the message.
         **/
        id: H256;

        /**
         * The queue of the message.
         **/
        origin: PolkadotRuntimeParachainsInclusionAggregateMessageOrigin;

        /**
         * The error that occurred.
         *
         * This error is pretty opaque. More fine-grained errors need to be emitted as events
         * by the `MessageProcessor`.
         **/
        error: FrameSupportMessagesProcessMessageError;
      };
    }
  /**
   * Message is processed.
   **/
  | {
      name: 'Processed';
      data: {
        /**
         * The `blake2_256` hash of the message.
         **/
        id: H256;

        /**
         * The queue of the message.
         **/
        origin: PolkadotRuntimeParachainsInclusionAggregateMessageOrigin;

        /**
         * How much weight was used to process the message.
         **/
        weightUsed: SpWeightsWeightV2Weight;

        /**
         * Whether the message was processed.
         *
         * Note that this does not mean that the underlying `MessageProcessor` was internally
         * successful. It *solely* means that the MQ pallet will treat this as a success
         * condition and discard the message. Any internal error needs to be emitted as events
         * by the `MessageProcessor`.
         **/
        success: boolean;
      };
    }
  /**
   * Message placed in overweight queue.
   **/
  | {
      name: 'OverweightEnqueued';
      data: {
        /**
         * The `blake2_256` hash of the message.
         **/
        id: FixedBytes<32>;

        /**
         * The queue of the message.
         **/
        origin: PolkadotRuntimeParachainsInclusionAggregateMessageOrigin;

        /**
         * The page of the message.
         **/
        pageIndex: number;

        /**
         * The index of the message within the page.
         **/
        messageIndex: number;
      };
    }
  /**
   * This page was reaped.
   **/
  | {
      name: 'PageReaped';
      data: {
        /**
         * The queue of the page.
         **/
        origin: PolkadotRuntimeParachainsInclusionAggregateMessageOrigin;

        /**
         * The index of the page.
         **/
        index: number;
      };
    };

export type FrameSupportMessagesProcessMessageError =
  | { tag: 'BadFormat' }
  | { tag: 'Corrupt' }
  | { tag: 'Unsupported' }
  | { tag: 'Overweight'; value: SpWeightsWeightV2Weight }
  | { tag: 'Yield' };

/**
 * The `Event` enum of this pallet
 **/
export type PolkadotRuntimeParachainsAssignerOnDemandPalletEvent =
  /**
   * An order was placed at some spot price amount.
   **/
  | { name: 'OnDemandOrderPlaced'; data: { paraId: PolkadotParachainPrimitivesPrimitivesId; spotPrice: bigint } }
  /**
   * The value of the spot traffic multiplier changed.
   **/
  | { name: 'SpotTrafficSet'; data: { traffic: FixedU128 } };

/**
 * The `Event` enum of this pallet
 **/
export type PolkadotRuntimeCommonParasRegistrarPalletEvent =
  | { name: 'Registered'; data: { paraId: PolkadotParachainPrimitivesPrimitivesId; manager: AccountId32 } }
  | { name: 'Deregistered'; data: { paraId: PolkadotParachainPrimitivesPrimitivesId } }
  | { name: 'Reserved'; data: { paraId: PolkadotParachainPrimitivesPrimitivesId; who: AccountId32 } }
  | {
      name: 'Swapped';
      data: { paraId: PolkadotParachainPrimitivesPrimitivesId; otherId: PolkadotParachainPrimitivesPrimitivesId };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PolkadotRuntimeCommonSlotsPalletEvent =
  /**
   * A new `[lease_period]` is beginning.
   **/
  | { name: 'NewLeasePeriod'; data: { leasePeriod: number } }
  /**
   * A para has won the right to a continuous set of lease periods as a parachain.
   * First balance is any extra amount reserved on top of the para's existing deposit.
   * Second balance is the total amount reserved.
   **/
  | {
      name: 'Leased';
      data: {
        paraId: PolkadotParachainPrimitivesPrimitivesId;
        leaser: AccountId32;
        periodBegin: number;
        periodCount: number;
        extraReserved: bigint;
        totalAmount: bigint;
      };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PolkadotRuntimeCommonAuctionsPalletEvent =
  /**
   * An auction started. Provides its index and the block number where it will begin to
   * close and the first lease period of the quadruplet that is auctioned.
   **/
  | { name: 'AuctionStarted'; data: { auctionIndex: number; leasePeriod: number; ending: number } }
  /**
   * An auction ended. All funds become unreserved.
   **/
  | { name: 'AuctionClosed'; data: { auctionIndex: number } }
  /**
   * Funds were reserved for a winning bid. First balance is the extra amount reserved.
   * Second is the total.
   **/
  | { name: 'Reserved'; data: { bidder: AccountId32; extraReserved: bigint; totalAmount: bigint } }
  /**
   * Funds were unreserved since bidder is no longer active. `[bidder, amount]`
   **/
  | { name: 'Unreserved'; data: { bidder: AccountId32; amount: bigint } }
  /**
   * Someone attempted to lease the same slot twice for a parachain. The amount is held in
   * reserve but no parachain slot has been leased.
   **/
  | {
      name: 'ReserveConfiscated';
      data: { paraId: PolkadotParachainPrimitivesPrimitivesId; leaser: AccountId32; amount: bigint };
    }
  /**
   * A new bid has been accepted as the current winner.
   **/
  | {
      name: 'BidAccepted';
      data: {
        bidder: AccountId32;
        paraId: PolkadotParachainPrimitivesPrimitivesId;
        amount: bigint;
        firstSlot: number;
        lastSlot: number;
      };
    }
  /**
   * The winning offset was chosen for an auction. This will map into the `Winning` storage
   * map.
   **/
  | { name: 'WinningOffset'; data: { auctionIndex: number; blockNumber: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PolkadotRuntimeCommonCrowdloanPalletEvent =
  /**
   * Create a new crowdloaning campaign.
   **/
  | { name: 'Created'; data: { paraId: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Contributed to a crowd sale.
   **/
  | {
      name: 'Contributed';
      data: { who: AccountId32; fundIndex: PolkadotParachainPrimitivesPrimitivesId; amount: bigint };
    }
  /**
   * Withdrew full balance of a contributor.
   **/
  | { name: 'Withdrew'; data: { who: AccountId32; fundIndex: PolkadotParachainPrimitivesPrimitivesId; amount: bigint } }
  /**
   * The loans in a fund have been partially dissolved, i.e. there are some left
   * over child keys that still need to be killed.
   **/
  | { name: 'PartiallyRefunded'; data: { paraId: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * All loans in a fund have been refunded.
   **/
  | { name: 'AllRefunded'; data: { paraId: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * Fund is dissolved.
   **/
  | { name: 'Dissolved'; data: { paraId: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * The result of trying to submit a new bid to the Slots pallet.
   **/
  | {
      name: 'HandleBidResult';
      data: { paraId: PolkadotParachainPrimitivesPrimitivesId; result: Result<[], DispatchError> };
    }
  /**
   * The configuration to a crowdloan has been edited.
   **/
  | { name: 'Edited'; data: { paraId: PolkadotParachainPrimitivesPrimitivesId } }
  /**
   * A memo has been updated.
   **/
  | { name: 'MemoUpdated'; data: { who: AccountId32; paraId: PolkadotParachainPrimitivesPrimitivesId; memo: Bytes } }
  /**
   * A parachain has been moved to `NewRaise`
   **/
  | { name: 'AddedToNewRaise'; data: { paraId: PolkadotParachainPrimitivesPrimitivesId } };

/**
 * The `Event` enum of this pallet
 **/
export type PolkadotRuntimeParachainsCoretimePalletEvent =
  /**
   * The broker chain has asked for revenue information for a specific block.
   **/
  | { name: 'RevenueInfoRequested'; data: { when: number } }
  /**
   * A core has received a new assignment from the broker chain.
   **/
  | { name: 'CoreAssigned'; data: { core: PolkadotPrimitivesV6CoreIndex } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletXcmEvent =
  /**
   * Execution of an XCM message was attempted.
   **/
  | { name: 'Attempted'; data: { outcome: StagingXcmV4TraitsOutcome } }
  /**
   * A XCM message was sent.
   **/
  | {
      name: 'Sent';
      data: {
        origin: StagingXcmV4Location;
        destination: StagingXcmV4Location;
        message: StagingXcmV4Xcm;
        messageId: FixedBytes<32>;
      };
    }
  /**
   * Query response received which does not match a registered query. This may be because a
   * matching query was never registered, it may be because it is a duplicate response, or
   * because the query timed out.
   **/
  | { name: 'UnexpectedResponse'; data: { origin: StagingXcmV4Location; queryId: bigint } }
  /**
   * Query response has been received and is ready for taking with `take_response`. There is
   * no registered notification call.
   **/
  | { name: 'ResponseReady'; data: { queryId: bigint; response: StagingXcmV4Response } }
  /**
   * Query response has been received and query is removed. The registered notification has
   * been dispatched and executed successfully.
   **/
  | { name: 'Notified'; data: { queryId: bigint; palletIndex: number; callIndex: number } }
  /**
   * Query response has been received and query is removed. The registered notification
   * could not be dispatched because the dispatch weight is greater than the maximum weight
   * originally budgeted by this runtime for the query result.
   **/
  | {
      name: 'NotifyOverweight';
      data: {
        queryId: bigint;
        palletIndex: number;
        callIndex: number;
        actualWeight: SpWeightsWeightV2Weight;
        maxBudgetedWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Query response has been received and query is removed. There was a general error with
   * dispatching the notification call.
   **/
  | { name: 'NotifyDispatchError'; data: { queryId: bigint; palletIndex: number; callIndex: number } }
  /**
   * Query response has been received and query is removed. The dispatch was unable to be
   * decoded into a `Call`; this might be due to dispatch function having a signature which
   * is not `(origin, QueryId, Response)`.
   **/
  | { name: 'NotifyDecodeFailed'; data: { queryId: bigint; palletIndex: number; callIndex: number } }
  /**
   * Expected query response has been received but the origin location of the response does
   * not match that expected. The query remains registered for a later, valid, response to
   * be received and acted upon.
   **/
  | {
      name: 'InvalidResponder';
      data: { origin: StagingXcmV4Location; queryId: bigint; expectedLocation?: StagingXcmV4Location | undefined };
    }
  /**
   * Expected query response has been received but the expected origin location placed in
   * storage by this runtime previously cannot be decoded. The query remains registered.
   *
   * This is unexpected (since a location placed in storage in a previously executing
   * runtime should be readable prior to query timeout) and dangerous since the possibly
   * valid response will be dropped. Manual governance intervention is probably going to be
   * needed.
   **/
  | { name: 'InvalidResponderVersion'; data: { origin: StagingXcmV4Location; queryId: bigint } }
  /**
   * Received query response has been read and removed.
   **/
  | { name: 'ResponseTaken'; data: { queryId: bigint } }
  /**
   * Some assets have been placed in an asset trap.
   **/
  | { name: 'AssetsTrapped'; data: { hash: H256; origin: StagingXcmV4Location; assets: XcmVersionedAssets } }
  /**
   * An XCM version change notification message has been attempted to be sent.
   *
   * The cost of sending it (borne by the chain) is included.
   **/
  | {
      name: 'VersionChangeNotified';
      data: {
        destination: StagingXcmV4Location;
        result: number;
        cost: StagingXcmV4AssetAssets;
        messageId: FixedBytes<32>;
      };
    }
  /**
   * The supported version of a location has been changed. This might be through an
   * automatic notification or a manual intervention.
   **/
  | { name: 'SupportedVersionChanged'; data: { location: StagingXcmV4Location; version: number } }
  /**
   * A given location which had a version change subscription was dropped owing to an error
   * sending the notification to it.
   **/
  | { name: 'NotifyTargetSendFail'; data: { location: StagingXcmV4Location; queryId: bigint; error: XcmV3TraitsError } }
  /**
   * A given location which had a version change subscription was dropped owing to an error
   * migrating the location to our new XCM format.
   **/
  | { name: 'NotifyTargetMigrationFail'; data: { location: XcmVersionedLocation; queryId: bigint } }
  /**
   * Expected query response has been received but the expected querier location placed in
   * storage by this runtime previously cannot be decoded. The query remains registered.
   *
   * This is unexpected (since a location placed in storage in a previously executing
   * runtime should be readable prior to query timeout) and dangerous since the possibly
   * valid response will be dropped. Manual governance intervention is probably going to be
   * needed.
   **/
  | { name: 'InvalidQuerierVersion'; data: { origin: StagingXcmV4Location; queryId: bigint } }
  /**
   * Expected query response has been received but the querier location of the response does
   * not match the expected. The query remains registered for a later, valid, response to
   * be received and acted upon.
   **/
  | {
      name: 'InvalidQuerier';
      data: {
        origin: StagingXcmV4Location;
        queryId: bigint;
        expectedQuerier: StagingXcmV4Location;
        maybeActualQuerier?: StagingXcmV4Location | undefined;
      };
    }
  /**
   * A remote has requested XCM version change notification from us and we have honored it.
   * A version information message is sent to them and its cost is included.
   **/
  | {
      name: 'VersionNotifyStarted';
      data: { destination: StagingXcmV4Location; cost: StagingXcmV4AssetAssets; messageId: FixedBytes<32> };
    }
  /**
   * We have requested that a remote chain send us XCM version change notifications.
   **/
  | {
      name: 'VersionNotifyRequested';
      data: { destination: StagingXcmV4Location; cost: StagingXcmV4AssetAssets; messageId: FixedBytes<32> };
    }
  /**
   * We have requested that a remote chain stops sending us XCM version change
   * notifications.
   **/
  | {
      name: 'VersionNotifyUnrequested';
      data: { destination: StagingXcmV4Location; cost: StagingXcmV4AssetAssets; messageId: FixedBytes<32> };
    }
  /**
   * Fees were paid from a location for an operation (often for using `SendXcm`).
   **/
  | { name: 'FeesPaid'; data: { paying: StagingXcmV4Location; fees: StagingXcmV4AssetAssets } }
  /**
   * Some assets have been claimed from an asset trap
   **/
  | { name: 'AssetsClaimed'; data: { hash: H256; origin: StagingXcmV4Location; assets: XcmVersionedAssets } }
  /**
   * A XCM version migration finished.
   **/
  | { name: 'VersionMigrationFinished'; data: { version: number } };

export type StagingXcmV4TraitsOutcome =
  | { tag: 'Complete'; value: { used: SpWeightsWeightV2Weight } }
  | { tag: 'Incomplete'; value: { used: SpWeightsWeightV2Weight; error: XcmV3TraitsError } }
  | { tag: 'Error'; value: { error: XcmV3TraitsError } };

/**
 * The `Event` enum of this pallet
 **/
export type PolkadotRuntimeCommonIdentityMigratorPalletEvent =
  /**
   * The identity and all sub accounts were reaped for `who`.
   **/
  | { name: 'IdentityReaped'; data: { who: AccountId32 } }
  /**
   * The deposits held for `who` were updated. `identity` is the new deposit held for
   * identity info, and `subs` is the new deposit held for the sub-accounts.
   **/
  | { name: 'DepositUpdated'; data: { who: AccountId32; identity: bigint; subs: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PolkadotRuntimeCommonAssignedSlotsPalletEvent =
  /**
   * A parachain was assigned a permanent parachain slot
   **/
  | { name: 'PermanentSlotAssigned'; data: PolkadotParachainPrimitivesPrimitivesId }
  /**
   * A parachain was assigned a temporary parachain slot
   **/
  | { name: 'TemporarySlotAssigned'; data: PolkadotParachainPrimitivesPrimitivesId }
  /**
   * The maximum number of permanent slots has been changed
   **/
  | { name: 'MaxPermanentSlotsChanged'; data: { slots: number } }
  /**
   * The maximum number of temporary slots has been changed
   **/
  | { name: 'MaxTemporarySlotsChanged'; data: { slots: number } };

/**
 * The `Event` enum of this pallet
 **/
export type RococoRuntimeValidatorManagerPalletEvent =
  /**
   * New validators were added to the set.
   **/
  | { name: 'ValidatorsRegistered'; data: Array<AccountId32> }
  /**
   * Validators were removed from the set.
   **/
  | { name: 'ValidatorsDeregistered'; data: Array<AccountId32> };

/**
 * Inner events of this pallet.
 **/
export type PalletStateTrieMigrationEvent =
  /**
   * Given number of `(top, child)` keys were migrated respectively, with the given
   * `compute`.
   **/
  | { name: 'Migrated'; data: { top: number; child: number; compute: PalletStateTrieMigrationMigrationCompute } }
  /**
   * Some account got slashed by the given amount.
   **/
  | { name: 'Slashed'; data: { who: AccountId32; amount: bigint } }
  /**
   * The auto migration task finished.
   **/
  | { name: 'AutoMigrationFinished' }
  /**
   * Migration got halted due to an error or miss-configuration.
   **/
  | { name: 'Halted'; data: { error: PalletStateTrieMigrationError } };

export type PalletStateTrieMigrationMigrationCompute = 'Signed' | 'Auto';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletStateTrieMigrationError =
  /**
   * Max signed limits not respected.
   **/
  | 'MaxSignedLimits'
  /**
   * A key was longer than the configured maximum.
   *
   * This means that the migration halted at the current [`Progress`] and
   * can be resumed with a larger [`crate::Config::MaxKeyLen`] value.
   * Retrying with the same [`crate::Config::MaxKeyLen`] value will not work.
   * The value should only be increased to avoid a storage migration for the currently
   * stored [`crate::Progress::LastKey`].
   **/
  | 'KeyTooLong'
  /**
   * submitter does not have enough funds.
   **/
  | 'NotEnoughFunds'
  /**
   * Bad witness data provided.
   **/
  | 'BadWitness'
  /**
   * Signed migration is not allowed because the maximum limit is not set yet.
   **/
  | 'SignedMigrationNotAllowed'
  /**
   * Bad child root provided.
   **/
  | 'BadChildRoot';

/**
 * The `Event` enum of this pallet
 **/
export type PalletRootTestingEvent =
  /**
   * Event dispatched when the trigger_defensive extrinsic is called.
   **/
  'DefensiveTestCall';

/**
 * The `Event` enum of this pallet
 **/
export type PalletSudoEvent =
  /**
   * A sudo call just took place.
   **/
  | {
      name: 'Sudid';
      data: {
        /**
         * The result of the call made by the sudo user.
         **/
        sudoResult: Result<[], DispatchError>;
      };
    }
  /**
   * The sudo key has been updated.
   **/
  | {
      name: 'KeyChanged';
      data: {
        /**
         * The old sudo key (if one was previously set).
         **/
        old?: AccountId32 | undefined;

        /**
         * The new sudo key (if one was set).
         **/
        new: AccountId32;
      };
    }
  /**
   * The key was permanently removed.
   **/
  | { name: 'KeyRemoved' }
  /**
   * A [sudo_as](Pallet::sudo_as) call just took place.
   **/
  | {
      name: 'SudoAsDone';
      data: {
        /**
         * The result of the call made by the sudo user.
         **/
        sudoResult: Result<[], DispatchError>;
      };
    };

export type FrameSystemLastRuntimeUpgradeInfo = { specVersion: number; specName: string };

export type FrameSystemCodeUpgradeAuthorization = { codeHash: H256; checkVersion: boolean };

export type FrameSystemLimitsBlockWeights = {
  baseBlock: SpWeightsWeightV2Weight;
  maxBlock: SpWeightsWeightV2Weight;
  perClass: FrameSupportDispatchPerDispatchClassWeightsPerClass;
};

export type FrameSupportDispatchPerDispatchClassWeightsPerClass = {
  normal: FrameSystemLimitsWeightsPerClass;
  operational: FrameSystemLimitsWeightsPerClass;
  mandatory: FrameSystemLimitsWeightsPerClass;
};

export type FrameSystemLimitsWeightsPerClass = {
  baseExtrinsic: SpWeightsWeightV2Weight;
  maxExtrinsic?: SpWeightsWeightV2Weight | undefined;
  maxTotal?: SpWeightsWeightV2Weight | undefined;
  reserved?: SpWeightsWeightV2Weight | undefined;
};

export type FrameSystemLimitsBlockLength = { max: FrameSupportDispatchPerDispatchClassU32 };

export type FrameSupportDispatchPerDispatchClassU32 = { normal: number; operational: number; mandatory: number };

export type SpWeightsRuntimeDbWeight = { read: bigint; write: bigint };

/**
 * Error for the System pallet
 **/
export type FrameSystemError =
  /**
   * The name of specification does not match between the current runtime
   * and the new runtime.
   **/
  | 'InvalidSpecName'
  /**
   * The specification version is not allowed to decrease between the current runtime
   * and the new runtime.
   **/
  | 'SpecVersionNeedsToIncrease'
  /**
   * Failed to extract the runtime version from the new runtime.
   *
   * Either calling `Core_version` or decoding `RuntimeVersion` failed.
   **/
  | 'FailedToExtractRuntimeVersion'
  /**
   * Suicide called when the account has non-default composite data.
   **/
  | 'NonDefaultComposite'
  /**
   * There is a non-zero reference count preventing the account from being purged.
   **/
  | 'NonZeroRefCount'
  /**
   * The origin filter prevent the call to be dispatched.
   **/
  | 'CallFiltered'
  /**
   * A multi-block migration is ongoing and prevents the current code from being replaced.
   **/
  | 'MultiBlockMigrationsOngoing'
  /**
   * No upgrade authorized.
   **/
  | 'NothingAuthorized'
  /**
   * The submitted code is not authorized.
   **/
  | 'Unauthorized';

export type SpConsensusBabeDigestsPreDigest =
  | { tag: 'Primary'; value: SpConsensusBabeDigestsPrimaryPreDigest }
  | { tag: 'SecondaryPlain'; value: SpConsensusBabeDigestsSecondaryPlainPreDigest }
  | { tag: 'SecondaryVRF'; value: SpConsensusBabeDigestsSecondaryVRFPreDigest };

export type SpConsensusBabeDigestsPrimaryPreDigest = {
  authorityIndex: number;
  slot: SpConsensusSlotsSlot;
  vrfSignature: SpCoreSr25519VrfVrfSignature;
};

export type SpCoreSr25519VrfVrfSignature = { preOutput: FixedBytes<32>; proof: FixedBytes<64> };

export type SpConsensusBabeDigestsSecondaryPlainPreDigest = { authorityIndex: number; slot: SpConsensusSlotsSlot };

export type SpConsensusBabeDigestsSecondaryVRFPreDigest = {
  authorityIndex: number;
  slot: SpConsensusSlotsSlot;
  vrfSignature: SpCoreSr25519VrfVrfSignature;
};

export type SpConsensusBabeBabeEpochConfiguration = { c: [bigint, bigint]; allowedSlots: SpConsensusBabeAllowedSlots };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBabeError =
  /**
   * An equivocation proof provided as part of an equivocation report is invalid.
   **/
  | 'InvalidEquivocationProof'
  /**
   * A key ownership proof provided as part of an equivocation report is invalid.
   **/
  | 'InvalidKeyOwnershipProof'
  /**
   * A given equivocation report is valid but already previously reported.
   **/
  | 'DuplicateOffenceReport'
  /**
   * Submitted configuration is invalid.
   **/
  | 'InvalidConfiguration';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletIndicesError =
  /**
   * The index was not already assigned.
   **/
  | 'NotAssigned'
  /**
   * The index is assigned to another account.
   **/
  | 'NotOwner'
  /**
   * The index was not available.
   **/
  | 'InUse'
  /**
   * The source and destination accounts are identical.
   **/
  | 'NotTransfer'
  /**
   * The index is permanent and may not be freed/changed.
   **/
  | 'Permanent';

export type PalletBalancesBalanceLock = { id: FixedBytes<8>; amount: bigint; reasons: PalletBalancesReasons };

export type PalletBalancesReasons = 'Fee' | 'Misc' | 'All';

export type PalletBalancesReserveData = { id: FixedBytes<8>; amount: bigint };

export type PalletBalancesIdAmount = { id: RococoRuntimeRuntimeHoldReason; amount: bigint };

export type RococoRuntimeRuntimeHoldReason =
  | { tag: 'Preimage'; value: PalletPreimageHoldReason }
  | { tag: 'Nis'; value: PalletNisHoldReason }
  | { tag: 'StateTrieMigration'; value: PalletStateTrieMigrationHoldReason };

export type PalletPreimageHoldReason = 'Preimage';

export type PalletNisHoldReason = 'NftReceipt';

export type PalletStateTrieMigrationHoldReason = 'SlashForMigrate';

export type PalletBalancesIdAmount002 = { id: []; amount: bigint };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBalancesError =
  /**
   * Vesting balance too high to send value.
   **/
  | 'VestingBalance'
  /**
   * Account liquidity restrictions prevent withdrawal.
   **/
  | 'LiquidityRestrictions'
  /**
   * Balance too low to send value.
   **/
  | 'InsufficientBalance'
  /**
   * Value too low to create account due to existential deposit.
   **/
  | 'ExistentialDeposit'
  /**
   * Transfer/payment would kill account.
   **/
  | 'Expendability'
  /**
   * A vesting schedule already exists for this account.
   **/
  | 'ExistingVestingSchedule'
  /**
   * Beneficiary account must pre-exist.
   **/
  | 'DeadAccount'
  /**
   * Number of named reserves exceed `MaxReserves`.
   **/
  | 'TooManyReserves'
  /**
   * Number of holds exceed `VariantCountOf<T::RuntimeHoldReason>`.
   **/
  | 'TooManyHolds'
  /**
   * Number of freezes exceed `MaxFreezes`.
   **/
  | 'TooManyFreezes'
  /**
   * The issuance cannot be modified since it is already deactivated.
   **/
  | 'IssuanceDeactivated'
  /**
   * The delta cannot be zero.
   **/
  | 'DeltaZero';

export type PalletTransactionPaymentReleases = 'V1Ancient' | 'V2';

export type SpStakingOffenceOffenceDetails = { offender: [AccountId32, []]; reporters: Array<AccountId32> };

export type SpCoreCryptoKeyTypeId = FixedBytes<4>;

/**
 * Error for the session pallet.
 **/
export type PalletSessionError =
  /**
   * Invalid ownership proof.
   **/
  | 'InvalidProof'
  /**
   * No associated validator ID for account.
   **/
  | 'NoAssociatedValidatorId'
  /**
   * Registered duplicate key.
   **/
  | 'DuplicatedKey'
  /**
   * No keys are associated with this account.
   **/
  | 'NoKeys'
  /**
   * Key setting account is not live, so it's impossible to associate keys.
   **/
  | 'NoAccount';

export type PalletGrandpaStoredState =
  | { tag: 'Live' }
  | { tag: 'PendingPause'; value: { scheduledAt: number; delay: number } }
  | { tag: 'Paused' }
  | { tag: 'PendingResume'; value: { scheduledAt: number; delay: number } };

export type PalletGrandpaStoredPendingChange = {
  scheduledAt: number;
  delay: number;
  nextAuthorities: Array<[SpConsensusGrandpaAppPublic, bigint]>;
  forced?: number | undefined;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletGrandpaError =
  /**
   * Attempt to signal GRANDPA pause when the authority set isn't live
   * (either paused or already pending pause).
   **/
  | 'PauseFailed'
  /**
   * Attempt to signal GRANDPA resume when the authority set isn't paused
   * (either live or already pending resume).
   **/
  | 'ResumeFailed'
  /**
   * Attempt to signal GRANDPA change with one already pending.
   **/
  | 'ChangePending'
  /**
   * Cannot signal forced change so soon after last.
   **/
  | 'TooSoon'
  /**
   * A key ownership proof provided as part of an equivocation report is invalid.
   **/
  | 'InvalidKeyOwnershipProof'
  /**
   * An equivocation proof provided as part of an equivocation report is invalid.
   **/
  | 'InvalidEquivocationProof'
  /**
   * A given equivocation report is valid but already previously reported.
   **/
  | 'DuplicateOffenceReport';

export type PalletTreasuryProposal = { proposer: AccountId32; value: bigint; beneficiary: AccountId32; bond: bigint };

export type PalletTreasurySpendStatus = {
  assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset;
  amount: bigint;
  beneficiary: XcmVersionedLocation;
  validFrom: number;
  expireAt: number;
  status: PalletTreasuryPaymentState;
};

export type PalletTreasuryPaymentState =
  | { tag: 'Pending' }
  | { tag: 'Attempted'; value: { id: bigint } }
  | { tag: 'Failed' };

export type FrameSupportPalletId = FixedBytes<8>;

/**
 * Error for the treasury pallet.
 **/
export type PalletTreasuryError =
  /**
   * Proposer's balance is too low.
   **/
  | 'InsufficientProposersBalance'
  /**
   * No proposal, bounty or spend at that index.
   **/
  | 'InvalidIndex'
  /**
   * Too many approvals in the queue.
   **/
  | 'TooManyApprovals'
  /**
   * The spend origin is valid but the amount it is allowed to spend is lower than the
   * amount to be spent.
   **/
  | 'InsufficientPermission'
  /**
   * Proposal has not been approved.
   **/
  | 'ProposalNotApproved'
  /**
   * The balance of the asset kind is not convertible to the balance of the native asset.
   **/
  | 'FailedToConvertBalance'
  /**
   * The spend has expired and cannot be claimed.
   **/
  | 'SpendExpired'
  /**
   * The spend is not yet eligible for payout.
   **/
  | 'EarlyPayout'
  /**
   * The payment has already been attempted.
   **/
  | 'AlreadyAttempted'
  /**
   * There was some issue with the mechanism of payment.
   **/
  | 'PayoutError'
  /**
   * The payout was not yet attempted/claimed.
   **/
  | 'NotAttempted'
  /**
   * The payment has neither failed nor succeeded yet.
   **/
  | 'Inconclusive';

export type PalletConvictionVotingVoteVoting =
  | { tag: 'Casting'; value: PalletConvictionVotingVoteCasting }
  | { tag: 'Delegating'; value: PalletConvictionVotingVoteDelegating };

export type PalletConvictionVotingVoteCasting = {
  votes: Array<[number, PalletConvictionVotingVoteAccountVote]>;
  delegations: PalletConvictionVotingDelegations;
  prior: PalletConvictionVotingVotePriorLock;
};

export type PalletConvictionVotingDelegations = { votes: bigint; capital: bigint };

export type PalletConvictionVotingVotePriorLock = [number, bigint];

export type PalletConvictionVotingVoteDelegating = {
  balance: bigint;
  target: AccountId32;
  conviction: PalletConvictionVotingConviction;
  delegations: PalletConvictionVotingDelegations;
  prior: PalletConvictionVotingVotePriorLock;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletConvictionVotingError =
  /**
   * Poll is not ongoing.
   **/
  | 'NotOngoing'
  /**
   * The given account did not vote on the poll.
   **/
  | 'NotVoter'
  /**
   * The actor has no permission to conduct the action.
   **/
  | 'NoPermission'
  /**
   * The actor has no permission to conduct the action right now but will do in the future.
   **/
  | 'NoPermissionYet'
  /**
   * The account is already delegating.
   **/
  | 'AlreadyDelegating'
  /**
   * The account currently has votes attached to it and the operation cannot succeed until
   * these are removed through `remove_vote`.
   **/
  | 'AlreadyVoting'
  /**
   * Too high a balance was provided that the account cannot afford.
   **/
  | 'InsufficientFunds'
  /**
   * The account is not currently delegating.
   **/
  | 'NotDelegating'
  /**
   * Delegation to oneself makes no sense.
   **/
  | 'Nonsense'
  /**
   * Maximum number of votes reached.
   **/
  | 'MaxVotesReached'
  /**
   * The class must be supplied since it is not easily determinable from the state.
   **/
  | 'ClassNeeded'
  /**
   * The class ID supplied is invalid.
   **/
  | 'BadClass';

export type PalletReferendaReferendumInfo =
  | { tag: 'Ongoing'; value: PalletReferendaReferendumStatus }
  | { tag: 'Approved'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { tag: 'Rejected'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { tag: 'Cancelled'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { tag: 'TimedOut'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { tag: 'Killed'; value: number };

export type PalletReferendaReferendumStatus = {
  track: number;
  origin: RococoRuntimeOriginCaller;
  proposal: FrameSupportPreimagesBounded;
  enactment: FrameSupportScheduleDispatchTime;
  submitted: number;
  submissionDeposit: PalletReferendaDeposit;
  decisionDeposit?: PalletReferendaDeposit | undefined;
  deciding?: PalletReferendaDecidingStatus | undefined;
  tally: PalletConvictionVotingTally;
  inQueue: boolean;
  alarm?: [number, [number, number]] | undefined;
};

export type PalletReferendaDeposit = { who: AccountId32; amount: bigint };

export type PalletReferendaDecidingStatus = { since: number; confirming?: number | undefined };

export type PalletReferendaTrackInfo = {
  name: string;
  maxDeciding: number;
  decisionDeposit: bigint;
  preparePeriod: number;
  decisionPeriod: number;
  confirmPeriod: number;
  minEnactmentPeriod: number;
  minApproval: PalletReferendaCurve;
  minSupport: PalletReferendaCurve;
};

export type PalletReferendaCurve =
  | { tag: 'LinearDecreasing'; value: { length: Perbill; floor: Perbill; ceil: Perbill } }
  | { tag: 'SteppedDecreasing'; value: { begin: Perbill; end: Perbill; step: Perbill; period: Perbill } }
  | { tag: 'Reciprocal'; value: { factor: FixedI64; xOffset: FixedI64; yOffset: FixedI64 } };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletReferendaError =
  /**
   * Referendum is not ongoing.
   **/
  | 'NotOngoing'
  /**
   * Referendum's decision deposit is already paid.
   **/
  | 'HasDeposit'
  /**
   * The track identifier given was invalid.
   **/
  | 'BadTrack'
  /**
   * There are already a full complement of referenda in progress for this track.
   **/
  | 'Full'
  /**
   * The queue of the track is empty.
   **/
  | 'QueueEmpty'
  /**
   * The referendum index provided is invalid in this context.
   **/
  | 'BadReferendum'
  /**
   * There was nothing to do in the advancement.
   **/
  | 'NothingToDo'
  /**
   * No track exists for the proposal origin.
   **/
  | 'NoTrack'
  /**
   * Any deposit cannot be refunded until after the decision is over.
   **/
  | 'Unfinished'
  /**
   * The deposit refunder is not the depositor.
   **/
  | 'NoPermission'
  /**
   * The deposit cannot be refunded since none was made.
   **/
  | 'NoDeposit'
  /**
   * The referendum status is invalid for this operation.
   **/
  | 'BadStatus'
  /**
   * The preimage does not exist.
   **/
  | 'PreimageNotExist';

export type PalletRankedCollectiveMemberRecord = { rank: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletRankedCollectiveError =
  /**
   * Account is already a member.
   **/
  | 'AlreadyMember'
  /**
   * Account is not a member.
   **/
  | 'NotMember'
  /**
   * The given poll index is unknown or has closed.
   **/
  | 'NotPolling'
  /**
   * The given poll is still ongoing.
   **/
  | 'Ongoing'
  /**
   * There are no further records to be removed.
   **/
  | 'NoneRemaining'
  /**
   * Unexpected error in state.
   **/
  | 'Corruption'
  /**
   * The member's rank is too low to vote.
   **/
  | 'RankTooLow'
  /**
   * The information provided is incorrect.
   **/
  | 'InvalidWitness'
  /**
   * The origin is not sufficiently privileged to do the operation.
   **/
  | 'NoPermission'
  /**
   * The new member to exchange is the same as the old member
   **/
  | 'SameMember';

export type PalletReferendaReferendumInfoTally =
  | { tag: 'Ongoing'; value: PalletReferendaReferendumStatusTally }
  | { tag: 'Approved'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { tag: 'Rejected'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { tag: 'Cancelled'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { tag: 'TimedOut'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { tag: 'Killed'; value: number };

export type PalletReferendaReferendumStatusTally = {
  track: number;
  origin: RococoRuntimeOriginCaller;
  proposal: FrameSupportPreimagesBounded;
  enactment: FrameSupportScheduleDispatchTime;
  submitted: number;
  submissionDeposit: PalletReferendaDeposit;
  decisionDeposit?: PalletReferendaDeposit | undefined;
  deciding?: PalletReferendaDecidingStatus | undefined;
  tally: PalletRankedCollectiveTally;
  inQueue: boolean;
  alarm?: [number, [number, number]] | undefined;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletWhitelistError =
  /**
   * The preimage of the call hash could not be loaded.
   **/
  | 'UnavailablePreImage'
  /**
   * The call could not be decoded.
   **/
  | 'UndecodableCall'
  /**
   * The weight of the decoded call was higher than the witness.
   **/
  | 'InvalidCallWeightWitness'
  /**
   * The call was not whitelisted.
   **/
  | 'CallIsNotWhitelisted'
  /**
   * The call was already whitelisted; No-Op.
   **/
  | 'CallAlreadyWhitelisted';

/**
 * The `Error` enum of this pallet.
 **/
export type PolkadotRuntimeCommonClaimsPalletError =
  /**
   * Invalid Ethereum signature.
   **/
  | 'InvalidEthereumSignature'
  /**
   * Ethereum address has no claim.
   **/
  | 'SignerHasNoClaim'
  /**
   * Account ID sending transaction has no claim.
   **/
  | 'SenderHasNoClaim'
  /**
   * There's not enough in the pot to pay out some unvested amount. Generally implies a
   * logic error.
   **/
  | 'PotUnderflow'
  /**
   * A needed statement was not included.
   **/
  | 'InvalidStatement'
  /**
   * The account already has a vested balance.
   **/
  | 'VestedBalanceExists';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletUtilityError =
  /**
   * Too many calls batched.
   **/
  'TooManyCalls';

export type PalletIdentityRegistration = {
  judgements: Array<[number, PalletIdentityJudgement]>;
  deposit: bigint;
  info: PalletIdentityLegacyIdentityInfo;
};

export type PalletIdentityRegistrarInfo = { account: AccountId32; fee: bigint; fields: bigint };

export type PalletIdentityAuthorityProperties = { suffix: Bytes; allocation: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletIdentityError =
  /**
   * Too many subs-accounts.
   **/
  | 'TooManySubAccounts'
  /**
   * Account isn't found.
   **/
  | 'NotFound'
  /**
   * Account isn't named.
   **/
  | 'NotNamed'
  /**
   * Empty index.
   **/
  | 'EmptyIndex'
  /**
   * Fee is changed.
   **/
  | 'FeeChanged'
  /**
   * No identity found.
   **/
  | 'NoIdentity'
  /**
   * Sticky judgement.
   **/
  | 'StickyJudgement'
  /**
   * Judgement given.
   **/
  | 'JudgementGiven'
  /**
   * Invalid judgement.
   **/
  | 'InvalidJudgement'
  /**
   * The index is invalid.
   **/
  | 'InvalidIndex'
  /**
   * The target is invalid.
   **/
  | 'InvalidTarget'
  /**
   * Maximum amount of registrars reached. Cannot add any more.
   **/
  | 'TooManyRegistrars'
  /**
   * Account ID is already named.
   **/
  | 'AlreadyClaimed'
  /**
   * Sender is not a sub-account.
   **/
  | 'NotSub'
  /**
   * Sub-account isn't owned by sender.
   **/
  | 'NotOwned'
  /**
   * The provided judgement was for a different identity.
   **/
  | 'JudgementForDifferentIdentity'
  /**
   * Error that occurs when there is an issue paying for judgement.
   **/
  | 'JudgementPaymentFailed'
  /**
   * The provided suffix is too long.
   **/
  | 'InvalidSuffix'
  /**
   * The sender does not have permission to issue a username.
   **/
  | 'NotUsernameAuthority'
  /**
   * The authority cannot allocate any more usernames.
   **/
  | 'NoAllocation'
  /**
   * The signature on a username was not valid.
   **/
  | 'InvalidSignature'
  /**
   * Setting this username requires a signature, but none was provided.
   **/
  | 'RequiresSignature'
  /**
   * The username does not meet the requirements.
   **/
  | 'InvalidUsername'
  /**
   * The username is already taken.
   **/
  | 'UsernameTaken'
  /**
   * The requested username does not exist.
   **/
  | 'NoUsername'
  /**
   * The username cannot be forcefully removed because it can still be accepted.
   **/
  | 'NotExpired';

export type PalletSocietyMemberRecord = {
  rank: number;
  strikes: number;
  vouching?: PalletSocietyVouchingStatus | undefined;
  index: number;
};

export type PalletSocietyVouchingStatus = 'Vouching' | 'Banned';

export type PalletSocietyPayoutRecord = { paid: bigint; payouts: Array<[number, bigint]> };

export type PalletSocietyBid = { who: AccountId32; kind: PalletSocietyBidKind; value: bigint };

export type PalletSocietyBidKind = { tag: 'Deposit'; value: bigint } | { tag: 'Vouch'; value: [AccountId32, bigint] };

export type PalletSocietyCandidacy = {
  round: number;
  kind: PalletSocietyBidKind;
  bid: bigint;
  tally: PalletSocietyTally;
  skepticStruck: boolean;
};

export type PalletSocietyTally = { approvals: number; rejections: number };

export type PalletSocietyVote = { approve: boolean; weight: number };

export type PalletSocietyIntakeRecord = { who: AccountId32; bid: bigint; round: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletSocietyError =
  /**
   * User is not a member.
   **/
  | 'NotMember'
  /**
   * User is already a member.
   **/
  | 'AlreadyMember'
  /**
   * User is suspended.
   **/
  | 'Suspended'
  /**
   * User is not suspended.
   **/
  | 'NotSuspended'
  /**
   * Nothing to payout.
   **/
  | 'NoPayout'
  /**
   * Society already founded.
   **/
  | 'AlreadyFounded'
  /**
   * Not enough in pot to accept candidate.
   **/
  | 'InsufficientPot'
  /**
   * Member is already vouching or banned from vouching again.
   **/
  | 'AlreadyVouching'
  /**
   * Member is not vouching.
   **/
  | 'NotVouchingOnBidder'
  /**
   * Cannot remove the head of the chain.
   **/
  | 'Head'
  /**
   * Cannot remove the founder.
   **/
  | 'Founder'
  /**
   * User has already made a bid.
   **/
  | 'AlreadyBid'
  /**
   * User is already a candidate.
   **/
  | 'AlreadyCandidate'
  /**
   * User is not a candidate.
   **/
  | 'NotCandidate'
  /**
   * Too many members in the society.
   **/
  | 'MaxMembers'
  /**
   * The caller is not the founder.
   **/
  | 'NotFounder'
  /**
   * The caller is not the head.
   **/
  | 'NotHead'
  /**
   * The membership cannot be claimed as the candidate was not clearly approved.
   **/
  | 'NotApproved'
  /**
   * The candidate cannot be kicked as the candidate was not clearly rejected.
   **/
  | 'NotRejected'
  /**
   * The candidacy cannot be dropped as the candidate was clearly approved.
   **/
  | 'Approved'
  /**
   * The candidacy cannot be bestowed as the candidate was clearly rejected.
   **/
  | 'Rejected'
  /**
   * The candidacy cannot be concluded as the voting is still in progress.
   **/
  | 'InProgress'
  /**
   * The candidacy cannot be pruned until a full additional intake period has passed.
   **/
  | 'TooEarly'
  /**
   * The skeptic already voted.
   **/
  | 'Voted'
  /**
   * The skeptic need not vote on candidates from expired rounds.
   **/
  | 'Expired'
  /**
   * User is not a bidder.
   **/
  | 'NotBidder'
  /**
   * There is no defender currently.
   **/
  | 'NoDefender'
  /**
   * Group doesn't exist.
   **/
  | 'NotGroup'
  /**
   * The member is already elevated to this rank.
   **/
  | 'AlreadyElevated'
  /**
   * The skeptic has already been punished for this offence.
   **/
  | 'AlreadyPunished'
  /**
   * Funds are insufficient to pay off society debts.
   **/
  | 'InsufficientFunds'
  /**
   * The candidate/defender has no stale votes to remove.
   **/
  | 'NoVotes';

export type PalletRecoveryRecoveryConfig = {
  delayPeriod: number;
  deposit: bigint;
  friends: Array<AccountId32>;
  threshold: number;
};

export type PalletRecoveryActiveRecovery = { created: number; deposit: bigint; friends: Array<AccountId32> };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletRecoveryError =
  /**
   * User is not allowed to make a call on behalf of this account
   **/
  | 'NotAllowed'
  /**
   * Threshold must be greater than zero
   **/
  | 'ZeroThreshold'
  /**
   * Friends list must be greater than zero and threshold
   **/
  | 'NotEnoughFriends'
  /**
   * Friends list must be less than max friends
   **/
  | 'MaxFriends'
  /**
   * Friends list must be sorted and free of duplicates
   **/
  | 'NotSorted'
  /**
   * This account is not set up for recovery
   **/
  | 'NotRecoverable'
  /**
   * This account is already set up for recovery
   **/
  | 'AlreadyRecoverable'
  /**
   * A recovery process has already started for this account
   **/
  | 'AlreadyStarted'
  /**
   * A recovery process has not started for this rescuer
   **/
  | 'NotStarted'
  /**
   * This account is not a friend who can vouch
   **/
  | 'NotFriend'
  /**
   * The friend must wait until the delay period to vouch for this recovery
   **/
  | 'DelayPeriod'
  /**
   * This user has already vouched for this recovery
   **/
  | 'AlreadyVouched'
  /**
   * The threshold for recovering this account has not been met
   **/
  | 'Threshold'
  /**
   * There are still active recovery attempts that need to be closed
   **/
  | 'StillActive'
  /**
   * This account is already set up for recovery
   **/
  | 'AlreadyProxy'
  /**
   * Some internal state is broken.
   **/
  | 'BadState';

export type PalletVestingReleases = 'V0' | 'V1';

/**
 * Error for the vesting pallet.
 **/
export type PalletVestingError =
  /**
   * The account given is not vesting.
   **/
  | 'NotVesting'
  /**
   * The account already has `MaxVestingSchedules` count of schedules and thus
   * cannot add another one. Consider merging existing schedules in order to add another.
   **/
  | 'AtMaxVestingSchedules'
  /**
   * Amount being transferred is too low to create a vesting schedule.
   **/
  | 'AmountLow'
  /**
   * An index was out of bounds of the vesting schedules.
   **/
  | 'ScheduleIndexOutOfBounds'
  /**
   * Failed to create a new schedule because some parameter was invalid.
   **/
  | 'InvalidScheduleParams';

export type PalletSchedulerScheduled = {
  maybeId?: FixedBytes<32> | undefined;
  priority: number;
  call: FrameSupportPreimagesBounded;
  maybePeriodic?: [number, number] | undefined;
  origin: RococoRuntimeOriginCaller;
};

export type PalletSchedulerRetryConfig = { totalRetries: number; remaining: number; period: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletSchedulerError =
  /**
   * Failed to schedule a call
   **/
  | 'FailedToSchedule'
  /**
   * Cannot find the scheduled call.
   **/
  | 'NotFound'
  /**
   * Given target block number is in the past.
   **/
  | 'TargetBlockNumberInPast'
  /**
   * Reschedule failed because it does not change scheduled time.
   **/
  | 'RescheduleNoChange'
  /**
   * Attempt to use a non-named function on a named task.
   **/
  | 'Named';

export type PalletProxyProxyDefinition = { delegate: AccountId32; proxyType: RococoRuntimeProxyType; delay: number };

export type PalletProxyAnnouncement = { real: AccountId32; callHash: H256; height: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletProxyError =
  /**
   * There are too many proxies registered or too many announcements pending.
   **/
  | 'TooMany'
  /**
   * Proxy registration not found.
   **/
  | 'NotFound'
  /**
   * Sender is not a proxy of the account to be proxied.
   **/
  | 'NotProxy'
  /**
   * A call which is incompatible with the proxy type's filter was attempted.
   **/
  | 'Unproxyable'
  /**
   * Account is already a proxy.
   **/
  | 'Duplicate'
  /**
   * Call may not be made by proxy because it may escalate its privileges.
   **/
  | 'NoPermission'
  /**
   * Announcement, if made at all, was made too recently.
   **/
  | 'Unannounced'
  /**
   * Cannot add self as proxy.
   **/
  | 'NoSelfProxy';

export type PalletMultisigMultisig = {
  when: PalletMultisigTimepoint;
  deposit: bigint;
  depositor: AccountId32;
  approvals: Array<AccountId32>;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletMultisigError =
  /**
   * Threshold must be 2 or greater.
   **/
  | 'MinimumThreshold'
  /**
   * Call is already approved by this signatory.
   **/
  | 'AlreadyApproved'
  /**
   * Call doesn't need any (more) approvals.
   **/
  | 'NoApprovalsNeeded'
  /**
   * There are too few signatories in the list.
   **/
  | 'TooFewSignatories'
  /**
   * There are too many signatories in the list.
   **/
  | 'TooManySignatories'
  /**
   * The signatories were provided out of order; they should be ordered.
   **/
  | 'SignatoriesOutOfOrder'
  /**
   * The sender was contained in the other signatories; it shouldn't be.
   **/
  | 'SenderInSignatories'
  /**
   * Multisig operation not found when attempting to cancel.
   **/
  | 'NotFound'
  /**
   * Only the account that originally created the multisig is able to cancel it.
   **/
  | 'NotOwner'
  /**
   * No timepoint was given, yet the multisig operation is already underway.
   **/
  | 'NoTimepoint'
  /**
   * A different timepoint was given to the multisig operation that is underway.
   **/
  | 'WrongTimepoint'
  /**
   * A timepoint was given, yet no multisig operation is underway.
   **/
  | 'UnexpectedTimepoint'
  /**
   * The maximum weight information provided was too low.
   **/
  | 'MaxWeightTooLow'
  /**
   * The data to be stored is already stored.
   **/
  | 'AlreadyStored';

export type PalletPreimageOldRequestStatus =
  | { tag: 'Unrequested'; value: { deposit: [AccountId32, bigint]; len: number } }
  | {
      tag: 'Requested';
      value: { deposit?: [AccountId32, bigint] | undefined; count: number; len?: number | undefined };
    };

export type PalletPreimageRequestStatus =
  | { tag: 'Unrequested'; value: { ticket: [AccountId32, FrameSupportTokensFungibleHoldConsideration]; len: number } }
  | {
      tag: 'Requested';
      value: {
        maybeTicket?: [AccountId32, FrameSupportTokensFungibleHoldConsideration] | undefined;
        count: number;
        maybeLen?: number | undefined;
      };
    };

export type FrameSupportTokensFungibleHoldConsideration = bigint;

/**
 * The `Error` enum of this pallet.
 **/
export type PalletPreimageError =
  /**
   * Preimage is too large to store on-chain.
   **/
  | 'TooBig'
  /**
   * Preimage has already been noted on-chain.
   **/
  | 'AlreadyNoted'
  /**
   * The user is not authorized to perform this action.
   **/
  | 'NotAuthorized'
  /**
   * The preimage cannot be removed since it has not yet been noted.
   **/
  | 'NotNoted'
  /**
   * A preimage may not be removed when there are outstanding requests.
   **/
  | 'Requested'
  /**
   * The preimage request cannot be removed since no outstanding requests exist.
   **/
  | 'NotRequested'
  /**
   * More than `MAX_HASH_UPGRADE_BULK_COUNT` hashes were requested to be upgraded at once.
   **/
  | 'TooMany'
  /**
   * Too few hashes were requested to be upgraded (i.e. zero).
   **/
  | 'TooFew';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletAssetRateError =
  /**
   * The given asset ID is unknown.
   **/
  | 'UnknownAssetKind'
  /**
   * The given asset ID already has an assigned conversion rate and cannot be re-created.
   **/
  | 'AlreadyExists'
  /**
   * Overflow ocurred when calculating the inverse rate.
   **/
  | 'Overflow';

export type PalletBountiesBounty = {
  proposer: AccountId32;
  value: bigint;
  fee: bigint;
  curatorDeposit: bigint;
  bond: bigint;
  status: PalletBountiesBountyStatus;
};

export type PalletBountiesBountyStatus =
  | { tag: 'Proposed' }
  | { tag: 'Approved' }
  | { tag: 'Funded' }
  | { tag: 'CuratorProposed'; value: { curator: AccountId32 } }
  | { tag: 'Active'; value: { curator: AccountId32; updateDue: number } }
  | { tag: 'PendingPayout'; value: { curator: AccountId32; beneficiary: AccountId32; unlockAt: number } };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBountiesError =
  /**
   * Proposer's balance is too low.
   **/
  | 'InsufficientProposersBalance'
  /**
   * No proposal or bounty at that index.
   **/
  | 'InvalidIndex'
  /**
   * The reason given is just too big.
   **/
  | 'ReasonTooBig'
  /**
   * The bounty status is unexpected.
   **/
  | 'UnexpectedStatus'
  /**
   * Require bounty curator.
   **/
  | 'RequireCurator'
  /**
   * Invalid bounty value.
   **/
  | 'InvalidValue'
  /**
   * Invalid bounty fee.
   **/
  | 'InvalidFee'
  /**
   * A bounty payout is pending.
   * To cancel the bounty, you must unassign and slash the curator.
   **/
  | 'PendingPayout'
  /**
   * The bounties cannot be claimed/closed because it's still in the countdown period.
   **/
  | 'Premature'
  /**
   * The bounty cannot be closed because it has active child bounties.
   **/
  | 'HasActiveChildBounty'
  /**
   * Too many approvals are already queued.
   **/
  | 'TooManyQueued';

export type PalletChildBountiesChildBounty = {
  parentBounty: number;
  value: bigint;
  fee: bigint;
  curatorDeposit: bigint;
  status: PalletChildBountiesChildBountyStatus;
};

export type PalletChildBountiesChildBountyStatus =
  | { tag: 'Added' }
  | { tag: 'CuratorProposed'; value: { curator: AccountId32 } }
  | { tag: 'Active'; value: { curator: AccountId32 } }
  | { tag: 'PendingPayout'; value: { curator: AccountId32; beneficiary: AccountId32; unlockAt: number } };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletChildBountiesError =
  /**
   * The parent bounty is not in active state.
   **/
  | 'ParentBountyNotActive'
  /**
   * The bounty balance is not enough to add new child-bounty.
   **/
  | 'InsufficientBountyBalance'
  /**
   * Number of child bounties exceeds limit `MaxActiveChildBountyCount`.
   **/
  | 'TooManyChildBounties';

export type PalletNisBid = { amount: bigint; who: AccountId32 };

export type PalletNisSummaryRecord = {
  proportionOwed: Perquintill;
  index: number;
  thawed: Perquintill;
  lastPeriod: number;
  receiptsOnHold: bigint;
};

export type PalletNisReceiptRecord = {
  proportion: Perquintill;
  owner?: [AccountId32, bigint] | undefined;
  expiry: number;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletNisError =
  /**
   * The duration of the bid is less than one.
   **/
  | 'DurationTooSmall'
  /**
   * The duration is the bid is greater than the number of queues.
   **/
  | 'DurationTooBig'
  /**
   * The amount of the bid is less than the minimum allowed.
   **/
  | 'AmountTooSmall'
  /**
   * The queue for the bid's duration is full and the amount bid is too low to get in
   * through replacing an existing bid.
   **/
  | 'BidTooLow'
  /**
   * Receipt index is unknown.
   **/
  | 'UnknownReceipt'
  /**
   * Not the owner of the receipt.
   **/
  | 'NotOwner'
  /**
   * Bond not yet at expiry date.
   **/
  | 'NotExpired'
  /**
   * The given bid for retraction is not found.
   **/
  | 'UnknownBid'
  /**
   * The portion supplied is beyond the value of the receipt.
   **/
  | 'PortionTooBig'
  /**
   * Not enough funds are held to pay out.
   **/
  | 'Unfunded'
  /**
   * There are enough funds for what is required.
   **/
  | 'AlreadyFunded'
  /**
   * The thaw throttle has been reached for this period.
   **/
  | 'Throttled'
  /**
   * The operation would result in a receipt worth an insignficant value.
   **/
  | 'MakesDust'
  /**
   * The receipt is already communal.
   **/
  | 'AlreadyCommunal'
  /**
   * The receipt is already private.
   **/
  | 'AlreadyPrivate';

export type PolkadotRuntimeParachainsConfigurationHostConfiguration = {
  maxCodeSize: number;
  maxHeadDataSize: number;
  maxUpwardQueueCount: number;
  maxUpwardQueueSize: number;
  maxUpwardMessageSize: number;
  maxUpwardMessageNumPerCandidate: number;
  hrmpMaxMessageNumPerCandidate: number;
  validationUpgradeCooldown: number;
  validationUpgradeDelay: number;
  asyncBackingParams: PolkadotPrimitivesV6AsyncBackingAsyncBackingParams;
  maxPovSize: number;
  maxDownwardMessageSize: number;
  hrmpMaxParachainOutboundChannels: number;
  hrmpSenderDeposit: bigint;
  hrmpRecipientDeposit: bigint;
  hrmpChannelMaxCapacity: number;
  hrmpChannelMaxTotalSize: number;
  hrmpMaxParachainInboundChannels: number;
  hrmpChannelMaxMessageSize: number;
  executorParams: PolkadotPrimitivesV6ExecutorParams;
  codeRetentionPeriod: number;
  maxValidators?: number | undefined;
  disputePeriod: number;
  disputePostConclusionAcceptancePeriod: number;
  noShowSlots: number;
  nDelayTranches: number;
  zerothDelayTrancheWidth: number;
  neededApprovals: number;
  relayVrfModuloSamples: number;
  pvfVotingTtl: number;
  minimumValidationUpgradeDelay: number;
  minimumBackingVotes: number;
  nodeFeatures: BitSequence;
  approvalVotingParams: PolkadotPrimitivesVstagingApprovalVotingParams;
  schedulerParams: PolkadotPrimitivesVstagingSchedulerParams;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PolkadotRuntimeParachainsConfigurationPalletError =
  /**
   * The new value for a configuration parameter is invalid.
   **/
  'InvalidNewValue';

export type PolkadotRuntimeParachainsSharedAllowedRelayParentsTracker = {
  buffer: Array<[H256, H256]>;
  latestNumber: number;
};

export type PolkadotRuntimeParachainsInclusionAvailabilityBitfieldRecord = {
  bitfield: PolkadotPrimitivesV6AvailabilityBitfield;
  submittedAt: number;
};

export type PolkadotRuntimeParachainsInclusionCandidatePendingAvailability = {
  core: PolkadotPrimitivesV6CoreIndex;
  hash: PolkadotCorePrimitivesCandidateHash;
  descriptor: PolkadotPrimitivesV6CandidateDescriptor;
  availabilityVotes: BitSequence;
  backers: BitSequence;
  relayParentNumber: number;
  backedInNumber: number;
  backingGroup: PolkadotPrimitivesV6GroupIndex;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PolkadotRuntimeParachainsInclusionPalletError =
  /**
   * Validator indices are out of order or contains duplicates.
   **/
  | 'UnsortedOrDuplicateValidatorIndices'
  /**
   * Dispute statement sets are out of order or contain duplicates.
   **/
  | 'UnsortedOrDuplicateDisputeStatementSet'
  /**
   * Backed candidates are out of order (core index) or contain duplicates.
   **/
  | 'UnsortedOrDuplicateBackedCandidates'
  /**
   * A different relay parent was provided compared to the on-chain stored one.
   **/
  | 'UnexpectedRelayParent'
  /**
   * Availability bitfield has unexpected size.
   **/
  | 'WrongBitfieldSize'
  /**
   * Bitfield consists of zeros only.
   **/
  | 'BitfieldAllZeros'
  /**
   * Multiple bitfields submitted by same validator or validators out of order by index.
   **/
  | 'BitfieldDuplicateOrUnordered'
  /**
   * Validator index out of bounds.
   **/
  | 'ValidatorIndexOutOfBounds'
  /**
   * Invalid signature
   **/
  | 'InvalidBitfieldSignature'
  /**
   * Candidate submitted but para not scheduled.
   **/
  | 'UnscheduledCandidate'
  /**
   * Candidate scheduled despite pending candidate already existing for the para.
   **/
  | 'CandidateScheduledBeforeParaFree'
  /**
   * Scheduled cores out of order.
   **/
  | 'ScheduledOutOfOrder'
  /**
   * Head data exceeds the configured maximum.
   **/
  | 'HeadDataTooLarge'
  /**
   * Code upgrade prematurely.
   **/
  | 'PrematureCodeUpgrade'
  /**
   * Output code is too large
   **/
  | 'NewCodeTooLarge'
  /**
   * The candidate's relay-parent was not allowed. Either it was
   * not recent enough or it didn't advance based on the last parachain block.
   **/
  | 'DisallowedRelayParent'
  /**
   * Failed to compute group index for the core: either it's out of bounds
   * or the relay parent doesn't belong to the current session.
   **/
  | 'InvalidAssignment'
  /**
   * Invalid group index in core assignment.
   **/
  | 'InvalidGroupIndex'
  /**
   * Insufficient (non-majority) backing.
   **/
  | 'InsufficientBacking'
  /**
   * Invalid (bad signature, unknown validator, etc.) backing.
   **/
  | 'InvalidBacking'
  /**
   * Collator did not sign PoV.
   **/
  | 'NotCollatorSigned'
  /**
   * The validation data hash does not match expected.
   **/
  | 'ValidationDataHashMismatch'
  /**
   * The downward message queue is not processed correctly.
   **/
  | 'IncorrectDownwardMessageHandling'
  /**
   * At least one upward message sent does not pass the acceptance criteria.
   **/
  | 'InvalidUpwardMessages'
  /**
   * The candidate didn't follow the rules of HRMP watermark advancement.
   **/
  | 'HrmpWatermarkMishandling'
  /**
   * The HRMP messages sent by the candidate is not valid.
   **/
  | 'InvalidOutboundHrmp'
  /**
   * The validation code hash of the candidate is not valid.
   **/
  | 'InvalidValidationCodeHash'
  /**
   * The `para_head` hash in the candidate descriptor doesn't match the hash of the actual
   * para head in the commitments.
   **/
  | 'ParaHeadMismatch'
  /**
   * A bitfield that references a freed core,
   * either intentionally or as part of a concluded
   * invalid dispute.
   **/
  | 'BitfieldReferencesFreedCore';

export type PolkadotPrimitivesV6ScrapedOnChainVotes = {
  session: number;
  backingValidatorsPerCandidate: Array<
    [
      PolkadotPrimitivesV6CandidateReceipt,
      Array<[PolkadotPrimitivesV6ValidatorIndex, PolkadotPrimitivesV6ValidityAttestation]>,
    ]
  >;
  disputes: Array<PolkadotPrimitivesV6DisputeStatementSet>;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PolkadotRuntimeParachainsParasInherentPalletError =
  /**
   * Inclusion inherent called more than once per block.
   **/
  | 'TooManyInclusionInherents'
  /**
   * The hash of the submitted parent header doesn't correspond to the saved block hash of
   * the parent.
   **/
  | 'InvalidParentHeader'
  /**
   * Disputed candidate that was concluded invalid.
   **/
  | 'CandidateConcludedInvalid'
  /**
   * The data given to the inherent will result in an overweight block.
   **/
  | 'InherentOverweight'
  /**
   * The ordering of dispute statements was invalid.
   **/
  | 'DisputeStatementsUnsortedOrDuplicates'
  /**
   * A dispute statement was invalid.
   **/
  | 'DisputeInvalid'
  /**
   * A candidate was backed by a disabled validator
   **/
  | 'BackedByDisabled'
  /**
   * A candidate was backed even though the paraid was not scheduled.
   **/
  | 'BackedOnUnscheduledCore'
  /**
   * Too many candidates supplied.
   **/
  | 'UnscheduledCandidate';

export type PolkadotRuntimeParachainsSchedulerPalletCoreOccupied =
  | { tag: 'Free' }
  | { tag: 'Paras'; value: PolkadotRuntimeParachainsSchedulerPalletParasEntry };

export type PolkadotRuntimeParachainsSchedulerPalletParasEntry = {
  assignment: PolkadotRuntimeParachainsSchedulerCommonAssignment;
  availabilityTimeouts: number;
  ttl: number;
};

export type PolkadotRuntimeParachainsSchedulerCommonAssignment =
  | {
      tag: 'Pool';
      value: { paraId: PolkadotParachainPrimitivesPrimitivesId; coreIndex: PolkadotPrimitivesV6CoreIndex };
    }
  | { tag: 'Bulk'; value: PolkadotParachainPrimitivesPrimitivesId };

export type PolkadotRuntimeParachainsParasPvfCheckActiveVoteState = {
  votesAccept: BitSequence;
  votesReject: BitSequence;
  age: number;
  createdAt: number;
  causes: Array<PolkadotRuntimeParachainsParasPvfCheckCause>;
};

export type PolkadotRuntimeParachainsParasPvfCheckCause =
  | { tag: 'Onboarding'; value: PolkadotParachainPrimitivesPrimitivesId }
  | {
      tag: 'Upgrade';
      value: {
        id: PolkadotParachainPrimitivesPrimitivesId;
        includedAt: number;
        setGoAhead: PolkadotRuntimeParachainsParasSetGoAhead;
      };
    };

export type PolkadotRuntimeParachainsParasSetGoAhead = 'Yes' | 'No';

export type PolkadotRuntimeParachainsParasParaLifecycle =
  | 'Onboarding'
  | 'Parathread'
  | 'Parachain'
  | 'UpgradingParathread'
  | 'DowngradingParachain'
  | 'OffboardingParathread'
  | 'OffboardingParachain';

export type PolkadotRuntimeParachainsParasParaPastCodeMeta = {
  upgradeTimes: Array<PolkadotRuntimeParachainsParasReplacementTimes>;
  lastPruned?: number | undefined;
};

export type PolkadotRuntimeParachainsParasReplacementTimes = { expectedAt: number; activatedAt: number };

export type PolkadotPrimitivesV6UpgradeGoAhead = 'Abort' | 'GoAhead';

export type PolkadotPrimitivesV6UpgradeRestriction = 'Present';

/**
 * The `Error` enum of this pallet.
 **/
export type PolkadotRuntimeParachainsParasPalletError =
  /**
   * Para is not registered in our system.
   **/
  | 'NotRegistered'
  /**
   * Para cannot be onboarded because it is already tracked by our system.
   **/
  | 'CannotOnboard'
  /**
   * Para cannot be offboarded at this time.
   **/
  | 'CannotOffboard'
  /**
   * Para cannot be upgraded to a lease holding parachain.
   **/
  | 'CannotUpgrade'
  /**
   * Para cannot be downgraded to an on-demand parachain.
   **/
  | 'CannotDowngrade'
  /**
   * The statement for PVF pre-checking is stale.
   **/
  | 'PvfCheckStatementStale'
  /**
   * The statement for PVF pre-checking is for a future session.
   **/
  | 'PvfCheckStatementFuture'
  /**
   * Claimed validator index is out of bounds.
   **/
  | 'PvfCheckValidatorIndexOutOfBounds'
  /**
   * The signature for the PVF pre-checking is invalid.
   **/
  | 'PvfCheckInvalidSignature'
  /**
   * The given validator already has cast a vote.
   **/
  | 'PvfCheckDoubleVote'
  /**
   * The given PVF does not exist at the moment of process a vote.
   **/
  | 'PvfCheckSubjectInvalid'
  /**
   * Parachain cannot currently schedule a code upgrade.
   **/
  | 'CannotUpgradeCode'
  /**
   * Invalid validation code size.
   **/
  | 'InvalidCode';

export type PolkadotRuntimeParachainsInitializerBufferedSessionChange = {
  validators: Array<PolkadotPrimitivesV6ValidatorAppPublic>;
  queued: Array<PolkadotPrimitivesV6ValidatorAppPublic>;
  sessionIndex: number;
};

export type PolkadotCorePrimitivesInboundDownwardMessage = { sentAt: number; msg: Bytes };

export type PolkadotRuntimeParachainsHrmpHrmpOpenChannelRequest = {
  confirmed: boolean;
  age: number;
  senderDeposit: bigint;
  maxMessageSize: number;
  maxCapacity: number;
  maxTotalSize: number;
};

export type PolkadotRuntimeParachainsHrmpHrmpChannel = {
  maxCapacity: number;
  maxTotalSize: number;
  maxMessageSize: number;
  msgCount: number;
  totalSize: number;
  mqcHead?: H256 | undefined;
  senderDeposit: bigint;
  recipientDeposit: bigint;
};

export type PolkadotCorePrimitivesInboundHrmpMessage = { sentAt: number; data: Bytes };

/**
 * The `Error` enum of this pallet.
 **/
export type PolkadotRuntimeParachainsHrmpPalletError =
  /**
   * The sender tried to open a channel to themselves.
   **/
  | 'OpenHrmpChannelToSelf'
  /**
   * The recipient is not a valid para.
   **/
  | 'OpenHrmpChannelInvalidRecipient'
  /**
   * The requested capacity is zero.
   **/
  | 'OpenHrmpChannelZeroCapacity'
  /**
   * The requested capacity exceeds the global limit.
   **/
  | 'OpenHrmpChannelCapacityExceedsLimit'
  /**
   * The requested maximum message size is 0.
   **/
  | 'OpenHrmpChannelZeroMessageSize'
  /**
   * The open request requested the message size that exceeds the global limit.
   **/
  | 'OpenHrmpChannelMessageSizeExceedsLimit'
  /**
   * The channel already exists
   **/
  | 'OpenHrmpChannelAlreadyExists'
  /**
   * There is already a request to open the same channel.
   **/
  | 'OpenHrmpChannelAlreadyRequested'
  /**
   * The sender already has the maximum number of allowed outbound channels.
   **/
  | 'OpenHrmpChannelLimitExceeded'
  /**
   * The channel from the sender to the origin doesn't exist.
   **/
  | 'AcceptHrmpChannelDoesntExist'
  /**
   * The channel is already confirmed.
   **/
  | 'AcceptHrmpChannelAlreadyConfirmed'
  /**
   * The recipient already has the maximum number of allowed inbound channels.
   **/
  | 'AcceptHrmpChannelLimitExceeded'
  /**
   * The origin tries to close a channel where it is neither the sender nor the recipient.
   **/
  | 'CloseHrmpChannelUnauthorized'
  /**
   * The channel to be closed doesn't exist.
   **/
  | 'CloseHrmpChannelDoesntExist'
  /**
   * The channel close request is already requested.
   **/
  | 'CloseHrmpChannelAlreadyUnderway'
  /**
   * Canceling is requested by neither the sender nor recipient of the open channel request.
   **/
  | 'CancelHrmpOpenChannelUnauthorized'
  /**
   * The open request doesn't exist.
   **/
  | 'OpenHrmpChannelDoesntExist'
  /**
   * Cannot cancel an HRMP open channel request because it is already confirmed.
   **/
  | 'OpenHrmpChannelAlreadyConfirmed'
  /**
   * The provided witness data is wrong.
   **/
  | 'WrongWitness'
  /**
   * The channel between these two chains cannot be authorized.
   **/
  | 'ChannelCreationNotAuthorized';

export type PolkadotPrimitivesV6SessionInfo = {
  activeValidatorIndices: Array<PolkadotPrimitivesV6ValidatorIndex>;
  randomSeed: FixedBytes<32>;
  disputePeriod: number;
  validators: PolkadotPrimitivesV6IndexedVec;
  discoveryKeys: Array<SpAuthorityDiscoveryAppPublic>;
  assignmentKeys: Array<PolkadotPrimitivesV6AssignmentAppPublic>;
  validatorGroups: PolkadotPrimitivesV6IndexedVecGroupIndex;
  nCores: number;
  zerothDelayTrancheWidth: number;
  relayVrfModuloSamples: number;
  nDelayTranches: number;
  noShowSlots: number;
  neededApprovals: number;
};

export type PolkadotPrimitivesV6IndexedVec = Array<PolkadotPrimitivesV6ValidatorAppPublic>;

export type PolkadotPrimitivesV6IndexedVecGroupIndex = Array<Array<PolkadotPrimitivesV6ValidatorIndex>>;

export type PolkadotPrimitivesV6DisputeState = {
  validatorsFor: BitSequence;
  validatorsAgainst: BitSequence;
  start: number;
  concludedAt?: number | undefined;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PolkadotRuntimeParachainsDisputesPalletError =
  /**
   * Duplicate dispute statement sets provided.
   **/
  | 'DuplicateDisputeStatementSets'
  /**
   * Ancient dispute statement provided.
   **/
  | 'AncientDisputeStatement'
  /**
   * Validator index on statement is out of bounds for session.
   **/
  | 'ValidatorIndexOutOfBounds'
  /**
   * Invalid signature on statement.
   **/
  | 'InvalidSignature'
  /**
   * Validator vote submitted more than once to dispute.
   **/
  | 'DuplicateStatement'
  /**
   * A dispute where there are only votes on one side.
   **/
  | 'SingleSidedDispute'
  /**
   * A dispute vote from a malicious backer.
   **/
  | 'MaliciousBacker'
  /**
   * No backing votes were provides along dispute statements.
   **/
  | 'MissingBackingVotes'
  /**
   * Unconfirmed dispute statement sets provided.
   **/
  | 'UnconfirmedDispute';

export type PolkadotPrimitivesV6SlashingPendingSlashes = {
  keys: Array<[PolkadotPrimitivesV6ValidatorIndex, PolkadotPrimitivesV6ValidatorAppPublic]>;
  kind: PolkadotPrimitivesV6SlashingSlashingOffenceKind;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PolkadotRuntimeParachainsDisputesSlashingPalletError =
  /**
   * The key ownership proof is invalid.
   **/
  | 'InvalidKeyOwnershipProof'
  /**
   * The session index is too old or invalid.
   **/
  | 'InvalidSessionIndex'
  /**
   * The candidate hash is invalid.
   **/
  | 'InvalidCandidateHash'
  /**
   * There is no pending slash for the given validator index and time
   * slot.
   **/
  | 'InvalidValidatorIndex'
  /**
   * The validator index does not match the validator id.
   **/
  | 'ValidatorIndexIdMismatch'
  /**
   * The given slashing report is valid but already previously reported.
   **/
  | 'DuplicateSlashingReport';

export type PalletMessageQueueBookState = {
  begin: number;
  end: number;
  count: number;
  readyNeighbours?: PalletMessageQueueNeighbours | undefined;
  messageCount: bigint;
  size: bigint;
};

export type PalletMessageQueueNeighbours = {
  prev: PolkadotRuntimeParachainsInclusionAggregateMessageOrigin;
  next: PolkadotRuntimeParachainsInclusionAggregateMessageOrigin;
};

export type PalletMessageQueuePage = {
  remaining: number;
  remainingSize: number;
  firstIndex: number;
  first: number;
  last: number;
  heap: Bytes;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletMessageQueueError =
  /**
   * Page is not reapable because it has items remaining to be processed and is not old
   * enough.
   **/
  | 'NotReapable'
  /**
   * Page to be reaped does not exist.
   **/
  | 'NoPage'
  /**
   * The referenced message could not be found.
   **/
  | 'NoMessage'
  /**
   * The message was already processed and cannot be processed again.
   **/
  | 'AlreadyProcessed'
  /**
   * The message is queued for future execution.
   **/
  | 'Queued'
  /**
   * There is temporarily not enough weight to continue servicing messages.
   **/
  | 'InsufficientWeight'
  /**
   * This message is temporarily unprocessable.
   *
   * Such errors are expected, but not guaranteed, to resolve themselves eventually through
   * retrying.
   **/
  | 'TemporarilyUnprocessable'
  /**
   * The queue is paused and no message can be executed from it.
   *
   * This can change at any time and may resolve in the future by re-trying.
   **/
  | 'QueuePaused'
  /**
   * Another call is in progress and needs to finish before this call can happen.
   **/
  | 'RecursiveDisallowed';

export type PolkadotRuntimeParachainsAssignerOnDemandEnqueuedOrder = {
  paraId: PolkadotParachainPrimitivesPrimitivesId;
};

export type PolkadotRuntimeParachainsAssignerOnDemandCoreAffinityCount = {
  coreIdx: PolkadotPrimitivesV6CoreIndex;
  count: number;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PolkadotRuntimeParachainsAssignerOnDemandPalletError =
  /**
   * The `ParaId` supplied to the `place_order` call is not a valid `ParaThread`, making the
   * call is invalid.
   **/
  | 'InvalidParaId'
  /**
   * The order queue is full, `place_order` will not continue.
   **/
  | 'QueueFull'
  /**
   * The current spot price is higher than the max amount specified in the `place_order`
   * call, making it invalid.
   **/
  | 'SpotPriceHigherThanMaxAmount';

export type PolkadotRuntimeParachainsAssignerCoretimeSchedule = {
  assignments: Array<
    [PalletBrokerCoretimeInterfaceCoreAssignment, PolkadotRuntimeParachainsAssignerCoretimePartsOf57600]
  >;
  endHint?: number | undefined;
  nextSchedule?: number | undefined;
};

export type PolkadotRuntimeParachainsAssignerCoretimeCoreDescriptor = {
  queue?: PolkadotRuntimeParachainsAssignerCoretimeQueueDescriptor | undefined;
  currentWork?: PolkadotRuntimeParachainsAssignerCoretimeWorkState | undefined;
};

export type PolkadotRuntimeParachainsAssignerCoretimeQueueDescriptor = { first: number; last: number };

export type PolkadotRuntimeParachainsAssignerCoretimeWorkState = {
  assignments: Array<
    [PalletBrokerCoretimeInterfaceCoreAssignment, PolkadotRuntimeParachainsAssignerCoretimeAssignmentState]
  >;
  endHint?: number | undefined;
  pos: number;
  step: PolkadotRuntimeParachainsAssignerCoretimePartsOf57600;
};

export type PolkadotRuntimeParachainsAssignerCoretimeAssignmentState = {
  ratio: PolkadotRuntimeParachainsAssignerCoretimePartsOf57600;
  remaining: PolkadotRuntimeParachainsAssignerCoretimePartsOf57600;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PolkadotRuntimeParachainsAssignerCoretimePalletError =
  | 'AssignmentsEmpty'
  /**
   * Assignments together exceeded 57600.
   **/
  | 'OverScheduled'
  /**
   * Assignments together less than 57600
   **/
  | 'UnderScheduled'
  /**
   * assign_core is only allowed to append new assignments at the end of already existing
   * ones.
   **/
  | 'DisallowedInsert'
  /**
   * Tried to insert a schedule for the same core and block number as an existing schedule
   **/
  | 'DuplicateInsert'
  /**
   * Tried to add an unsorted set of assignments
   **/
  | 'AssignmentsNotSorted';

export type PolkadotRuntimeCommonParasRegistrarParaInfo = {
  manager: AccountId32;
  deposit: bigint;
  locked?: boolean | undefined;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PolkadotRuntimeCommonParasRegistrarPalletError =
  /**
   * The ID is not registered.
   **/
  | 'NotRegistered'
  /**
   * The ID is already registered.
   **/
  | 'AlreadyRegistered'
  /**
   * The caller is not the owner of this Id.
   **/
  | 'NotOwner'
  /**
   * Invalid para code size.
   **/
  | 'CodeTooLarge'
  /**
   * Invalid para head data size.
   **/
  | 'HeadDataTooLarge'
  /**
   * Para is not a Parachain.
   **/
  | 'NotParachain'
  /**
   * Para is not a Parathread (on-demand parachain).
   **/
  | 'NotParathread'
  /**
   * Cannot deregister para
   **/
  | 'CannotDeregister'
  /**
   * Cannot schedule downgrade of lease holding parachain to on-demand parachain
   **/
  | 'CannotDowngrade'
  /**
   * Cannot schedule upgrade of on-demand parachain to lease holding parachain
   **/
  | 'CannotUpgrade'
  /**
   * Para is locked from manipulation by the manager. Must use parachain or relay chain
   * governance.
   **/
  | 'ParaLocked'
  /**
   * The ID given for registration has not been reserved.
   **/
  | 'NotReserved'
  /**
   * The validation code is invalid.
   **/
  | 'InvalidCode'
  /**
   * Cannot perform a parachain slot / lifecycle swap. Check that the state of both paras
   * are correct for the swap to work.
   **/
  | 'CannotSwap';

/**
 * The `Error` enum of this pallet.
 **/
export type PolkadotRuntimeCommonSlotsPalletError =
  /**
   * The parachain ID is not onboarding.
   **/
  | 'ParaNotOnboarding'
  /**
   * There was an error with the lease.
   **/
  | 'LeaseError';

/**
 * The `Error` enum of this pallet.
 **/
export type PolkadotRuntimeCommonAuctionsPalletError =
  /**
   * This auction is already in progress.
   **/
  | 'AuctionInProgress'
  /**
   * The lease period is in the past.
   **/
  | 'LeasePeriodInPast'
  /**
   * Para is not registered
   **/
  | 'ParaNotRegistered'
  /**
   * Not a current auction.
   **/
  | 'NotCurrentAuction'
  /**
   * Not an auction.
   **/
  | 'NotAuction'
  /**
   * Auction has already ended.
   **/
  | 'AuctionEnded'
  /**
   * The para is already leased out for part of this range.
   **/
  | 'AlreadyLeasedOut';

export type PolkadotRuntimeCommonCrowdloanFundInfo = {
  depositor: AccountId32;
  verifier?: SpRuntimeMultiSigner | undefined;
  deposit: bigint;
  raised: bigint;
  end: number;
  cap: bigint;
  lastContribution: PolkadotRuntimeCommonCrowdloanLastContribution;
  firstPeriod: number;
  lastPeriod: number;
  fundIndex: number;
};

export type PolkadotRuntimeCommonCrowdloanLastContribution =
  | { tag: 'Never' }
  | { tag: 'PreEnding'; value: number }
  | { tag: 'Ending'; value: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PolkadotRuntimeCommonCrowdloanPalletError =
  /**
   * The current lease period is more than the first lease period.
   **/
  | 'FirstPeriodInPast'
  /**
   * The first lease period needs to at least be less than 3 `max_value`.
   **/
  | 'FirstPeriodTooFarInFuture'
  /**
   * Last lease period must be greater than first lease period.
   **/
  | 'LastPeriodBeforeFirstPeriod'
  /**
   * The last lease period cannot be more than 3 periods after the first period.
   **/
  | 'LastPeriodTooFarInFuture'
  /**
   * The campaign ends before the current block number. The end must be in the future.
   **/
  | 'CannotEndInPast'
  /**
   * The end date for this crowdloan is not sensible.
   **/
  | 'EndTooFarInFuture'
  /**
   * There was an overflow.
   **/
  | 'Overflow'
  /**
   * The contribution was below the minimum, `MinContribution`.
   **/
  | 'ContributionTooSmall'
  /**
   * Invalid fund index.
   **/
  | 'InvalidParaId'
  /**
   * Contributions exceed maximum amount.
   **/
  | 'CapExceeded'
  /**
   * The contribution period has already ended.
   **/
  | 'ContributionPeriodOver'
  /**
   * The origin of this call is invalid.
   **/
  | 'InvalidOrigin'
  /**
   * This crowdloan does not correspond to a parachain.
   **/
  | 'NotParachain'
  /**
   * This parachain lease is still active and retirement cannot yet begin.
   **/
  | 'LeaseActive'
  /**
   * This parachain's bid or lease is still active and withdraw cannot yet begin.
   **/
  | 'BidOrLeaseActive'
  /**
   * The crowdloan has not yet ended.
   **/
  | 'FundNotEnded'
  /**
   * There are no contributions stored in this crowdloan.
   **/
  | 'NoContributions'
  /**
   * The crowdloan is not ready to dissolve. Potentially still has a slot or in retirement
   * period.
   **/
  | 'NotReadyToDissolve'
  /**
   * Invalid signature.
   **/
  | 'InvalidSignature'
  /**
   * The provided memo is too large.
   **/
  | 'MemoTooLarge'
  /**
   * The fund is already in `NewRaise`
   **/
  | 'AlreadyInNewRaise'
  /**
   * No contributions allowed during the VRF delay
   **/
  | 'VrfDelayInProgress'
  /**
   * A lease period has not started yet, due to an offset in the starting block.
   **/
  | 'NoLeasePeriod';

/**
 * The `Error` enum of this pallet.
 **/
export type PolkadotRuntimeParachainsCoretimePalletError =
  /**
   * The paraid making the call is not the coretime brokerage system parachain.
   **/
  'NotBroker';

export type PalletXcmQueryStatus =
  | {
      tag: 'Pending';
      value: {
        responder: XcmVersionedLocation;
        maybeMatchQuerier?: XcmVersionedLocation | undefined;
        maybeNotify?: [number, number] | undefined;
        timeout: number;
      };
    }
  | { tag: 'VersionNotifier'; value: { origin: XcmVersionedLocation; isActive: boolean } }
  | { tag: 'Ready'; value: { response: XcmVersionedResponse; at: number } };

export type XcmVersionedResponse =
  | { tag: 'V2'; value: XcmV2Response }
  | { tag: 'V3'; value: XcmV3Response }
  | { tag: 'V4'; value: StagingXcmV4Response };

export type PalletXcmVersionMigrationStage =
  | { tag: 'MigrateSupportedVersion' }
  | { tag: 'MigrateVersionNotifiers' }
  | { tag: 'NotifyCurrentTargets'; value?: Bytes | undefined }
  | { tag: 'MigrateAndNotifyOldTargets' };

export type XcmVersionedAssetId =
  | { tag: 'V3'; value: XcmV3MultiassetAssetId }
  | { tag: 'V4'; value: StagingXcmV4AssetAssetId };

export type PalletXcmRemoteLockedFungibleRecord = {
  amount: bigint;
  owner: XcmVersionedLocation;
  locker: XcmVersionedLocation;
  consumers: Array<[[], bigint]>;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletXcmError =
  /**
   * The desired destination was unreachable, generally because there is a no way of routing
   * to it.
   **/
  | 'Unreachable'
  /**
   * There was some other issue (i.e. not to do with routing) in sending the message.
   * Perhaps a lack of space for buffering the message.
   **/
  | 'SendFailure'
  /**
   * The message execution fails the filter.
   **/
  | 'Filtered'
  /**
   * The message's weight could not be determined.
   **/
  | 'UnweighableMessage'
  /**
   * The destination `Location` provided cannot be inverted.
   **/
  | 'DestinationNotInvertible'
  /**
   * The assets to be sent are empty.
   **/
  | 'Empty'
  /**
   * Could not re-anchor the assets to declare the fees for the destination chain.
   **/
  | 'CannotReanchor'
  /**
   * Too many assets have been attempted for transfer.
   **/
  | 'TooManyAssets'
  /**
   * Origin is invalid for sending.
   **/
  | 'InvalidOrigin'
  /**
   * The version of the `Versioned` value used is not able to be interpreted.
   **/
  | 'BadVersion'
  /**
   * The given location could not be used (e.g. because it cannot be expressed in the
   * desired version of XCM).
   **/
  | 'BadLocation'
  /**
   * The referenced subscription could not be found.
   **/
  | 'NoSubscription'
  /**
   * The location is invalid since it already has a subscription from us.
   **/
  | 'AlreadySubscribed'
  /**
   * Could not check-out the assets for teleportation to the destination chain.
   **/
  | 'CannotCheckOutTeleport'
  /**
   * The owner does not own (all) of the asset that they wish to do the operation on.
   **/
  | 'LowBalance'
  /**
   * The asset owner has too many locks on the asset.
   **/
  | 'TooManyLocks'
  /**
   * The given account is not an identifiable sovereign account for any location.
   **/
  | 'AccountNotSovereign'
  /**
   * The operation required fees to be paid which the initiator could not meet.
   **/
  | 'FeesNotMet'
  /**
   * A remote lock with the corresponding data could not be found.
   **/
  | 'LockNotFound'
  /**
   * The unlock operation cannot succeed because there are still consumers of the lock.
   **/
  | 'InUse'
  /**
   * Invalid non-concrete asset.
   **/
  | 'InvalidAssetNotConcrete'
  /**
   * Invalid asset, reserve chain could not be determined for it.
   **/
  | 'InvalidAssetUnknownReserve'
  /**
   * Invalid asset, do not support remote asset reserves with different fees reserves.
   **/
  | 'InvalidAssetUnsupportedReserve'
  /**
   * Too many assets with different reserve locations have been attempted for transfer.
   **/
  | 'TooManyReserves'
  /**
   * Local XCM execution incomplete.
   **/
  | 'LocalExecutionIncomplete';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBeefyError =
  /**
   * A key ownership proof provided as part of an equivocation report is invalid.
   **/
  | 'InvalidKeyOwnershipProof'
  /**
   * An equivocation proof provided as part of an equivocation report is invalid.
   **/
  | 'InvalidEquivocationProof'
  /**
   * A given equivocation report is valid but already previously reported.
   **/
  | 'DuplicateOffenceReport'
  /**
   * Submitted configuration is invalid.
   **/
  | 'InvalidConfiguration';

export type SpConsensusBeefyMmrBeefyAuthoritySet = { id: bigint; len: number; keysetCommitment: H256 };

/**
 * The `Error` enum of this pallet.
 **/
export type PolkadotRuntimeCommonParasSudoWrapperPalletError =
  /**
   * The specified parachain is not registered.
   **/
  | 'ParaDoesntExist'
  /**
   * The specified parachain is already registered.
   **/
  | 'ParaAlreadyExists'
  /**
   * A DMP message couldn't be sent because it exceeds the maximum size allowed for a
   * downward message.
   **/
  | 'ExceedsMaxMessageSize'
  /**
   * Could not schedule para cleanup.
   **/
  | 'CouldntCleanup'
  /**
   * Not a parathread (on-demand parachain).
   **/
  | 'NotParathread'
  /**
   * Not a lease holding parachain.
   **/
  | 'NotParachain'
  /**
   * Cannot upgrade on-demand parachain to lease holding parachain.
   **/
  | 'CannotUpgrade'
  /**
   * Cannot downgrade lease holding parachain to on-demand.
   **/
  | 'CannotDowngrade'
  /**
   * There are more cores than supported by the runtime.
   **/
  | 'TooManyCores';

export type PolkadotRuntimeCommonAssignedSlotsParachainTemporarySlot = {
  manager: AccountId32;
  periodBegin: number;
  periodCount: number;
  lastLease?: number | undefined;
  leaseCount: number;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PolkadotRuntimeCommonAssignedSlotsPalletError =
  /**
   * The specified parachain is not registered.
   **/
  | 'ParaDoesntExist'
  /**
   * Not a parathread (on-demand parachain).
   **/
  | 'NotParathread'
  /**
   * Cannot upgrade on-demand parachain to lease holding
   * parachain.
   **/
  | 'CannotUpgrade'
  /**
   * Cannot downgrade lease holding parachain to
   * on-demand.
   **/
  | 'CannotDowngrade'
  /**
   * Permanent or Temporary slot already assigned.
   **/
  | 'SlotAlreadyAssigned'
  /**
   * Permanent or Temporary slot has not been assigned.
   **/
  | 'SlotNotAssigned'
  /**
   * An ongoing lease already exists.
   **/
  | 'OngoingLeaseExists'
  | 'MaxPermanentSlotsExceeded'
  | 'MaxTemporarySlotsExceeded';

/**
 * Error for the Sudo pallet.
 **/
export type PalletSudoError =
  /**
   * Sender must be the Sudo account.
   **/
  'RequireSudo';

export type FrameSystemExtensionsCheckNonZeroSender = {};

export type FrameSystemExtensionsCheckSpecVersion = {};

export type FrameSystemExtensionsCheckTxVersion = {};

export type FrameSystemExtensionsCheckGenesis = {};

export type FrameSystemExtensionsCheckMortality = Era;

export type FrameSystemExtensionsCheckNonce = number;

export type FrameSystemExtensionsCheckWeight = {};

export type PalletTransactionPaymentChargeTransactionPayment = bigint;

export type RococoRuntimeRuntime = {};

export type SpRuntimeBlock = { header: Header; extrinsics: Array<UncheckedExtrinsic> };

export type SpRuntimeExtrinsicInclusionMode = 'AllExtrinsics' | 'OnlyInherents';

export type SpCoreOpaqueMetadata = Bytes;

export type SpRuntimeTransactionValidityTransactionValidityError =
  | { tag: 'Invalid'; value: SpRuntimeTransactionValidityInvalidTransaction }
  | { tag: 'Unknown'; value: SpRuntimeTransactionValidityUnknownTransaction };

export type SpRuntimeTransactionValidityInvalidTransaction =
  | { tag: 'Call' }
  | { tag: 'Payment' }
  | { tag: 'Future' }
  | { tag: 'Stale' }
  | { tag: 'BadProof' }
  | { tag: 'AncientBirthBlock' }
  | { tag: 'ExhaustsResources' }
  | { tag: 'Custom'; value: number }
  | { tag: 'BadMandatory' }
  | { tag: 'MandatoryValidation' }
  | { tag: 'BadSigner' };

export type SpRuntimeTransactionValidityUnknownTransaction =
  | { tag: 'CannotLookup' }
  | { tag: 'NoUnsignedValidator' }
  | { tag: 'Custom'; value: number };

export type SpInherentsInherentData = { data: Array<[FixedBytes<8>, Bytes]> };

export type SpInherentsCheckInherentsResult = { okay: boolean; fatalError: boolean; errors: SpInherentsInherentData };

export type SpRuntimeTransactionValidityTransactionSource = 'InBlock' | 'Local' | 'External';

export type SpRuntimeTransactionValidityValidTransaction = {
  priority: bigint;
  requires: Array<Bytes>;
  provides: Array<Bytes>;
  longevity: bigint;
  propagate: boolean;
};

export type PolkadotPrimitivesV6GroupRotationInfo = {
  sessionStartBlock: number;
  groupRotationFrequency: number;
  now: number;
};

export type PolkadotPrimitivesV6CoreState =
  | { tag: 'Occupied'; value: PolkadotPrimitivesV6OccupiedCore }
  | { tag: 'Scheduled'; value: PolkadotPrimitivesV6ScheduledCore }
  | { tag: 'Free' };

export type PolkadotPrimitivesV6OccupiedCore = {
  nextUpOnAvailable?: PolkadotPrimitivesV6ScheduledCore | undefined;
  occupiedSince: number;
  timeOutAt: number;
  nextUpOnTimeOut?: PolkadotPrimitivesV6ScheduledCore | undefined;
  availability: BitSequence;
  groupResponsible: PolkadotPrimitivesV6GroupIndex;
  candidateHash: PolkadotCorePrimitivesCandidateHash;
  candidateDescriptor: PolkadotPrimitivesV6CandidateDescriptor;
};

export type PolkadotPrimitivesV6ScheduledCore = {
  paraId: PolkadotParachainPrimitivesPrimitivesId;
  collator?: PolkadotPrimitivesV6CollatorAppPublic | undefined;
};

export type PolkadotPrimitivesV6OccupiedCoreAssumption = 'Included' | 'TimedOut' | 'Free';

export type PolkadotPrimitivesV6PersistedValidationData = {
  parentHead: PolkadotParachainPrimitivesPrimitivesHeadData;
  relayParentNumber: number;
  relayParentStorageRoot: H256;
  maxPovSize: number;
};

export type PolkadotPrimitivesV6CandidateEvent =
  | {
      tag: 'CandidateBacked';
      value: [
        PolkadotPrimitivesV6CandidateReceipt,
        PolkadotParachainPrimitivesPrimitivesHeadData,
        PolkadotPrimitivesV6CoreIndex,
        PolkadotPrimitivesV6GroupIndex,
      ];
    }
  | {
      tag: 'CandidateIncluded';
      value: [
        PolkadotPrimitivesV6CandidateReceipt,
        PolkadotParachainPrimitivesPrimitivesHeadData,
        PolkadotPrimitivesV6CoreIndex,
        PolkadotPrimitivesV6GroupIndex,
      ];
    }
  | {
      tag: 'CandidateTimedOut';
      value: [
        PolkadotPrimitivesV6CandidateReceipt,
        PolkadotParachainPrimitivesPrimitivesHeadData,
        PolkadotPrimitivesV6CoreIndex,
      ];
    };

export type PolkadotPrimitivesV6SlashingOpaqueKeyOwnershipProof = Bytes;

export type PolkadotPrimitivesV6AsyncBackingBackingState = {
  constraints: PolkadotPrimitivesV6AsyncBackingConstraints;
  pendingAvailability: Array<PolkadotPrimitivesV6AsyncBackingCandidatePendingAvailability>;
};

export type PolkadotPrimitivesV6AsyncBackingConstraints = {
  minRelayParentNumber: number;
  maxPovSize: number;
  maxCodeSize: number;
  umpRemaining: number;
  umpRemainingBytes: number;
  maxUmpNumPerCandidate: number;
  dmpRemainingMessages: Array<number>;
  hrmpInbound: PolkadotPrimitivesV6AsyncBackingInboundHrmpLimitations;
  hrmpChannelsOut: Array<
    [PolkadotParachainPrimitivesPrimitivesId, PolkadotPrimitivesV6AsyncBackingOutboundHrmpChannelLimitations]
  >;
  maxHrmpNumPerCandidate: number;
  requiredParent: PolkadotParachainPrimitivesPrimitivesHeadData;
  validationCodeHash: PolkadotParachainPrimitivesPrimitivesValidationCodeHash;
  upgradeRestriction?: PolkadotPrimitivesV6UpgradeRestriction | undefined;
  futureValidationCode?: [number, PolkadotParachainPrimitivesPrimitivesValidationCodeHash] | undefined;
};

export type PolkadotPrimitivesV6AsyncBackingInboundHrmpLimitations = { validWatermarks: Array<number> };

export type PolkadotPrimitivesV6AsyncBackingOutboundHrmpChannelLimitations = {
  bytesRemaining: number;
  messagesRemaining: number;
};

export type PolkadotPrimitivesV6AsyncBackingCandidatePendingAvailability = {
  candidateHash: PolkadotCorePrimitivesCandidateHash;
  descriptor: PolkadotPrimitivesV6CandidateDescriptor;
  commitments: PolkadotPrimitivesV6CandidateCommitments;
  relayParentNumber: number;
  maxPovSize: number;
};

export type SpConsensusBeefyValidatorSet = { validators: Array<SpConsensusBeefyEcdsaCryptoPublic>; id: bigint };

export type SpConsensusBeefyOpaqueKeyOwnershipProof = Bytes;

export type SpMmrPrimitivesError =
  | 'InvalidNumericOp'
  | 'Push'
  | 'GetRoot'
  | 'Commit'
  | 'GenerateProof'
  | 'Verify'
  | 'LeafNotFound'
  | 'PalletNotIncluded'
  | 'InvalidLeafIndex'
  | 'InvalidBestKnownBlock';

export type SpMmrPrimitivesEncodableOpaqueLeaf = Bytes;

export type SpMmrPrimitivesProof = { leafIndices: Array<bigint>; leafCount: bigint; items: Array<H256> };

export type SpConsensusGrandpaOpaqueKeyOwnershipProof = Bytes;

export type SpConsensusBabeBabeConfiguration = {
  slotDuration: bigint;
  epochLength: bigint;
  c: [bigint, bigint];
  authorities: Array<[SpConsensusBabeAppPublic, bigint]>;
  randomness: FixedBytes<32>;
  allowedSlots: SpConsensusBabeAllowedSlots;
};

export type SpConsensusBabeEpoch = {
  epochIndex: bigint;
  startSlot: SpConsensusSlotsSlot;
  duration: bigint;
  authorities: Array<[SpConsensusBabeAppPublic, bigint]>;
  randomness: FixedBytes<32>;
  config: SpConsensusBabeBabeEpochConfiguration;
};

export type SpConsensusBabeOpaqueKeyOwnershipProof = Bytes;

export type PalletTransactionPaymentRuntimeDispatchInfo = {
  weight: SpWeightsWeightV2Weight;
  class: FrameSupportDispatchDispatchClass;
  partialFee: bigint;
};

export type PalletTransactionPaymentFeeDetails = {
  inclusionFee?: PalletTransactionPaymentInclusionFee | undefined;
  tip: bigint;
};

export type PalletTransactionPaymentInclusionFee = { baseFee: bigint; lenFee: bigint; adjustedWeightFee: bigint };

export type RococoRuntimeRuntimeError =
  | { tag: 'System'; value: FrameSystemError }
  | { tag: 'Babe'; value: PalletBabeError }
  | { tag: 'Indices'; value: PalletIndicesError }
  | { tag: 'Balances'; value: PalletBalancesError }
  | { tag: 'Session'; value: PalletSessionError }
  | { tag: 'Grandpa'; value: PalletGrandpaError }
  | { tag: 'Treasury'; value: PalletTreasuryError }
  | { tag: 'ConvictionVoting'; value: PalletConvictionVotingError }
  | { tag: 'Referenda'; value: PalletReferendaError }
  | { tag: 'FellowshipCollective'; value: PalletRankedCollectiveError }
  | { tag: 'FellowshipReferenda'; value: PalletReferendaError }
  | { tag: 'Whitelist'; value: PalletWhitelistError }
  | { tag: 'Claims'; value: PolkadotRuntimeCommonClaimsPalletError }
  | { tag: 'Utility'; value: PalletUtilityError }
  | { tag: 'Identity'; value: PalletIdentityError }
  | { tag: 'Society'; value: PalletSocietyError }
  | { tag: 'Recovery'; value: PalletRecoveryError }
  | { tag: 'Vesting'; value: PalletVestingError }
  | { tag: 'Scheduler'; value: PalletSchedulerError }
  | { tag: 'Proxy'; value: PalletProxyError }
  | { tag: 'Multisig'; value: PalletMultisigError }
  | { tag: 'Preimage'; value: PalletPreimageError }
  | { tag: 'AssetRate'; value: PalletAssetRateError }
  | { tag: 'Bounties'; value: PalletBountiesError }
  | { tag: 'ChildBounties'; value: PalletChildBountiesError }
  | { tag: 'Nis'; value: PalletNisError }
  | { tag: 'NisCounterpartBalances'; value: PalletBalancesError }
  | { tag: 'Configuration'; value: PolkadotRuntimeParachainsConfigurationPalletError }
  | { tag: 'ParaInclusion'; value: PolkadotRuntimeParachainsInclusionPalletError }
  | { tag: 'ParaInherent'; value: PolkadotRuntimeParachainsParasInherentPalletError }
  | { tag: 'Paras'; value: PolkadotRuntimeParachainsParasPalletError }
  | { tag: 'Hrmp'; value: PolkadotRuntimeParachainsHrmpPalletError }
  | { tag: 'ParasDisputes'; value: PolkadotRuntimeParachainsDisputesPalletError }
  | { tag: 'ParasSlashing'; value: PolkadotRuntimeParachainsDisputesSlashingPalletError }
  | { tag: 'MessageQueue'; value: PalletMessageQueueError }
  | { tag: 'OnDemandAssignmentProvider'; value: PolkadotRuntimeParachainsAssignerOnDemandPalletError }
  | { tag: 'CoretimeAssignmentProvider'; value: PolkadotRuntimeParachainsAssignerCoretimePalletError }
  | { tag: 'Registrar'; value: PolkadotRuntimeCommonParasRegistrarPalletError }
  | { tag: 'Slots'; value: PolkadotRuntimeCommonSlotsPalletError }
  | { tag: 'Auctions'; value: PolkadotRuntimeCommonAuctionsPalletError }
  | { tag: 'Crowdloan'; value: PolkadotRuntimeCommonCrowdloanPalletError }
  | { tag: 'Coretime'; value: PolkadotRuntimeParachainsCoretimePalletError }
  | { tag: 'XcmPallet'; value: PalletXcmError }
  | { tag: 'Beefy'; value: PalletBeefyError }
  | { tag: 'ParasSudoWrapper'; value: PolkadotRuntimeCommonParasSudoWrapperPalletError }
  | { tag: 'AssignedSlots'; value: PolkadotRuntimeCommonAssignedSlotsPalletError }
  | { tag: 'StateTrieMigration'; value: PalletStateTrieMigrationError }
  | { tag: 'Sudo'; value: PalletSudoError };
