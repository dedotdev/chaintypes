// Generated by dedot cli

import type { GenericRuntimeApis, GenericRuntimeApiMethod, RpcVersion } from 'dedot/types';
import type {
  RuntimeVersion,
  Header,
  DispatchError,
  Result,
  UncheckedExtrinsicLike,
  UncheckedExtrinsic,
  AccountId32Like,
  H256,
  BitSequence,
  Bytes,
  BytesLike,
  AccountId32,
} from 'dedot/codecs';
import type {
  RelayCommonApisInflationInfo,
  SpRuntimeBlock,
  SpRuntimeExtrinsicInclusionMode,
  SpCoreOpaqueMetadata,
  SpRuntimeTransactionValidityTransactionValidityError,
  SpInherentsInherentData,
  SpInherentsCheckInherentsResult,
  SpRuntimeTransactionValidityValidTransaction,
  SpRuntimeTransactionValidityTransactionSource,
  PolkadotPrimitivesV7ValidatorAppPublic,
  PolkadotPrimitivesV7ValidatorIndex,
  PolkadotPrimitivesV7GroupRotationInfo,
  PolkadotPrimitivesV7CoreState,
  PolkadotPrimitivesV7PersistedValidationData,
  PolkadotParachainPrimitivesPrimitivesId,
  PolkadotPrimitivesV7OccupiedCoreAssumption,
  PolkadotParachainPrimitivesPrimitivesValidationCodeHash,
  PolkadotPrimitivesV7CandidateCommitments,
  PolkadotParachainPrimitivesPrimitivesValidationCode,
  PolkadotPrimitivesV7CommittedCandidateReceipt,
  PolkadotPrimitivesV7CandidateEvent,
  PolkadotCorePrimitivesInboundDownwardMessage,
  PolkadotCorePrimitivesInboundHrmpMessage,
  PolkadotPrimitivesV7ScrapedOnChainVotes,
  PolkadotPrimitivesV7SessionInfo,
  PolkadotPrimitivesV7PvfCheckStatement,
  PolkadotPrimitivesV7ValidatorAppSignature,
  PolkadotCorePrimitivesCandidateHash,
  PolkadotPrimitivesV7DisputeState,
  PolkadotPrimitivesV7ExecutorParams,
  PolkadotPrimitivesV7SlashingPendingSlashes,
  PolkadotPrimitivesV7SlashingOpaqueKeyOwnershipProof,
  PolkadotPrimitivesV7SlashingDisputeProof,
  PolkadotPrimitivesV7AsyncBackingBackingState,
  PolkadotPrimitivesV7AsyncBackingAsyncBackingParams,
  PolkadotPrimitivesV7ApprovalVotingParams,
  PolkadotPrimitivesV7CoreIndex,
  SpConsensusBeefyValidatorSet,
  SpConsensusBeefyDoubleVotingProof,
  SpRuntimeOpaqueValue,
  SpConsensusBeefyEcdsaCryptoPublic,
  SpMmrPrimitivesError,
  SpMmrPrimitivesEncodableOpaqueLeaf,
  SpMmrPrimitivesLeafProof,
  SpConsensusBeefyMmrBeefyAuthoritySet,
  SpConsensusGrandpaAppPublic,
  SpConsensusGrandpaEquivocationProof,
  SpConsensusBabeBabeConfiguration,
  SpConsensusSlotsSlot,
  SpConsensusBabeEpoch,
  SpConsensusBabeOpaqueKeyOwnershipProof,
  SpConsensusBabeAppPublic,
  SpConsensusSlotsEquivocationProof,
  SpAuthorityDiscoveryAppPublic,
  SpCoreCryptoKeyTypeId,
  PalletTransactionPaymentRuntimeDispatchInfo,
  PalletTransactionPaymentFeeDetails,
  SpWeightsWeightV2Weight,
  PolkadotRuntimeRuntimeCallLike,
  XcmVersionedAssetId,
  XcmRuntimeApisFeesError,
  XcmVersionedXcm,
  XcmVersionedAssets,
  XcmVersionedLocation,
  XcmRuntimeApisDryRunCallDryRunEffects,
  XcmRuntimeApisDryRunError,
  PolkadotRuntimeOriginCaller,
  XcmRuntimeApisDryRunXcmDryRunEffects,
  XcmRuntimeApisConversionsError,
} from './types';

export interface RuntimeApis<Rv extends RpcVersion> extends GenericRuntimeApis<Rv> {
  /**
   * @runtimeapi: Inflation - 0xc51ff1fa3f5d0cca
   **/
  inflation: {
    /**
     * Return the current estimates of the inflation amount.
     *
     * This is marked as experimental in light of RFC#89. Nonetheless, its usage is highly
     * recommended over trying to read-storage, or re-create the onchain logic.
     *
     * @callname: Inflation_experimental_inflation_prediction_info
     **/
    experimentalInflationPredictionInfo: GenericRuntimeApiMethod<Rv, () => Promise<RelayCommonApisInflationInfo>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: Core - 0xdf6acb689907609b
   **/
  core: {
    /**
     * Returns the version of the runtime.
     *
     * @callname: Core_version
     **/
    version: GenericRuntimeApiMethod<Rv, () => Promise<RuntimeVersion>>;

    /**
     * Execute the given block.
     *
     * @callname: Core_execute_block
     * @param {SpRuntimeBlock} block
     **/
    executeBlock: GenericRuntimeApiMethod<Rv, (block: SpRuntimeBlock) => Promise<[]>>;

    /**
     * Initialize a block with the given header and return the runtime executive mode.
     *
     * @callname: Core_initialize_block
     * @param {Header} header
     **/
    initializeBlock: GenericRuntimeApiMethod<Rv, (header: Header) => Promise<SpRuntimeExtrinsicInclusionMode>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: Metadata - 0x37e397fc7c91f5e4
   **/
  metadata: {
    /**
     * Returns the metadata of a runtime.
     *
     * @callname: Metadata_metadata
     **/
    metadata: GenericRuntimeApiMethod<Rv, () => Promise<SpCoreOpaqueMetadata>>;

    /**
     * Returns the metadata at a given version.
     *
     * If the given `version` isn't supported, this will return `None`.
     * Use [`Self::metadata_versions`] to find out about supported metadata version of the runtime.
     *
     * @callname: Metadata_metadata_at_version
     * @param {number} version
     **/
    metadataAtVersion: GenericRuntimeApiMethod<Rv, (version: number) => Promise<SpCoreOpaqueMetadata | undefined>>;

    /**
     * Returns the supported metadata versions.
     *
     * This can be used to call `metadata_at_version`.
     *
     * @callname: Metadata_metadata_versions
     **/
    metadataVersions: GenericRuntimeApiMethod<Rv, () => Promise<Array<number>>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: BlockBuilder - 0x40fe3ad401f8959a
   **/
  blockBuilder: {
    /**
     * Apply the given extrinsic.
     *
     * Returns an inclusion outcome which specifies if this extrinsic is included in
     * this block or not.
     *
     * @callname: BlockBuilder_apply_extrinsic
     * @param {UncheckedExtrinsicLike} extrinsic
     **/
    applyExtrinsic: GenericRuntimeApiMethod<
      Rv,
      (
        extrinsic: UncheckedExtrinsicLike,
      ) => Promise<Result<Result<[], DispatchError>, SpRuntimeTransactionValidityTransactionValidityError>>
    >;

    /**
     * Finish the current block.
     *
     * @callname: BlockBuilder_finalize_block
     **/
    finalizeBlock: GenericRuntimeApiMethod<Rv, () => Promise<Header>>;

    /**
     * Generate inherent extrinsics. The inherent data will vary from chain to chain.
     *
     * @callname: BlockBuilder_inherent_extrinsics
     * @param {SpInherentsInherentData} inherent
     **/
    inherentExtrinsics: GenericRuntimeApiMethod<
      Rv,
      (inherent: SpInherentsInherentData) => Promise<Array<UncheckedExtrinsic>>
    >;

    /**
     * Check that the inherents are valid. The inherent data will vary from chain to chain.
     *
     * @callname: BlockBuilder_check_inherents
     * @param {SpRuntimeBlock} block
     * @param {SpInherentsInherentData} data
     **/
    checkInherents: GenericRuntimeApiMethod<
      Rv,
      (block: SpRuntimeBlock, data: SpInherentsInherentData) => Promise<SpInherentsCheckInherentsResult>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: NominationPoolsApi - 0x17a6bc0d0062aeb3
   **/
  nominationPoolsApi: {
    /**
     * Returns the pending rewards for the member that the AccountId was given for.
     *
     * @callname: NominationPoolsApi_pending_rewards
     * @param {AccountId32Like} who
     **/
    pendingRewards: GenericRuntimeApiMethod<Rv, (who: AccountId32Like) => Promise<bigint>>;

    /**
     * Returns the equivalent balance of `points` for a given pool.
     *
     * @callname: NominationPoolsApi_points_to_balance
     * @param {number} pool_id
     * @param {bigint} points
     **/
    pointsToBalance: GenericRuntimeApiMethod<Rv, (poolId: number, points: bigint) => Promise<bigint>>;

    /**
     * Returns the equivalent points of `new_funds` for a given pool.
     *
     * @callname: NominationPoolsApi_balance_to_points
     * @param {number} pool_id
     * @param {bigint} new_funds
     **/
    balanceToPoints: GenericRuntimeApiMethod<Rv, (poolId: number, newFunds: bigint) => Promise<bigint>>;

    /**
     * Returns the pending slash for a given pool.
     *
     * @callname: NominationPoolsApi_pool_pending_slash
     * @param {number} pool_id
     **/
    poolPendingSlash: GenericRuntimeApiMethod<Rv, (poolId: number) => Promise<bigint>>;

    /**
     * Returns the pending slash for a given pool member.
     *
     * @callname: NominationPoolsApi_member_pending_slash
     * @param {AccountId32Like} member
     **/
    memberPendingSlash: GenericRuntimeApiMethod<Rv, (member: AccountId32Like) => Promise<bigint>>;

    /**
     * Returns true if the pool with `pool_id` needs migration.
     *
     * This can happen when the `pallet-nomination-pools` has switched to using strategy
     * [`DelegateStake`](pallet_nomination_pools::adapter::DelegateStake) but the pool
     * still has funds that were staked using the older strategy
     * [TransferStake](pallet_nomination_pools::adapter::TransferStake). Use
     * [`migrate_pool_to_delegate_stake`](pallet_nomination_pools::Call::migrate_pool_to_delegate_stake)
     * to migrate the pool.
     *
     * @callname: NominationPoolsApi_pool_needs_delegate_migration
     * @param {number} pool_id
     **/
    poolNeedsDelegateMigration: GenericRuntimeApiMethod<Rv, (poolId: number) => Promise<boolean>>;

    /**
     * Returns true if the delegated funds of the pool `member` needs migration.
     *
     * Once a pool has successfully migrated to the strategy
     * [`DelegateStake`](pallet_nomination_pools::adapter::DelegateStake), the funds of the
     * member can be migrated from pool account to the member's account. Use
     * [`migrate_delegation`](pallet_nomination_pools::Call::migrate_delegation)
     * to migrate the funds of the pool member.
     *
     * @callname: NominationPoolsApi_member_needs_delegate_migration
     * @param {AccountId32Like} member
     **/
    memberNeedsDelegateMigration: GenericRuntimeApiMethod<Rv, (member: AccountId32Like) => Promise<boolean>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: StakingApi - 0x18ef58a3b67ba770
   **/
  stakingApi: {
    /**
     * Returns the nominations quota for a nominator with a given balance.
     *
     * @callname: StakingApi_nominations_quota
     * @param {bigint} balance
     **/
    nominationsQuota: GenericRuntimeApiMethod<Rv, (balance: bigint) => Promise<number>>;

    /**
     * Returns the page count of exposures for a validator `account` in a given era.
     *
     * @callname: StakingApi_eras_stakers_page_count
     * @param {number} era
     * @param {AccountId32Like} account
     **/
    erasStakersPageCount: GenericRuntimeApiMethod<Rv, (era: number, account: AccountId32Like) => Promise<number>>;

    /**
     * Returns true if validator `account` has pages to be claimed for the given era.
     *
     * @callname: StakingApi_pending_rewards
     * @param {number} era
     * @param {AccountId32Like} account
     **/
    pendingRewards: GenericRuntimeApiMethod<Rv, (era: number, account: AccountId32Like) => Promise<boolean>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: TaggedTransactionQueue - 0xd2bc9897eed08f15
   **/
  taggedTransactionQueue: {
    /**
     * Validate the transaction.
     *
     * This method is invoked by the transaction pool to learn details about given transaction.
     * The implementation should make sure to verify the correctness of the transaction
     * against current state. The given `block_hash` corresponds to the hash of the block
     * that is used as current state.
     *
     * Note that this call may be performed by the pool multiple times and transactions
     * might be verified in any possible order.
     *
     * @callname: TaggedTransactionQueue_validate_transaction
     * @param {SpRuntimeTransactionValidityTransactionSource} source
     * @param {UncheckedExtrinsicLike} tx
     * @param {H256} block_hash
     **/
    validateTransaction: GenericRuntimeApiMethod<
      Rv,
      (
        source: SpRuntimeTransactionValidityTransactionSource,
        tx: UncheckedExtrinsicLike,
        blockHash: H256,
      ) => Promise<
        Result<SpRuntimeTransactionValidityValidTransaction, SpRuntimeTransactionValidityTransactionValidityError>
      >
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: OffchainWorkerApi - 0xf78b278be53f454c
   **/
  offchainWorkerApi: {
    /**
     * Starts the off-chain task for given block header.
     *
     * @callname: OffchainWorkerApi_offchain_worker
     * @param {Header} header
     **/
    offchainWorker: GenericRuntimeApiMethod<Rv, (header: Header) => Promise<[]>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: ParachainHost - 0xaf2c0297a23e6d3d
   **/
  parachainHost: {
    /**
     * Get the current validators.
     *
     * @callname: ParachainHost_validators
     **/
    validators: GenericRuntimeApiMethod<Rv, () => Promise<Array<PolkadotPrimitivesV7ValidatorAppPublic>>>;

    /**
     * Returns the validator groups and rotation info localized based on the hypothetical child
     * of a block whose state this is invoked on. Note that `now` in the `GroupRotationInfo`
     * should be the successor of the number of the block.
     *
     * @callname: ParachainHost_validator_groups
     **/
    validatorGroups: GenericRuntimeApiMethod<
      Rv,
      () => Promise<[Array<Array<PolkadotPrimitivesV7ValidatorIndex>>, PolkadotPrimitivesV7GroupRotationInfo]>
    >;

    /**
     * Yields information on all availability cores as relevant to the child block.
     * Cores are either free or occupied. Free cores can have paras assigned to them.
     *
     * @callname: ParachainHost_availability_cores
     **/
    availabilityCores: GenericRuntimeApiMethod<Rv, () => Promise<Array<PolkadotPrimitivesV7CoreState>>>;

    /**
     * Yields the persisted validation data for the given `ParaId` along with an assumption that
     * should be used if the para currently occupies a core.
     *
     * Returns `None` if either the para is not registered or the assumption is `Freed`
     * and the para already occupies a core.
     *
     * @callname: ParachainHost_persisted_validation_data
     * @param {PolkadotParachainPrimitivesPrimitivesId} para_id
     * @param {PolkadotPrimitivesV7OccupiedCoreAssumption} assumption
     **/
    persistedValidationData: GenericRuntimeApiMethod<
      Rv,
      (
        paraId: PolkadotParachainPrimitivesPrimitivesId,
        assumption: PolkadotPrimitivesV7OccupiedCoreAssumption,
      ) => Promise<PolkadotPrimitivesV7PersistedValidationData | undefined>
    >;

    /**
     * Returns the persisted validation data for the given `ParaId` along with the corresponding
     * validation code hash. Instead of accepting assumption about the para, matches the validation
     * data hash against an expected one and yields `None` if they're not equal.
     *
     * @callname: ParachainHost_assumed_validation_data
     * @param {PolkadotParachainPrimitivesPrimitivesId} para_id
     * @param {H256} expected_persisted_validation_data_hash
     **/
    assumedValidationData: GenericRuntimeApiMethod<
      Rv,
      (
        paraId: PolkadotParachainPrimitivesPrimitivesId,
        expectedPersistedValidationDataHash: H256,
      ) => Promise<
        | [PolkadotPrimitivesV7PersistedValidationData, PolkadotParachainPrimitivesPrimitivesValidationCodeHash]
        | undefined
      >
    >;

    /**
     * Checks if the given validation outputs pass the acceptance criteria.
     *
     * @callname: ParachainHost_check_validation_outputs
     * @param {PolkadotParachainPrimitivesPrimitivesId} para_id
     * @param {PolkadotPrimitivesV7CandidateCommitments} outputs
     **/
    checkValidationOutputs: GenericRuntimeApiMethod<
      Rv,
      (
        paraId: PolkadotParachainPrimitivesPrimitivesId,
        outputs: PolkadotPrimitivesV7CandidateCommitments,
      ) => Promise<boolean>
    >;

    /**
     * Returns the session index expected at a child of the block.
     *
     * This can be used to instantiate a `SigningContext`.
     *
     * @callname: ParachainHost_session_index_for_child
     **/
    sessionIndexForChild: GenericRuntimeApiMethod<Rv, () => Promise<number>>;

    /**
     * Fetch the validation code used by a para, making the given `OccupiedCoreAssumption`.
     *
     * Returns `None` if either the para is not registered or the assumption is `Freed`
     * and the para already occupies a core.
     *
     * @callname: ParachainHost_validation_code
     * @param {PolkadotParachainPrimitivesPrimitivesId} para_id
     * @param {PolkadotPrimitivesV7OccupiedCoreAssumption} assumption
     **/
    validationCode: GenericRuntimeApiMethod<
      Rv,
      (
        paraId: PolkadotParachainPrimitivesPrimitivesId,
        assumption: PolkadotPrimitivesV7OccupiedCoreAssumption,
      ) => Promise<PolkadotParachainPrimitivesPrimitivesValidationCode | undefined>
    >;

    /**
     * Get the receipt of a candidate pending availability. This returns `Some` for any paras
     * assigned to occupied cores in `availability_cores` and `None` otherwise.
     *
     * @callname: ParachainHost_candidate_pending_availability
     * @param {PolkadotParachainPrimitivesPrimitivesId} para_id
     **/
    candidatePendingAvailability: GenericRuntimeApiMethod<
      Rv,
      (
        paraId: PolkadotParachainPrimitivesPrimitivesId,
      ) => Promise<PolkadotPrimitivesV7CommittedCandidateReceipt | undefined>
    >;

    /**
     * Get a vector of events concerning candidates that occurred within a block.
     *
     * @callname: ParachainHost_candidate_events
     **/
    candidateEvents: GenericRuntimeApiMethod<Rv, () => Promise<Array<PolkadotPrimitivesV7CandidateEvent>>>;

    /**
     * Get all the pending inbound messages in the downward message queue for a para.
     *
     * @callname: ParachainHost_dmq_contents
     * @param {PolkadotParachainPrimitivesPrimitivesId} recipient
     **/
    dmqContents: GenericRuntimeApiMethod<
      Rv,
      (
        recipient: PolkadotParachainPrimitivesPrimitivesId,
      ) => Promise<Array<PolkadotCorePrimitivesInboundDownwardMessage>>
    >;

    /**
     * Get the contents of all channels addressed to the given recipient. Channels that have no
     * messages in them are also included.
     *
     * @callname: ParachainHost_inbound_hrmp_channels_contents
     * @param {PolkadotParachainPrimitivesPrimitivesId} recipient
     **/
    inboundHrmpChannelsContents: GenericRuntimeApiMethod<
      Rv,
      (
        recipient: PolkadotParachainPrimitivesPrimitivesId,
      ) => Promise<Array<[PolkadotParachainPrimitivesPrimitivesId, Array<PolkadotCorePrimitivesInboundHrmpMessage>]>>
    >;

    /**
     * Get the validation code from its hash.
     *
     * @callname: ParachainHost_validation_code_by_hash
     * @param {PolkadotParachainPrimitivesPrimitivesValidationCodeHash} hash
     **/
    validationCodeByHash: GenericRuntimeApiMethod<
      Rv,
      (
        hash: PolkadotParachainPrimitivesPrimitivesValidationCodeHash,
      ) => Promise<PolkadotParachainPrimitivesPrimitivesValidationCode | undefined>
    >;

    /**
     * Scrape dispute relevant from on-chain, backing votes and resolved disputes.
     *
     * @callname: ParachainHost_on_chain_votes
     **/
    onChainVotes: GenericRuntimeApiMethod<Rv, () => Promise<PolkadotPrimitivesV7ScrapedOnChainVotes | undefined>>;

    /**
     * Get the session info for the given session, if stored.
     *
     * NOTE: This function is only available since parachain host version 2.
     *
     * @callname: ParachainHost_session_info
     * @param {number} index
     **/
    sessionInfo: GenericRuntimeApiMethod<Rv, (index: number) => Promise<PolkadotPrimitivesV7SessionInfo | undefined>>;

    /**
     * Submits a PVF pre-checking statement into the transaction pool.
     *
     * NOTE: This function is only available since parachain host version 2.
     *
     * @callname: ParachainHost_submit_pvf_check_statement
     * @param {PolkadotPrimitivesV7PvfCheckStatement} stmt
     * @param {PolkadotPrimitivesV7ValidatorAppSignature} signature
     **/
    submitPvfCheckStatement: GenericRuntimeApiMethod<
      Rv,
      (stmt: PolkadotPrimitivesV7PvfCheckStatement, signature: PolkadotPrimitivesV7ValidatorAppSignature) => Promise<[]>
    >;

    /**
     * Returns code hashes of PVFs that require pre-checking by validators in the active set.
     *
     * NOTE: This function is only available since parachain host version 2.
     *
     * @callname: ParachainHost_pvfs_require_precheck
     **/
    pvfsRequirePrecheck: GenericRuntimeApiMethod<
      Rv,
      () => Promise<Array<PolkadotParachainPrimitivesPrimitivesValidationCodeHash>>
    >;

    /**
     * Fetch the hash of the validation code used by a para, making the given `OccupiedCoreAssumption`.
     *
     * NOTE: This function is only available since parachain host version 2.
     *
     * @callname: ParachainHost_validation_code_hash
     * @param {PolkadotParachainPrimitivesPrimitivesId} para_id
     * @param {PolkadotPrimitivesV7OccupiedCoreAssumption} assumption
     **/
    validationCodeHash: GenericRuntimeApiMethod<
      Rv,
      (
        paraId: PolkadotParachainPrimitivesPrimitivesId,
        assumption: PolkadotPrimitivesV7OccupiedCoreAssumption,
      ) => Promise<PolkadotParachainPrimitivesPrimitivesValidationCodeHash | undefined>
    >;

    /**
     * Returns all onchain disputes.
     *
     * @callname: ParachainHost_disputes
     **/
    disputes: GenericRuntimeApiMethod<
      Rv,
      () => Promise<Array<[number, PolkadotCorePrimitivesCandidateHash, PolkadotPrimitivesV7DisputeState]>>
    >;

    /**
     * Returns execution parameters for the session.
     *
     * @callname: ParachainHost_session_executor_params
     * @param {number} session_index
     **/
    sessionExecutorParams: GenericRuntimeApiMethod<
      Rv,
      (sessionIndex: number) => Promise<PolkadotPrimitivesV7ExecutorParams | undefined>
    >;

    /**
     * Returns a list of validators that lost a past session dispute and need to be slashed.
     * NOTE: This function is only available since parachain host version 5.
     *
     * @callname: ParachainHost_unapplied_slashes
     **/
    unappliedSlashes: GenericRuntimeApiMethod<
      Rv,
      () => Promise<Array<[number, PolkadotCorePrimitivesCandidateHash, PolkadotPrimitivesV7SlashingPendingSlashes]>>
    >;

    /**
     * Returns a merkle proof of a validator session key.
     * NOTE: This function is only available since parachain host version 5.
     *
     * @callname: ParachainHost_key_ownership_proof
     * @param {PolkadotPrimitivesV7ValidatorAppPublic} validator_id
     **/
    keyOwnershipProof: GenericRuntimeApiMethod<
      Rv,
      (
        validatorId: PolkadotPrimitivesV7ValidatorAppPublic,
      ) => Promise<PolkadotPrimitivesV7SlashingOpaqueKeyOwnershipProof | undefined>
    >;

    /**
     * Submit an unsigned extrinsic to slash validators who lost a dispute about
     * a candidate of a past session.
     * NOTE: This function is only available since parachain host version 5.
     *
     * @callname: ParachainHost_submit_report_dispute_lost
     * @param {PolkadotPrimitivesV7SlashingDisputeProof} dispute_proof
     * @param {PolkadotPrimitivesV7SlashingOpaqueKeyOwnershipProof} key_ownership_proof
     **/
    submitReportDisputeLost: GenericRuntimeApiMethod<
      Rv,
      (
        disputeProof: PolkadotPrimitivesV7SlashingDisputeProof,
        keyOwnershipProof: PolkadotPrimitivesV7SlashingOpaqueKeyOwnershipProof,
      ) => Promise<[] | undefined>
    >;

    /**
     * Get the minimum number of backing votes for a parachain candidate.
     * This is a staging method! Do not use on production runtimes!
     *
     * @callname: ParachainHost_minimum_backing_votes
     **/
    minimumBackingVotes: GenericRuntimeApiMethod<Rv, () => Promise<number>>;

    /**
     * Returns the state of parachain backing for a given para.
     *
     * @callname: ParachainHost_para_backing_state
     * @param {PolkadotParachainPrimitivesPrimitivesId} _
     **/
    paraBackingState: GenericRuntimeApiMethod<
      Rv,
      (
        undefined: PolkadotParachainPrimitivesPrimitivesId,
      ) => Promise<PolkadotPrimitivesV7AsyncBackingBackingState | undefined>
    >;

    /**
     * Returns candidate's acceptance limitations for asynchronous backing for a relay parent.
     *
     * @callname: ParachainHost_async_backing_params
     **/
    asyncBackingParams: GenericRuntimeApiMethod<Rv, () => Promise<PolkadotPrimitivesV7AsyncBackingAsyncBackingParams>>;

    /**
     * Returns a list of all disabled validators at the given block.
     *
     * @callname: ParachainHost_disabled_validators
     **/
    disabledValidators: GenericRuntimeApiMethod<Rv, () => Promise<Array<PolkadotPrimitivesV7ValidatorIndex>>>;

    /**
     * Get node features.
     * This is a staging method! Do not use on production runtimes!
     *
     * @callname: ParachainHost_node_features
     **/
    nodeFeatures: GenericRuntimeApiMethod<Rv, () => Promise<BitSequence>>;

    /**
     * Approval voting configuration parameters
     *
     * @callname: ParachainHost_approval_voting_params
     **/
    approvalVotingParams: GenericRuntimeApiMethod<Rv, () => Promise<PolkadotPrimitivesV7ApprovalVotingParams>>;

    /**
     * Claim queue
     *
     * @callname: ParachainHost_claim_queue
     **/
    claimQueue: GenericRuntimeApiMethod<
      Rv,
      () => Promise<Array<[PolkadotPrimitivesV7CoreIndex, Array<PolkadotParachainPrimitivesPrimitivesId>]>>
    >;

    /**
     * Elastic scaling support
     *
     * @callname: ParachainHost_candidates_pending_availability
     * @param {PolkadotParachainPrimitivesPrimitivesId} para_id
     **/
    candidatesPendingAvailability: GenericRuntimeApiMethod<
      Rv,
      (paraId: PolkadotParachainPrimitivesPrimitivesId) => Promise<Array<PolkadotPrimitivesV7CommittedCandidateReceipt>>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: BeefyApi - 0x49eaaf1b548a0cb0
   **/
  beefyApi: {
    /**
     * Return the block number where BEEFY consensus is enabled/started
     *
     * @callname: BeefyApi_beefy_genesis
     **/
    beefyGenesis: GenericRuntimeApiMethod<Rv, () => Promise<number | undefined>>;

    /**
     * Return the current active BEEFY validator set
     *
     * @callname: BeefyApi_validator_set
     **/
    validatorSet: GenericRuntimeApiMethod<Rv, () => Promise<SpConsensusBeefyValidatorSet | undefined>>;

    /**
     * Submits an unsigned extrinsic to report an equivocation. The caller
     * must provide the equivocation proof and a key ownership proof
     * (should be obtained using `generate_key_ownership_proof`). The
     * extrinsic will be unsigned and should only be accepted for local
     * authorship (not to be broadcast to the network). This method returns
     * `None` when creation of the extrinsic fails, e.g. if equivocation
     * reporting is disabled for the given runtime (i.e. this method is
     * hardcoded to return `None`). Only useful in an offchain context.
     *
     * @callname: BeefyApi_submit_report_equivocation_unsigned_extrinsic
     * @param {SpConsensusBeefyDoubleVotingProof} equivocation_proof
     * @param {SpRuntimeOpaqueValue} key_owner_proof
     **/
    submitReportEquivocationUnsignedExtrinsic: GenericRuntimeApiMethod<
      Rv,
      (
        equivocationProof: SpConsensusBeefyDoubleVotingProof,
        keyOwnerProof: SpRuntimeOpaqueValue,
      ) => Promise<[] | undefined>
    >;

    /**
     * Generates a proof of key ownership for the given authority in the
     * given set. An example usage of this module is coupled with the
     * session historical module to prove that a given authority key is
     * tied to a given staking identity during a specific session. Proofs
     * of key ownership are necessary for submitting equivocation reports.
     * NOTE: even though the API takes a `set_id` as parameter the current
     * implementations ignores this parameter and instead relies on this
     * method being called at the correct block height, i.e. any point at
     * which the given set id is live on-chain. Future implementations will
     * instead use indexed data through an offchain worker, not requiring
     * older states to be available.
     *
     * @callname: BeefyApi_generate_key_ownership_proof
     * @param {bigint} set_id
     * @param {SpConsensusBeefyEcdsaCryptoPublic} authority_id
     **/
    generateKeyOwnershipProof: GenericRuntimeApiMethod<
      Rv,
      (setId: bigint, authorityId: SpConsensusBeefyEcdsaCryptoPublic) => Promise<SpRuntimeOpaqueValue | undefined>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: MmrApi - 0x91d5df18b0d2cf58
   **/
  mmrApi: {
    /**
     * Return the on-chain MMR root hash.
     *
     * @callname: MmrApi_mmr_root
     **/
    mmrRoot: GenericRuntimeApiMethod<Rv, () => Promise<Result<H256, SpMmrPrimitivesError>>>;

    /**
     * Return the number of MMR blocks in the chain.
     *
     * @callname: MmrApi_mmr_leaf_count
     **/
    mmrLeafCount: GenericRuntimeApiMethod<Rv, () => Promise<Result<bigint, SpMmrPrimitivesError>>>;

    /**
     * Generate MMR proof for a series of block numbers. If `best_known_block_number = Some(n)`,
     * use historical MMR state at given block height `n`. Else, use current MMR state.
     *
     * @callname: MmrApi_generate_proof
     * @param {Array<number>} block_numbers
     * @param {number | undefined} best_known_block_number
     **/
    generateProof: GenericRuntimeApiMethod<
      Rv,
      (
        blockNumbers: Array<number>,
        bestKnownBlockNumber?: number | undefined,
      ) => Promise<Result<[Array<SpMmrPrimitivesEncodableOpaqueLeaf>, SpMmrPrimitivesLeafProof], SpMmrPrimitivesError>>
    >;

    /**
     * Verify MMR proof against on-chain MMR for a batch of leaves.
     *
     * Note this function will use on-chain MMR root hash and check if the proof matches the hash.
     * Note, the leaves should be sorted such that corresponding leaves and leaf indices have the
     * same position in both the `leaves` vector and the `leaf_indices` vector contained in the [LeafProof]
     *
     * @callname: MmrApi_verify_proof
     * @param {Array<SpMmrPrimitivesEncodableOpaqueLeaf>} leaves
     * @param {SpMmrPrimitivesLeafProof} proof
     **/
    verifyProof: GenericRuntimeApiMethod<
      Rv,
      (
        leaves: Array<SpMmrPrimitivesEncodableOpaqueLeaf>,
        proof: SpMmrPrimitivesLeafProof,
      ) => Promise<Result<[], SpMmrPrimitivesError>>
    >;

    /**
     * Verify MMR proof against given root hash for a batch of leaves.
     *
     * Note this function does not require any on-chain storage - the
     * proof is verified against given MMR root hash.
     *
     * Note, the leaves should be sorted such that corresponding leaves and leaf indices have the
     * same position in both the `leaves` vector and the `leaf_indices` vector contained in the [LeafProof]
     *
     * @callname: MmrApi_verify_proof_stateless
     * @param {H256} root
     * @param {Array<SpMmrPrimitivesEncodableOpaqueLeaf>} leaves
     * @param {SpMmrPrimitivesLeafProof} proof
     **/
    verifyProofStateless: GenericRuntimeApiMethod<
      Rv,
      (
        root: H256,
        leaves: Array<SpMmrPrimitivesEncodableOpaqueLeaf>,
        proof: SpMmrPrimitivesLeafProof,
      ) => Promise<Result<[], SpMmrPrimitivesError>>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: BeefyMmrApi - 0x2a5e924655399e60
   **/
  beefyMmrApi: {
    /**
     * Return the currently active BEEFY authority set proof.
     *
     * @callname: BeefyMmrApi_authority_set_proof
     **/
    authoritySetProof: GenericRuntimeApiMethod<Rv, () => Promise<SpConsensusBeefyMmrBeefyAuthoritySet>>;

    /**
     * Return the next/queued BEEFY authority set proof.
     *
     * @callname: BeefyMmrApi_next_authority_set_proof
     **/
    nextAuthoritySetProof: GenericRuntimeApiMethod<Rv, () => Promise<SpConsensusBeefyMmrBeefyAuthoritySet>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: GrandpaApi - 0xed99c5acb25eedf5
   **/
  grandpaApi: {
    /**
     * Get the current GRANDPA authorities and weights. This should not change except
     * for when changes are scheduled and the corresponding delay has passed.
     *
     * When called at block B, it will return the set of authorities that should be
     * used to finalize descendants of this block (B+1, B+2, ...). The block B itself
     * is finalized by the authorities from block B-1.
     *
     * @callname: GrandpaApi_grandpa_authorities
     **/
    grandpaAuthorities: GenericRuntimeApiMethod<Rv, () => Promise<Array<[SpConsensusGrandpaAppPublic, bigint]>>>;

    /**
     * Submits an unsigned extrinsic to report an equivocation. The caller
     * must provide the equivocation proof and a key ownership proof
     * (should be obtained using `generate_key_ownership_proof`). The
     * extrinsic will be unsigned and should only be accepted for local
     * authorship (not to be broadcast to the network). This method returns
     * `None` when creation of the extrinsic fails, e.g. if equivocation
     * reporting is disabled for the given runtime (i.e. this method is
     * hardcoded to return `None`). Only useful in an offchain context.
     *
     * @callname: GrandpaApi_submit_report_equivocation_unsigned_extrinsic
     * @param {SpConsensusGrandpaEquivocationProof} equivocation_proof
     * @param {SpRuntimeOpaqueValue} key_owner_proof
     **/
    submitReportEquivocationUnsignedExtrinsic: GenericRuntimeApiMethod<
      Rv,
      (
        equivocationProof: SpConsensusGrandpaEquivocationProof,
        keyOwnerProof: SpRuntimeOpaqueValue,
      ) => Promise<[] | undefined>
    >;

    /**
     * Generates a proof of key ownership for the given authority in the
     * given set. An example usage of this module is coupled with the
     * session historical module to prove that a given authority key is
     * tied to a given staking identity during a specific session. Proofs
     * of key ownership are necessary for submitting equivocation reports.
     * NOTE: even though the API takes a `set_id` as parameter the current
     * implementations ignore this parameter and instead rely on this
     * method being called at the correct block height, i.e. any point at
     * which the given set id is live on-chain. Future implementations will
     * instead use indexed data through an offchain worker, not requiring
     * older states to be available.
     *
     * @callname: GrandpaApi_generate_key_ownership_proof
     * @param {bigint} set_id
     * @param {SpConsensusGrandpaAppPublic} authority_id
     **/
    generateKeyOwnershipProof: GenericRuntimeApiMethod<
      Rv,
      (setId: bigint, authorityId: SpConsensusGrandpaAppPublic) => Promise<SpRuntimeOpaqueValue | undefined>
    >;

    /**
     * Get current GRANDPA authority set id.
     *
     * @callname: GrandpaApi_current_set_id
     **/
    currentSetId: GenericRuntimeApiMethod<Rv, () => Promise<bigint>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: BabeApi - 0xcbca25e39f142387
   **/
  babeApi: {
    /**
     * Return the configuration for BABE.
     *
     * @callname: BabeApi_configuration
     **/
    configuration: GenericRuntimeApiMethod<Rv, () => Promise<SpConsensusBabeBabeConfiguration>>;

    /**
     * Returns the slot that started the current epoch.
     *
     * @callname: BabeApi_current_epoch_start
     **/
    currentEpochStart: GenericRuntimeApiMethod<Rv, () => Promise<SpConsensusSlotsSlot>>;

    /**
     * Returns information regarding the current epoch.
     *
     * @callname: BabeApi_current_epoch
     **/
    currentEpoch: GenericRuntimeApiMethod<Rv, () => Promise<SpConsensusBabeEpoch>>;

    /**
     * Returns information regarding the next epoch (which was already
     * previously announced).
     *
     * @callname: BabeApi_next_epoch
     **/
    nextEpoch: GenericRuntimeApiMethod<Rv, () => Promise<SpConsensusBabeEpoch>>;

    /**
     * Generates a proof of key ownership for the given authority in the
     * current epoch. An example usage of this module is coupled with the
     * session historical module to prove that a given authority key is
     * tied to a given staking identity during a specific session. Proofs
     * of key ownership are necessary for submitting equivocation reports.
     * NOTE: even though the API takes a `slot` as parameter the current
     * implementations ignores this parameter and instead relies on this
     * method being called at the correct block height, i.e. any point at
     * which the epoch for the given slot is live on-chain. Future
     * implementations will instead use indexed data through an offchain
     * worker, not requiring older states to be available.
     *
     * @callname: BabeApi_generate_key_ownership_proof
     * @param {SpConsensusSlotsSlot} slot
     * @param {SpConsensusBabeAppPublic} authority_id
     **/
    generateKeyOwnershipProof: GenericRuntimeApiMethod<
      Rv,
      (
        slot: SpConsensusSlotsSlot,
        authorityId: SpConsensusBabeAppPublic,
      ) => Promise<SpConsensusBabeOpaqueKeyOwnershipProof | undefined>
    >;

    /**
     * Submits an unsigned extrinsic to report an equivocation. The caller
     * must provide the equivocation proof and a key ownership proof
     * (should be obtained using `generate_key_ownership_proof`). The
     * extrinsic will be unsigned and should only be accepted for local
     * authorship (not to be broadcast to the network). This method returns
     * `None` when creation of the extrinsic fails, e.g. if equivocation
     * reporting is disabled for the given runtime (i.e. this method is
     * hardcoded to return `None`). Only useful in an offchain context.
     *
     * @callname: BabeApi_submit_report_equivocation_unsigned_extrinsic
     * @param {SpConsensusSlotsEquivocationProof} equivocation_proof
     * @param {SpConsensusBabeOpaqueKeyOwnershipProof} key_owner_proof
     **/
    submitReportEquivocationUnsignedExtrinsic: GenericRuntimeApiMethod<
      Rv,
      (
        equivocationProof: SpConsensusSlotsEquivocationProof,
        keyOwnerProof: SpConsensusBabeOpaqueKeyOwnershipProof,
      ) => Promise<[] | undefined>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: AuthorityDiscoveryApi - 0x687ad44ad37f03c2
   **/
  authorityDiscoveryApi: {
    /**
     * Retrieve authority identifiers of the current and next authority set.
     *
     * @callname: AuthorityDiscoveryApi_authorities
     **/
    authorities: GenericRuntimeApiMethod<Rv, () => Promise<Array<SpAuthorityDiscoveryAppPublic>>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: SessionKeys - 0xab3c0572291feb8b
   **/
  sessionKeys: {
    /**
     * Generate a set of session keys with optionally using the given seed.
     * The keys should be stored within the keystore exposed via runtime
     * externalities.
     *
     * The seed needs to be a valid `utf8` string.
     *
     * Returns the concatenated SCALE encoded public keys.
     *
     * @callname: SessionKeys_generate_session_keys
     * @param {BytesLike | undefined} seed
     **/
    generateSessionKeys: GenericRuntimeApiMethod<Rv, (seed?: BytesLike | undefined) => Promise<Bytes>>;

    /**
     * Decode the given public session keys.
     *
     * Returns the list of public raw public keys + key type.
     *
     * @callname: SessionKeys_decode_session_keys
     * @param {BytesLike} encoded
     **/
    decodeSessionKeys: GenericRuntimeApiMethod<
      Rv,
      (encoded: BytesLike) => Promise<Array<[Bytes, SpCoreCryptoKeyTypeId]> | undefined>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: AccountNonceApi - 0xbc9d89904f5b923f
   **/
  accountNonceApi: {
    /**
     * Get current account nonce of given `AccountId`.
     *
     * @callname: AccountNonceApi_account_nonce
     * @param {AccountId32Like} account
     **/
    accountNonce: GenericRuntimeApiMethod<Rv, (account: AccountId32Like) => Promise<number>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: TransactionPaymentApi - 0x37c8bb1350a9a2a8
   **/
  transactionPaymentApi: {
    /**
     *
     * @callname: TransactionPaymentApi_query_info
     * @param {UncheckedExtrinsicLike} uxt
     * @param {number} len
     **/
    queryInfo: GenericRuntimeApiMethod<
      Rv,
      (uxt: UncheckedExtrinsicLike, len: number) => Promise<PalletTransactionPaymentRuntimeDispatchInfo>
    >;

    /**
     *
     * @callname: TransactionPaymentApi_query_fee_details
     * @param {UncheckedExtrinsicLike} uxt
     * @param {number} len
     **/
    queryFeeDetails: GenericRuntimeApiMethod<
      Rv,
      (uxt: UncheckedExtrinsicLike, len: number) => Promise<PalletTransactionPaymentFeeDetails>
    >;

    /**
     *
     * @callname: TransactionPaymentApi_query_weight_to_fee
     * @param {SpWeightsWeightV2Weight} weight
     **/
    queryWeightToFee: GenericRuntimeApiMethod<Rv, (weight: SpWeightsWeightV2Weight) => Promise<bigint>>;

    /**
     *
     * @callname: TransactionPaymentApi_query_length_to_fee
     * @param {number} length
     **/
    queryLengthToFee: GenericRuntimeApiMethod<Rv, (length: number) => Promise<bigint>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: TransactionPaymentCallApi - 0xf3ff14d5ab527059
   **/
  transactionPaymentCallApi: {
    /**
     * Query information of a dispatch class, weight, and fee of a given encoded `Call`.
     *
     * @callname: TransactionPaymentCallApi_query_call_info
     * @param {PolkadotRuntimeRuntimeCallLike} call
     * @param {number} len
     **/
    queryCallInfo: GenericRuntimeApiMethod<
      Rv,
      (call: PolkadotRuntimeRuntimeCallLike, len: number) => Promise<PalletTransactionPaymentRuntimeDispatchInfo>
    >;

    /**
     * Query fee details of a given encoded `Call`.
     *
     * @callname: TransactionPaymentCallApi_query_call_fee_details
     * @param {PolkadotRuntimeRuntimeCallLike} call
     * @param {number} len
     **/
    queryCallFeeDetails: GenericRuntimeApiMethod<
      Rv,
      (call: PolkadotRuntimeRuntimeCallLike, len: number) => Promise<PalletTransactionPaymentFeeDetails>
    >;

    /**
     * Query the output of the current `WeightToFee` given some input.
     *
     * @callname: TransactionPaymentCallApi_query_weight_to_fee
     * @param {SpWeightsWeightV2Weight} weight
     **/
    queryWeightToFee: GenericRuntimeApiMethod<Rv, (weight: SpWeightsWeightV2Weight) => Promise<bigint>>;

    /**
     * Query the output of the current `LengthToFee` given some input.
     *
     * @callname: TransactionPaymentCallApi_query_length_to_fee
     * @param {number} length
     **/
    queryLengthToFee: GenericRuntimeApiMethod<Rv, (length: number) => Promise<bigint>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: XcmPaymentApi - 0x6ff52ee858e6c5bd
   **/
  xcmPaymentApi: {
    /**
     * Returns a list of acceptable payment assets.
     *
     * # Arguments
     *
     * * `xcm_version`: Version.
     *
     * @callname: XcmPaymentApi_query_acceptable_payment_assets
     * @param {number} xcm_version
     **/
    queryAcceptablePaymentAssets: GenericRuntimeApiMethod<
      Rv,
      (xcmVersion: number) => Promise<Result<Array<XcmVersionedAssetId>, XcmRuntimeApisFeesError>>
    >;

    /**
     * Returns a weight needed to execute a XCM.
     *
     * # Arguments
     *
     * * `message`: `VersionedXcm`.
     *
     * @callname: XcmPaymentApi_query_xcm_weight
     * @param {XcmVersionedXcm} message
     **/
    queryXcmWeight: GenericRuntimeApiMethod<
      Rv,
      (message: XcmVersionedXcm) => Promise<Result<SpWeightsWeightV2Weight, XcmRuntimeApisFeesError>>
    >;

    /**
     * Converts a weight into a fee for the specified `AssetId`.
     *
     * # Arguments
     *
     * * `weight`: convertible `Weight`.
     * * `asset`: `VersionedAssetId`.
     *
     * @callname: XcmPaymentApi_query_weight_to_asset_fee
     * @param {SpWeightsWeightV2Weight} weight
     * @param {XcmVersionedAssetId} asset
     **/
    queryWeightToAssetFee: GenericRuntimeApiMethod<
      Rv,
      (weight: SpWeightsWeightV2Weight, asset: XcmVersionedAssetId) => Promise<Result<bigint, XcmRuntimeApisFeesError>>
    >;

    /**
     * Get delivery fees for sending a specific `message` to a `destination`.
     * These always come in a specific asset, defined by the chain.
     *
     * # Arguments
     * * `message`: The message that'll be sent, necessary because most delivery fees are based on the
     * size of the message.
     * * `destination`: The destination to send the message to. Different destinations may use
     * different senders that charge different fees.
     *
     * @callname: XcmPaymentApi_query_delivery_fees
     * @param {XcmVersionedLocation} destination
     * @param {XcmVersionedXcm} message
     **/
    queryDeliveryFees: GenericRuntimeApiMethod<
      Rv,
      (
        destination: XcmVersionedLocation,
        message: XcmVersionedXcm,
      ) => Promise<Result<XcmVersionedAssets, XcmRuntimeApisFeesError>>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: DryRunApi - 0x91b1c8b16328eb92
   **/
  dryRunApi: {
    /**
     * Dry run call.
     *
     * @callname: DryRunApi_dry_run_call
     * @param {PolkadotRuntimeOriginCaller} origin
     * @param {PolkadotRuntimeRuntimeCallLike} call
     **/
    dryRunCall: GenericRuntimeApiMethod<
      Rv,
      (
        origin: PolkadotRuntimeOriginCaller,
        call: PolkadotRuntimeRuntimeCallLike,
      ) => Promise<Result<XcmRuntimeApisDryRunCallDryRunEffects, XcmRuntimeApisDryRunError>>
    >;

    /**
     * Dry run XCM program
     *
     * @callname: DryRunApi_dry_run_xcm
     * @param {XcmVersionedLocation} origin_location
     * @param {XcmVersionedXcm} xcm
     **/
    dryRunXcm: GenericRuntimeApiMethod<
      Rv,
      (
        originLocation: XcmVersionedLocation,
        xcm: XcmVersionedXcm,
      ) => Promise<Result<XcmRuntimeApisDryRunXcmDryRunEffects, XcmRuntimeApisDryRunError>>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: LocationToAccountApi - 0x9ffb505aa738d69c
   **/
  locationToAccountApi: {
    /**
     * Converts `Location` to `AccountId`.
     *
     * @callname: LocationToAccountApi_convert_location
     * @param {XcmVersionedLocation} location
     **/
    convertLocation: GenericRuntimeApiMethod<
      Rv,
      (location: XcmVersionedLocation) => Promise<Result<AccountId32, XcmRuntimeApisConversionsError>>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: GenesisBuilder - 0xfbc577b9d747efd6
   **/
  genesisBuilder: {
    /**
     * Build `RuntimeGenesisConfig` from a JSON blob not using any defaults and store it in the
     * storage.
     *
     * In the case of a FRAME-based runtime, this function deserializes the full `RuntimeGenesisConfig` from the given JSON blob and
     * puts it into the storage. If the provided JSON blob is incorrect or incomplete or the
     * deserialization fails, an error is returned.
     *
     * Please note that provided JSON blob must contain all `RuntimeGenesisConfig` fields, no
     * defaults will be used.
     *
     * @callname: GenesisBuilder_build_state
     * @param {BytesLike} json
     **/
    buildState: GenericRuntimeApiMethod<Rv, (json: BytesLike) => Promise<Result<[], string>>>;

    /**
     * Returns a JSON blob representation of the built-in `RuntimeGenesisConfig` identified by
     * `id`.
     *
     * If `id` is `None` the function returns JSON blob representation of the default
     * `RuntimeGenesisConfig` struct of the runtime. Implementation must provide default
     * `RuntimeGenesisConfig`.
     *
     * Otherwise function returns a JSON representation of the built-in, named
     * `RuntimeGenesisConfig` preset identified by `id`, or `None` if such preset does not
     * exists. Returned `Vec<u8>` contains bytes of JSON blob (patch) which comprises a list of
     * (potentially nested) key-value pairs that are intended for customizing the default
     * runtime genesis config. The patch shall be merged (rfc7386) with the JSON representation
     * of the default `RuntimeGenesisConfig` to create a comprehensive genesis config that can
     * be used in `build_state` method.
     *
     * @callname: GenesisBuilder_get_preset
     * @param {string | undefined} id
     **/
    getPreset: GenericRuntimeApiMethod<Rv, (id?: string | undefined) => Promise<Bytes | undefined>>;

    /**
     * Returns a list of identifiers for available builtin `RuntimeGenesisConfig` presets.
     *
     * The presets from the list can be queried with [`GenesisBuilder::get_preset`] method. If
     * no named presets are provided by the runtime the list is empty.
     *
     * @callname: GenesisBuilder_preset_names
     **/
    presetNames: GenericRuntimeApiMethod<Rv, () => Promise<Array<string>>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
}
