// Generated by dedot cli

import type {
  Phase,
  H256,
  DispatchInfo,
  DispatchError,
  AccountId32,
  Result,
  FixedBytes,
  Perquintill,
  H160,
  Bytes,
  FixedU128,
  U256,
  BytesLike,
  MultiAddress,
  Data,
  MultiAddressLike,
  AccountId32Like,
  Permill,
  Era,
  Header,
  UncheckedExtrinsic,
} from 'dedot/codecs';

export type FrameSystemAccountInfo = {
  nonce: number;
  consumers: number;
  providers: number;
  sufficients: number;
  data: PalletBalancesAccountData;
};

export type PalletBalancesAccountData = {
  free: bigint;
  reserved: bigint;
  frozen: bigint;
  flags: PalletBalancesExtraFlags;
};

export type PalletBalancesExtraFlags = bigint;

export type FrameSupportDispatchPerDispatchClass = {
  normal: SpWeightsWeightV2Weight;
  operational: SpWeightsWeightV2Weight;
  mandatory: SpWeightsWeightV2Weight;
};

export type SpWeightsWeightV2Weight = { refTime: bigint; proofSize: bigint };

export type FrameSystemEventRecord = { phase: Phase; event: AstarRuntimeRuntimeEvent; topics: Array<H256> };

export type AstarRuntimeRuntimeEvent =
  | { pallet: 'System'; palletEvent: FrameSystemEvent }
  | { pallet: 'Utility'; palletEvent: PalletUtilityEvent }
  | { pallet: 'Identity'; palletEvent: PalletIdentityEvent }
  | { pallet: 'Multisig'; palletEvent: PalletMultisigEvent }
  | { pallet: 'Proxy'; palletEvent: PalletProxyEvent }
  | { pallet: 'ParachainSystem'; palletEvent: CumulusPalletParachainSystemEvent }
  | { pallet: 'TransactionPayment'; palletEvent: PalletTransactionPaymentEvent }
  | { pallet: 'Balances'; palletEvent: PalletBalancesEvent }
  | { pallet: 'Vesting'; palletEvent: PalletVestingEvent }
  | { pallet: 'Inflation'; palletEvent: PalletInflationEvent }
  | { pallet: 'DappStaking'; palletEvent: PalletDappStakingV3Event }
  | { pallet: 'Assets'; palletEvent: PalletAssetsEvent }
  | { pallet: 'PriceAggregator'; palletEvent: PalletPriceAggregatorEvent }
  | { pallet: 'Oracle'; palletEvent: OrmlOracleModuleEvent }
  | { pallet: 'OracleMembership'; palletEvent: PalletMembershipEvent }
  | { pallet: 'CollatorSelection'; palletEvent: PalletCollatorSelectionEvent }
  | { pallet: 'Session'; palletEvent: PalletSessionEvent }
  | { pallet: 'XcmpQueue'; palletEvent: CumulusPalletXcmpQueueEvent }
  | { pallet: 'PolkadotXcm'; palletEvent: PalletXcmEvent }
  | { pallet: 'CumulusXcm'; palletEvent: CumulusPalletXcmEvent }
  | { pallet: 'DmpQueue'; palletEvent: CumulusPalletDmpQueueEvent }
  | { pallet: 'XcAssetConfig'; palletEvent: PalletXcAssetConfigEvent }
  | { pallet: 'XTokens'; palletEvent: OrmlXtokensModuleEvent }
  | { pallet: 'Evm'; palletEvent: PalletEvmEvent }
  | { pallet: 'Ethereum'; palletEvent: PalletEthereumEvent }
  | { pallet: 'DynamicEvmBaseFee'; palletEvent: PalletDynamicEvmBaseFeeEvent }
  | { pallet: 'Contracts'; palletEvent: PalletContractsEvent }
  | { pallet: 'Sudo'; palletEvent: PalletSudoEvent };

/**
 * Event for the System pallet.
 **/
export type FrameSystemEvent =
  /**
   * An extrinsic completed successfully.
   **/
  | { name: 'ExtrinsicSuccess'; data: { dispatchInfo: DispatchInfo } }
  /**
   * An extrinsic failed.
   **/
  | { name: 'ExtrinsicFailed'; data: { dispatchError: DispatchError; dispatchInfo: DispatchInfo } }
  /**
   * `:code` was updated.
   **/
  | { name: 'CodeUpdated' }
  /**
   * A new account was created.
   **/
  | { name: 'NewAccount'; data: { account: AccountId32 } }
  /**
   * An account was reaped.
   **/
  | { name: 'KilledAccount'; data: { account: AccountId32 } }
  /**
   * On on-chain remark happened.
   **/
  | { name: 'Remarked'; data: { sender: AccountId32; hash: H256 } };

export type FrameSupportDispatchDispatchClass = 'Normal' | 'Operational' | 'Mandatory';

export type FrameSupportDispatchPays = 'Yes' | 'No';

/**
 * The `Event` enum of this pallet
 **/
export type PalletUtilityEvent =
  /**
   * Batch of dispatches did not complete fully. Index of first failing dispatch given, as
   * well as the error.
   **/
  | { name: 'BatchInterrupted'; data: { index: number; error: DispatchError } }
  /**
   * Batch of dispatches completed fully with no error.
   **/
  | { name: 'BatchCompleted' }
  /**
   * Batch of dispatches completed but has errors.
   **/
  | { name: 'BatchCompletedWithErrors' }
  /**
   * A single item within a Batch of dispatches has completed with no error.
   **/
  | { name: 'ItemCompleted' }
  /**
   * A single item within a Batch of dispatches has completed with error.
   **/
  | { name: 'ItemFailed'; data: { error: DispatchError } }
  /**
   * A call was dispatched.
   **/
  | { name: 'DispatchedAs'; data: { result: Result<[], DispatchError> } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletIdentityEvent =
  /**
   * A name was set or reset (which will remove all judgements).
   **/
  | { name: 'IdentitySet'; data: { who: AccountId32 } }
  /**
   * A name was cleared, and the given balance returned.
   **/
  | { name: 'IdentityCleared'; data: { who: AccountId32; deposit: bigint } }
  /**
   * A name was removed and the given balance slashed.
   **/
  | { name: 'IdentityKilled'; data: { who: AccountId32; deposit: bigint } }
  /**
   * A judgement was asked from a registrar.
   **/
  | { name: 'JudgementRequested'; data: { who: AccountId32; registrarIndex: number } }
  /**
   * A judgement request was retracted.
   **/
  | { name: 'JudgementUnrequested'; data: { who: AccountId32; registrarIndex: number } }
  /**
   * A judgement was given by a registrar.
   **/
  | { name: 'JudgementGiven'; data: { target: AccountId32; registrarIndex: number } }
  /**
   * A registrar was added.
   **/
  | { name: 'RegistrarAdded'; data: { registrarIndex: number } }
  /**
   * A sub-identity was added to an identity and the deposit paid.
   **/
  | { name: 'SubIdentityAdded'; data: { sub: AccountId32; main: AccountId32; deposit: bigint } }
  /**
   * A sub-identity was removed from an identity and the deposit freed.
   **/
  | { name: 'SubIdentityRemoved'; data: { sub: AccountId32; main: AccountId32; deposit: bigint } }
  /**
   * A sub-identity was cleared, and the given deposit repatriated from the
   * main identity account to the sub-identity account.
   **/
  | { name: 'SubIdentityRevoked'; data: { sub: AccountId32; main: AccountId32; deposit: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletMultisigEvent =
  /**
   * A new multisig operation has begun.
   **/
  | { name: 'NewMultisig'; data: { approving: AccountId32; multisig: AccountId32; callHash: FixedBytes<32> } }
  /**
   * A multisig operation has been approved by someone.
   **/
  | {
      name: 'MultisigApproval';
      data: {
        approving: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
      };
    }
  /**
   * A multisig operation has been executed.
   **/
  | {
      name: 'MultisigExecuted';
      data: {
        approving: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
        result: Result<[], DispatchError>;
      };
    }
  /**
   * A multisig operation has been cancelled.
   **/
  | {
      name: 'MultisigCancelled';
      data: {
        cancelling: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
      };
    };

export type PalletMultisigTimepoint = { height: number; index: number };

/**
 * The `Event` enum of this pallet
 **/
export type PalletProxyEvent =
  /**
   * A proxy was executed correctly, with the given.
   **/
  | { name: 'ProxyExecuted'; data: { result: Result<[], DispatchError> } }
  /**
   * A pure account has been created by new proxy with given
   * disambiguation index and proxy type.
   **/
  | {
      name: 'PureCreated';
      data: { pure: AccountId32; who: AccountId32; proxyType: AstarRuntimeProxyType; disambiguationIndex: number };
    }
  /**
   * An announcement was placed to make a call in the future.
   **/
  | { name: 'Announced'; data: { real: AccountId32; proxy: AccountId32; callHash: H256 } }
  /**
   * A proxy was added.
   **/
  | {
      name: 'ProxyAdded';
      data: { delegator: AccountId32; delegatee: AccountId32; proxyType: AstarRuntimeProxyType; delay: number };
    }
  /**
   * A proxy was removed.
   **/
  | {
      name: 'ProxyRemoved';
      data: { delegator: AccountId32; delegatee: AccountId32; proxyType: AstarRuntimeProxyType; delay: number };
    };

export type AstarRuntimeProxyType =
  | 'Any'
  | 'NonTransfer'
  | 'Balances'
  | 'Assets'
  | 'IdentityJudgement'
  | 'CancelProxy'
  | 'DappStaking'
  | 'StakerRewardClaim';

/**
 * The `Event` enum of this pallet
 **/
export type CumulusPalletParachainSystemEvent =
  /**
   * The validation function has been scheduled to apply.
   **/
  | { name: 'ValidationFunctionStored' }
  /**
   * The validation function was applied as of the contained relay chain block number.
   **/
  | { name: 'ValidationFunctionApplied'; data: { relayChainBlockNum: number } }
  /**
   * The relay-chain aborted the upgrade process.
   **/
  | { name: 'ValidationFunctionDiscarded' }
  /**
   * An upgrade has been authorized.
   **/
  | { name: 'UpgradeAuthorized'; data: { codeHash: H256 } }
  /**
   * Some downward messages have been received and will be processed.
   **/
  | { name: 'DownwardMessagesReceived'; data: { count: number } }
  /**
   * Downward messages were processed using the given weight.
   **/
  | { name: 'DownwardMessagesProcessed'; data: { weightUsed: SpWeightsWeightV2Weight; dmqHead: H256 } }
  /**
   * An upward message was sent to the relay chain.
   **/
  | { name: 'UpwardMessageSent'; data: { messageHash?: FixedBytes<32> | undefined } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletTransactionPaymentEvent =
  /**
   * A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,
   * has been paid by `who`.
   **/
  { name: 'TransactionFeePaid'; data: { who: AccountId32; actualFee: bigint; tip: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletBalancesEvent =
  /**
   * An account was created with some free balance.
   **/
  | { name: 'Endowed'; data: { account: AccountId32; freeBalance: bigint } }
  /**
   * An account was removed whose balance was non-zero but below ExistentialDeposit,
   * resulting in an outright loss.
   **/
  | { name: 'DustLost'; data: { account: AccountId32; amount: bigint } }
  /**
   * Transfer succeeded.
   **/
  | { name: 'Transfer'; data: { from: AccountId32; to: AccountId32; amount: bigint } }
  /**
   * A balance was set by root.
   **/
  | { name: 'BalanceSet'; data: { who: AccountId32; free: bigint } }
  /**
   * Some balance was reserved (moved from free to reserved).
   **/
  | { name: 'Reserved'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was unreserved (moved from reserved to free).
   **/
  | { name: 'Unreserved'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was moved from the reserve of the first account to the second account.
   * Final argument indicates the destination balance type.
   **/
  | {
      name: 'ReserveRepatriated';
      data: {
        from: AccountId32;
        to: AccountId32;
        amount: bigint;
        destinationStatus: FrameSupportTokensMiscBalanceStatus;
      };
    }
  /**
   * Some amount was deposited (e.g. for transaction fees).
   **/
  | { name: 'Deposit'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was withdrawn from the account (e.g. for transaction fees).
   **/
  | { name: 'Withdraw'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was removed from the account (e.g. for misbehavior).
   **/
  | { name: 'Slashed'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was minted into an account.
   **/
  | { name: 'Minted'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was burned from an account.
   **/
  | { name: 'Burned'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was suspended from an account (it can be restored later).
   **/
  | { name: 'Suspended'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was restored into an account.
   **/
  | { name: 'Restored'; data: { who: AccountId32; amount: bigint } }
  /**
   * An account was upgraded.
   **/
  | { name: 'Upgraded'; data: { who: AccountId32 } }
  /**
   * Total issuance was increased by `amount`, creating a credit to be balanced.
   **/
  | { name: 'Issued'; data: { amount: bigint } }
  /**
   * Total issuance was decreased by `amount`, creating a debt to be balanced.
   **/
  | { name: 'Rescinded'; data: { amount: bigint } }
  /**
   * Some balance was locked.
   **/
  | { name: 'Locked'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was unlocked.
   **/
  | { name: 'Unlocked'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was frozen.
   **/
  | { name: 'Frozen'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was thawed.
   **/
  | { name: 'Thawed'; data: { who: AccountId32; amount: bigint } };

export type FrameSupportTokensMiscBalanceStatus = 'Free' | 'Reserved';

/**
 * The `Event` enum of this pallet
 **/
export type PalletVestingEvent =
  /**
   * The amount vested has been updated. This could indicate a change in funds available.
   * The balance given is the amount which is left unvested (and thus locked).
   **/
  | { name: 'VestingUpdated'; data: { account: AccountId32; unvested: bigint } }
  /**
   * An \[account\] has become fully vested.
   **/
  | { name: 'VestingCompleted'; data: { account: AccountId32 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletInflationEvent =
  /**
   * Inflation parameters have been force changed. This will have effect on the next inflation recalculation.
   **/
  | { name: 'InflationParametersForceChanged' }
  /**
   * Inflation configuration has been force changed. This will have an immediate effect from this block.
   **/
  | { name: 'InflationConfigurationForceChanged'; data: { config: PalletInflationInflationConfiguration } }
  /**
   * Inflation recalculation has been forced.
   **/
  | { name: 'ForcedInflationRecalculation'; data: { config: PalletInflationInflationConfiguration } }
  /**
   * New inflation configuration has been set.
   **/
  | { name: 'NewInflationConfiguration'; data: { config: PalletInflationInflationConfiguration } };

export type PalletInflationInflationConfiguration = {
  recalculationEra: number;
  issuanceSafetyCap: bigint;
  collatorRewardPerBlock: bigint;
  treasuryRewardPerBlock: bigint;
  dappRewardPoolPerEra: bigint;
  baseStakerRewardPoolPerEra: bigint;
  adjustableStakerRewardPoolPerEra: bigint;
  bonusRewardPoolPerPeriod: bigint;
  idealStakingRate: Perquintill;
};

/**
 * The `Event` enum of this pallet
 **/
export type PalletDappStakingV3Event =
  /**
   * Maintenance mode has been either enabled or disabled.
   **/
  | { name: 'MaintenanceMode'; data: { enabled: boolean } }
  /**
   * New era has started.
   **/
  | { name: 'NewEra'; data: { era: number } }
  /**
   * New subperiod has started.
   **/
  | { name: 'NewSubperiod'; data: { subperiod: PalletDappStakingV3Subperiod; number: number } }
  /**
   * A smart contract has been registered for dApp staking
   **/
  | {
      name: 'DAppRegistered';
      data: { owner: AccountId32; smartContract: AstarPrimitivesDappStakingSmartContract; dappId: number };
    }
  /**
   * dApp reward destination has been updated.
   **/
  | {
      name: 'DAppRewardDestinationUpdated';
      data: { smartContract: AstarPrimitivesDappStakingSmartContract; beneficiary?: AccountId32 | undefined };
    }
  /**
   * dApp owner has been changed.
   **/
  | {
      name: 'DAppOwnerChanged';
      data: { smartContract: AstarPrimitivesDappStakingSmartContract; newOwner: AccountId32 };
    }
  /**
   * dApp has been unregistered
   **/
  | { name: 'DAppUnregistered'; data: { smartContract: AstarPrimitivesDappStakingSmartContract; era: number } }
  /**
   * Account has locked some amount into dApp staking.
   **/
  | { name: 'Locked'; data: { account: AccountId32; amount: bigint } }
  /**
   * Account has started the unlocking process for some amount.
   **/
  | { name: 'Unlocking'; data: { account: AccountId32; amount: bigint } }
  /**
   * Account has claimed unlocked amount, removing the lock from it.
   **/
  | { name: 'ClaimedUnlocked'; data: { account: AccountId32; amount: bigint } }
  /**
   * Account has relocked all of the unlocking chunks.
   **/
  | { name: 'Relock'; data: { account: AccountId32; amount: bigint } }
  /**
   * Account has staked some amount on a smart contract.
   **/
  | {
      name: 'Stake';
      data: { account: AccountId32; smartContract: AstarPrimitivesDappStakingSmartContract; amount: bigint };
    }
  /**
   * Account has unstaked some amount from a smart contract.
   **/
  | {
      name: 'Unstake';
      data: { account: AccountId32; smartContract: AstarPrimitivesDappStakingSmartContract; amount: bigint };
    }
  /**
   * Account has claimed some stake rewards.
   **/
  | { name: 'Reward'; data: { account: AccountId32; era: number; amount: bigint } }
  /**
   * Bonus reward has been paid out to a loyal staker.
   **/
  | {
      name: 'BonusReward';
      data: {
        account: AccountId32;
        smartContract: AstarPrimitivesDappStakingSmartContract;
        period: number;
        amount: bigint;
      };
    }
  /**
   * dApp reward has been paid out to a beneficiary.
   **/
  | {
      name: 'DAppReward';
      data: {
        beneficiary: AccountId32;
        smartContract: AstarPrimitivesDappStakingSmartContract;
        tierId: number;
        rank: number;
        era: number;
        amount: bigint;
      };
    }
  /**
   * Account has unstaked funds from an unregistered smart contract
   **/
  | {
      name: 'UnstakeFromUnregistered';
      data: { account: AccountId32; smartContract: AstarPrimitivesDappStakingSmartContract; amount: bigint };
    }
  /**
   * Some expired stake entries have been removed from storage.
   **/
  | { name: 'ExpiredEntriesRemoved'; data: { account: AccountId32; count: number } }
  /**
   * Privileged origin has forced a new era and possibly a subperiod to start from next block.
   **/
  | { name: 'Force'; data: { forcingType: PalletDappStakingV3ForcingType } };

export type PalletDappStakingV3Subperiod = 'Voting' | 'BuildAndEarn';

export type AstarPrimitivesDappStakingSmartContract =
  | { type: 'Evm'; value: H160 }
  | { type: 'Wasm'; value: AccountId32 };

export type PalletDappStakingV3ForcingType = 'Era' | 'Subperiod';

/**
 * The `Event` enum of this pallet
 **/
export type PalletAssetsEvent =
  /**
   * Some asset class was created.
   **/
  | { name: 'Created'; data: { assetId: bigint; creator: AccountId32; owner: AccountId32 } }
  /**
   * Some assets were issued.
   **/
  | { name: 'Issued'; data: { assetId: bigint; owner: AccountId32; amount: bigint } }
  /**
   * Some assets were transferred.
   **/
  | { name: 'Transferred'; data: { assetId: bigint; from: AccountId32; to: AccountId32; amount: bigint } }
  /**
   * Some assets were destroyed.
   **/
  | { name: 'Burned'; data: { assetId: bigint; owner: AccountId32; balance: bigint } }
  /**
   * The management team changed.
   **/
  | { name: 'TeamChanged'; data: { assetId: bigint; issuer: AccountId32; admin: AccountId32; freezer: AccountId32 } }
  /**
   * The owner changed.
   **/
  | { name: 'OwnerChanged'; data: { assetId: bigint; owner: AccountId32 } }
  /**
   * Some account `who` was frozen.
   **/
  | { name: 'Frozen'; data: { assetId: bigint; who: AccountId32 } }
  /**
   * Some account `who` was thawed.
   **/
  | { name: 'Thawed'; data: { assetId: bigint; who: AccountId32 } }
  /**
   * Some asset `asset_id` was frozen.
   **/
  | { name: 'AssetFrozen'; data: { assetId: bigint } }
  /**
   * Some asset `asset_id` was thawed.
   **/
  | { name: 'AssetThawed'; data: { assetId: bigint } }
  /**
   * Accounts were destroyed for given asset.
   **/
  | { name: 'AccountsDestroyed'; data: { assetId: bigint; accountsDestroyed: number; accountsRemaining: number } }
  /**
   * Approvals were destroyed for given asset.
   **/
  | { name: 'ApprovalsDestroyed'; data: { assetId: bigint; approvalsDestroyed: number; approvalsRemaining: number } }
  /**
   * An asset class is in the process of being destroyed.
   **/
  | { name: 'DestructionStarted'; data: { assetId: bigint } }
  /**
   * An asset class was destroyed.
   **/
  | { name: 'Destroyed'; data: { assetId: bigint } }
  /**
   * Some asset class was force-created.
   **/
  | { name: 'ForceCreated'; data: { assetId: bigint; owner: AccountId32 } }
  /**
   * New metadata has been set for an asset.
   **/
  | { name: 'MetadataSet'; data: { assetId: bigint; name: Bytes; symbol: Bytes; decimals: number; isFrozen: boolean } }
  /**
   * Metadata has been cleared for an asset.
   **/
  | { name: 'MetadataCleared'; data: { assetId: bigint } }
  /**
   * (Additional) funds have been approved for transfer to a destination account.
   **/
  | { name: 'ApprovedTransfer'; data: { assetId: bigint; source: AccountId32; delegate: AccountId32; amount: bigint } }
  /**
   * An approval for account `delegate` was cancelled by `owner`.
   **/
  | { name: 'ApprovalCancelled'; data: { assetId: bigint; owner: AccountId32; delegate: AccountId32 } }
  /**
   * An `amount` was transferred in its entirety from `owner` to `destination` by
   * the approved `delegate`.
   **/
  | {
      name: 'TransferredApproved';
      data: { assetId: bigint; owner: AccountId32; delegate: AccountId32; destination: AccountId32; amount: bigint };
    }
  /**
   * An asset has had its attributes changed by the `Force` origin.
   **/
  | { name: 'AssetStatusChanged'; data: { assetId: bigint } }
  /**
   * The min_balance of an asset has been updated by the asset owner.
   **/
  | { name: 'AssetMinBalanceChanged'; data: { assetId: bigint; newMinBalance: bigint } }
  /**
   * Some account `who` was created with a deposit from `depositor`.
   **/
  | { name: 'Touched'; data: { assetId: bigint; who: AccountId32; depositor: AccountId32 } }
  /**
   * Some account `who` was blocked.
   **/
  | { name: 'Blocked'; data: { assetId: bigint; who: AccountId32 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletPriceAggregatorEvent =
  /**
   * New average native currency value has been calculated and pushed into the moving average buffer.
   **/
  { name: 'AverageAggregatedValue'; data: { value: FixedU128 } };

/**
 * The `Event` enum of this pallet
 **/
export type OrmlOracleModuleEvent =
  /**
   * New feed data is submitted.
   **/
  { name: 'NewFeedData'; data: { sender: AccountId32; values: Array<[AstarPrimitivesOracleCurrencyId, FixedU128]> } };

export type AstarPrimitivesOracleCurrencyId = 'Astr' | 'Sdn';

/**
 * The `Event` enum of this pallet
 **/
export type PalletMembershipEvent =
  /**
   * The given member was added; see the transaction for who.
   **/
  | 'MemberAdded'
  /**
   * The given member was removed; see the transaction for who.
   **/
  | 'MemberRemoved'
  /**
   * Two members were swapped; see the transaction for who.
   **/
  | 'MembersSwapped'
  /**
   * The membership was reset; see the transaction for who the new set is.
   **/
  | 'MembersReset'
  /**
   * One of the members' keys changed.
   **/
  | 'KeyChanged'
  /**
   * Phantom member, never used.
   **/
  | 'Dummy';

/**
 * The `Event` enum of this pallet
 **/
export type PalletCollatorSelectionEvent =
  | { name: 'NewInvulnerables'; data: Array<AccountId32> }
  | { name: 'NewDesiredCandidates'; data: number }
  | { name: 'NewCandidacyBond'; data: bigint }
  | { name: 'CandidateAdded'; data: [AccountId32, bigint] }
  | { name: 'CandidateRemoved'; data: AccountId32 }
  | { name: 'CandidateSlashed'; data: AccountId32 };

/**
 * The `Event` enum of this pallet
 **/
export type PalletSessionEvent =
  /**
   * New session has happened. Note that the argument is the session index, not the
   * block number as the type might suggest.
   **/
  { name: 'NewSession'; data: { sessionIndex: number } };

/**
 * The `Event` enum of this pallet
 **/
export type CumulusPalletXcmpQueueEvent =
  /**
   * Some XCM was executed ok.
   **/
  | {
      name: 'Success';
      data: { messageHash: FixedBytes<32>; messageId: FixedBytes<32>; weight: SpWeightsWeightV2Weight };
    }
  /**
   * Some XCM failed.
   **/
  | {
      name: 'Fail';
      data: {
        messageHash: FixedBytes<32>;
        messageId: FixedBytes<32>;
        error: XcmV3TraitsError;
        weight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Bad XCM version used.
   **/
  | { name: 'BadVersion'; data: { messageHash: FixedBytes<32> } }
  /**
   * Bad XCM format used.
   **/
  | { name: 'BadFormat'; data: { messageHash: FixedBytes<32> } }
  /**
   * An HRMP message was sent to a sibling parachain.
   **/
  | { name: 'XcmpMessageSent'; data: { messageHash: FixedBytes<32> } }
  /**
   * An XCM exceeded the individual message weight budget.
   **/
  | {
      name: 'OverweightEnqueued';
      data: {
        sender: PolkadotParachainPrimitivesPrimitivesId;
        sentAt: number;
        index: bigint;
        required: SpWeightsWeightV2Weight;
      };
    }
  /**
   * An XCM from the overweight queue was executed with the given actual weight used.
   **/
  | { name: 'OverweightServiced'; data: { index: bigint; used: SpWeightsWeightV2Weight } };

export type XcmV3TraitsError =
  | { type: 'Overflow' }
  | { type: 'Unimplemented' }
  | { type: 'UntrustedReserveLocation' }
  | { type: 'UntrustedTeleportLocation' }
  | { type: 'LocationFull' }
  | { type: 'LocationNotInvertible' }
  | { type: 'BadOrigin' }
  | { type: 'InvalidLocation' }
  | { type: 'AssetNotFound' }
  | { type: 'FailedToTransactAsset' }
  | { type: 'NotWithdrawable' }
  | { type: 'LocationCannotHold' }
  | { type: 'ExceedsMaxMessageSize' }
  | { type: 'DestinationUnsupported' }
  | { type: 'Transport' }
  | { type: 'Unroutable' }
  | { type: 'UnknownClaim' }
  | { type: 'FailedToDecode' }
  | { type: 'MaxWeightInvalid' }
  | { type: 'NotHoldingFees' }
  | { type: 'TooExpensive' }
  | { type: 'Trap'; value: bigint }
  | { type: 'ExpectationFalse' }
  | { type: 'PalletNotFound' }
  | { type: 'NameMismatch' }
  | { type: 'VersionIncompatible' }
  | { type: 'HoldingWouldOverflow' }
  | { type: 'ExportError' }
  | { type: 'ReanchorFailed' }
  | { type: 'NoDeal' }
  | { type: 'FeesNotMet' }
  | { type: 'LockError' }
  | { type: 'NoPermission' }
  | { type: 'Unanchored' }
  | { type: 'NotDepositable' }
  | { type: 'UnhandledXcmVersion' }
  | { type: 'WeightLimitReached'; value: SpWeightsWeightV2Weight }
  | { type: 'Barrier' }
  | { type: 'WeightNotComputable' }
  | { type: 'ExceedsStackLimit' };

export type PolkadotParachainPrimitivesPrimitivesId = number;

/**
 * The `Event` enum of this pallet
 **/
export type PalletXcmEvent =
  /**
   * Execution of an XCM message was attempted.
   **/
  | { name: 'Attempted'; data: { outcome: XcmV3TraitsOutcome } }
  /**
   * A XCM message was sent.
   **/
  | {
      name: 'Sent';
      data: {
        origin: StagingXcmV3MultilocationMultiLocation;
        destination: StagingXcmV3MultilocationMultiLocation;
        message: XcmV3Xcm;
        messageId: FixedBytes<32>;
      };
    }
  /**
   * Query response received which does not match a registered query. This may be because a
   * matching query was never registered, it may be because it is a duplicate response, or
   * because the query timed out.
   **/
  | { name: 'UnexpectedResponse'; data: { origin: StagingXcmV3MultilocationMultiLocation; queryId: bigint } }
  /**
   * Query response has been received and is ready for taking with `take_response`. There is
   * no registered notification call.
   **/
  | { name: 'ResponseReady'; data: { queryId: bigint; response: XcmV3Response } }
  /**
   * Query response has been received and query is removed. The registered notification has
   * been dispatched and executed successfully.
   **/
  | { name: 'Notified'; data: { queryId: bigint; palletIndex: number; callIndex: number } }
  /**
   * Query response has been received and query is removed. The registered notification
   * could not be dispatched because the dispatch weight is greater than the maximum weight
   * originally budgeted by this runtime for the query result.
   **/
  | {
      name: 'NotifyOverweight';
      data: {
        queryId: bigint;
        palletIndex: number;
        callIndex: number;
        actualWeight: SpWeightsWeightV2Weight;
        maxBudgetedWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Query response has been received and query is removed. There was a general error with
   * dispatching the notification call.
   **/
  | { name: 'NotifyDispatchError'; data: { queryId: bigint; palletIndex: number; callIndex: number } }
  /**
   * Query response has been received and query is removed. The dispatch was unable to be
   * decoded into a `Call`; this might be due to dispatch function having a signature which
   * is not `(origin, QueryId, Response)`.
   **/
  | { name: 'NotifyDecodeFailed'; data: { queryId: bigint; palletIndex: number; callIndex: number } }
  /**
   * Expected query response has been received but the origin location of the response does
   * not match that expected. The query remains registered for a later, valid, response to
   * be received and acted upon.
   **/
  | {
      name: 'InvalidResponder';
      data: {
        origin: StagingXcmV3MultilocationMultiLocation;
        queryId: bigint;
        expectedLocation?: StagingXcmV3MultilocationMultiLocation | undefined;
      };
    }
  /**
   * Expected query response has been received but the expected origin location placed in
   * storage by this runtime previously cannot be decoded. The query remains registered.
   *
   * This is unexpected (since a location placed in storage in a previously executing
   * runtime should be readable prior to query timeout) and dangerous since the possibly
   * valid response will be dropped. Manual governance intervention is probably going to be
   * needed.
   **/
  | { name: 'InvalidResponderVersion'; data: { origin: StagingXcmV3MultilocationMultiLocation; queryId: bigint } }
  /**
   * Received query response has been read and removed.
   **/
  | { name: 'ResponseTaken'; data: { queryId: bigint } }
  /**
   * Some assets have been placed in an asset trap.
   **/
  | {
      name: 'AssetsTrapped';
      data: { hash: H256; origin: StagingXcmV3MultilocationMultiLocation; assets: XcmVersionedMultiAssets };
    }
  /**
   * An XCM version change notification message has been attempted to be sent.
   *
   * The cost of sending it (borne by the chain) is included.
   **/
  | {
      name: 'VersionChangeNotified';
      data: {
        destination: StagingXcmV3MultilocationMultiLocation;
        result: number;
        cost: XcmV3MultiassetMultiAssets;
        messageId: FixedBytes<32>;
      };
    }
  /**
   * The supported version of a location has been changed. This might be through an
   * automatic notification or a manual intervention.
   **/
  | { name: 'SupportedVersionChanged'; data: { location: StagingXcmV3MultilocationMultiLocation; version: number } }
  /**
   * A given location which had a version change subscription was dropped owing to an error
   * sending the notification to it.
   **/
  | {
      name: 'NotifyTargetSendFail';
      data: { location: StagingXcmV3MultilocationMultiLocation; queryId: bigint; error: XcmV3TraitsError };
    }
  /**
   * A given location which had a version change subscription was dropped owing to an error
   * migrating the location to our new XCM format.
   **/
  | { name: 'NotifyTargetMigrationFail'; data: { location: XcmVersionedMultiLocation; queryId: bigint } }
  /**
   * Expected query response has been received but the expected querier location placed in
   * storage by this runtime previously cannot be decoded. The query remains registered.
   *
   * This is unexpected (since a location placed in storage in a previously executing
   * runtime should be readable prior to query timeout) and dangerous since the possibly
   * valid response will be dropped. Manual governance intervention is probably going to be
   * needed.
   **/
  | { name: 'InvalidQuerierVersion'; data: { origin: StagingXcmV3MultilocationMultiLocation; queryId: bigint } }
  /**
   * Expected query response has been received but the querier location of the response does
   * not match the expected. The query remains registered for a later, valid, response to
   * be received and acted upon.
   **/
  | {
      name: 'InvalidQuerier';
      data: {
        origin: StagingXcmV3MultilocationMultiLocation;
        queryId: bigint;
        expectedQuerier: StagingXcmV3MultilocationMultiLocation;
        maybeActualQuerier?: StagingXcmV3MultilocationMultiLocation | undefined;
      };
    }
  /**
   * A remote has requested XCM version change notification from us and we have honored it.
   * A version information message is sent to them and its cost is included.
   **/
  | {
      name: 'VersionNotifyStarted';
      data: {
        destination: StagingXcmV3MultilocationMultiLocation;
        cost: XcmV3MultiassetMultiAssets;
        messageId: FixedBytes<32>;
      };
    }
  /**
   * We have requested that a remote chain send us XCM version change notifications.
   **/
  | {
      name: 'VersionNotifyRequested';
      data: {
        destination: StagingXcmV3MultilocationMultiLocation;
        cost: XcmV3MultiassetMultiAssets;
        messageId: FixedBytes<32>;
      };
    }
  /**
   * We have requested that a remote chain stops sending us XCM version change
   * notifications.
   **/
  | {
      name: 'VersionNotifyUnrequested';
      data: {
        destination: StagingXcmV3MultilocationMultiLocation;
        cost: XcmV3MultiassetMultiAssets;
        messageId: FixedBytes<32>;
      };
    }
  /**
   * Fees were paid from a location for an operation (often for using `SendXcm`).
   **/
  | { name: 'FeesPaid'; data: { paying: StagingXcmV3MultilocationMultiLocation; fees: XcmV3MultiassetMultiAssets } }
  /**
   * Some assets have been claimed from an asset trap
   **/
  | {
      name: 'AssetsClaimed';
      data: { hash: H256; origin: StagingXcmV3MultilocationMultiLocation; assets: XcmVersionedMultiAssets };
    };

export type XcmV3TraitsOutcome =
  | { type: 'Complete'; value: SpWeightsWeightV2Weight }
  | { type: 'Incomplete'; value: [SpWeightsWeightV2Weight, XcmV3TraitsError] }
  | { type: 'Error'; value: XcmV3TraitsError };

export type StagingXcmV3MultilocationMultiLocation = { parents: number; interior: XcmV3Junctions };

export type XcmV3Junctions =
  | { type: 'Here' }
  | { type: 'X1'; value: XcmV3Junction }
  | { type: 'X2'; value: [XcmV3Junction, XcmV3Junction] }
  | { type: 'X3'; value: [XcmV3Junction, XcmV3Junction, XcmV3Junction] }
  | { type: 'X4'; value: [XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction] }
  | { type: 'X5'; value: [XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction] }
  | { type: 'X6'; value: [XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction] }
  | {
      type: 'X7';
      value: [XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction];
    }
  | {
      type: 'X8';
      value: [
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
      ];
    };

export type XcmV3Junction =
  | { type: 'Parachain'; value: number }
  | { type: 'AccountId32'; value: { network?: XcmV3JunctionNetworkId | undefined; id: FixedBytes<32> } }
  | { type: 'AccountIndex64'; value: { network?: XcmV3JunctionNetworkId | undefined; index: bigint } }
  | { type: 'AccountKey20'; value: { network?: XcmV3JunctionNetworkId | undefined; key: FixedBytes<20> } }
  | { type: 'PalletInstance'; value: number }
  | { type: 'GeneralIndex'; value: bigint }
  | { type: 'GeneralKey'; value: { length: number; data: FixedBytes<32> } }
  | { type: 'OnlyChild' }
  | { type: 'Plurality'; value: { id: XcmV3JunctionBodyId; part: XcmV3JunctionBodyPart } }
  | { type: 'GlobalConsensus'; value: XcmV3JunctionNetworkId };

export type XcmV3JunctionNetworkId =
  | { type: 'ByGenesis'; value: FixedBytes<32> }
  | { type: 'ByFork'; value: { blockNumber: bigint; blockHash: FixedBytes<32> } }
  | { type: 'Polkadot' }
  | { type: 'Kusama' }
  | { type: 'Westend' }
  | { type: 'Rococo' }
  | { type: 'Wococo' }
  | { type: 'Ethereum'; value: { chainId: bigint } }
  | { type: 'BitcoinCore' }
  | { type: 'BitcoinCash' };

export type XcmV3JunctionBodyId =
  | { type: 'Unit' }
  | { type: 'Moniker'; value: FixedBytes<4> }
  | { type: 'Index'; value: number }
  | { type: 'Executive' }
  | { type: 'Technical' }
  | { type: 'Legislative' }
  | { type: 'Judicial' }
  | { type: 'Defense' }
  | { type: 'Administration' }
  | { type: 'Treasury' };

export type XcmV3JunctionBodyPart =
  | { type: 'Voice' }
  | { type: 'Members'; value: { count: number } }
  | { type: 'Fraction'; value: { nom: number; denom: number } }
  | { type: 'AtLeastProportion'; value: { nom: number; denom: number } }
  | { type: 'MoreThanProportion'; value: { nom: number; denom: number } };

export type XcmV3Xcm = Array<XcmV3Instruction>;

export type XcmV3Instruction =
  | { type: 'WithdrawAsset'; value: XcmV3MultiassetMultiAssets }
  | { type: 'ReserveAssetDeposited'; value: XcmV3MultiassetMultiAssets }
  | { type: 'ReceiveTeleportedAsset'; value: XcmV3MultiassetMultiAssets }
  | {
      type: 'QueryResponse';
      value: {
        queryId: bigint;
        response: XcmV3Response;
        maxWeight: SpWeightsWeightV2Weight;
        querier?: StagingXcmV3MultilocationMultiLocation | undefined;
      };
    }
  | {
      type: 'TransferAsset';
      value: { assets: XcmV3MultiassetMultiAssets; beneficiary: StagingXcmV3MultilocationMultiLocation };
    }
  | {
      type: 'TransferReserveAsset';
      value: { assets: XcmV3MultiassetMultiAssets; dest: StagingXcmV3MultilocationMultiLocation; xcm: XcmV3Xcm };
    }
  | {
      type: 'Transact';
      value: { originKind: XcmV2OriginKind; requireWeightAtMost: SpWeightsWeightV2Weight; call: XcmDoubleEncoded };
    }
  | { type: 'HrmpNewChannelOpenRequest'; value: { sender: number; maxMessageSize: number; maxCapacity: number } }
  | { type: 'HrmpChannelAccepted'; value: { recipient: number } }
  | { type: 'HrmpChannelClosing'; value: { initiator: number; sender: number; recipient: number } }
  | { type: 'ClearOrigin' }
  | { type: 'DescendOrigin'; value: XcmV3Junctions }
  | { type: 'ReportError'; value: XcmV3QueryResponseInfo }
  | {
      type: 'DepositAsset';
      value: { assets: XcmV3MultiassetMultiAssetFilter; beneficiary: StagingXcmV3MultilocationMultiLocation };
    }
  | {
      type: 'DepositReserveAsset';
      value: { assets: XcmV3MultiassetMultiAssetFilter; dest: StagingXcmV3MultilocationMultiLocation; xcm: XcmV3Xcm };
    }
  | {
      type: 'ExchangeAsset';
      value: { give: XcmV3MultiassetMultiAssetFilter; want: XcmV3MultiassetMultiAssets; maximal: boolean };
    }
  | {
      type: 'InitiateReserveWithdraw';
      value: {
        assets: XcmV3MultiassetMultiAssetFilter;
        reserve: StagingXcmV3MultilocationMultiLocation;
        xcm: XcmV3Xcm;
      };
    }
  | {
      type: 'InitiateTeleport';
      value: { assets: XcmV3MultiassetMultiAssetFilter; dest: StagingXcmV3MultilocationMultiLocation; xcm: XcmV3Xcm };
    }
  | { type: 'ReportHolding'; value: { responseInfo: XcmV3QueryResponseInfo; assets: XcmV3MultiassetMultiAssetFilter } }
  | { type: 'BuyExecution'; value: { fees: XcmV3MultiassetMultiAsset; weightLimit: XcmV3WeightLimit } }
  | { type: 'RefundSurplus' }
  | { type: 'SetErrorHandler'; value: XcmV3Xcm }
  | { type: 'SetAppendix'; value: XcmV3Xcm }
  | { type: 'ClearError' }
  | {
      type: 'ClaimAsset';
      value: { assets: XcmV3MultiassetMultiAssets; ticket: StagingXcmV3MultilocationMultiLocation };
    }
  | { type: 'Trap'; value: bigint }
  | { type: 'SubscribeVersion'; value: { queryId: bigint; maxResponseWeight: SpWeightsWeightV2Weight } }
  | { type: 'UnsubscribeVersion' }
  | { type: 'BurnAsset'; value: XcmV3MultiassetMultiAssets }
  | { type: 'ExpectAsset'; value: XcmV3MultiassetMultiAssets }
  | { type: 'ExpectOrigin'; value?: StagingXcmV3MultilocationMultiLocation | undefined }
  | { type: 'ExpectError'; value?: [number, XcmV3TraitsError] | undefined }
  | { type: 'ExpectTransactStatus'; value: XcmV3MaybeErrorCode }
  | { type: 'QueryPallet'; value: { moduleName: Bytes; responseInfo: XcmV3QueryResponseInfo } }
  | {
      type: 'ExpectPallet';
      value: { index: number; name: Bytes; moduleName: Bytes; crateMajor: number; minCrateMinor: number };
    }
  | { type: 'ReportTransactStatus'; value: XcmV3QueryResponseInfo }
  | { type: 'ClearTransactStatus' }
  | { type: 'UniversalOrigin'; value: XcmV3Junction }
  | { type: 'ExportMessage'; value: { network: XcmV3JunctionNetworkId; destination: XcmV3Junctions; xcm: XcmV3Xcm } }
  | { type: 'LockAsset'; value: { asset: XcmV3MultiassetMultiAsset; unlocker: StagingXcmV3MultilocationMultiLocation } }
  | { type: 'UnlockAsset'; value: { asset: XcmV3MultiassetMultiAsset; target: StagingXcmV3MultilocationMultiLocation } }
  | {
      type: 'NoteUnlockable';
      value: { asset: XcmV3MultiassetMultiAsset; owner: StagingXcmV3MultilocationMultiLocation };
    }
  | {
      type: 'RequestUnlock';
      value: { asset: XcmV3MultiassetMultiAsset; locker: StagingXcmV3MultilocationMultiLocation };
    }
  | { type: 'SetFeesMode'; value: { jitWithdraw: boolean } }
  | { type: 'SetTopic'; value: FixedBytes<32> }
  | { type: 'ClearTopic' }
  | { type: 'AliasOrigin'; value: StagingXcmV3MultilocationMultiLocation }
  | {
      type: 'UnpaidExecution';
      value: { weightLimit: XcmV3WeightLimit; checkOrigin?: StagingXcmV3MultilocationMultiLocation | undefined };
    };

export type XcmV3MultiassetMultiAssets = Array<XcmV3MultiassetMultiAsset>;

export type XcmV3MultiassetMultiAsset = { id: XcmV3MultiassetAssetId; fun: XcmV3MultiassetFungibility };

export type XcmV3MultiassetAssetId =
  | { type: 'Concrete'; value: StagingXcmV3MultilocationMultiLocation }
  | { type: 'Abstract'; value: FixedBytes<32> };

export type XcmV3MultiassetFungibility =
  | { type: 'Fungible'; value: bigint }
  | { type: 'NonFungible'; value: XcmV3MultiassetAssetInstance };

export type XcmV3MultiassetAssetInstance =
  | { type: 'Undefined' }
  | { type: 'Index'; value: bigint }
  | { type: 'Array4'; value: FixedBytes<4> }
  | { type: 'Array8'; value: FixedBytes<8> }
  | { type: 'Array16'; value: FixedBytes<16> }
  | { type: 'Array32'; value: FixedBytes<32> };

export type XcmV3Response =
  | { type: 'Null' }
  | { type: 'Assets'; value: XcmV3MultiassetMultiAssets }
  | { type: 'ExecutionResult'; value?: [number, XcmV3TraitsError] | undefined }
  | { type: 'Version'; value: number }
  | { type: 'PalletsInfo'; value: Array<XcmV3PalletInfo> }
  | { type: 'DispatchResult'; value: XcmV3MaybeErrorCode };

export type XcmV3PalletInfo = {
  index: number;
  name: Bytes;
  moduleName: Bytes;
  major: number;
  minor: number;
  patch: number;
};

export type XcmV3MaybeErrorCode =
  | { type: 'Success' }
  | { type: 'Error'; value: Bytes }
  | { type: 'TruncatedError'; value: Bytes };

export type XcmV2OriginKind = 'Native' | 'SovereignAccount' | 'Superuser' | 'Xcm';

export type XcmDoubleEncoded = { encoded: Bytes };

export type XcmV3QueryResponseInfo = {
  destination: StagingXcmV3MultilocationMultiLocation;
  queryId: bigint;
  maxWeight: SpWeightsWeightV2Weight;
};

export type XcmV3MultiassetMultiAssetFilter =
  | { type: 'Definite'; value: XcmV3MultiassetMultiAssets }
  | { type: 'Wild'; value: XcmV3MultiassetWildMultiAsset };

export type XcmV3MultiassetWildMultiAsset =
  | { type: 'All' }
  | { type: 'AllOf'; value: { id: XcmV3MultiassetAssetId; fun: XcmV3MultiassetWildFungibility } }
  | { type: 'AllCounted'; value: number }
  | { type: 'AllOfCounted'; value: { id: XcmV3MultiassetAssetId; fun: XcmV3MultiassetWildFungibility; count: number } };

export type XcmV3MultiassetWildFungibility = 'Fungible' | 'NonFungible';

export type XcmV3WeightLimit = { type: 'Unlimited' } | { type: 'Limited'; value: SpWeightsWeightV2Weight };

export type XcmVersionedMultiAssets =
  | { type: 'V2'; value: XcmV2MultiassetMultiAssets }
  | { type: 'V3'; value: XcmV3MultiassetMultiAssets };

export type XcmV2MultiassetMultiAssets = Array<XcmV2MultiassetMultiAsset>;

export type XcmV2MultiassetMultiAsset = { id: XcmV2MultiassetAssetId; fun: XcmV2MultiassetFungibility };

export type XcmV2MultiassetAssetId =
  | { type: 'Concrete'; value: XcmV2MultilocationMultiLocation }
  | { type: 'Abstract'; value: Bytes };

export type XcmV2MultilocationMultiLocation = { parents: number; interior: XcmV2MultilocationJunctions };

export type XcmV2MultilocationJunctions =
  | { type: 'Here' }
  | { type: 'X1'; value: XcmV2Junction }
  | { type: 'X2'; value: [XcmV2Junction, XcmV2Junction] }
  | { type: 'X3'; value: [XcmV2Junction, XcmV2Junction, XcmV2Junction] }
  | { type: 'X4'; value: [XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction] }
  | { type: 'X5'; value: [XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction] }
  | { type: 'X6'; value: [XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction] }
  | {
      type: 'X7';
      value: [XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction];
    }
  | {
      type: 'X8';
      value: [
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
      ];
    };

export type XcmV2Junction =
  | { type: 'Parachain'; value: number }
  | { type: 'AccountId32'; value: { network: XcmV2NetworkId; id: FixedBytes<32> } }
  | { type: 'AccountIndex64'; value: { network: XcmV2NetworkId; index: bigint } }
  | { type: 'AccountKey20'; value: { network: XcmV2NetworkId; key: FixedBytes<20> } }
  | { type: 'PalletInstance'; value: number }
  | { type: 'GeneralIndex'; value: bigint }
  | { type: 'GeneralKey'; value: Bytes }
  | { type: 'OnlyChild' }
  | { type: 'Plurality'; value: { id: XcmV2BodyId; part: XcmV2BodyPart } };

export type XcmV2NetworkId =
  | { type: 'Any' }
  | { type: 'Named'; value: Bytes }
  | { type: 'Polkadot' }
  | { type: 'Kusama' };

export type XcmV2BodyId =
  | { type: 'Unit' }
  | { type: 'Named'; value: Bytes }
  | { type: 'Index'; value: number }
  | { type: 'Executive' }
  | { type: 'Technical' }
  | { type: 'Legislative' }
  | { type: 'Judicial' }
  | { type: 'Defense' }
  | { type: 'Administration' }
  | { type: 'Treasury' };

export type XcmV2BodyPart =
  | { type: 'Voice' }
  | { type: 'Members'; value: { count: number } }
  | { type: 'Fraction'; value: { nom: number; denom: number } }
  | { type: 'AtLeastProportion'; value: { nom: number; denom: number } }
  | { type: 'MoreThanProportion'; value: { nom: number; denom: number } };

export type XcmV2MultiassetFungibility =
  | { type: 'Fungible'; value: bigint }
  | { type: 'NonFungible'; value: XcmV2MultiassetAssetInstance };

export type XcmV2MultiassetAssetInstance =
  | { type: 'Undefined' }
  | { type: 'Index'; value: bigint }
  | { type: 'Array4'; value: FixedBytes<4> }
  | { type: 'Array8'; value: FixedBytes<8> }
  | { type: 'Array16'; value: FixedBytes<16> }
  | { type: 'Array32'; value: FixedBytes<32> }
  | { type: 'Blob'; value: Bytes };

export type XcmVersionedMultiLocation =
  | { type: 'V2'; value: XcmV2MultilocationMultiLocation }
  | { type: 'V3'; value: StagingXcmV3MultilocationMultiLocation };

/**
 * The `Event` enum of this pallet
 **/
export type CumulusPalletXcmEvent =
  /**
   * Downward message is invalid XCM.
   * \[ id \]
   **/
  | { name: 'InvalidFormat'; data: FixedBytes<32> }
  /**
   * Downward message is unsupported version of XCM.
   * \[ id \]
   **/
  | { name: 'UnsupportedVersion'; data: FixedBytes<32> }
  /**
   * Downward message executed with the given outcome.
   * \[ id, outcome \]
   **/
  | { name: 'ExecutedDownward'; data: [FixedBytes<32>, XcmV3TraitsOutcome] };

/**
 * The `Event` enum of this pallet
 **/
export type CumulusPalletDmpQueueEvent =
  /**
   * Downward message is invalid XCM.
   **/
  | { name: 'InvalidFormat'; data: { messageHash: FixedBytes<32> } }
  /**
   * Downward message is unsupported version of XCM.
   **/
  | { name: 'UnsupportedVersion'; data: { messageHash: FixedBytes<32> } }
  /**
   * Downward message executed with the given outcome.
   **/
  | {
      name: 'ExecutedDownward';
      data: { messageHash: FixedBytes<32>; messageId: FixedBytes<32>; outcome: XcmV3TraitsOutcome };
    }
  /**
   * The weight limit for handling downward messages was reached.
   **/
  | {
      name: 'WeightExhausted';
      data: {
        messageHash: FixedBytes<32>;
        messageId: FixedBytes<32>;
        remainingWeight: SpWeightsWeightV2Weight;
        requiredWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Downward message is overweight and was placed in the overweight queue.
   **/
  | {
      name: 'OverweightEnqueued';
      data: {
        messageHash: FixedBytes<32>;
        messageId: FixedBytes<32>;
        overweightIndex: bigint;
        requiredWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Downward message from the overweight queue was executed.
   **/
  | { name: 'OverweightServiced'; data: { overweightIndex: bigint; weightUsed: SpWeightsWeightV2Weight } }
  /**
   * The maximum number of downward messages was reached.
   **/
  | { name: 'MaxMessagesExhausted'; data: { messageHash: FixedBytes<32> } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletXcAssetConfigEvent =
  /**
   * Registed mapping between asset type and asset Id.
   **/
  | { name: 'AssetRegistered'; data: { assetLocation: XcmVersionedMultiLocation; assetId: bigint } }
  /**
   * Changed the amount of units we are charging per execution second for an asset
   **/
  | { name: 'UnitsPerSecondChanged'; data: { assetLocation: XcmVersionedMultiLocation; unitsPerSecond: bigint } }
  /**
   * Changed the asset type mapping for a given asset id
   **/
  | {
      name: 'AssetLocationChanged';
      data: {
        previousAssetLocation: XcmVersionedMultiLocation;
        assetId: bigint;
        newAssetLocation: XcmVersionedMultiLocation;
      };
    }
  /**
   * Supported asset type for fee payment removed.
   **/
  | { name: 'SupportedAssetRemoved'; data: { assetLocation: XcmVersionedMultiLocation } }
  /**
   * Removed all information related to an asset Id
   **/
  | { name: 'AssetRemoved'; data: { assetLocation: XcmVersionedMultiLocation; assetId: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type OrmlXtokensModuleEvent =
  /**
   * Transferred `MultiAsset` with fee.
   **/
  {
    name: 'TransferredMultiAssets';
    data: {
      sender: AccountId32;
      assets: XcmV3MultiassetMultiAssets;
      fee: XcmV3MultiassetMultiAsset;
      dest: StagingXcmV3MultilocationMultiLocation;
    };
  };

/**
 * The `Event` enum of this pallet
 **/
export type PalletEvmEvent =
  /**
   * Ethereum events from contracts.
   **/
  | { name: 'Log'; data: { log: EthereumLog } }
  /**
   * A contract has been created at given address.
   **/
  | { name: 'Created'; data: { address: H160 } }
  /**
   * A contract was attempted to be created, but the execution failed.
   **/
  | { name: 'CreatedFailed'; data: { address: H160 } }
  /**
   * A contract has been executed successfully with states applied.
   **/
  | { name: 'Executed'; data: { address: H160 } }
  /**
   * A contract has been executed with errors. States are reverted with only gas fees applied.
   **/
  | { name: 'ExecutedFailed'; data: { address: H160 } };

export type EthereumLog = { address: H160; topics: Array<H256>; data: Bytes };

/**
 * The `Event` enum of this pallet
 **/
export type PalletEthereumEvent =
  /**
   * An ethereum transaction was successfully executed.
   **/
  {
    name: 'Executed';
    data: { from: H160; to: H160; transactionHash: H256; exitReason: EvmCoreErrorExitReason; extraData: Bytes };
  };

export type EvmCoreErrorExitReason =
  | { type: 'Succeed'; value: EvmCoreErrorExitSucceed }
  | { type: 'Error'; value: EvmCoreErrorExitError }
  | { type: 'Revert'; value: EvmCoreErrorExitRevert }
  | { type: 'Fatal'; value: EvmCoreErrorExitFatal };

export type EvmCoreErrorExitSucceed = 'Stopped' | 'Returned' | 'Suicided';

export type EvmCoreErrorExitError =
  | { type: 'StackUnderflow' }
  | { type: 'StackOverflow' }
  | { type: 'InvalidJump' }
  | { type: 'InvalidRange' }
  | { type: 'DesignatedInvalid' }
  | { type: 'CallTooDeep' }
  | { type: 'CreateCollision' }
  | { type: 'CreateContractLimit' }
  | { type: 'InvalidCode'; value: EvmCoreOpcode }
  | { type: 'OutOfOffset' }
  | { type: 'OutOfGas' }
  | { type: 'OutOfFund' }
  | { type: 'PcUnderflow' }
  | { type: 'CreateEmpty' }
  | { type: 'Other'; value: string }
  | { type: 'MaxNonce' };

export type EvmCoreOpcode = number;

export type EvmCoreErrorExitRevert = 'Reverted';

export type EvmCoreErrorExitFatal =
  | { type: 'NotSupported' }
  | { type: 'UnhandledInterrupt' }
  | { type: 'CallErrorAsFatal'; value: EvmCoreErrorExitError }
  | { type: 'Other'; value: string };

/**
 * The `Event` enum of this pallet
 **/
export type PalletDynamicEvmBaseFeeEvent =
  /**
   * New `base fee per gas` value has been force-set.
   **/
  { name: 'NewBaseFeePerGas'; data: { fee: U256 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletContractsEvent =
  /**
   * Contract deployed by address at the specified address.
   **/
  | { name: 'Instantiated'; data: { deployer: AccountId32; contract: AccountId32 } }
  /**
   * Contract has been removed.
   *
   * # Note
   *
   * The only way for a contract to be removed and emitting this event is by calling
   * `seal_terminate`.
   **/
  | {
      name: 'Terminated';
      data: {
        /**
         * The contract that was terminated.
         **/
        contract: AccountId32;

        /**
         * The account that received the contracts remaining balance
         **/
        beneficiary: AccountId32;
      };
    }
  /**
   * Code with the specified hash has been stored.
   **/
  | { name: 'CodeStored'; data: { codeHash: H256; depositHeld: bigint; uploader: AccountId32 } }
  /**
   * A custom event emitted by the contract.
   **/
  | {
      name: 'ContractEmitted';
      data: {
        /**
         * The contract that emitted the event.
         **/
        contract: AccountId32;

        /**
         * Data supplied by the contract. Metadata generated during contract compilation
         * is needed to decode it.
         **/
        data: Bytes;
      };
    }
  /**
   * A code with the specified hash was removed.
   **/
  | { name: 'CodeRemoved'; data: { codeHash: H256; depositReleased: bigint; remover: AccountId32 } }
  /**
   * A contract's code was updated.
   **/
  | {
      name: 'ContractCodeUpdated';
      data: {
        /**
         * The contract that has been updated.
         **/
        contract: AccountId32;

        /**
         * New code hash that was set for the contract.
         **/
        newCodeHash: H256;

        /**
         * Previous code hash of the contract.
         **/
        oldCodeHash: H256;
      };
    }
  /**
   * A contract was called either by a plain account or another contract.
   *
   * # Note
   *
   * Please keep in mind that like all events this is only emitted for successful
   * calls. This is because on failure all storage changes including events are
   * rolled back.
   **/
  | {
      name: 'Called';
      data: {
        /**
         * The caller of the `contract`.
         **/
        caller: PalletContractsOrigin;

        /**
         * The contract that was called.
         **/
        contract: AccountId32;
      };
    }
  /**
   * A contract delegate called a code hash.
   *
   * # Note
   *
   * Please keep in mind that like all events this is only emitted for successful
   * calls. This is because on failure all storage changes including events are
   * rolled back.
   **/
  | {
      name: 'DelegateCalled';
      data: {
        /**
         * The contract that performed the delegate call and hence in whose context
         * the `code_hash` is executed.
         **/
        contract: AccountId32;

        /**
         * The code hash that was delegate called.
         **/
        codeHash: H256;
      };
    }
  /**
   * Some funds have been transferred and held as storage deposit.
   **/
  | { name: 'StorageDepositTransferredAndHeld'; data: { from: AccountId32; to: AccountId32; amount: bigint } }
  /**
   * Some storage deposit funds have been transferred and released.
   **/
  | { name: 'StorageDepositTransferredAndReleased'; data: { from: AccountId32; to: AccountId32; amount: bigint } };

export type PalletContractsOrigin = { type: 'Root' } | { type: 'Signed'; value: AccountId32 };

export type AstarRuntimeRuntime = {};

/**
 * The `Event` enum of this pallet
 **/
export type PalletSudoEvent =
  /**
   * A sudo call just took place.
   **/
  | {
      name: 'Sudid';
      data: {
        /**
         * The result of the call made by the sudo user.
         **/
        sudoResult: Result<[], DispatchError>;
      };
    }
  /**
   * The sudo key has been updated.
   **/
  | {
      name: 'KeyChanged';
      data: {
        /**
         * The old sudo key if one was previously set.
         **/
        oldSudoer?: AccountId32 | undefined;
      };
    }
  /**
   * A [sudo_as](Pallet::sudo_as) call just took place.
   **/
  | {
      name: 'SudoAsDone';
      data: {
        /**
         * The result of the call made by the sudo user.
         **/
        sudoResult: Result<[], DispatchError>;
      };
    };

export type FrameSystemLastRuntimeUpgradeInfo = { specVersion: number; specName: string };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type FrameSystemCall =
  /**
   * See [`Pallet::remark`].
   **/
  | { name: 'Remark'; params: { remark: Bytes } }
  /**
   * See [`Pallet::set_heap_pages`].
   **/
  | { name: 'SetHeapPages'; params: { pages: bigint } }
  /**
   * See [`Pallet::set_code`].
   **/
  | { name: 'SetCode'; params: { code: Bytes } }
  /**
   * See [`Pallet::set_code_without_checks`].
   **/
  | { name: 'SetCodeWithoutChecks'; params: { code: Bytes } }
  /**
   * See [`Pallet::set_storage`].
   **/
  | { name: 'SetStorage'; params: { items: Array<[Bytes, Bytes]> } }
  /**
   * See [`Pallet::kill_storage`].
   **/
  | { name: 'KillStorage'; params: { keys: Array<Bytes> } }
  /**
   * See [`Pallet::kill_prefix`].
   **/
  | { name: 'KillPrefix'; params: { prefix: Bytes; subkeys: number } }
  /**
   * See [`Pallet::remark_with_event`].
   **/
  | { name: 'RemarkWithEvent'; params: { remark: Bytes } };

export type FrameSystemCallLike =
  /**
   * See [`Pallet::remark`].
   **/
  | { name: 'Remark'; params: { remark: BytesLike } }
  /**
   * See [`Pallet::set_heap_pages`].
   **/
  | { name: 'SetHeapPages'; params: { pages: bigint } }
  /**
   * See [`Pallet::set_code`].
   **/
  | { name: 'SetCode'; params: { code: BytesLike } }
  /**
   * See [`Pallet::set_code_without_checks`].
   **/
  | { name: 'SetCodeWithoutChecks'; params: { code: BytesLike } }
  /**
   * See [`Pallet::set_storage`].
   **/
  | { name: 'SetStorage'; params: { items: Array<[BytesLike, BytesLike]> } }
  /**
   * See [`Pallet::kill_storage`].
   **/
  | { name: 'KillStorage'; params: { keys: Array<BytesLike> } }
  /**
   * See [`Pallet::kill_prefix`].
   **/
  | { name: 'KillPrefix'; params: { prefix: BytesLike; subkeys: number } }
  /**
   * See [`Pallet::remark_with_event`].
   **/
  | { name: 'RemarkWithEvent'; params: { remark: BytesLike } };

export type FrameSystemLimitsBlockWeights = {
  baseBlock: SpWeightsWeightV2Weight;
  maxBlock: SpWeightsWeightV2Weight;
  perClass: FrameSupportDispatchPerDispatchClassWeightsPerClass;
};

export type FrameSupportDispatchPerDispatchClassWeightsPerClass = {
  normal: FrameSystemLimitsWeightsPerClass;
  operational: FrameSystemLimitsWeightsPerClass;
  mandatory: FrameSystemLimitsWeightsPerClass;
};

export type FrameSystemLimitsWeightsPerClass = {
  baseExtrinsic: SpWeightsWeightV2Weight;
  maxExtrinsic?: SpWeightsWeightV2Weight | undefined;
  maxTotal?: SpWeightsWeightV2Weight | undefined;
  reserved?: SpWeightsWeightV2Weight | undefined;
};

export type FrameSystemLimitsBlockLength = { max: FrameSupportDispatchPerDispatchClassU32 };

export type FrameSupportDispatchPerDispatchClassU32 = { normal: number; operational: number; mandatory: number };

export type SpWeightsRuntimeDbWeight = { read: bigint; write: bigint };

/**
 * Error for the System pallet
 **/
export type FrameSystemError =
  /**
   * The name of specification does not match between the current runtime
   * and the new runtime.
   **/
  | 'InvalidSpecName'
  /**
   * The specification version is not allowed to decrease between the current runtime
   * and the new runtime.
   **/
  | 'SpecVersionNeedsToIncrease'
  /**
   * Failed to extract the runtime version from the new runtime.
   *
   * Either calling `Core_version` or decoding `RuntimeVersion` failed.
   **/
  | 'FailedToExtractRuntimeVersion'
  /**
   * Suicide called when the account has non-default composite data.
   **/
  | 'NonDefaultComposite'
  /**
   * There is a non-zero reference count preventing the account from being purged.
   **/
  | 'NonZeroRefCount'
  /**
   * The origin filter prevent the call to be dispatched.
   **/
  | 'CallFiltered';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletUtilityCall =
  /**
   * See [`Pallet::batch`].
   **/
  | { name: 'Batch'; params: { calls: Array<AstarRuntimeRuntimeCall> } }
  /**
   * See [`Pallet::as_derivative`].
   **/
  | { name: 'AsDerivative'; params: { index: number; call: AstarRuntimeRuntimeCall } }
  /**
   * See [`Pallet::batch_all`].
   **/
  | { name: 'BatchAll'; params: { calls: Array<AstarRuntimeRuntimeCall> } }
  /**
   * See [`Pallet::dispatch_as`].
   **/
  | { name: 'DispatchAs'; params: { asOrigin: AstarRuntimeOriginCaller; call: AstarRuntimeRuntimeCall } }
  /**
   * See [`Pallet::force_batch`].
   **/
  | { name: 'ForceBatch'; params: { calls: Array<AstarRuntimeRuntimeCall> } }
  /**
   * See [`Pallet::with_weight`].
   **/
  | { name: 'WithWeight'; params: { call: AstarRuntimeRuntimeCall; weight: SpWeightsWeightV2Weight } };

export type PalletUtilityCallLike =
  /**
   * See [`Pallet::batch`].
   **/
  | { name: 'Batch'; params: { calls: Array<AstarRuntimeRuntimeCallLike> } }
  /**
   * See [`Pallet::as_derivative`].
   **/
  | { name: 'AsDerivative'; params: { index: number; call: AstarRuntimeRuntimeCallLike } }
  /**
   * See [`Pallet::batch_all`].
   **/
  | { name: 'BatchAll'; params: { calls: Array<AstarRuntimeRuntimeCallLike> } }
  /**
   * See [`Pallet::dispatch_as`].
   **/
  | { name: 'DispatchAs'; params: { asOrigin: AstarRuntimeOriginCaller; call: AstarRuntimeRuntimeCallLike } }
  /**
   * See [`Pallet::force_batch`].
   **/
  | { name: 'ForceBatch'; params: { calls: Array<AstarRuntimeRuntimeCallLike> } }
  /**
   * See [`Pallet::with_weight`].
   **/
  | { name: 'WithWeight'; params: { call: AstarRuntimeRuntimeCallLike; weight: SpWeightsWeightV2Weight } };

export type AstarRuntimeRuntimeCall =
  | { pallet: 'System'; palletCall: FrameSystemCall }
  | { pallet: 'Utility'; palletCall: PalletUtilityCall }
  | { pallet: 'Identity'; palletCall: PalletIdentityCall }
  | { pallet: 'Timestamp'; palletCall: PalletTimestampCall }
  | { pallet: 'Multisig'; palletCall: PalletMultisigCall }
  | { pallet: 'Proxy'; palletCall: PalletProxyCall }
  | { pallet: 'ParachainSystem'; palletCall: CumulusPalletParachainSystemCall }
  | { pallet: 'ParachainInfo'; palletCall: ParachainInfoCall }
  | { pallet: 'Balances'; palletCall: PalletBalancesCall }
  | { pallet: 'Vesting'; palletCall: PalletVestingCall }
  | { pallet: 'Inflation'; palletCall: PalletInflationCall }
  | { pallet: 'DappStaking'; palletCall: PalletDappStakingV3Call }
  | { pallet: 'Assets'; palletCall: PalletAssetsCall }
  | { pallet: 'Oracle'; palletCall: OrmlOracleModuleCall }
  | { pallet: 'OracleMembership'; palletCall: PalletMembershipCall }
  | { pallet: 'CollatorSelection'; palletCall: PalletCollatorSelectionCall }
  | { pallet: 'Session'; palletCall: PalletSessionCall }
  | { pallet: 'XcmpQueue'; palletCall: CumulusPalletXcmpQueueCall }
  | { pallet: 'PolkadotXcm'; palletCall: PalletXcmCall }
  | { pallet: 'CumulusXcm'; palletCall: CumulusPalletXcmCall }
  | { pallet: 'DmpQueue'; palletCall: CumulusPalletDmpQueueCall }
  | { pallet: 'XcAssetConfig'; palletCall: PalletXcAssetConfigCall }
  | { pallet: 'XTokens'; palletCall: OrmlXtokensModuleCall }
  | { pallet: 'Evm'; palletCall: PalletEvmCall }
  | { pallet: 'Ethereum'; palletCall: PalletEthereumCall }
  | { pallet: 'DynamicEvmBaseFee'; palletCall: PalletDynamicEvmBaseFeeCall }
  | { pallet: 'Contracts'; palletCall: PalletContractsCall }
  | { pallet: 'Sudo'; palletCall: PalletSudoCall };

export type AstarRuntimeRuntimeCallLike =
  | { pallet: 'System'; palletCall: FrameSystemCallLike }
  | { pallet: 'Utility'; palletCall: PalletUtilityCallLike }
  | { pallet: 'Identity'; palletCall: PalletIdentityCallLike }
  | { pallet: 'Timestamp'; palletCall: PalletTimestampCallLike }
  | { pallet: 'Multisig'; palletCall: PalletMultisigCallLike }
  | { pallet: 'Proxy'; palletCall: PalletProxyCallLike }
  | { pallet: 'ParachainSystem'; palletCall: CumulusPalletParachainSystemCallLike }
  | { pallet: 'ParachainInfo'; palletCall: ParachainInfoCallLike }
  | { pallet: 'Balances'; palletCall: PalletBalancesCallLike }
  | { pallet: 'Vesting'; palletCall: PalletVestingCallLike }
  | { pallet: 'Inflation'; palletCall: PalletInflationCallLike }
  | { pallet: 'DappStaking'; palletCall: PalletDappStakingV3CallLike }
  | { pallet: 'Assets'; palletCall: PalletAssetsCallLike }
  | { pallet: 'Oracle'; palletCall: OrmlOracleModuleCallLike }
  | { pallet: 'OracleMembership'; palletCall: PalletMembershipCallLike }
  | { pallet: 'CollatorSelection'; palletCall: PalletCollatorSelectionCallLike }
  | { pallet: 'Session'; palletCall: PalletSessionCallLike }
  | { pallet: 'XcmpQueue'; palletCall: CumulusPalletXcmpQueueCallLike }
  | { pallet: 'PolkadotXcm'; palletCall: PalletXcmCallLike }
  | { pallet: 'CumulusXcm'; palletCall: CumulusPalletXcmCallLike }
  | { pallet: 'DmpQueue'; palletCall: CumulusPalletDmpQueueCallLike }
  | { pallet: 'XcAssetConfig'; palletCall: PalletXcAssetConfigCallLike }
  | { pallet: 'XTokens'; palletCall: OrmlXtokensModuleCallLike }
  | { pallet: 'Evm'; palletCall: PalletEvmCallLike }
  | { pallet: 'Ethereum'; palletCall: PalletEthereumCallLike }
  | { pallet: 'DynamicEvmBaseFee'; palletCall: PalletDynamicEvmBaseFeeCallLike }
  | { pallet: 'Contracts'; palletCall: PalletContractsCallLike }
  | { pallet: 'Sudo'; palletCall: PalletSudoCallLike };

/**
 * Identity pallet declaration.
 **/
export type PalletIdentityCall =
  /**
   * See [`Pallet::add_registrar`].
   **/
  | { name: 'AddRegistrar'; params: { account: MultiAddress } }
  /**
   * See [`Pallet::set_identity`].
   **/
  | { name: 'SetIdentity'; params: { info: PalletIdentitySimpleIdentityInfo } }
  /**
   * See [`Pallet::set_subs`].
   **/
  | { name: 'SetSubs'; params: { subs: Array<[AccountId32, Data]> } }
  /**
   * See [`Pallet::clear_identity`].
   **/
  | { name: 'ClearIdentity' }
  /**
   * See [`Pallet::request_judgement`].
   **/
  | { name: 'RequestJudgement'; params: { regIndex: number; maxFee: bigint } }
  /**
   * See [`Pallet::cancel_request`].
   **/
  | { name: 'CancelRequest'; params: { regIndex: number } }
  /**
   * See [`Pallet::set_fee`].
   **/
  | { name: 'SetFee'; params: { index: number; fee: bigint } }
  /**
   * See [`Pallet::set_account_id`].
   **/
  | { name: 'SetAccountId'; params: { index: number; new: MultiAddress } }
  /**
   * See [`Pallet::set_fields`].
   **/
  | { name: 'SetFields'; params: { index: number; fields: PalletIdentityBitFlags } }
  /**
   * See [`Pallet::provide_judgement`].
   **/
  | {
      name: 'ProvideJudgement';
      params: { regIndex: number; target: MultiAddress; judgement: PalletIdentityJudgement; identity: H256 };
    }
  /**
   * See [`Pallet::kill_identity`].
   **/
  | { name: 'KillIdentity'; params: { target: MultiAddress } }
  /**
   * See [`Pallet::add_sub`].
   **/
  | { name: 'AddSub'; params: { sub: MultiAddress; data: Data } }
  /**
   * See [`Pallet::rename_sub`].
   **/
  | { name: 'RenameSub'; params: { sub: MultiAddress; data: Data } }
  /**
   * See [`Pallet::remove_sub`].
   **/
  | { name: 'RemoveSub'; params: { sub: MultiAddress } }
  /**
   * See [`Pallet::quit_sub`].
   **/
  | { name: 'QuitSub' };

export type PalletIdentityCallLike =
  /**
   * See [`Pallet::add_registrar`].
   **/
  | { name: 'AddRegistrar'; params: { account: MultiAddressLike } }
  /**
   * See [`Pallet::set_identity`].
   **/
  | { name: 'SetIdentity'; params: { info: PalletIdentitySimpleIdentityInfo } }
  /**
   * See [`Pallet::set_subs`].
   **/
  | { name: 'SetSubs'; params: { subs: Array<[AccountId32Like, Data]> } }
  /**
   * See [`Pallet::clear_identity`].
   **/
  | { name: 'ClearIdentity' }
  /**
   * See [`Pallet::request_judgement`].
   **/
  | { name: 'RequestJudgement'; params: { regIndex: number; maxFee: bigint } }
  /**
   * See [`Pallet::cancel_request`].
   **/
  | { name: 'CancelRequest'; params: { regIndex: number } }
  /**
   * See [`Pallet::set_fee`].
   **/
  | { name: 'SetFee'; params: { index: number; fee: bigint } }
  /**
   * See [`Pallet::set_account_id`].
   **/
  | { name: 'SetAccountId'; params: { index: number; new: MultiAddressLike } }
  /**
   * See [`Pallet::set_fields`].
   **/
  | { name: 'SetFields'; params: { index: number; fields: PalletIdentityBitFlags } }
  /**
   * See [`Pallet::provide_judgement`].
   **/
  | {
      name: 'ProvideJudgement';
      params: { regIndex: number; target: MultiAddressLike; judgement: PalletIdentityJudgement; identity: H256 };
    }
  /**
   * See [`Pallet::kill_identity`].
   **/
  | { name: 'KillIdentity'; params: { target: MultiAddressLike } }
  /**
   * See [`Pallet::add_sub`].
   **/
  | { name: 'AddSub'; params: { sub: MultiAddressLike; data: Data } }
  /**
   * See [`Pallet::rename_sub`].
   **/
  | { name: 'RenameSub'; params: { sub: MultiAddressLike; data: Data } }
  /**
   * See [`Pallet::remove_sub`].
   **/
  | { name: 'RemoveSub'; params: { sub: MultiAddressLike } }
  /**
   * See [`Pallet::quit_sub`].
   **/
  | { name: 'QuitSub' };

export type PalletIdentitySimpleIdentityInfo = {
  additional: Array<[Data, Data]>;
  display: Data;
  legal: Data;
  web: Data;
  riot: Data;
  email: Data;
  pgpFingerprint?: FixedBytes<20> | undefined;
  image: Data;
  twitter: Data;
};

export type PalletIdentityBitFlags = bigint;

export type PalletIdentitySimpleIdentityField =
  | 'Display'
  | 'Legal'
  | 'Web'
  | 'Riot'
  | 'Email'
  | 'PgpFingerprint'
  | 'Image'
  | 'Twitter';

export type PalletIdentityJudgement =
  | { type: 'Unknown' }
  | { type: 'FeePaid'; value: bigint }
  | { type: 'Reasonable' }
  | { type: 'KnownGood' }
  | { type: 'OutOfDate' }
  | { type: 'LowQuality' }
  | { type: 'Erroneous' };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTimestampCall =
  /**
   * See [`Pallet::set`].
   **/
  { name: 'Set'; params: { now: bigint } };

export type PalletTimestampCallLike =
  /**
   * See [`Pallet::set`].
   **/
  { name: 'Set'; params: { now: bigint } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMultisigCall =
  /**
   * See [`Pallet::as_multi_threshold_1`].
   **/
  | { name: 'AsMultiThreshold1'; params: { otherSignatories: Array<AccountId32>; call: AstarRuntimeRuntimeCall } }
  /**
   * See [`Pallet::as_multi`].
   **/
  | {
      name: 'AsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        call: AstarRuntimeRuntimeCall;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * See [`Pallet::approve_as_multi`].
   **/
  | {
      name: 'ApproveAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        callHash: FixedBytes<32>;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * See [`Pallet::cancel_as_multi`].
   **/
  | {
      name: 'CancelAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        timepoint: PalletMultisigTimepoint;
        callHash: FixedBytes<32>;
      };
    };

export type PalletMultisigCallLike =
  /**
   * See [`Pallet::as_multi_threshold_1`].
   **/
  | {
      name: 'AsMultiThreshold1';
      params: { otherSignatories: Array<AccountId32Like>; call: AstarRuntimeRuntimeCallLike };
    }
  /**
   * See [`Pallet::as_multi`].
   **/
  | {
      name: 'AsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        call: AstarRuntimeRuntimeCallLike;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * See [`Pallet::approve_as_multi`].
   **/
  | {
      name: 'ApproveAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        callHash: FixedBytes<32>;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * See [`Pallet::cancel_as_multi`].
   **/
  | {
      name: 'CancelAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        timepoint: PalletMultisigTimepoint;
        callHash: FixedBytes<32>;
      };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletProxyCall =
  /**
   * See [`Pallet::proxy`].
   **/
  | {
      name: 'Proxy';
      params: { real: MultiAddress; forceProxyType?: AstarRuntimeProxyType | undefined; call: AstarRuntimeRuntimeCall };
    }
  /**
   * See [`Pallet::add_proxy`].
   **/
  | { name: 'AddProxy'; params: { delegate: MultiAddress; proxyType: AstarRuntimeProxyType; delay: number } }
  /**
   * See [`Pallet::remove_proxy`].
   **/
  | { name: 'RemoveProxy'; params: { delegate: MultiAddress; proxyType: AstarRuntimeProxyType; delay: number } }
  /**
   * See [`Pallet::remove_proxies`].
   **/
  | { name: 'RemoveProxies' }
  /**
   * See [`Pallet::create_pure`].
   **/
  | { name: 'CreatePure'; params: { proxyType: AstarRuntimeProxyType; delay: number; index: number } }
  /**
   * See [`Pallet::kill_pure`].
   **/
  | {
      name: 'KillPure';
      params: {
        spawner: MultiAddress;
        proxyType: AstarRuntimeProxyType;
        index: number;
        height: number;
        extIndex: number;
      };
    }
  /**
   * See [`Pallet::announce`].
   **/
  | { name: 'Announce'; params: { real: MultiAddress; callHash: H256 } }
  /**
   * See [`Pallet::remove_announcement`].
   **/
  | { name: 'RemoveAnnouncement'; params: { real: MultiAddress; callHash: H256 } }
  /**
   * See [`Pallet::reject_announcement`].
   **/
  | { name: 'RejectAnnouncement'; params: { delegate: MultiAddress; callHash: H256 } }
  /**
   * See [`Pallet::proxy_announced`].
   **/
  | {
      name: 'ProxyAnnounced';
      params: {
        delegate: MultiAddress;
        real: MultiAddress;
        forceProxyType?: AstarRuntimeProxyType | undefined;
        call: AstarRuntimeRuntimeCall;
      };
    };

export type PalletProxyCallLike =
  /**
   * See [`Pallet::proxy`].
   **/
  | {
      name: 'Proxy';
      params: {
        real: MultiAddressLike;
        forceProxyType?: AstarRuntimeProxyType | undefined;
        call: AstarRuntimeRuntimeCallLike;
      };
    }
  /**
   * See [`Pallet::add_proxy`].
   **/
  | { name: 'AddProxy'; params: { delegate: MultiAddressLike; proxyType: AstarRuntimeProxyType; delay: number } }
  /**
   * See [`Pallet::remove_proxy`].
   **/
  | { name: 'RemoveProxy'; params: { delegate: MultiAddressLike; proxyType: AstarRuntimeProxyType; delay: number } }
  /**
   * See [`Pallet::remove_proxies`].
   **/
  | { name: 'RemoveProxies' }
  /**
   * See [`Pallet::create_pure`].
   **/
  | { name: 'CreatePure'; params: { proxyType: AstarRuntimeProxyType; delay: number; index: number } }
  /**
   * See [`Pallet::kill_pure`].
   **/
  | {
      name: 'KillPure';
      params: {
        spawner: MultiAddressLike;
        proxyType: AstarRuntimeProxyType;
        index: number;
        height: number;
        extIndex: number;
      };
    }
  /**
   * See [`Pallet::announce`].
   **/
  | { name: 'Announce'; params: { real: MultiAddressLike; callHash: H256 } }
  /**
   * See [`Pallet::remove_announcement`].
   **/
  | { name: 'RemoveAnnouncement'; params: { real: MultiAddressLike; callHash: H256 } }
  /**
   * See [`Pallet::reject_announcement`].
   **/
  | { name: 'RejectAnnouncement'; params: { delegate: MultiAddressLike; callHash: H256 } }
  /**
   * See [`Pallet::proxy_announced`].
   **/
  | {
      name: 'ProxyAnnounced';
      params: {
        delegate: MultiAddressLike;
        real: MultiAddressLike;
        forceProxyType?: AstarRuntimeProxyType | undefined;
        call: AstarRuntimeRuntimeCallLike;
      };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type CumulusPalletParachainSystemCall =
  /**
   * See [`Pallet::set_validation_data`].
   **/
  | { name: 'SetValidationData'; params: { data: CumulusPrimitivesParachainInherentParachainInherentData } }
  /**
   * See [`Pallet::sudo_send_upward_message`].
   **/
  | { name: 'SudoSendUpwardMessage'; params: { message: Bytes } }
  /**
   * See [`Pallet::authorize_upgrade`].
   **/
  | { name: 'AuthorizeUpgrade'; params: { codeHash: H256; checkVersion: boolean } }
  /**
   * See [`Pallet::enact_authorized_upgrade`].
   **/
  | { name: 'EnactAuthorizedUpgrade'; params: { code: Bytes } };

export type CumulusPalletParachainSystemCallLike =
  /**
   * See [`Pallet::set_validation_data`].
   **/
  | { name: 'SetValidationData'; params: { data: CumulusPrimitivesParachainInherentParachainInherentData } }
  /**
   * See [`Pallet::sudo_send_upward_message`].
   **/
  | { name: 'SudoSendUpwardMessage'; params: { message: BytesLike } }
  /**
   * See [`Pallet::authorize_upgrade`].
   **/
  | { name: 'AuthorizeUpgrade'; params: { codeHash: H256; checkVersion: boolean } }
  /**
   * See [`Pallet::enact_authorized_upgrade`].
   **/
  | { name: 'EnactAuthorizedUpgrade'; params: { code: BytesLike } };

export type CumulusPrimitivesParachainInherentParachainInherentData = {
  validationData: PolkadotPrimitivesV6PersistedValidationData;
  relayChainState: SpTrieStorageProof;
  downwardMessages: Array<PolkadotCorePrimitivesInboundDownwardMessage>;
  horizontalMessages: Array<[PolkadotParachainPrimitivesPrimitivesId, Array<PolkadotCorePrimitivesInboundHrmpMessage>]>;
};

export type PolkadotPrimitivesV6PersistedValidationData = {
  parentHead: PolkadotParachainPrimitivesPrimitivesHeadData;
  relayParentNumber: number;
  relayParentStorageRoot: H256;
  maxPovSize: number;
};

export type PolkadotParachainPrimitivesPrimitivesHeadData = Bytes;

export type SpTrieStorageProof = { trieNodes: Array<Bytes> };

export type PolkadotCorePrimitivesInboundDownwardMessage = { sentAt: number; msg: Bytes };

export type PolkadotCorePrimitivesInboundHrmpMessage = { sentAt: number; data: Bytes };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type ParachainInfoCall = null;

export type ParachainInfoCallLike = null;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBalancesCall =
  /**
   * See [`Pallet::transfer_allow_death`].
   **/
  | { name: 'TransferAllowDeath'; params: { dest: MultiAddress; value: bigint } }
  /**
   * See [`Pallet::force_transfer`].
   **/
  | { name: 'ForceTransfer'; params: { source: MultiAddress; dest: MultiAddress; value: bigint } }
  /**
   * See [`Pallet::transfer_keep_alive`].
   **/
  | { name: 'TransferKeepAlive'; params: { dest: MultiAddress; value: bigint } }
  /**
   * See [`Pallet::transfer_all`].
   **/
  | { name: 'TransferAll'; params: { dest: MultiAddress; keepAlive: boolean } }
  /**
   * See [`Pallet::force_unreserve`].
   **/
  | { name: 'ForceUnreserve'; params: { who: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::upgrade_accounts`].
   **/
  | { name: 'UpgradeAccounts'; params: { who: Array<AccountId32> } }
  /**
   * See [`Pallet::force_set_balance`].
   **/
  | { name: 'ForceSetBalance'; params: { who: MultiAddress; newFree: bigint } }
  /**
   * See [`Pallet::burn`].
   **/
  | { name: 'Burn'; params: { value: bigint; ignorable: boolean } };

export type PalletBalancesCallLike =
  /**
   * See [`Pallet::transfer_allow_death`].
   **/
  | { name: 'TransferAllowDeath'; params: { dest: MultiAddressLike; value: bigint } }
  /**
   * See [`Pallet::force_transfer`].
   **/
  | { name: 'ForceTransfer'; params: { source: MultiAddressLike; dest: MultiAddressLike; value: bigint } }
  /**
   * See [`Pallet::transfer_keep_alive`].
   **/
  | { name: 'TransferKeepAlive'; params: { dest: MultiAddressLike; value: bigint } }
  /**
   * See [`Pallet::transfer_all`].
   **/
  | { name: 'TransferAll'; params: { dest: MultiAddressLike; keepAlive: boolean } }
  /**
   * See [`Pallet::force_unreserve`].
   **/
  | { name: 'ForceUnreserve'; params: { who: MultiAddressLike; amount: bigint } }
  /**
   * See [`Pallet::upgrade_accounts`].
   **/
  | { name: 'UpgradeAccounts'; params: { who: Array<AccountId32Like> } }
  /**
   * See [`Pallet::force_set_balance`].
   **/
  | { name: 'ForceSetBalance'; params: { who: MultiAddressLike; newFree: bigint } }
  /**
   * See [`Pallet::burn`].
   **/
  | { name: 'Burn'; params: { value: bigint; ignorable: boolean } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletVestingCall =
  /**
   * See [`Pallet::vest`].
   **/
  | { name: 'Vest' }
  /**
   * See [`Pallet::vest_other`].
   **/
  | { name: 'VestOther'; params: { target: MultiAddress } }
  /**
   * See [`Pallet::vested_transfer`].
   **/
  | { name: 'VestedTransfer'; params: { target: MultiAddress; schedule: PalletVestingVestingInfo } }
  /**
   * See [`Pallet::force_vested_transfer`].
   **/
  | {
      name: 'ForceVestedTransfer';
      params: { source: MultiAddress; target: MultiAddress; schedule: PalletVestingVestingInfo };
    }
  /**
   * See [`Pallet::merge_schedules`].
   **/
  | { name: 'MergeSchedules'; params: { schedule1Index: number; schedule2Index: number } };

export type PalletVestingCallLike =
  /**
   * See [`Pallet::vest`].
   **/
  | { name: 'Vest' }
  /**
   * See [`Pallet::vest_other`].
   **/
  | { name: 'VestOther'; params: { target: MultiAddressLike } }
  /**
   * See [`Pallet::vested_transfer`].
   **/
  | { name: 'VestedTransfer'; params: { target: MultiAddressLike; schedule: PalletVestingVestingInfo } }
  /**
   * See [`Pallet::force_vested_transfer`].
   **/
  | {
      name: 'ForceVestedTransfer';
      params: { source: MultiAddressLike; target: MultiAddressLike; schedule: PalletVestingVestingInfo };
    }
  /**
   * See [`Pallet::merge_schedules`].
   **/
  | { name: 'MergeSchedules'; params: { schedule1Index: number; schedule2Index: number } };

export type PalletVestingVestingInfo = { locked: bigint; perBlock: bigint; startingBlock: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletInflationCall =
  /**
   * See [`Pallet::force_set_inflation_params`].
   **/
  | { name: 'ForceSetInflationParams'; params: { params: PalletInflationInflationParameters } }
  /**
   * See [`Pallet::force_inflation_recalculation`].
   **/
  | { name: 'ForceInflationRecalculation'; params: { nextEra: number } };

export type PalletInflationCallLike =
  /**
   * See [`Pallet::force_set_inflation_params`].
   **/
  | { name: 'ForceSetInflationParams'; params: { params: PalletInflationInflationParameters } }
  /**
   * See [`Pallet::force_inflation_recalculation`].
   **/
  | { name: 'ForceInflationRecalculation'; params: { nextEra: number } };

export type PalletInflationInflationParameters = {
  maxInflationRate: Perquintill;
  treasuryPart: Perquintill;
  collatorsPart: Perquintill;
  dappsPart: Perquintill;
  baseStakersPart: Perquintill;
  adjustableStakersPart: Perquintill;
  bonusPart: Perquintill;
  idealStakingRate: Perquintill;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletDappStakingV3Call =
  /**
   * See [`Pallet::unbond_and_unstake`].
   **/
  | { name: 'UnbondAndUnstake'; params: { contractId: AstarPrimitivesDappStakingSmartContract; value: bigint } }
  /**
   * See [`Pallet::withdraw_unbonded`].
   **/
  | { name: 'WithdrawUnbonded' }
  /**
   * See [`Pallet::maintenance_mode`].
   **/
  | { name: 'MaintenanceMode'; params: { enabled: boolean } }
  /**
   * See [`Pallet::register`].
   **/
  | { name: 'Register'; params: { owner: AccountId32; smartContract: AstarPrimitivesDappStakingSmartContract } }
  /**
   * See [`Pallet::set_dapp_reward_beneficiary`].
   **/
  | {
      name: 'SetDappRewardBeneficiary';
      params: { smartContract: AstarPrimitivesDappStakingSmartContract; beneficiary?: AccountId32 | undefined };
    }
  /**
   * See [`Pallet::set_dapp_owner`].
   **/
  | { name: 'SetDappOwner'; params: { smartContract: AstarPrimitivesDappStakingSmartContract; newOwner: AccountId32 } }
  /**
   * See [`Pallet::unregister`].
   **/
  | { name: 'Unregister'; params: { smartContract: AstarPrimitivesDappStakingSmartContract } }
  /**
   * See [`Pallet::lock`].
   **/
  | { name: 'Lock'; params: { amount: bigint } }
  /**
   * See [`Pallet::unlock`].
   **/
  | { name: 'Unlock'; params: { amount: bigint } }
  /**
   * See [`Pallet::claim_unlocked`].
   **/
  | { name: 'ClaimUnlocked' }
  /**
   * See [`Pallet::relock_unlocking`].
   **/
  | { name: 'RelockUnlocking' }
  /**
   * See [`Pallet::stake`].
   **/
  | { name: 'Stake'; params: { smartContract: AstarPrimitivesDappStakingSmartContract; amount: bigint } }
  /**
   * See [`Pallet::unstake`].
   **/
  | { name: 'Unstake'; params: { smartContract: AstarPrimitivesDappStakingSmartContract; amount: bigint } }
  /**
   * See [`Pallet::claim_staker_rewards`].
   **/
  | { name: 'ClaimStakerRewards' }
  /**
   * See [`Pallet::claim_bonus_reward`].
   **/
  | { name: 'ClaimBonusReward'; params: { smartContract: AstarPrimitivesDappStakingSmartContract } }
  /**
   * See [`Pallet::claim_dapp_reward`].
   **/
  | { name: 'ClaimDappReward'; params: { smartContract: AstarPrimitivesDappStakingSmartContract; era: number } }
  /**
   * See [`Pallet::unstake_from_unregistered`].
   **/
  | { name: 'UnstakeFromUnregistered'; params: { smartContract: AstarPrimitivesDappStakingSmartContract } }
  /**
   * See [`Pallet::cleanup_expired_entries`].
   **/
  | { name: 'CleanupExpiredEntries' }
  /**
   * See [`Pallet::force`].
   **/
  | { name: 'Force'; params: { forcingType: PalletDappStakingV3ForcingType } }
  /**
   * See [`Pallet::fix_account`].
   **/
  | { name: 'FixAccount'; params: { account: AccountId32 } };

export type PalletDappStakingV3CallLike =
  /**
   * See [`Pallet::unbond_and_unstake`].
   **/
  | { name: 'UnbondAndUnstake'; params: { contractId: AstarPrimitivesDappStakingSmartContract; value: bigint } }
  /**
   * See [`Pallet::withdraw_unbonded`].
   **/
  | { name: 'WithdrawUnbonded' }
  /**
   * See [`Pallet::maintenance_mode`].
   **/
  | { name: 'MaintenanceMode'; params: { enabled: boolean } }
  /**
   * See [`Pallet::register`].
   **/
  | { name: 'Register'; params: { owner: AccountId32Like; smartContract: AstarPrimitivesDappStakingSmartContract } }
  /**
   * See [`Pallet::set_dapp_reward_beneficiary`].
   **/
  | {
      name: 'SetDappRewardBeneficiary';
      params: { smartContract: AstarPrimitivesDappStakingSmartContract; beneficiary?: AccountId32Like | undefined };
    }
  /**
   * See [`Pallet::set_dapp_owner`].
   **/
  | {
      name: 'SetDappOwner';
      params: { smartContract: AstarPrimitivesDappStakingSmartContract; newOwner: AccountId32Like };
    }
  /**
   * See [`Pallet::unregister`].
   **/
  | { name: 'Unregister'; params: { smartContract: AstarPrimitivesDappStakingSmartContract } }
  /**
   * See [`Pallet::lock`].
   **/
  | { name: 'Lock'; params: { amount: bigint } }
  /**
   * See [`Pallet::unlock`].
   **/
  | { name: 'Unlock'; params: { amount: bigint } }
  /**
   * See [`Pallet::claim_unlocked`].
   **/
  | { name: 'ClaimUnlocked' }
  /**
   * See [`Pallet::relock_unlocking`].
   **/
  | { name: 'RelockUnlocking' }
  /**
   * See [`Pallet::stake`].
   **/
  | { name: 'Stake'; params: { smartContract: AstarPrimitivesDappStakingSmartContract; amount: bigint } }
  /**
   * See [`Pallet::unstake`].
   **/
  | { name: 'Unstake'; params: { smartContract: AstarPrimitivesDappStakingSmartContract; amount: bigint } }
  /**
   * See [`Pallet::claim_staker_rewards`].
   **/
  | { name: 'ClaimStakerRewards' }
  /**
   * See [`Pallet::claim_bonus_reward`].
   **/
  | { name: 'ClaimBonusReward'; params: { smartContract: AstarPrimitivesDappStakingSmartContract } }
  /**
   * See [`Pallet::claim_dapp_reward`].
   **/
  | { name: 'ClaimDappReward'; params: { smartContract: AstarPrimitivesDappStakingSmartContract; era: number } }
  /**
   * See [`Pallet::unstake_from_unregistered`].
   **/
  | { name: 'UnstakeFromUnregistered'; params: { smartContract: AstarPrimitivesDappStakingSmartContract } }
  /**
   * See [`Pallet::cleanup_expired_entries`].
   **/
  | { name: 'CleanupExpiredEntries' }
  /**
   * See [`Pallet::force`].
   **/
  | { name: 'Force'; params: { forcingType: PalletDappStakingV3ForcingType } }
  /**
   * See [`Pallet::fix_account`].
   **/
  | { name: 'FixAccount'; params: { account: AccountId32Like } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletAssetsCall =
  /**
   * See [`Pallet::create`].
   **/
  | { name: 'Create'; params: { id: bigint; admin: MultiAddress; minBalance: bigint } }
  /**
   * See [`Pallet::force_create`].
   **/
  | { name: 'ForceCreate'; params: { id: bigint; owner: MultiAddress; isSufficient: boolean; minBalance: bigint } }
  /**
   * See [`Pallet::start_destroy`].
   **/
  | { name: 'StartDestroy'; params: { id: bigint } }
  /**
   * See [`Pallet::destroy_accounts`].
   **/
  | { name: 'DestroyAccounts'; params: { id: bigint } }
  /**
   * See [`Pallet::destroy_approvals`].
   **/
  | { name: 'DestroyApprovals'; params: { id: bigint } }
  /**
   * See [`Pallet::finish_destroy`].
   **/
  | { name: 'FinishDestroy'; params: { id: bigint } }
  /**
   * See [`Pallet::mint`].
   **/
  | { name: 'Mint'; params: { id: bigint; beneficiary: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::burn`].
   **/
  | { name: 'Burn'; params: { id: bigint; who: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::transfer`].
   **/
  | { name: 'Transfer'; params: { id: bigint; target: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::transfer_keep_alive`].
   **/
  | { name: 'TransferKeepAlive'; params: { id: bigint; target: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::force_transfer`].
   **/
  | { name: 'ForceTransfer'; params: { id: bigint; source: MultiAddress; dest: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::freeze`].
   **/
  | { name: 'Freeze'; params: { id: bigint; who: MultiAddress } }
  /**
   * See [`Pallet::thaw`].
   **/
  | { name: 'Thaw'; params: { id: bigint; who: MultiAddress } }
  /**
   * See [`Pallet::freeze_asset`].
   **/
  | { name: 'FreezeAsset'; params: { id: bigint } }
  /**
   * See [`Pallet::thaw_asset`].
   **/
  | { name: 'ThawAsset'; params: { id: bigint } }
  /**
   * See [`Pallet::transfer_ownership`].
   **/
  | { name: 'TransferOwnership'; params: { id: bigint; owner: MultiAddress } }
  /**
   * See [`Pallet::set_team`].
   **/
  | { name: 'SetTeam'; params: { id: bigint; issuer: MultiAddress; admin: MultiAddress; freezer: MultiAddress } }
  /**
   * See [`Pallet::set_metadata`].
   **/
  | { name: 'SetMetadata'; params: { id: bigint; name: Bytes; symbol: Bytes; decimals: number } }
  /**
   * See [`Pallet::clear_metadata`].
   **/
  | { name: 'ClearMetadata'; params: { id: bigint } }
  /**
   * See [`Pallet::force_set_metadata`].
   **/
  | {
      name: 'ForceSetMetadata';
      params: { id: bigint; name: Bytes; symbol: Bytes; decimals: number; isFrozen: boolean };
    }
  /**
   * See [`Pallet::force_clear_metadata`].
   **/
  | { name: 'ForceClearMetadata'; params: { id: bigint } }
  /**
   * See [`Pallet::force_asset_status`].
   **/
  | {
      name: 'ForceAssetStatus';
      params: {
        id: bigint;
        owner: MultiAddress;
        issuer: MultiAddress;
        admin: MultiAddress;
        freezer: MultiAddress;
        minBalance: bigint;
        isSufficient: boolean;
        isFrozen: boolean;
      };
    }
  /**
   * See [`Pallet::approve_transfer`].
   **/
  | { name: 'ApproveTransfer'; params: { id: bigint; delegate: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::cancel_approval`].
   **/
  | { name: 'CancelApproval'; params: { id: bigint; delegate: MultiAddress } }
  /**
   * See [`Pallet::force_cancel_approval`].
   **/
  | { name: 'ForceCancelApproval'; params: { id: bigint; owner: MultiAddress; delegate: MultiAddress } }
  /**
   * See [`Pallet::transfer_approved`].
   **/
  | { name: 'TransferApproved'; params: { id: bigint; owner: MultiAddress; destination: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::touch`].
   **/
  | { name: 'Touch'; params: { id: bigint } }
  /**
   * See [`Pallet::refund`].
   **/
  | { name: 'Refund'; params: { id: bigint; allowBurn: boolean } }
  /**
   * See [`Pallet::set_min_balance`].
   **/
  | { name: 'SetMinBalance'; params: { id: bigint; minBalance: bigint } }
  /**
   * See [`Pallet::touch_other`].
   **/
  | { name: 'TouchOther'; params: { id: bigint; who: MultiAddress } }
  /**
   * See [`Pallet::refund_other`].
   **/
  | { name: 'RefundOther'; params: { id: bigint; who: MultiAddress } }
  /**
   * See [`Pallet::block`].
   **/
  | { name: 'Block'; params: { id: bigint; who: MultiAddress } };

export type PalletAssetsCallLike =
  /**
   * See [`Pallet::create`].
   **/
  | { name: 'Create'; params: { id: bigint; admin: MultiAddressLike; minBalance: bigint } }
  /**
   * See [`Pallet::force_create`].
   **/
  | { name: 'ForceCreate'; params: { id: bigint; owner: MultiAddressLike; isSufficient: boolean; minBalance: bigint } }
  /**
   * See [`Pallet::start_destroy`].
   **/
  | { name: 'StartDestroy'; params: { id: bigint } }
  /**
   * See [`Pallet::destroy_accounts`].
   **/
  | { name: 'DestroyAccounts'; params: { id: bigint } }
  /**
   * See [`Pallet::destroy_approvals`].
   **/
  | { name: 'DestroyApprovals'; params: { id: bigint } }
  /**
   * See [`Pallet::finish_destroy`].
   **/
  | { name: 'FinishDestroy'; params: { id: bigint } }
  /**
   * See [`Pallet::mint`].
   **/
  | { name: 'Mint'; params: { id: bigint; beneficiary: MultiAddressLike; amount: bigint } }
  /**
   * See [`Pallet::burn`].
   **/
  | { name: 'Burn'; params: { id: bigint; who: MultiAddressLike; amount: bigint } }
  /**
   * See [`Pallet::transfer`].
   **/
  | { name: 'Transfer'; params: { id: bigint; target: MultiAddressLike; amount: bigint } }
  /**
   * See [`Pallet::transfer_keep_alive`].
   **/
  | { name: 'TransferKeepAlive'; params: { id: bigint; target: MultiAddressLike; amount: bigint } }
  /**
   * See [`Pallet::force_transfer`].
   **/
  | { name: 'ForceTransfer'; params: { id: bigint; source: MultiAddressLike; dest: MultiAddressLike; amount: bigint } }
  /**
   * See [`Pallet::freeze`].
   **/
  | { name: 'Freeze'; params: { id: bigint; who: MultiAddressLike } }
  /**
   * See [`Pallet::thaw`].
   **/
  | { name: 'Thaw'; params: { id: bigint; who: MultiAddressLike } }
  /**
   * See [`Pallet::freeze_asset`].
   **/
  | { name: 'FreezeAsset'; params: { id: bigint } }
  /**
   * See [`Pallet::thaw_asset`].
   **/
  | { name: 'ThawAsset'; params: { id: bigint } }
  /**
   * See [`Pallet::transfer_ownership`].
   **/
  | { name: 'TransferOwnership'; params: { id: bigint; owner: MultiAddressLike } }
  /**
   * See [`Pallet::set_team`].
   **/
  | {
      name: 'SetTeam';
      params: { id: bigint; issuer: MultiAddressLike; admin: MultiAddressLike; freezer: MultiAddressLike };
    }
  /**
   * See [`Pallet::set_metadata`].
   **/
  | { name: 'SetMetadata'; params: { id: bigint; name: BytesLike; symbol: BytesLike; decimals: number } }
  /**
   * See [`Pallet::clear_metadata`].
   **/
  | { name: 'ClearMetadata'; params: { id: bigint } }
  /**
   * See [`Pallet::force_set_metadata`].
   **/
  | {
      name: 'ForceSetMetadata';
      params: { id: bigint; name: BytesLike; symbol: BytesLike; decimals: number; isFrozen: boolean };
    }
  /**
   * See [`Pallet::force_clear_metadata`].
   **/
  | { name: 'ForceClearMetadata'; params: { id: bigint } }
  /**
   * See [`Pallet::force_asset_status`].
   **/
  | {
      name: 'ForceAssetStatus';
      params: {
        id: bigint;
        owner: MultiAddressLike;
        issuer: MultiAddressLike;
        admin: MultiAddressLike;
        freezer: MultiAddressLike;
        minBalance: bigint;
        isSufficient: boolean;
        isFrozen: boolean;
      };
    }
  /**
   * See [`Pallet::approve_transfer`].
   **/
  | { name: 'ApproveTransfer'; params: { id: bigint; delegate: MultiAddressLike; amount: bigint } }
  /**
   * See [`Pallet::cancel_approval`].
   **/
  | { name: 'CancelApproval'; params: { id: bigint; delegate: MultiAddressLike } }
  /**
   * See [`Pallet::force_cancel_approval`].
   **/
  | { name: 'ForceCancelApproval'; params: { id: bigint; owner: MultiAddressLike; delegate: MultiAddressLike } }
  /**
   * See [`Pallet::transfer_approved`].
   **/
  | {
      name: 'TransferApproved';
      params: { id: bigint; owner: MultiAddressLike; destination: MultiAddressLike; amount: bigint };
    }
  /**
   * See [`Pallet::touch`].
   **/
  | { name: 'Touch'; params: { id: bigint } }
  /**
   * See [`Pallet::refund`].
   **/
  | { name: 'Refund'; params: { id: bigint; allowBurn: boolean } }
  /**
   * See [`Pallet::set_min_balance`].
   **/
  | { name: 'SetMinBalance'; params: { id: bigint; minBalance: bigint } }
  /**
   * See [`Pallet::touch_other`].
   **/
  | { name: 'TouchOther'; params: { id: bigint; who: MultiAddressLike } }
  /**
   * See [`Pallet::refund_other`].
   **/
  | { name: 'RefundOther'; params: { id: bigint; who: MultiAddressLike } }
  /**
   * See [`Pallet::block`].
   **/
  | { name: 'Block'; params: { id: bigint; who: MultiAddressLike } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type OrmlOracleModuleCall =
  /**
   * See [`Pallet::feed_values`].
   **/
  { name: 'FeedValues'; params: { values: Array<[AstarPrimitivesOracleCurrencyId, FixedU128]> } };

export type OrmlOracleModuleCallLike =
  /**
   * See [`Pallet::feed_values`].
   **/
  { name: 'FeedValues'; params: { values: Array<[AstarPrimitivesOracleCurrencyId, FixedU128]> } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMembershipCall =
  /**
   * See [`Pallet::add_member`].
   **/
  | { name: 'AddMember'; params: { who: MultiAddress } }
  /**
   * See [`Pallet::remove_member`].
   **/
  | { name: 'RemoveMember'; params: { who: MultiAddress } }
  /**
   * See [`Pallet::swap_member`].
   **/
  | { name: 'SwapMember'; params: { remove: MultiAddress; add: MultiAddress } }
  /**
   * See [`Pallet::reset_members`].
   **/
  | { name: 'ResetMembers'; params: { members: Array<AccountId32> } }
  /**
   * See [`Pallet::change_key`].
   **/
  | { name: 'ChangeKey'; params: { new: MultiAddress } }
  /**
   * See [`Pallet::set_prime`].
   **/
  | { name: 'SetPrime'; params: { who: MultiAddress } }
  /**
   * See [`Pallet::clear_prime`].
   **/
  | { name: 'ClearPrime' };

export type PalletMembershipCallLike =
  /**
   * See [`Pallet::add_member`].
   **/
  | { name: 'AddMember'; params: { who: MultiAddressLike } }
  /**
   * See [`Pallet::remove_member`].
   **/
  | { name: 'RemoveMember'; params: { who: MultiAddressLike } }
  /**
   * See [`Pallet::swap_member`].
   **/
  | { name: 'SwapMember'; params: { remove: MultiAddressLike; add: MultiAddressLike } }
  /**
   * See [`Pallet::reset_members`].
   **/
  | { name: 'ResetMembers'; params: { members: Array<AccountId32Like> } }
  /**
   * See [`Pallet::change_key`].
   **/
  | { name: 'ChangeKey'; params: { new: MultiAddressLike } }
  /**
   * See [`Pallet::set_prime`].
   **/
  | { name: 'SetPrime'; params: { who: MultiAddressLike } }
  /**
   * See [`Pallet::clear_prime`].
   **/
  | { name: 'ClearPrime' };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletCollatorSelectionCall =
  /**
   * See [`Pallet::set_invulnerables`].
   **/
  | { name: 'SetInvulnerables'; params: { new: Array<AccountId32> } }
  /**
   * See [`Pallet::set_desired_candidates`].
   **/
  | { name: 'SetDesiredCandidates'; params: { max: number } }
  /**
   * See [`Pallet::set_candidacy_bond`].
   **/
  | { name: 'SetCandidacyBond'; params: { bond: bigint } }
  /**
   * See [`Pallet::register_as_candidate`].
   **/
  | { name: 'RegisterAsCandidate' }
  /**
   * See [`Pallet::leave_intent`].
   **/
  | { name: 'LeaveIntent' };

export type PalletCollatorSelectionCallLike =
  /**
   * See [`Pallet::set_invulnerables`].
   **/
  | { name: 'SetInvulnerables'; params: { new: Array<AccountId32Like> } }
  /**
   * See [`Pallet::set_desired_candidates`].
   **/
  | { name: 'SetDesiredCandidates'; params: { max: number } }
  /**
   * See [`Pallet::set_candidacy_bond`].
   **/
  | { name: 'SetCandidacyBond'; params: { bond: bigint } }
  /**
   * See [`Pallet::register_as_candidate`].
   **/
  | { name: 'RegisterAsCandidate' }
  /**
   * See [`Pallet::leave_intent`].
   **/
  | { name: 'LeaveIntent' };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSessionCall =
  /**
   * See [`Pallet::set_keys`].
   **/
  | { name: 'SetKeys'; params: { keys: AstarRuntimeSessionKeys; proof: Bytes } }
  /**
   * See [`Pallet::purge_keys`].
   **/
  | { name: 'PurgeKeys' };

export type PalletSessionCallLike =
  /**
   * See [`Pallet::set_keys`].
   **/
  | { name: 'SetKeys'; params: { keys: AstarRuntimeSessionKeys; proof: BytesLike } }
  /**
   * See [`Pallet::purge_keys`].
   **/
  | { name: 'PurgeKeys' };

export type AstarRuntimeSessionKeys = { aura: SpConsensusAuraSr25519AppSr25519Public };

export type SpConsensusAuraSr25519AppSr25519Public = SpCoreSr25519Public;

export type SpCoreSr25519Public = FixedBytes<32>;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type CumulusPalletXcmpQueueCall =
  /**
   * See [`Pallet::service_overweight`].
   **/
  | { name: 'ServiceOverweight'; params: { index: bigint; weightLimit: SpWeightsWeightV2Weight } }
  /**
   * See [`Pallet::suspend_xcm_execution`].
   **/
  | { name: 'SuspendXcmExecution' }
  /**
   * See [`Pallet::resume_xcm_execution`].
   **/
  | { name: 'ResumeXcmExecution' }
  /**
   * See [`Pallet::update_suspend_threshold`].
   **/
  | { name: 'UpdateSuspendThreshold'; params: { new: number } }
  /**
   * See [`Pallet::update_drop_threshold`].
   **/
  | { name: 'UpdateDropThreshold'; params: { new: number } }
  /**
   * See [`Pallet::update_resume_threshold`].
   **/
  | { name: 'UpdateResumeThreshold'; params: { new: number } }
  /**
   * See [`Pallet::update_threshold_weight`].
   **/
  | { name: 'UpdateThresholdWeight'; params: { new: SpWeightsWeightV2Weight } }
  /**
   * See [`Pallet::update_weight_restrict_decay`].
   **/
  | { name: 'UpdateWeightRestrictDecay'; params: { new: SpWeightsWeightV2Weight } }
  /**
   * See [`Pallet::update_xcmp_max_individual_weight`].
   **/
  | { name: 'UpdateXcmpMaxIndividualWeight'; params: { new: SpWeightsWeightV2Weight } };

export type CumulusPalletXcmpQueueCallLike =
  /**
   * See [`Pallet::service_overweight`].
   **/
  | { name: 'ServiceOverweight'; params: { index: bigint; weightLimit: SpWeightsWeightV2Weight } }
  /**
   * See [`Pallet::suspend_xcm_execution`].
   **/
  | { name: 'SuspendXcmExecution' }
  /**
   * See [`Pallet::resume_xcm_execution`].
   **/
  | { name: 'ResumeXcmExecution' }
  /**
   * See [`Pallet::update_suspend_threshold`].
   **/
  | { name: 'UpdateSuspendThreshold'; params: { new: number } }
  /**
   * See [`Pallet::update_drop_threshold`].
   **/
  | { name: 'UpdateDropThreshold'; params: { new: number } }
  /**
   * See [`Pallet::update_resume_threshold`].
   **/
  | { name: 'UpdateResumeThreshold'; params: { new: number } }
  /**
   * See [`Pallet::update_threshold_weight`].
   **/
  | { name: 'UpdateThresholdWeight'; params: { new: SpWeightsWeightV2Weight } }
  /**
   * See [`Pallet::update_weight_restrict_decay`].
   **/
  | { name: 'UpdateWeightRestrictDecay'; params: { new: SpWeightsWeightV2Weight } }
  /**
   * See [`Pallet::update_xcmp_max_individual_weight`].
   **/
  | { name: 'UpdateXcmpMaxIndividualWeight'; params: { new: SpWeightsWeightV2Weight } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletXcmCall =
  /**
   * See [`Pallet::send`].
   **/
  | { name: 'Send'; params: { dest: XcmVersionedMultiLocation; message: XcmVersionedXcm } }
  /**
   * See [`Pallet::teleport_assets`].
   **/
  | {
      name: 'TeleportAssets';
      params: {
        dest: XcmVersionedMultiLocation;
        beneficiary: XcmVersionedMultiLocation;
        assets: XcmVersionedMultiAssets;
        feeAssetItem: number;
      };
    }
  /**
   * See [`Pallet::reserve_transfer_assets`].
   **/
  | {
      name: 'ReserveTransferAssets';
      params: {
        dest: XcmVersionedMultiLocation;
        beneficiary: XcmVersionedMultiLocation;
        assets: XcmVersionedMultiAssets;
        feeAssetItem: number;
      };
    }
  /**
   * See [`Pallet::execute`].
   **/
  | { name: 'Execute'; params: { message: XcmVersionedXcm; maxWeight: SpWeightsWeightV2Weight } }
  /**
   * See [`Pallet::force_xcm_version`].
   **/
  | { name: 'ForceXcmVersion'; params: { location: StagingXcmV3MultilocationMultiLocation; version: number } }
  /**
   * See [`Pallet::force_default_xcm_version`].
   **/
  | { name: 'ForceDefaultXcmVersion'; params: { maybeXcmVersion?: number | undefined } }
  /**
   * See [`Pallet::force_subscribe_version_notify`].
   **/
  | { name: 'ForceSubscribeVersionNotify'; params: { location: XcmVersionedMultiLocation } }
  /**
   * See [`Pallet::force_unsubscribe_version_notify`].
   **/
  | { name: 'ForceUnsubscribeVersionNotify'; params: { location: XcmVersionedMultiLocation } }
  /**
   * See [`Pallet::limited_reserve_transfer_assets`].
   **/
  | {
      name: 'LimitedReserveTransferAssets';
      params: {
        dest: XcmVersionedMultiLocation;
        beneficiary: XcmVersionedMultiLocation;
        assets: XcmVersionedMultiAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * See [`Pallet::limited_teleport_assets`].
   **/
  | {
      name: 'LimitedTeleportAssets';
      params: {
        dest: XcmVersionedMultiLocation;
        beneficiary: XcmVersionedMultiLocation;
        assets: XcmVersionedMultiAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * See [`Pallet::force_suspension`].
   **/
  | { name: 'ForceSuspension'; params: { suspended: boolean } };

export type PalletXcmCallLike =
  /**
   * See [`Pallet::send`].
   **/
  | { name: 'Send'; params: { dest: XcmVersionedMultiLocation; message: XcmVersionedXcm } }
  /**
   * See [`Pallet::teleport_assets`].
   **/
  | {
      name: 'TeleportAssets';
      params: {
        dest: XcmVersionedMultiLocation;
        beneficiary: XcmVersionedMultiLocation;
        assets: XcmVersionedMultiAssets;
        feeAssetItem: number;
      };
    }
  /**
   * See [`Pallet::reserve_transfer_assets`].
   **/
  | {
      name: 'ReserveTransferAssets';
      params: {
        dest: XcmVersionedMultiLocation;
        beneficiary: XcmVersionedMultiLocation;
        assets: XcmVersionedMultiAssets;
        feeAssetItem: number;
      };
    }
  /**
   * See [`Pallet::execute`].
   **/
  | { name: 'Execute'; params: { message: XcmVersionedXcm; maxWeight: SpWeightsWeightV2Weight } }
  /**
   * See [`Pallet::force_xcm_version`].
   **/
  | { name: 'ForceXcmVersion'; params: { location: StagingXcmV3MultilocationMultiLocation; version: number } }
  /**
   * See [`Pallet::force_default_xcm_version`].
   **/
  | { name: 'ForceDefaultXcmVersion'; params: { maybeXcmVersion?: number | undefined } }
  /**
   * See [`Pallet::force_subscribe_version_notify`].
   **/
  | { name: 'ForceSubscribeVersionNotify'; params: { location: XcmVersionedMultiLocation } }
  /**
   * See [`Pallet::force_unsubscribe_version_notify`].
   **/
  | { name: 'ForceUnsubscribeVersionNotify'; params: { location: XcmVersionedMultiLocation } }
  /**
   * See [`Pallet::limited_reserve_transfer_assets`].
   **/
  | {
      name: 'LimitedReserveTransferAssets';
      params: {
        dest: XcmVersionedMultiLocation;
        beneficiary: XcmVersionedMultiLocation;
        assets: XcmVersionedMultiAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * See [`Pallet::limited_teleport_assets`].
   **/
  | {
      name: 'LimitedTeleportAssets';
      params: {
        dest: XcmVersionedMultiLocation;
        beneficiary: XcmVersionedMultiLocation;
        assets: XcmVersionedMultiAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * See [`Pallet::force_suspension`].
   **/
  | { name: 'ForceSuspension'; params: { suspended: boolean } };

export type XcmVersionedXcm = { type: 'V2'; value: XcmV2Xcm } | { type: 'V3'; value: XcmV3Xcm };

export type XcmV2Xcm = Array<XcmV2Instruction>;

export type XcmV2Instruction =
  | { type: 'WithdrawAsset'; value: XcmV2MultiassetMultiAssets }
  | { type: 'ReserveAssetDeposited'; value: XcmV2MultiassetMultiAssets }
  | { type: 'ReceiveTeleportedAsset'; value: XcmV2MultiassetMultiAssets }
  | { type: 'QueryResponse'; value: { queryId: bigint; response: XcmV2Response; maxWeight: bigint } }
  | {
      type: 'TransferAsset';
      value: { assets: XcmV2MultiassetMultiAssets; beneficiary: XcmV2MultilocationMultiLocation };
    }
  | {
      type: 'TransferReserveAsset';
      value: { assets: XcmV2MultiassetMultiAssets; dest: XcmV2MultilocationMultiLocation; xcm: XcmV2Xcm };
    }
  | { type: 'Transact'; value: { originType: XcmV2OriginKind; requireWeightAtMost: bigint; call: XcmDoubleEncoded } }
  | { type: 'HrmpNewChannelOpenRequest'; value: { sender: number; maxMessageSize: number; maxCapacity: number } }
  | { type: 'HrmpChannelAccepted'; value: { recipient: number } }
  | { type: 'HrmpChannelClosing'; value: { initiator: number; sender: number; recipient: number } }
  | { type: 'ClearOrigin' }
  | { type: 'DescendOrigin'; value: XcmV2MultilocationJunctions }
  | {
      type: 'ReportError';
      value: { queryId: bigint; dest: XcmV2MultilocationMultiLocation; maxResponseWeight: bigint };
    }
  | {
      type: 'DepositAsset';
      value: {
        assets: XcmV2MultiassetMultiAssetFilter;
        maxAssets: number;
        beneficiary: XcmV2MultilocationMultiLocation;
      };
    }
  | {
      type: 'DepositReserveAsset';
      value: {
        assets: XcmV2MultiassetMultiAssetFilter;
        maxAssets: number;
        dest: XcmV2MultilocationMultiLocation;
        xcm: XcmV2Xcm;
      };
    }
  | { type: 'ExchangeAsset'; value: { give: XcmV2MultiassetMultiAssetFilter; receive: XcmV2MultiassetMultiAssets } }
  | {
      type: 'InitiateReserveWithdraw';
      value: { assets: XcmV2MultiassetMultiAssetFilter; reserve: XcmV2MultilocationMultiLocation; xcm: XcmV2Xcm };
    }
  | {
      type: 'InitiateTeleport';
      value: { assets: XcmV2MultiassetMultiAssetFilter; dest: XcmV2MultilocationMultiLocation; xcm: XcmV2Xcm };
    }
  | {
      type: 'QueryHolding';
      value: {
        queryId: bigint;
        dest: XcmV2MultilocationMultiLocation;
        assets: XcmV2MultiassetMultiAssetFilter;
        maxResponseWeight: bigint;
      };
    }
  | { type: 'BuyExecution'; value: { fees: XcmV2MultiassetMultiAsset; weightLimit: XcmV2WeightLimit } }
  | { type: 'RefundSurplus' }
  | { type: 'SetErrorHandler'; value: XcmV2Xcm }
  | { type: 'SetAppendix'; value: XcmV2Xcm }
  | { type: 'ClearError' }
  | { type: 'ClaimAsset'; value: { assets: XcmV2MultiassetMultiAssets; ticket: XcmV2MultilocationMultiLocation } }
  | { type: 'Trap'; value: bigint }
  | { type: 'SubscribeVersion'; value: { queryId: bigint; maxResponseWeight: bigint } }
  | { type: 'UnsubscribeVersion' };

export type XcmV2Response =
  | { type: 'Null' }
  | { type: 'Assets'; value: XcmV2MultiassetMultiAssets }
  | { type: 'ExecutionResult'; value?: [number, XcmV2TraitsError] | undefined }
  | { type: 'Version'; value: number };

export type XcmV2TraitsError =
  | { type: 'Overflow' }
  | { type: 'Unimplemented' }
  | { type: 'UntrustedReserveLocation' }
  | { type: 'UntrustedTeleportLocation' }
  | { type: 'MultiLocationFull' }
  | { type: 'MultiLocationNotInvertible' }
  | { type: 'BadOrigin' }
  | { type: 'InvalidLocation' }
  | { type: 'AssetNotFound' }
  | { type: 'FailedToTransactAsset' }
  | { type: 'NotWithdrawable' }
  | { type: 'LocationCannotHold' }
  | { type: 'ExceedsMaxMessageSize' }
  | { type: 'DestinationUnsupported' }
  | { type: 'Transport' }
  | { type: 'Unroutable' }
  | { type: 'UnknownClaim' }
  | { type: 'FailedToDecode' }
  | { type: 'MaxWeightInvalid' }
  | { type: 'NotHoldingFees' }
  | { type: 'TooExpensive' }
  | { type: 'Trap'; value: bigint }
  | { type: 'UnhandledXcmVersion' }
  | { type: 'WeightLimitReached'; value: bigint }
  | { type: 'Barrier' }
  | { type: 'WeightNotComputable' };

export type XcmV2MultiassetMultiAssetFilter =
  | { type: 'Definite'; value: XcmV2MultiassetMultiAssets }
  | { type: 'Wild'; value: XcmV2MultiassetWildMultiAsset };

export type XcmV2MultiassetWildMultiAsset =
  | { type: 'All' }
  | { type: 'AllOf'; value: { id: XcmV2MultiassetAssetId; fun: XcmV2MultiassetWildFungibility } };

export type XcmV2MultiassetWildFungibility = 'Fungible' | 'NonFungible';

export type XcmV2WeightLimit = { type: 'Unlimited' } | { type: 'Limited'; value: bigint };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type CumulusPalletXcmCall = null;

export type CumulusPalletXcmCallLike = null;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type CumulusPalletDmpQueueCall =
  /**
   * See [`Pallet::service_overweight`].
   **/
  { name: 'ServiceOverweight'; params: { index: bigint; weightLimit: SpWeightsWeightV2Weight } };

export type CumulusPalletDmpQueueCallLike =
  /**
   * See [`Pallet::service_overweight`].
   **/
  { name: 'ServiceOverweight'; params: { index: bigint; weightLimit: SpWeightsWeightV2Weight } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletXcAssetConfigCall =
  /**
   * See [`Pallet::register_asset_location`].
   **/
  | { name: 'RegisterAssetLocation'; params: { assetLocation: XcmVersionedMultiLocation; assetId: bigint } }
  /**
   * See [`Pallet::set_asset_units_per_second`].
   **/
  | { name: 'SetAssetUnitsPerSecond'; params: { assetLocation: XcmVersionedMultiLocation; unitsPerSecond: bigint } }
  /**
   * See [`Pallet::change_existing_asset_location`].
   **/
  | { name: 'ChangeExistingAssetLocation'; params: { newAssetLocation: XcmVersionedMultiLocation; assetId: bigint } }
  /**
   * See [`Pallet::remove_payment_asset`].
   **/
  | { name: 'RemovePaymentAsset'; params: { assetLocation: XcmVersionedMultiLocation } }
  /**
   * See [`Pallet::remove_asset`].
   **/
  | { name: 'RemoveAsset'; params: { assetId: bigint } };

export type PalletXcAssetConfigCallLike =
  /**
   * See [`Pallet::register_asset_location`].
   **/
  | { name: 'RegisterAssetLocation'; params: { assetLocation: XcmVersionedMultiLocation; assetId: bigint } }
  /**
   * See [`Pallet::set_asset_units_per_second`].
   **/
  | { name: 'SetAssetUnitsPerSecond'; params: { assetLocation: XcmVersionedMultiLocation; unitsPerSecond: bigint } }
  /**
   * See [`Pallet::change_existing_asset_location`].
   **/
  | { name: 'ChangeExistingAssetLocation'; params: { newAssetLocation: XcmVersionedMultiLocation; assetId: bigint } }
  /**
   * See [`Pallet::remove_payment_asset`].
   **/
  | { name: 'RemovePaymentAsset'; params: { assetLocation: XcmVersionedMultiLocation } }
  /**
   * See [`Pallet::remove_asset`].
   **/
  | { name: 'RemoveAsset'; params: { assetId: bigint } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type OrmlXtokensModuleCall =
  /**
   * See [`Pallet::transfer`].
   **/
  | {
      name: 'Transfer';
      params: {
        currencyId: bigint;
        amount: bigint;
        dest: XcmVersionedMultiLocation;
        destWeightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * See [`Pallet::transfer_multiasset`].
   **/
  | {
      name: 'TransferMultiasset';
      params: { asset: XcmVersionedMultiAsset; dest: XcmVersionedMultiLocation; destWeightLimit: XcmV3WeightLimit };
    }
  /**
   * See [`Pallet::transfer_with_fee`].
   **/
  | {
      name: 'TransferWithFee';
      params: {
        currencyId: bigint;
        amount: bigint;
        fee: bigint;
        dest: XcmVersionedMultiLocation;
        destWeightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * See [`Pallet::transfer_multiasset_with_fee`].
   **/
  | {
      name: 'TransferMultiassetWithFee';
      params: {
        asset: XcmVersionedMultiAsset;
        fee: XcmVersionedMultiAsset;
        dest: XcmVersionedMultiLocation;
        destWeightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * See [`Pallet::transfer_multicurrencies`].
   **/
  | {
      name: 'TransferMulticurrencies';
      params: {
        currencies: Array<[bigint, bigint]>;
        feeItem: number;
        dest: XcmVersionedMultiLocation;
        destWeightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * See [`Pallet::transfer_multiassets`].
   **/
  | {
      name: 'TransferMultiassets';
      params: {
        assets: XcmVersionedMultiAssets;
        feeItem: number;
        dest: XcmVersionedMultiLocation;
        destWeightLimit: XcmV3WeightLimit;
      };
    };

export type OrmlXtokensModuleCallLike =
  /**
   * See [`Pallet::transfer`].
   **/
  | {
      name: 'Transfer';
      params: {
        currencyId: bigint;
        amount: bigint;
        dest: XcmVersionedMultiLocation;
        destWeightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * See [`Pallet::transfer_multiasset`].
   **/
  | {
      name: 'TransferMultiasset';
      params: { asset: XcmVersionedMultiAsset; dest: XcmVersionedMultiLocation; destWeightLimit: XcmV3WeightLimit };
    }
  /**
   * See [`Pallet::transfer_with_fee`].
   **/
  | {
      name: 'TransferWithFee';
      params: {
        currencyId: bigint;
        amount: bigint;
        fee: bigint;
        dest: XcmVersionedMultiLocation;
        destWeightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * See [`Pallet::transfer_multiasset_with_fee`].
   **/
  | {
      name: 'TransferMultiassetWithFee';
      params: {
        asset: XcmVersionedMultiAsset;
        fee: XcmVersionedMultiAsset;
        dest: XcmVersionedMultiLocation;
        destWeightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * See [`Pallet::transfer_multicurrencies`].
   **/
  | {
      name: 'TransferMulticurrencies';
      params: {
        currencies: Array<[bigint, bigint]>;
        feeItem: number;
        dest: XcmVersionedMultiLocation;
        destWeightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * See [`Pallet::transfer_multiassets`].
   **/
  | {
      name: 'TransferMultiassets';
      params: {
        assets: XcmVersionedMultiAssets;
        feeItem: number;
        dest: XcmVersionedMultiLocation;
        destWeightLimit: XcmV3WeightLimit;
      };
    };

export type XcmVersionedMultiAsset =
  | { type: 'V2'; value: XcmV2MultiassetMultiAsset }
  | { type: 'V3'; value: XcmV3MultiassetMultiAsset };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletEvmCall =
  /**
   * See [`Pallet::withdraw`].
   **/
  | { name: 'Withdraw'; params: { address: H160; value: bigint } }
  /**
   * See [`Pallet::call`].
   **/
  | {
      name: 'Call';
      params: {
        source: H160;
        target: H160;
        input: Bytes;
        value: U256;
        gasLimit: bigint;
        maxFeePerGas: U256;
        maxPriorityFeePerGas?: U256 | undefined;
        nonce?: U256 | undefined;
        accessList: Array<[H160, Array<H256>]>;
      };
    }
  /**
   * See [`Pallet::create`].
   **/
  | {
      name: 'Create';
      params: {
        source: H160;
        init: Bytes;
        value: U256;
        gasLimit: bigint;
        maxFeePerGas: U256;
        maxPriorityFeePerGas?: U256 | undefined;
        nonce?: U256 | undefined;
        accessList: Array<[H160, Array<H256>]>;
      };
    }
  /**
   * See [`Pallet::create2`].
   **/
  | {
      name: 'Create2';
      params: {
        source: H160;
        init: Bytes;
        salt: H256;
        value: U256;
        gasLimit: bigint;
        maxFeePerGas: U256;
        maxPriorityFeePerGas?: U256 | undefined;
        nonce?: U256 | undefined;
        accessList: Array<[H160, Array<H256>]>;
      };
    };

export type PalletEvmCallLike =
  /**
   * See [`Pallet::withdraw`].
   **/
  | { name: 'Withdraw'; params: { address: H160; value: bigint } }
  /**
   * See [`Pallet::call`].
   **/
  | {
      name: 'Call';
      params: {
        source: H160;
        target: H160;
        input: BytesLike;
        value: U256;
        gasLimit: bigint;
        maxFeePerGas: U256;
        maxPriorityFeePerGas?: U256 | undefined;
        nonce?: U256 | undefined;
        accessList: Array<[H160, Array<H256>]>;
      };
    }
  /**
   * See [`Pallet::create`].
   **/
  | {
      name: 'Create';
      params: {
        source: H160;
        init: BytesLike;
        value: U256;
        gasLimit: bigint;
        maxFeePerGas: U256;
        maxPriorityFeePerGas?: U256 | undefined;
        nonce?: U256 | undefined;
        accessList: Array<[H160, Array<H256>]>;
      };
    }
  /**
   * See [`Pallet::create2`].
   **/
  | {
      name: 'Create2';
      params: {
        source: H160;
        init: BytesLike;
        salt: H256;
        value: U256;
        gasLimit: bigint;
        maxFeePerGas: U256;
        maxPriorityFeePerGas?: U256 | undefined;
        nonce?: U256 | undefined;
        accessList: Array<[H160, Array<H256>]>;
      };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletEthereumCall =
  /**
   * See [`Pallet::transact`].
   **/
  { name: 'Transact'; params: { transaction: EthereumTransactionTransactionV2 } };

export type PalletEthereumCallLike =
  /**
   * See [`Pallet::transact`].
   **/
  { name: 'Transact'; params: { transaction: EthereumTransactionTransactionV2 } };

export type EthereumTransactionTransactionV2 =
  | { type: 'Legacy'; value: EthereumTransactionLegacyTransaction }
  | { type: 'Eip2930'; value: EthereumTransactionEip2930Transaction }
  | { type: 'Eip1559'; value: EthereumTransactionEip1559Transaction };

export type EthereumTransactionLegacyTransaction = {
  nonce: U256;
  gasPrice: U256;
  gasLimit: U256;
  action: EthereumTransactionTransactionAction;
  value: U256;
  input: Bytes;
  signature: EthereumTransactionTransactionSignature;
};

export type EthereumTransactionTransactionAction = { type: 'Call'; value: H160 } | { type: 'Create' };

export type EthereumTransactionTransactionSignature = { v: EthereumTransactionTransactionRecoveryId; r: H256; s: H256 };

export type EthereumTransactionTransactionRecoveryId = bigint;

export type EthereumTransactionEip2930Transaction = {
  chainId: bigint;
  nonce: U256;
  gasPrice: U256;
  gasLimit: U256;
  action: EthereumTransactionTransactionAction;
  value: U256;
  input: Bytes;
  accessList: Array<EthereumTransactionAccessListItem>;
  oddYParity: boolean;
  r: H256;
  s: H256;
};

export type EthereumTransactionAccessListItem = { address: H160; storageKeys: Array<H256> };

export type EthereumTransactionEip1559Transaction = {
  chainId: bigint;
  nonce: U256;
  maxPriorityFeePerGas: U256;
  maxFeePerGas: U256;
  gasLimit: U256;
  action: EthereumTransactionTransactionAction;
  value: U256;
  input: Bytes;
  accessList: Array<EthereumTransactionAccessListItem>;
  oddYParity: boolean;
  r: H256;
  s: H256;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletDynamicEvmBaseFeeCall =
  /**
   * See [`Pallet::set_base_fee_per_gas`].
   **/
  { name: 'SetBaseFeePerGas'; params: { fee: U256 } };

export type PalletDynamicEvmBaseFeeCallLike =
  /**
   * See [`Pallet::set_base_fee_per_gas`].
   **/
  { name: 'SetBaseFeePerGas'; params: { fee: U256 } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletContractsCall =
  /**
   * See [`Pallet::call_old_weight`].
   **/
  | {
      name: 'CallOldWeight';
      params: {
        dest: MultiAddress;
        value: bigint;
        gasLimit: bigint;
        storageDepositLimit?: bigint | undefined;
        data: Bytes;
      };
    }
  /**
   * See [`Pallet::instantiate_with_code_old_weight`].
   **/
  | {
      name: 'InstantiateWithCodeOldWeight';
      params: {
        value: bigint;
        gasLimit: bigint;
        storageDepositLimit?: bigint | undefined;
        code: Bytes;
        data: Bytes;
        salt: Bytes;
      };
    }
  /**
   * See [`Pallet::instantiate_old_weight`].
   **/
  | {
      name: 'InstantiateOldWeight';
      params: {
        value: bigint;
        gasLimit: bigint;
        storageDepositLimit?: bigint | undefined;
        codeHash: H256;
        data: Bytes;
        salt: Bytes;
      };
    }
  /**
   * See [`Pallet::upload_code`].
   **/
  | {
      name: 'UploadCode';
      params: { code: Bytes; storageDepositLimit?: bigint | undefined; determinism: PalletContractsWasmDeterminism };
    }
  /**
   * See [`Pallet::remove_code`].
   **/
  | { name: 'RemoveCode'; params: { codeHash: H256 } }
  /**
   * See [`Pallet::set_code`].
   **/
  | { name: 'SetCode'; params: { dest: MultiAddress; codeHash: H256 } }
  /**
   * See [`Pallet::call`].
   **/
  | {
      name: 'Call';
      params: {
        dest: MultiAddress;
        value: bigint;
        gasLimit: SpWeightsWeightV2Weight;
        storageDepositLimit?: bigint | undefined;
        data: Bytes;
      };
    }
  /**
   * See [`Pallet::instantiate_with_code`].
   **/
  | {
      name: 'InstantiateWithCode';
      params: {
        value: bigint;
        gasLimit: SpWeightsWeightV2Weight;
        storageDepositLimit?: bigint | undefined;
        code: Bytes;
        data: Bytes;
        salt: Bytes;
      };
    }
  /**
   * See [`Pallet::instantiate`].
   **/
  | {
      name: 'Instantiate';
      params: {
        value: bigint;
        gasLimit: SpWeightsWeightV2Weight;
        storageDepositLimit?: bigint | undefined;
        codeHash: H256;
        data: Bytes;
        salt: Bytes;
      };
    }
  /**
   * See [`Pallet::migrate`].
   **/
  | { name: 'Migrate'; params: { weightLimit: SpWeightsWeightV2Weight } };

export type PalletContractsCallLike =
  /**
   * See [`Pallet::call_old_weight`].
   **/
  | {
      name: 'CallOldWeight';
      params: {
        dest: MultiAddressLike;
        value: bigint;
        gasLimit: bigint;
        storageDepositLimit?: bigint | undefined;
        data: BytesLike;
      };
    }
  /**
   * See [`Pallet::instantiate_with_code_old_weight`].
   **/
  | {
      name: 'InstantiateWithCodeOldWeight';
      params: {
        value: bigint;
        gasLimit: bigint;
        storageDepositLimit?: bigint | undefined;
        code: BytesLike;
        data: BytesLike;
        salt: BytesLike;
      };
    }
  /**
   * See [`Pallet::instantiate_old_weight`].
   **/
  | {
      name: 'InstantiateOldWeight';
      params: {
        value: bigint;
        gasLimit: bigint;
        storageDepositLimit?: bigint | undefined;
        codeHash: H256;
        data: BytesLike;
        salt: BytesLike;
      };
    }
  /**
   * See [`Pallet::upload_code`].
   **/
  | {
      name: 'UploadCode';
      params: {
        code: BytesLike;
        storageDepositLimit?: bigint | undefined;
        determinism: PalletContractsWasmDeterminism;
      };
    }
  /**
   * See [`Pallet::remove_code`].
   **/
  | { name: 'RemoveCode'; params: { codeHash: H256 } }
  /**
   * See [`Pallet::set_code`].
   **/
  | { name: 'SetCode'; params: { dest: MultiAddressLike; codeHash: H256 } }
  /**
   * See [`Pallet::call`].
   **/
  | {
      name: 'Call';
      params: {
        dest: MultiAddressLike;
        value: bigint;
        gasLimit: SpWeightsWeightV2Weight;
        storageDepositLimit?: bigint | undefined;
        data: BytesLike;
      };
    }
  /**
   * See [`Pallet::instantiate_with_code`].
   **/
  | {
      name: 'InstantiateWithCode';
      params: {
        value: bigint;
        gasLimit: SpWeightsWeightV2Weight;
        storageDepositLimit?: bigint | undefined;
        code: BytesLike;
        data: BytesLike;
        salt: BytesLike;
      };
    }
  /**
   * See [`Pallet::instantiate`].
   **/
  | {
      name: 'Instantiate';
      params: {
        value: bigint;
        gasLimit: SpWeightsWeightV2Weight;
        storageDepositLimit?: bigint | undefined;
        codeHash: H256;
        data: BytesLike;
        salt: BytesLike;
      };
    }
  /**
   * See [`Pallet::migrate`].
   **/
  | { name: 'Migrate'; params: { weightLimit: SpWeightsWeightV2Weight } };

export type PalletContractsWasmDeterminism = 'Enforced' | 'Relaxed';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSudoCall =
  /**
   * See [`Pallet::sudo`].
   **/
  | { name: 'Sudo'; params: { call: AstarRuntimeRuntimeCall } }
  /**
   * See [`Pallet::sudo_unchecked_weight`].
   **/
  | { name: 'SudoUncheckedWeight'; params: { call: AstarRuntimeRuntimeCall; weight: SpWeightsWeightV2Weight } }
  /**
   * See [`Pallet::set_key`].
   **/
  | { name: 'SetKey'; params: { new: MultiAddress } }
  /**
   * See [`Pallet::sudo_as`].
   **/
  | { name: 'SudoAs'; params: { who: MultiAddress; call: AstarRuntimeRuntimeCall } };

export type PalletSudoCallLike =
  /**
   * See [`Pallet::sudo`].
   **/
  | { name: 'Sudo'; params: { call: AstarRuntimeRuntimeCallLike } }
  /**
   * See [`Pallet::sudo_unchecked_weight`].
   **/
  | { name: 'SudoUncheckedWeight'; params: { call: AstarRuntimeRuntimeCallLike; weight: SpWeightsWeightV2Weight } }
  /**
   * See [`Pallet::set_key`].
   **/
  | { name: 'SetKey'; params: { new: MultiAddressLike } }
  /**
   * See [`Pallet::sudo_as`].
   **/
  | { name: 'SudoAs'; params: { who: MultiAddressLike; call: AstarRuntimeRuntimeCallLike } };

export type AstarRuntimeOriginCaller =
  | { type: 'System'; value: FrameSupportDispatchRawOrigin }
  | { type: 'PolkadotXcm'; value: PalletXcmOrigin }
  | { type: 'CumulusXcm'; value: CumulusPalletXcmOrigin }
  | { type: 'Ethereum'; value: PalletEthereumRawOrigin }
  | { type: 'Void'; value: SpCoreVoid };

export type FrameSupportDispatchRawOrigin =
  | { type: 'Root' }
  | { type: 'Signed'; value: AccountId32 }
  | { type: 'None' };

export type PalletXcmOrigin =
  | { type: 'Xcm'; value: StagingXcmV3MultilocationMultiLocation }
  | { type: 'Response'; value: StagingXcmV3MultilocationMultiLocation };

export type CumulusPalletXcmOrigin =
  | { type: 'Relay' }
  | { type: 'SiblingParachain'; value: PolkadotParachainPrimitivesPrimitivesId };

export type PalletEthereumRawOrigin = { type: 'EthereumTransaction'; value: H160 };

export type SpCoreVoid = null;

/**
 * The `Error` enum of this pallet.
 **/
export type PalletUtilityError =
  /**
   * Too many calls batched.
   **/
  'TooManyCalls';

export type PalletIdentityRegistration = {
  judgements: Array<[number, PalletIdentityJudgement]>;
  deposit: bigint;
  info: PalletIdentitySimpleIdentityInfo;
};

export type PalletIdentityRegistrarInfo = { account: AccountId32; fee: bigint; fields: PalletIdentityBitFlags };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletIdentityError =
  /**
   * Too many subs-accounts.
   **/
  | 'TooManySubAccounts'
  /**
   * Account isn't found.
   **/
  | 'NotFound'
  /**
   * Account isn't named.
   **/
  | 'NotNamed'
  /**
   * Empty index.
   **/
  | 'EmptyIndex'
  /**
   * Fee is changed.
   **/
  | 'FeeChanged'
  /**
   * No identity found.
   **/
  | 'NoIdentity'
  /**
   * Sticky judgement.
   **/
  | 'StickyJudgement'
  /**
   * Judgement given.
   **/
  | 'JudgementGiven'
  /**
   * Invalid judgement.
   **/
  | 'InvalidJudgement'
  /**
   * The index is invalid.
   **/
  | 'InvalidIndex'
  /**
   * The target is invalid.
   **/
  | 'InvalidTarget'
  /**
   * Too many additional fields.
   **/
  | 'TooManyFields'
  /**
   * Maximum amount of registrars reached. Cannot add any more.
   **/
  | 'TooManyRegistrars'
  /**
   * Account ID is already named.
   **/
  | 'AlreadyClaimed'
  /**
   * Sender is not a sub-account.
   **/
  | 'NotSub'
  /**
   * Sub-account isn't owned by sender.
   **/
  | 'NotOwned'
  /**
   * The provided judgement was for a different identity.
   **/
  | 'JudgementForDifferentIdentity'
  /**
   * Error that occurs when there is an issue paying for judgement.
   **/
  | 'JudgementPaymentFailed';

export type PalletMultisigMultisig = {
  when: PalletMultisigTimepoint;
  deposit: bigint;
  depositor: AccountId32;
  approvals: Array<AccountId32>;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletMultisigError =
  /**
   * Threshold must be 2 or greater.
   **/
  | 'MinimumThreshold'
  /**
   * Call is already approved by this signatory.
   **/
  | 'AlreadyApproved'
  /**
   * Call doesn't need any (more) approvals.
   **/
  | 'NoApprovalsNeeded'
  /**
   * There are too few signatories in the list.
   **/
  | 'TooFewSignatories'
  /**
   * There are too many signatories in the list.
   **/
  | 'TooManySignatories'
  /**
   * The signatories were provided out of order; they should be ordered.
   **/
  | 'SignatoriesOutOfOrder'
  /**
   * The sender was contained in the other signatories; it shouldn't be.
   **/
  | 'SenderInSignatories'
  /**
   * Multisig operation not found when attempting to cancel.
   **/
  | 'NotFound'
  /**
   * Only the account that originally created the multisig is able to cancel it.
   **/
  | 'NotOwner'
  /**
   * No timepoint was given, yet the multisig operation is already underway.
   **/
  | 'NoTimepoint'
  /**
   * A different timepoint was given to the multisig operation that is underway.
   **/
  | 'WrongTimepoint'
  /**
   * A timepoint was given, yet no multisig operation is underway.
   **/
  | 'UnexpectedTimepoint'
  /**
   * The maximum weight information provided was too low.
   **/
  | 'MaxWeightTooLow'
  /**
   * The data to be stored is already stored.
   **/
  | 'AlreadyStored';

export type PalletProxyProxyDefinition = { delegate: AccountId32; proxyType: AstarRuntimeProxyType; delay: number };

export type PalletProxyAnnouncement = { real: AccountId32; callHash: H256; height: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletProxyError =
  /**
   * There are too many proxies registered or too many announcements pending.
   **/
  | 'TooMany'
  /**
   * Proxy registration not found.
   **/
  | 'NotFound'
  /**
   * Sender is not a proxy of the account to be proxied.
   **/
  | 'NotProxy'
  /**
   * A call which is incompatible with the proxy type's filter was attempted.
   **/
  | 'Unproxyable'
  /**
   * Account is already a proxy.
   **/
  | 'Duplicate'
  /**
   * Call may not be made by proxy because it may escalate its privileges.
   **/
  | 'NoPermission'
  /**
   * Announcement, if made at all, was made too recently.
   **/
  | 'Unannounced'
  /**
   * Cannot add self as proxy.
   **/
  | 'NoSelfProxy';

export type CumulusPalletParachainSystemUnincludedSegmentAncestor = {
  usedBandwidth: CumulusPalletParachainSystemUnincludedSegmentUsedBandwidth;
  paraHeadHash?: H256 | undefined;
  consumedGoAheadSignal?: PolkadotPrimitivesV6UpgradeGoAhead | undefined;
};

export type CumulusPalletParachainSystemUnincludedSegmentUsedBandwidth = {
  umpMsgCount: number;
  umpTotalBytes: number;
  hrmpOutgoing: Array<
    [PolkadotParachainPrimitivesPrimitivesId, CumulusPalletParachainSystemUnincludedSegmentHrmpChannelUpdate]
  >;
};

export type CumulusPalletParachainSystemUnincludedSegmentHrmpChannelUpdate = { msgCount: number; totalBytes: number };

export type PolkadotPrimitivesV6UpgradeGoAhead = 'Abort' | 'GoAhead';

export type CumulusPalletParachainSystemUnincludedSegmentSegmentTracker = {
  usedBandwidth: CumulusPalletParachainSystemUnincludedSegmentUsedBandwidth;
  hrmpWatermark?: number | undefined;
  consumedGoAheadSignal?: PolkadotPrimitivesV6UpgradeGoAhead | undefined;
};

export type PolkadotPrimitivesV6UpgradeRestriction = 'Present';

export type CumulusPalletParachainSystemRelayStateSnapshotMessagingStateSnapshot = {
  dmqMqcHead: H256;
  relayDispatchQueueRemainingCapacity: CumulusPalletParachainSystemRelayStateSnapshotRelayDispatchQueueRemainingCapacity;
  ingressChannels: Array<[PolkadotParachainPrimitivesPrimitivesId, PolkadotPrimitivesV6AbridgedHrmpChannel]>;
  egressChannels: Array<[PolkadotParachainPrimitivesPrimitivesId, PolkadotPrimitivesV6AbridgedHrmpChannel]>;
};

export type CumulusPalletParachainSystemRelayStateSnapshotRelayDispatchQueueRemainingCapacity = {
  remainingCount: number;
  remainingSize: number;
};

export type PolkadotPrimitivesV6AbridgedHrmpChannel = {
  maxCapacity: number;
  maxTotalSize: number;
  maxMessageSize: number;
  msgCount: number;
  totalSize: number;
  mqcHead?: H256 | undefined;
};

export type PolkadotPrimitivesV6AbridgedHostConfiguration = {
  maxCodeSize: number;
  maxHeadDataSize: number;
  maxUpwardQueueCount: number;
  maxUpwardQueueSize: number;
  maxUpwardMessageSize: number;
  maxUpwardMessageNumPerCandidate: number;
  hrmpMaxMessageNumPerCandidate: number;
  validationUpgradeCooldown: number;
  validationUpgradeDelay: number;
  asyncBackingParams: PolkadotPrimitivesV6AsyncBackingAsyncBackingParams;
};

export type PolkadotPrimitivesV6AsyncBackingAsyncBackingParams = {
  maxCandidateDepth: number;
  allowedAncestryLen: number;
};

export type CumulusPrimitivesParachainInherentMessageQueueChain = H256;

export type PolkadotCorePrimitivesOutboundHrmpMessage = {
  recipient: PolkadotParachainPrimitivesPrimitivesId;
  data: Bytes;
};

export type CumulusPalletParachainSystemCodeUpgradeAuthorization = { codeHash: H256; checkVersion: boolean };

/**
 * The `Error` enum of this pallet.
 **/
export type CumulusPalletParachainSystemError =
  /**
   * Attempt to upgrade validation function while existing upgrade pending.
   **/
  | 'OverlappingUpgrades'
  /**
   * Polkadot currently prohibits this parachain from upgrading its validation function.
   **/
  | 'ProhibitedByPolkadot'
  /**
   * The supplied validation function has compiled into a blob larger than Polkadot is
   * willing to run.
   **/
  | 'TooBig'
  /**
   * The inherent which supplies the validation data did not run this block.
   **/
  | 'ValidationDataNotAvailable'
  /**
   * The inherent which supplies the host configuration did not run this block.
   **/
  | 'HostConfigurationNotAvailable'
  /**
   * No validation function upgrade is currently scheduled.
   **/
  | 'NotScheduled'
  /**
   * No code upgrade has been authorized.
   **/
  | 'NothingAuthorized'
  /**
   * The given code upgrade has not been authorized.
   **/
  | 'Unauthorized';

export type PalletTransactionPaymentReleases = 'V1Ancient' | 'V2';

export type PalletBalancesBalanceLock = { id: FixedBytes<8>; amount: bigint; reasons: PalletBalancesReasons };

export type PalletBalancesReasons = 'Fee' | 'Misc' | 'All';

export type PalletBalancesReserveData = { id: FixedBytes<8>; amount: bigint };

export type PalletBalancesIdAmount = { id: AstarRuntimeRuntimeHoldReason; amount: bigint };

export type AstarRuntimeRuntimeHoldReason = { type: 'Contracts'; value: PalletContractsHoldReason };

export type PalletContractsHoldReason = 'CodeUploadDepositReserve' | 'StorageDepositReserve';

export type PalletBalancesIdAmountRuntimeFreezeReason = { id: AstarRuntimeRuntimeFreezeReason; amount: bigint };

export type AstarRuntimeRuntimeFreezeReason = { type: 'DappStaking'; value: PalletDappStakingV3FreezeReason };

export type PalletDappStakingV3FreezeReason = 'DAppStaking';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBalancesError =
  /**
   * Vesting balance too high to send value.
   **/
  | 'VestingBalance'
  /**
   * Account liquidity restrictions prevent withdrawal.
   **/
  | 'LiquidityRestrictions'
  /**
   * Balance too low to send value.
   **/
  | 'InsufficientBalance'
  /**
   * Value too low to create account due to existential deposit.
   **/
  | 'ExistentialDeposit'
  /**
   * Transfer/payment would kill account.
   **/
  | 'Expendability'
  /**
   * A vesting schedule already exists for this account.
   **/
  | 'ExistingVestingSchedule'
  /**
   * Beneficiary account must pre-exist.
   **/
  | 'DeadAccount'
  /**
   * Number of named reserves exceed `MaxReserves`.
   **/
  | 'TooManyReserves'
  /**
   * Number of holds exceed `MaxHolds`.
   **/
  | 'TooManyHolds'
  /**
   * Number of freezes exceed `MaxFreezes`.
   **/
  | 'TooManyFreezes';

export type PalletVestingReleases = 'V0' | 'V1';

/**
 * Error for the vesting pallet.
 **/
export type PalletVestingError =
  /**
   * The account given is not vesting.
   **/
  | 'NotVesting'
  /**
   * The account already has `MaxVestingSchedules` count of schedules and thus
   * cannot add another one. Consider merging existing schedules in order to add another.
   **/
  | 'AtMaxVestingSchedules'
  /**
   * Amount being transferred is too low to create a vesting schedule.
   **/
  | 'AmountLow'
  /**
   * An index was out of bounds of the vesting schedules.
   **/
  | 'ScheduleIndexOutOfBounds'
  /**
   * Failed to create a new schedule because some parameter was invalid.
   **/
  | 'InvalidScheduleParams';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletInflationError =
  /**
   * Sum of all parts must be one whole (100%).
   **/
  'InvalidInflationParameters';

export type PalletDappStakingV3ProtocolState = {
  era: number;
  nextEraStart: number;
  periodInfo: PalletDappStakingV3PeriodInfo;
  maintenance: boolean;
};

export type PalletDappStakingV3PeriodInfo = {
  number: number;
  subperiod: PalletDappStakingV3Subperiod;
  nextSubperiodStartEra: number;
};

export type PalletDappStakingV3DAppInfo = {
  owner: AccountId32;
  id: number;
  rewardBeneficiary?: AccountId32 | undefined;
};

export type PalletDappStakingV3AccountLedger = {
  locked: bigint;
  unlocking: Array<PalletDappStakingV3UnlockingChunk>;
  staked: PalletDappStakingV3StakeAmount;
  stakedFuture?: PalletDappStakingV3StakeAmount | undefined;
  contractStakeCount: number;
};

export type PalletDappStakingV3UnlockingChunk = { amount: bigint; unlockBlock: number };

export type PalletDappStakingV3StakeAmount = { voting: bigint; buildAndEarn: bigint; era: number; period: number };

export type PalletDappStakingV3SingularStakingInfo = {
  previousStaked: PalletDappStakingV3StakeAmount;
  staked: PalletDappStakingV3StakeAmount;
  loyalStaker: boolean;
};

export type PalletDappStakingV3ContractStakeAmount = {
  staked: PalletDappStakingV3StakeAmount;
  stakedFuture?: PalletDappStakingV3StakeAmount | undefined;
};

export type PalletDappStakingV3EraInfo = {
  totalLocked: bigint;
  unlocking: bigint;
  currentStakeAmount: PalletDappStakingV3StakeAmount;
  nextStakeAmount: PalletDappStakingV3StakeAmount;
};

export type PalletDappStakingV3EraRewardSpan = {
  span: Array<PalletDappStakingV3EraReward>;
  firstEra: number;
  lastEra: number;
};

export type PalletDappStakingV3EraReward = { stakerRewardPool: bigint; staked: bigint; dappRewardPool: bigint };

export type PalletDappStakingV3PeriodEndInfo = { bonusRewardPool: bigint; totalVpStake: bigint; finalEra: number };

export type PalletDappStakingV3TierParameters = {
  rewardPortion: Array<Permill>;
  slotDistribution: Array<Permill>;
  tierThresholds: Array<PalletDappStakingV3TierThreshold>;
};

export type PalletDappStakingV3TierThreshold =
  | { type: 'FixedTvlAmount'; value: { amount: bigint } }
  | { type: 'DynamicTvlAmount'; value: { amount: bigint; minimumAmount: bigint } };

export type PalletDappStakingV3TiersConfiguration = {
  numberOfSlots: number;
  slotsPerTier: Array<number>;
  rewardPortion: Array<Permill>;
  tierThresholds: Array<PalletDappStakingV3TierThreshold>;
};

export type PalletDappStakingV3DAppTierRewards = {
  dapps: Array<[number, AstarPrimitivesDappStakingRankedTier]>;
  rewards: Array<bigint>;
  period: number;
  rankRewards: Array<bigint>;
};

export type AstarPrimitivesDappStakingRankedTier = number;

export type PalletDappStakingV3CleanupMarker = {
  eraRewardIndex: number;
  dappTiersIndex: number;
  oldestValidEra: number;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletDappStakingV3Error =
  /**
   * Pallet is disabled/in maintenance mode.
   **/
  | 'Disabled'
  /**
   * Smart contract already exists within dApp staking protocol.
   **/
  | 'ContractAlreadyExists'
  /**
   * Maximum number of smart contracts has been reached.
   **/
  | 'ExceededMaxNumberOfContracts'
  /**
   * Not possible to assign a new dApp Id.
   * This should never happen since current type can support up to 65536 - 1 unique dApps.
   **/
  | 'NewDAppIdUnavailable'
  /**
   * Specified smart contract does not exist in dApp staking.
   **/
  | 'ContractNotFound'
  /**
   * Call origin is not dApp owner.
   **/
  | 'OriginNotOwner'
  /**
   * Performing locking or staking with 0 amount.
   **/
  | 'ZeroAmount'
  /**
   * Total locked amount for staker is below minimum threshold.
   **/
  | 'LockedAmountBelowThreshold'
  /**
   * Account is not allowed to participate in dApp staking due to some external reason (e.g. account is already a collator).
   **/
  | 'AccountNotAvailableForDappStaking'
  /**
   * Cannot add additional unlocking chunks due to capacity limit.
   **/
  | 'TooManyUnlockingChunks'
  /**
   * Remaining stake prevents entire balance of starting the unlocking process.
   **/
  | 'RemainingStakePreventsFullUnlock'
  /**
   * There are no eligible unlocked chunks to claim. This can happen either if no eligible chunks exist, or if user has no chunks at all.
   **/
  | 'NoUnlockedChunksToClaim'
  /**
   * There are no unlocking chunks available to relock.
   **/
  | 'NoUnlockingChunks'
  /**
   * The amount being staked is too large compared to what's available for staking.
   **/
  | 'UnavailableStakeFunds'
  /**
   * There are unclaimed rewards remaining from past eras or periods. They should be claimed before attempting any stake modification again.
   **/
  | 'UnclaimedRewards'
  /**
   * An unexpected error occurred while trying to stake.
   **/
  | 'InternalStakeError'
  /**
   * Total staked amount on contract is below the minimum required value.
   **/
  | 'InsufficientStakeAmount'
  /**
   * Stake operation is rejected since period ends in the next era.
   **/
  | 'PeriodEndsInNextEra'
  /**
   * Unstaking is rejected since the period in which past stake was active has passed.
   **/
  | 'UnstakeFromPastPeriod'
  /**
   * Unstake amount is greater than the staked amount.
   **/
  | 'UnstakeAmountTooLarge'
  /**
   * Account has no staking information for the contract.
   **/
  | 'NoStakingInfo'
  /**
   * An unexpected error occurred while trying to unstake.
   **/
  | 'InternalUnstakeError'
  /**
   * Rewards are no longer claimable since they are too old.
   **/
  | 'RewardExpired'
  /**
   * Reward payout has failed due to an unexpected reason.
   **/
  | 'RewardPayoutFailed'
  /**
   * There are no claimable rewards.
   **/
  | 'NoClaimableRewards'
  /**
   * An unexpected error occurred while trying to claim staker rewards.
   **/
  | 'InternalClaimStakerError'
  /**
   * Account is has no eligible stake amount for bonus reward.
   **/
  | 'NotEligibleForBonusReward'
  /**
   * An unexpected error occurred while trying to claim bonus reward.
   **/
  | 'InternalClaimBonusError'
  /**
   * Claim era is invalid - it must be in history, and rewards must exist for it.
   **/
  | 'InvalidClaimEra'
  /**
   * No dApp tier info exists for the specified era. This can be because era has expired
   * or because during the specified era there were no eligible rewards or protocol wasn't active.
   **/
  | 'NoDAppTierInfo'
  /**
   * An unexpected error occurred while trying to claim dApp reward.
   **/
  | 'InternalClaimDAppError'
  /**
   * Contract is still active, not unregistered.
   **/
  | 'ContractStillActive'
  /**
   * There are too many contract stake entries for the account. This can be cleaned up by either unstaking or cleaning expired entries.
   **/
  | 'TooManyStakedContracts'
  /**
   * There are no expired entries to cleanup for the account.
   **/
  | 'NoExpiredEntries'
  /**
   * Force call is not allowed in production.
   **/
  | 'ForceNotAllowed'
  /**
   * Account doesn't have the freeze inconsistency
   **/
  | 'AccountNotInconsistent';

export type PalletAssetsAssetDetails = {
  owner: AccountId32;
  issuer: AccountId32;
  admin: AccountId32;
  freezer: AccountId32;
  supply: bigint;
  deposit: bigint;
  minBalance: bigint;
  isSufficient: boolean;
  accounts: number;
  sufficients: number;
  approvals: number;
  status: PalletAssetsAssetStatus;
};

export type PalletAssetsAssetStatus = 'Live' | 'Frozen' | 'Destroying';

export type PalletAssetsAssetAccount = {
  balance: bigint;
  status: PalletAssetsAccountStatus;
  reason: PalletAssetsExistenceReason;
  extra: [];
};

export type PalletAssetsAccountStatus = 'Liquid' | 'Frozen' | 'Blocked';

export type PalletAssetsExistenceReason =
  | { type: 'Consumer' }
  | { type: 'Sufficient' }
  | { type: 'DepositHeld'; value: bigint }
  | { type: 'DepositRefunded' }
  | { type: 'DepositFrom'; value: [AccountId32, bigint] };

export type PalletAssetsApproval = { amount: bigint; deposit: bigint };

export type PalletAssetsAssetMetadata = {
  deposit: bigint;
  name: Bytes;
  symbol: Bytes;
  decimals: number;
  isFrozen: boolean;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletAssetsError =
  /**
   * Account balance must be greater than or equal to the transfer amount.
   **/
  | 'BalanceLow'
  /**
   * The account to alter does not exist.
   **/
  | 'NoAccount'
  /**
   * The signing account has no permission to do the operation.
   **/
  | 'NoPermission'
  /**
   * The given asset ID is unknown.
   **/
  | 'Unknown'
  /**
   * The origin account is frozen.
   **/
  | 'Frozen'
  /**
   * The asset ID is already taken.
   **/
  | 'InUse'
  /**
   * Invalid witness data given.
   **/
  | 'BadWitness'
  /**
   * Minimum balance should be non-zero.
   **/
  | 'MinBalanceZero'
  /**
   * Unable to increment the consumer reference counters on the account. Either no provider
   * reference exists to allow a non-zero balance of a non-self-sufficient asset, or one
   * fewer then the maximum number of consumers has been reached.
   **/
  | 'UnavailableConsumer'
  /**
   * Invalid metadata given.
   **/
  | 'BadMetadata'
  /**
   * No approval exists that would allow the transfer.
   **/
  | 'Unapproved'
  /**
   * The source account would not survive the transfer and it needs to stay alive.
   **/
  | 'WouldDie'
  /**
   * The asset-account already exists.
   **/
  | 'AlreadyExists'
  /**
   * The asset-account doesn't have an associated deposit.
   **/
  | 'NoDeposit'
  /**
   * The operation would result in funds being burned.
   **/
  | 'WouldBurn'
  /**
   * The asset is a live asset and is actively being used. Usually emit for operations such
   * as `start_destroy` which require the asset to be in a destroying state.
   **/
  | 'LiveAsset'
  /**
   * The asset is not live, and likely being destroyed.
   **/
  | 'AssetNotLive'
  /**
   * The asset status is not the expected status.
   **/
  | 'IncorrectStatus'
  /**
   * The asset should be frozen before the given operation.
   **/
  | 'NotFrozen'
  /**
   * Callback action resulted in error
   **/
  | 'CallbackFailed';

export type PalletPriceAggregatorValueAggregator = { total: FixedU128; count: number; limitBlock: number };

export type PalletPriceAggregatorCircularBuffer = { buffer: Array<FixedU128>; head: number };

export type OrmlOracleModuleTimestampedValue = { value: FixedU128; timestamp: bigint };

export type OrmlUtilitiesOrderedSet = Array<AccountId32>;

/**
 * The `Error` enum of this pallet.
 **/
export type OrmlOracleModuleError =
  /**
   * Sender does not have permission
   **/
  | 'NoPermission'
  /**
   * Feeder has already feeded at this block
   **/
  | 'AlreadyFeeded';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletMembershipError =
  /**
   * Already a member.
   **/
  | 'AlreadyMember'
  /**
   * Not a member.
   **/
  | 'NotMember'
  /**
   * Too many members.
   **/
  | 'TooManyMembers';

export type PalletCollatorSelectionCandidateInfo = { who: AccountId32; deposit: bigint };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletCollatorSelectionError =
  /**
   * Too many candidates
   **/
  | 'TooManyCandidates'
  /**
   * Too few candidates
   **/
  | 'TooFewCandidates'
  /**
   * Unknown error
   **/
  | 'Unknown'
  /**
   * Permission issue
   **/
  | 'Permission'
  /**
   * User is already a candidate
   **/
  | 'AlreadyCandidate'
  /**
   * User is not a candidate
   **/
  | 'NotCandidate'
  /**
   * User is already an Invulnerable
   **/
  | 'AlreadyInvulnerable'
  /**
   * Account has no associated validator ID
   **/
  | 'NoAssociatedValidatorId'
  /**
   * Validator ID is not yet registered
   **/
  | 'ValidatorNotRegistered'
  /**
   * Account is now allowed to be a candidate due to an external reason (e.g. it might be participating in dApp staking)
   **/
  | 'NotAllowedCandidate';

export type SpCoreCryptoKeyTypeId = FixedBytes<4>;

/**
 * Error for the session pallet.
 **/
export type PalletSessionError =
  /**
   * Invalid ownership proof.
   **/
  | 'InvalidProof'
  /**
   * No associated validator ID for account.
   **/
  | 'NoAssociatedValidatorId'
  /**
   * Registered duplicate key.
   **/
  | 'DuplicatedKey'
  /**
   * No keys are associated with this account.
   **/
  | 'NoKeys'
  /**
   * Key setting account is not live, so it's impossible to associate keys.
   **/
  | 'NoAccount';

export type SpConsensusSlotsSlot = bigint;

export type CumulusPalletXcmpQueueInboundChannelDetails = {
  sender: PolkadotParachainPrimitivesPrimitivesId;
  state: CumulusPalletXcmpQueueInboundState;
  messageMetadata: Array<[number, PolkadotParachainPrimitivesPrimitivesXcmpMessageFormat]>;
};

export type CumulusPalletXcmpQueueInboundState = 'Ok' | 'Suspended';

export type PolkadotParachainPrimitivesPrimitivesXcmpMessageFormat =
  | 'ConcatenatedVersionedXcm'
  | 'ConcatenatedEncodedBlob'
  | 'Signals';

export type CumulusPalletXcmpQueueOutboundChannelDetails = {
  recipient: PolkadotParachainPrimitivesPrimitivesId;
  state: CumulusPalletXcmpQueueOutboundState;
  signalsExist: boolean;
  firstIndex: number;
  lastIndex: number;
};

export type CumulusPalletXcmpQueueOutboundState = 'Ok' | 'Suspended';

export type CumulusPalletXcmpQueueQueueConfigData = {
  suspendThreshold: number;
  dropThreshold: number;
  resumeThreshold: number;
  thresholdWeight: SpWeightsWeightV2Weight;
  weightRestrictDecay: SpWeightsWeightV2Weight;
  xcmpMaxIndividualWeight: SpWeightsWeightV2Weight;
};

/**
 * The `Error` enum of this pallet.
 **/
export type CumulusPalletXcmpQueueError =
  /**
   * Failed to send XCM message.
   **/
  | 'FailedToSend'
  /**
   * Bad XCM origin.
   **/
  | 'BadXcmOrigin'
  /**
   * Bad XCM data.
   **/
  | 'BadXcm'
  /**
   * Bad overweight index.
   **/
  | 'BadOverweightIndex'
  /**
   * Provided weight is possibly not enough to execute the message.
   **/
  | 'WeightOverLimit';

export type PalletXcmQueryStatus =
  | {
      type: 'Pending';
      value: {
        responder: XcmVersionedMultiLocation;
        maybeMatchQuerier?: XcmVersionedMultiLocation | undefined;
        maybeNotify?: [number, number] | undefined;
        timeout: number;
      };
    }
  | { type: 'VersionNotifier'; value: { origin: XcmVersionedMultiLocation; isActive: boolean } }
  | { type: 'Ready'; value: { response: XcmVersionedResponse; at: number } };

export type XcmVersionedResponse = { type: 'V2'; value: XcmV2Response } | { type: 'V3'; value: XcmV3Response };

export type PalletXcmVersionMigrationStage =
  | { type: 'MigrateSupportedVersion' }
  | { type: 'MigrateVersionNotifiers' }
  | { type: 'NotifyCurrentTargets'; value?: Bytes | undefined }
  | { type: 'MigrateAndNotifyOldTargets' };

export type XcmVersionedAssetId = { type: 'V3'; value: XcmV3MultiassetAssetId };

export type PalletXcmRemoteLockedFungibleRecord = {
  amount: bigint;
  owner: XcmVersionedMultiLocation;
  locker: XcmVersionedMultiLocation;
  consumers: Array<[[], bigint]>;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletXcmError =
  /**
   * The desired destination was unreachable, generally because there is a no way of routing
   * to it.
   **/
  | 'Unreachable'
  /**
   * There was some other issue (i.e. not to do with routing) in sending the message.
   * Perhaps a lack of space for buffering the message.
   **/
  | 'SendFailure'
  /**
   * The message execution fails the filter.
   **/
  | 'Filtered'
  /**
   * The message's weight could not be determined.
   **/
  | 'UnweighableMessage'
  /**
   * The destination `MultiLocation` provided cannot be inverted.
   **/
  | 'DestinationNotInvertible'
  /**
   * The assets to be sent are empty.
   **/
  | 'Empty'
  /**
   * Could not re-anchor the assets to declare the fees for the destination chain.
   **/
  | 'CannotReanchor'
  /**
   * Too many assets have been attempted for transfer.
   **/
  | 'TooManyAssets'
  /**
   * Origin is invalid for sending.
   **/
  | 'InvalidOrigin'
  /**
   * The version of the `Versioned` value used is not able to be interpreted.
   **/
  | 'BadVersion'
  /**
   * The given location could not be used (e.g. because it cannot be expressed in the
   * desired version of XCM).
   **/
  | 'BadLocation'
  /**
   * The referenced subscription could not be found.
   **/
  | 'NoSubscription'
  /**
   * The location is invalid since it already has a subscription from us.
   **/
  | 'AlreadySubscribed'
  /**
   * Invalid asset for the operation.
   **/
  | 'InvalidAsset'
  /**
   * The owner does not own (all) of the asset that they wish to do the operation on.
   **/
  | 'LowBalance'
  /**
   * The asset owner has too many locks on the asset.
   **/
  | 'TooManyLocks'
  /**
   * The given account is not an identifiable sovereign account for any location.
   **/
  | 'AccountNotSovereign'
  /**
   * The operation required fees to be paid which the initiator could not meet.
   **/
  | 'FeesNotMet'
  /**
   * A remote lock with the corresponding data could not be found.
   **/
  | 'LockNotFound'
  /**
   * The unlock operation cannot succeed because there are still consumers of the lock.
   **/
  | 'InUse';

/**
 * The `Error` enum of this pallet.
 **/
export type CumulusPalletXcmError = null;

export type CumulusPalletDmpQueueConfigData = { maxIndividual: SpWeightsWeightV2Weight };

export type CumulusPalletDmpQueuePageIndexData = { beginUsed: number; endUsed: number; overweightCount: bigint };

/**
 * The `Error` enum of this pallet.
 **/
export type CumulusPalletDmpQueueError =
  /**
   * The message index given is unknown.
   **/
  | 'Unknown'
  /**
   * The amount of weight given is possibly not enough for executing the message.
   **/
  | 'OverLimit';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletXcAssetConfigError =
  /**
   * Asset is already registered.
   **/
  | 'AssetAlreadyRegistered'
  /**
   * Asset does not exist (hasn't been registered).
   **/
  | 'AssetDoesNotExist'
  /**
   * Failed to convert to latest versioned MultiLocation
   **/
  | 'MultiLocationNotSupported';

/**
 * The `Error` enum of this pallet.
 **/
export type OrmlXtokensModuleError =
  /**
   * Asset has no reserve location.
   **/
  | 'AssetHasNoReserve'
  /**
   * Not cross-chain transfer.
   **/
  | 'NotCrossChainTransfer'
  /**
   * Invalid transfer destination.
   **/
  | 'InvalidDest'
  /**
   * Currency is not cross-chain transferable.
   **/
  | 'NotCrossChainTransferableCurrency'
  /**
   * The message's weight could not be determined.
   **/
  | 'UnweighableMessage'
  /**
   * XCM execution failed.
   **/
  | 'XcmExecutionFailed'
  /**
   * Could not re-anchor the assets to declare the fees for the
   * destination chain.
   **/
  | 'CannotReanchor'
  /**
   * Could not get ancestry of asset reserve location.
   **/
  | 'InvalidAncestry'
  /**
   * The MultiAsset is invalid.
   **/
  | 'InvalidAsset'
  /**
   * The destination `MultiLocation` provided cannot be inverted.
   **/
  | 'DestinationNotInvertible'
  /**
   * The version of the `Versioned` value used is not able to be
   * interpreted.
   **/
  | 'BadVersion'
  /**
   * We tried sending distinct asset and fee but they have different
   * reserve chains.
   **/
  | 'DistinctReserveForAssetAndFee'
  /**
   * The fee is zero.
   **/
  | 'ZeroFee'
  /**
   * The transfering asset amount is zero.
   **/
  | 'ZeroAmount'
  /**
   * The number of assets to be sent is over the maximum.
   **/
  | 'TooManyAssetsBeingSent'
  /**
   * The specified index does not exist in a MultiAssets struct.
   **/
  | 'AssetIndexNonExistent'
  /**
   * Fee is not enough.
   **/
  | 'FeeNotEnough'
  /**
   * Not supported MultiLocation
   **/
  | 'NotSupportedMultiLocation'
  /**
   * MinXcmFee not registered for certain reserve location
   **/
  | 'MinXcmFeeNotDefined';

export type PalletEvmCodeMetadata = { size: bigint; hash: H256 };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletEvmError =
  /**
   * Not enough balance to perform action
   **/
  | 'BalanceLow'
  /**
   * Calculating total fee overflowed
   **/
  | 'FeeOverflow'
  /**
   * Calculating total payment overflowed
   **/
  | 'PaymentOverflow'
  /**
   * Withdraw fee failed
   **/
  | 'WithdrawFailed'
  /**
   * Gas price is too low.
   **/
  | 'GasPriceTooLow'
  /**
   * Nonce is invalid
   **/
  | 'InvalidNonce'
  /**
   * Gas limit is too low.
   **/
  | 'GasLimitTooLow'
  /**
   * Gas limit is too high.
   **/
  | 'GasLimitTooHigh'
  /**
   * The chain id is invalid.
   **/
  | 'InvalidChainId'
  /**
   * the signature is invalid.
   **/
  | 'InvalidSignature'
  /**
   * EVM reentrancy
   **/
  | 'Reentrancy'
  /**
   * EIP-3607,
   **/
  | 'TransactionMustComeFromEOA'
  /**
   * Undefined error.
   **/
  | 'Undefined';

export type FpRpcTransactionStatus = {
  transactionHash: H256;
  transactionIndex: number;
  from: H160;
  to?: H160 | undefined;
  contractAddress?: H160 | undefined;
  logs: Array<EthereumLog>;
  logsBloom: EthbloomBloom;
};

export type EthbloomBloom = FixedBytes<256>;

export type EthereumReceiptReceiptV3 =
  | { type: 'Legacy'; value: EthereumReceiptEip658ReceiptData }
  | { type: 'Eip2930'; value: EthereumReceiptEip658ReceiptData }
  | { type: 'Eip1559'; value: EthereumReceiptEip658ReceiptData };

export type EthereumReceiptEip658ReceiptData = {
  statusCode: number;
  usedGas: U256;
  logsBloom: EthbloomBloom;
  logs: Array<EthereumLog>;
};

export type EthereumBlock = {
  header: EthereumHeader;
  transactions: Array<EthereumTransactionTransactionV2>;
  ommers: Array<EthereumHeader>;
};

export type EthereumHeader = {
  parentHash: H256;
  ommersHash: H256;
  beneficiary: H160;
  stateRoot: H256;
  transactionsRoot: H256;
  receiptsRoot: H256;
  logsBloom: EthbloomBloom;
  difficulty: U256;
  number: U256;
  gasLimit: U256;
  gasUsed: U256;
  timestamp: bigint;
  extraData: Bytes;
  mixHash: H256;
  nonce: EthereumTypesHashH64;
};

export type EthereumTypesHashH64 = FixedBytes<8>;

/**
 * The `Error` enum of this pallet.
 **/
export type PalletEthereumError =
  /**
   * Signature is invalid.
   **/
  | 'InvalidSignature'
  /**
   * Pre-log is present, therefore transact is not allowed.
   **/
  | 'PreLogExists';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletDynamicEvmBaseFeeError =
  /**
   * Specified value is outside of the allowed range.
   **/
  'ValueOutOfBounds';

export type PalletContractsWasmCodeInfo = {
  owner: AccountId32;
  deposit: bigint;
  refcount: bigint;
  determinism: PalletContractsWasmDeterminism;
  codeLen: number;
};

export type PalletContractsStorageContractInfo = {
  trieId: Bytes;
  codeHash: H256;
  storageBytes: number;
  storageItems: number;
  storageByteDeposit: bigint;
  storageItemDeposit: bigint;
  storageBaseDeposit: bigint;
  delegateDependencies: Array<[H256, bigint]>;
};

export type PalletContractsStorageDeletionQueueManager = { insertCounter: number; deleteCounter: number };

export type PalletContractsSchedule = {
  limits: PalletContractsScheduleLimits;
  instructionWeights: PalletContractsScheduleInstructionWeights;
  hostFnWeights: PalletContractsScheduleHostFnWeights;
};

export type PalletContractsScheduleLimits = {
  eventTopics: number;
  globals: number;
  locals: number;
  parameters: number;
  memoryPages: number;
  tableSize: number;
  brTableSize: number;
  subjectLen: number;
  payloadLen: number;
  runtimeMemory: number;
};

export type PalletContractsScheduleInstructionWeights = { base: number };

export type PalletContractsScheduleHostFnWeights = {
  caller: SpWeightsWeightV2Weight;
  isContract: SpWeightsWeightV2Weight;
  codeHash: SpWeightsWeightV2Weight;
  ownCodeHash: SpWeightsWeightV2Weight;
  callerIsOrigin: SpWeightsWeightV2Weight;
  callerIsRoot: SpWeightsWeightV2Weight;
  address: SpWeightsWeightV2Weight;
  gasLeft: SpWeightsWeightV2Weight;
  balance: SpWeightsWeightV2Weight;
  valueTransferred: SpWeightsWeightV2Weight;
  minimumBalance: SpWeightsWeightV2Weight;
  blockNumber: SpWeightsWeightV2Weight;
  now: SpWeightsWeightV2Weight;
  weightToFee: SpWeightsWeightV2Weight;
  input: SpWeightsWeightV2Weight;
  inputPerByte: SpWeightsWeightV2Weight;
  rReturn: SpWeightsWeightV2Weight;
  returnPerByte: SpWeightsWeightV2Weight;
  terminate: SpWeightsWeightV2Weight;
  random: SpWeightsWeightV2Weight;
  depositEvent: SpWeightsWeightV2Weight;
  depositEventPerTopic: SpWeightsWeightV2Weight;
  depositEventPerByte: SpWeightsWeightV2Weight;
  debugMessage: SpWeightsWeightV2Weight;
  debugMessagePerByte: SpWeightsWeightV2Weight;
  setStorage: SpWeightsWeightV2Weight;
  setStoragePerNewByte: SpWeightsWeightV2Weight;
  setStoragePerOldByte: SpWeightsWeightV2Weight;
  setCodeHash: SpWeightsWeightV2Weight;
  clearStorage: SpWeightsWeightV2Weight;
  clearStoragePerByte: SpWeightsWeightV2Weight;
  containsStorage: SpWeightsWeightV2Weight;
  containsStoragePerByte: SpWeightsWeightV2Weight;
  getStorage: SpWeightsWeightV2Weight;
  getStoragePerByte: SpWeightsWeightV2Weight;
  takeStorage: SpWeightsWeightV2Weight;
  takeStoragePerByte: SpWeightsWeightV2Weight;
  transfer: SpWeightsWeightV2Weight;
  call: SpWeightsWeightV2Weight;
  delegateCall: SpWeightsWeightV2Weight;
  callTransferSurcharge: SpWeightsWeightV2Weight;
  callPerClonedByte: SpWeightsWeightV2Weight;
  instantiate: SpWeightsWeightV2Weight;
  instantiateTransferSurcharge: SpWeightsWeightV2Weight;
  instantiatePerInputByte: SpWeightsWeightV2Weight;
  instantiatePerSaltByte: SpWeightsWeightV2Weight;
  hashSha2256: SpWeightsWeightV2Weight;
  hashSha2256PerByte: SpWeightsWeightV2Weight;
  hashKeccak256: SpWeightsWeightV2Weight;
  hashKeccak256PerByte: SpWeightsWeightV2Weight;
  hashBlake2256: SpWeightsWeightV2Weight;
  hashBlake2256PerByte: SpWeightsWeightV2Weight;
  hashBlake2128: SpWeightsWeightV2Weight;
  hashBlake2128PerByte: SpWeightsWeightV2Weight;
  ecdsaRecover: SpWeightsWeightV2Weight;
  ecdsaToEthAddress: SpWeightsWeightV2Weight;
  sr25519Verify: SpWeightsWeightV2Weight;
  sr25519VerifyPerByte: SpWeightsWeightV2Weight;
  reentranceCount: SpWeightsWeightV2Weight;
  accountReentranceCount: SpWeightsWeightV2Weight;
  instantiationNonce: SpWeightsWeightV2Weight;
  addDelegateDependency: SpWeightsWeightV2Weight;
  removeDelegateDependency: SpWeightsWeightV2Weight;
};

export type PalletContractsEnvironment = {
  accountId: PalletContractsEnvironmentType;
  balance: PalletContractsEnvironmentTypeU128;
  hash: PalletContractsEnvironmentTypeH256;
  hasher: PalletContractsEnvironmentTypeBlakeTwo256;
  timestamp: PalletContractsEnvironmentTypeU64;
  blockNumber: PalletContractsEnvironmentTypeU32;
};

export type PalletContractsEnvironmentType = {};

export type PalletContractsEnvironmentTypeU128 = {};

export type PalletContractsEnvironmentTypeH256 = {};

export type PalletContractsEnvironmentTypeBlakeTwo256 = {};

export type SpRuntimeBlakeTwo256 = {};

export type PalletContractsEnvironmentTypeU64 = {};

export type PalletContractsEnvironmentTypeU32 = {};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletContractsError =
  /**
   * Invalid schedule supplied, e.g. with zero weight of a basic operation.
   **/
  | 'InvalidSchedule'
  /**
   * Invalid combination of flags supplied to `seal_call` or `seal_delegate_call`.
   **/
  | 'InvalidCallFlags'
  /**
   * The executed contract exhausted its gas limit.
   **/
  | 'OutOfGas'
  /**
   * The output buffer supplied to a contract API call was too small.
   **/
  | 'OutputBufferTooSmall'
  /**
   * Performing the requested transfer failed. Probably because there isn't enough
   * free balance in the sender's account.
   **/
  | 'TransferFailed'
  /**
   * Performing a call was denied because the calling depth reached the limit
   * of what is specified in the schedule.
   **/
  | 'MaxCallDepthReached'
  /**
   * No contract was found at the specified address.
   **/
  | 'ContractNotFound'
  /**
   * The code supplied to `instantiate_with_code` exceeds the limit specified in the
   * current schedule.
   **/
  | 'CodeTooLarge'
  /**
   * No code could be found at the supplied code hash.
   **/
  | 'CodeNotFound'
  /**
   * No code info could be found at the supplied code hash.
   **/
  | 'CodeInfoNotFound'
  /**
   * A buffer outside of sandbox memory was passed to a contract API function.
   **/
  | 'OutOfBounds'
  /**
   * Input passed to a contract API function failed to decode as expected type.
   **/
  | 'DecodingFailed'
  /**
   * Contract trapped during execution.
   **/
  | 'ContractTrapped'
  /**
   * The size defined in `T::MaxValueSize` was exceeded.
   **/
  | 'ValueTooLarge'
  /**
   * Termination of a contract is not allowed while the contract is already
   * on the call stack. Can be triggered by `seal_terminate`.
   **/
  | 'TerminatedWhileReentrant'
  /**
   * `seal_call` forwarded this contracts input. It therefore is no longer available.
   **/
  | 'InputForwarded'
  /**
   * The subject passed to `seal_random` exceeds the limit.
   **/
  | 'RandomSubjectTooLong'
  /**
   * The amount of topics passed to `seal_deposit_events` exceeds the limit.
   **/
  | 'TooManyTopics'
  /**
   * The chain does not provide a chain extension. Calling the chain extension results
   * in this error. Note that this usually shouldn't happen as deploying such contracts
   * is rejected.
   **/
  | 'NoChainExtension'
  /**
   * A contract with the same AccountId already exists.
   **/
  | 'DuplicateContract'
  /**
   * A contract self destructed in its constructor.
   *
   * This can be triggered by a call to `seal_terminate`.
   **/
  | 'TerminatedInConstructor'
  /**
   * A call tried to invoke a contract that is flagged as non-reentrant.
   * The only other cause is that a call from a contract into the runtime tried to call back
   * into `pallet-contracts`. This would make the whole pallet reentrant with regard to
   * contract code execution which is not supported.
   **/
  | 'ReentranceDenied'
  /**
   * Origin doesn't have enough balance to pay the required storage deposits.
   **/
  | 'StorageDepositNotEnoughFunds'
  /**
   * More storage was created than allowed by the storage deposit limit.
   **/
  | 'StorageDepositLimitExhausted'
  /**
   * Code removal was denied because the code is still in use by at least one contract.
   **/
  | 'CodeInUse'
  /**
   * The contract ran to completion but decided to revert its storage changes.
   * Please note that this error is only returned from extrinsics. When called directly
   * or via RPC an `Ok` will be returned. In this case the caller needs to inspect the flags
   * to determine whether a reversion has taken place.
   **/
  | 'ContractReverted'
  /**
   * The contract's code was found to be invalid during validation.
   *
   * The most likely cause of this is that an API was used which is not supported by the
   * node. This happens if an older node is used with a new version of ink!. Try updating
   * your node to the newest available version.
   *
   * A more detailed error can be found on the node console if debug messages are enabled
   * by supplying `-lruntime::contracts=debug`.
   **/
  | 'CodeRejected'
  /**
   * An indetermistic code was used in a context where this is not permitted.
   **/
  | 'Indeterministic'
  /**
   * A pending migration needs to complete before the extrinsic can be called.
   **/
  | 'MigrationInProgress'
  /**
   * Migrate dispatch call was attempted but no migration was performed.
   **/
  | 'NoMigrationPerformed'
  /**
   * The contract has reached its maximum number of delegate dependencies.
   **/
  | 'MaxDelegateDependenciesReached'
  /**
   * The dependency was not found in the contract's delegate dependencies.
   **/
  | 'DelegateDependencyNotFound'
  /**
   * The contract already depends on the given delegate dependency.
   **/
  | 'DelegateDependencyAlreadyExists'
  /**
   * Can not add a delegate dependency to the code hash of the contract itself.
   **/
  | 'CannotAddSelfAsDelegateDependency';

/**
 * Error for the Sudo pallet
 **/
export type PalletSudoError =
  /**
   * Sender must be the Sudo account
   **/
  'RequireSudo';

export type SpRuntimeMultiSignature =
  | { type: 'Ed25519'; value: SpCoreEd25519Signature }
  | { type: 'Sr25519'; value: SpCoreSr25519Signature }
  | { type: 'Ecdsa'; value: SpCoreEcdsaSignature };

export type SpCoreEd25519Signature = FixedBytes<64>;

export type SpCoreSr25519Signature = FixedBytes<64>;

export type SpCoreEcdsaSignature = FixedBytes<65>;

export type FrameSystemExtensionsCheckSpecVersion = {};

export type FrameSystemExtensionsCheckTxVersion = {};

export type FrameSystemExtensionsCheckGenesis = {};

export type FrameSystemExtensionsCheckMortality = Era;

export type FrameSystemExtensionsCheckNonce = number;

export type FrameSystemExtensionsCheckWeight = {};

export type PalletTransactionPaymentChargeTransactionPayment = bigint;

export type SpRuntimeBlock = { header: Header; extrinsics: Array<FpSelfContainedUncheckedExtrinsic> };

export type FpSelfContainedUncheckedExtrinsic = UncheckedExtrinsic;

export type SpCoreOpaqueMetadata = Bytes;

export type SpConsensusSlotsSlotDuration = bigint;

export type SpRuntimeTransactionValidityTransactionValidityError =
  | { type: 'Invalid'; value: SpRuntimeTransactionValidityInvalidTransaction }
  | { type: 'Unknown'; value: SpRuntimeTransactionValidityUnknownTransaction };

export type SpRuntimeTransactionValidityInvalidTransaction =
  | { type: 'Call' }
  | { type: 'Payment' }
  | { type: 'Future' }
  | { type: 'Stale' }
  | { type: 'BadProof' }
  | { type: 'AncientBirthBlock' }
  | { type: 'ExhaustsResources' }
  | { type: 'Custom'; value: number }
  | { type: 'BadMandatory' }
  | { type: 'MandatoryValidation' }
  | { type: 'BadSigner' };

export type SpRuntimeTransactionValidityUnknownTransaction =
  | { type: 'CannotLookup' }
  | { type: 'NoUnsignedValidator' }
  | { type: 'Custom'; value: number };

export type SpInherentsInherentData = { data: Array<[FixedBytes<8>, Bytes]> };

export type SpInherentsCheckInherentsResult = { okay: boolean; fatalError: boolean; errors: SpInherentsInherentData };

export type SpRuntimeTransactionValidityTransactionSource = 'InBlock' | 'Local' | 'External';

export type SpRuntimeTransactionValidityValidTransaction = {
  priority: bigint;
  requires: Array<Bytes>;
  provides: Array<Bytes>;
  longevity: bigint;
  propagate: boolean;
};

export type PalletTransactionPaymentRuntimeDispatchInfo = {
  weight: SpWeightsWeightV2Weight;
  class: FrameSupportDispatchDispatchClass;
  partialFee: bigint;
};

export type PalletTransactionPaymentFeeDetails = {
  inclusionFee?: PalletTransactionPaymentInclusionFee | undefined;
  tip: bigint;
};

export type PalletTransactionPaymentInclusionFee = { baseFee: bigint; lenFee: bigint; adjustedWeightFee: bigint };

export type CumulusPrimitivesCoreCollationInfo = {
  upwardMessages: Array<Bytes>;
  horizontalMessages: Array<PolkadotCorePrimitivesOutboundHrmpMessage>;
  newValidationCode?: PolkadotParachainPrimitivesPrimitivesValidationCode | undefined;
  processedDownwardMessages: number;
  hrmpWatermark: number;
  headData: PolkadotParachainPrimitivesPrimitivesHeadData;
};

export type PolkadotParachainPrimitivesPrimitivesValidationCode = Bytes;

export type EvmBackendBasic = { balance: U256; nonce: U256 };

export type FpEvmExecutionInfoV2 = {
  exitReason: EvmCoreErrorExitReason;
  value: Bytes;
  usedGas: FpEvmUsedGas;
  weightInfo?: FpEvmWeightInfo | undefined;
  logs: Array<EthereumLog>;
};

export type FpEvmUsedGas = { standard: U256; effective: U256 };

export type FpEvmWeightInfo = {
  refTimeLimit?: bigint | undefined;
  proofSizeLimit?: bigint | undefined;
  refTimeUsage?: bigint | undefined;
  proofSizeUsage?: bigint | undefined;
};

export type FpEvmExecutionInfoV2H160 = {
  exitReason: EvmCoreErrorExitReason;
  value: H160;
  usedGas: FpEvmUsedGas;
  weightInfo?: FpEvmWeightInfo | undefined;
  logs: Array<EthereumLog>;
};

export type PalletContractsPrimitivesContractResult = {
  gasConsumed: SpWeightsWeightV2Weight;
  gasRequired: SpWeightsWeightV2Weight;
  storageDeposit: PalletContractsPrimitivesStorageDeposit;
  debugMessage: Bytes;
  result: Result<PalletContractsPrimitivesExecReturnValue, DispatchError>;
  events?: Array<FrameSystemEventRecord> | undefined;
};

export type PalletContractsPrimitivesExecReturnValue = { flags: PalletContractsPrimitivesReturnFlags; data: Bytes };

export type PalletContractsPrimitivesReturnFlags = { bits: number };

export type PalletContractsPrimitivesStorageDeposit =
  | { type: 'Refund'; value: bigint }
  | { type: 'Charge'; value: bigint };

export type PalletContractsPrimitivesCode = { type: 'Upload'; value: Bytes } | { type: 'Existing'; value: H256 };

export type PalletContractsPrimitivesContractResultResult = {
  gasConsumed: SpWeightsWeightV2Weight;
  gasRequired: SpWeightsWeightV2Weight;
  storageDeposit: PalletContractsPrimitivesStorageDeposit;
  debugMessage: Bytes;
  result: Result<PalletContractsPrimitivesInstantiateReturnValue, DispatchError>;
  events?: Array<FrameSystemEventRecord> | undefined;
};

export type PalletContractsPrimitivesInstantiateReturnValue = {
  result: PalletContractsPrimitivesExecReturnValue;
  accountId: AccountId32;
};

export type PalletContractsPrimitivesCodeUploadReturnValue = { codeHash: H256; deposit: bigint };

export type PalletContractsPrimitivesContractAccessError = 'DoesntExist' | 'KeyDecodingFailed' | 'MigrationInProgress';

export type AstarRuntimeRuntimeError =
  | { pallet: 'System'; palletError: FrameSystemError }
  | { pallet: 'Utility'; palletError: PalletUtilityError }
  | { pallet: 'Identity'; palletError: PalletIdentityError }
  | { pallet: 'Multisig'; palletError: PalletMultisigError }
  | { pallet: 'Proxy'; palletError: PalletProxyError }
  | { pallet: 'ParachainSystem'; palletError: CumulusPalletParachainSystemError }
  | { pallet: 'Balances'; palletError: PalletBalancesError }
  | { pallet: 'Vesting'; palletError: PalletVestingError }
  | { pallet: 'Inflation'; palletError: PalletInflationError }
  | { pallet: 'DappStaking'; palletError: PalletDappStakingV3Error }
  | { pallet: 'Assets'; palletError: PalletAssetsError }
  | { pallet: 'Oracle'; palletError: OrmlOracleModuleError }
  | { pallet: 'OracleMembership'; palletError: PalletMembershipError }
  | { pallet: 'CollatorSelection'; palletError: PalletCollatorSelectionError }
  | { pallet: 'Session'; palletError: PalletSessionError }
  | { pallet: 'XcmpQueue'; palletError: CumulusPalletXcmpQueueError }
  | { pallet: 'PolkadotXcm'; palletError: PalletXcmError }
  | { pallet: 'CumulusXcm'; palletError: CumulusPalletXcmError }
  | { pallet: 'DmpQueue'; palletError: CumulusPalletDmpQueueError }
  | { pallet: 'XcAssetConfig'; palletError: PalletXcAssetConfigError }
  | { pallet: 'XTokens'; palletError: OrmlXtokensModuleError }
  | { pallet: 'Evm'; palletError: PalletEvmError }
  | { pallet: 'Ethereum'; palletError: PalletEthereumError }
  | { pallet: 'DynamicEvmBaseFee'; palletError: PalletDynamicEvmBaseFeeError }
  | { pallet: 'Contracts'; palletError: PalletContractsError }
  | { pallet: 'Sudo'; palletError: PalletSudoError };
