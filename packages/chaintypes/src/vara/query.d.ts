// Generated by dedot cli

import type { GenericChainStorage, GenericStorageQuery, Callback } from 'dedot/types';
import type {
  AccountId32,
  AccountId32Like,
  H256,
  Bytes,
  Digest,
  Phase,
  FixedBytes,
  FixedU128,
  BytesLike,
  Perbill,
  Percent,
  Data,
  Perquintill,
  U256,
} from 'dedot/codecs';
import type {
  FrameSystemAccountInfo,
  FrameSupportDispatchPerDispatchClass,
  FrameSystemEventRecord,
  FrameSystemLastRuntimeUpgradeInfo,
  FrameSystemCodeUpgradeAuthorization,
  SpConsensusBabeAppPublic,
  SpConsensusSlotsSlot,
  SpConsensusBabeDigestsNextConfigDescriptor,
  SpConsensusBabeDigestsPreDigest,
  SpConsensusBabeBabeEpochConfiguration,
  PalletGrandpaStoredState,
  PalletGrandpaStoredPendingChange,
  SpConsensusGrandpaAppPublic,
  PalletBalancesAccountData,
  PalletBalancesBalanceLock,
  PalletBalancesReserveData,
  FrameSupportTokensMiscIdAmount,
  FrameSupportTokensMiscIdAmountRuntimeFreezeReason,
  PalletTransactionPaymentReleases,
  VaraRuntimeSessionKeys,
  SpCoreCryptoKeyTypeId,
  SpAuthorityDiscoveryAppPublic,
  PalletVestingVestingInfo,
  PalletVestingReleases,
  PalletBagsListListNode,
  PalletBagsListListBag,
  PalletImOnlineSr25519AppSr25519Public,
  PalletStakingStakingLedger,
  PalletStakingRewardDestination,
  PalletStakingValidatorPrefs,
  PalletStakingNominations,
  PalletStakingActiveEraInfo,
  SpStakingExposure,
  SpStakingPagedExposureMetadata,
  SpStakingExposurePage,
  PalletStakingEraRewardPoints,
  PalletStakingForcing,
  PalletStakingUnappliedSlash,
  PalletStakingSlashingSlashingSpans,
  PalletStakingSlashingSpanRecord,
  PalletTreasuryProposal,
  PalletTreasurySpendStatus,
  PalletConvictionVotingVoteVoting,
  PalletReferendaReferendumInfo,
  PalletRankedCollectiveMemberRecord,
  PalletRankedCollectiveVoteRecord,
  PalletReferendaReferendumInfoTally,
  PalletSchedulerScheduled,
  PalletSchedulerRetryConfig,
  PalletPreimageOldRequestStatus,
  PalletPreimageRequestStatus,
  PalletIdentityRegistration,
  PalletIdentityRegistrarInfo,
  PalletIdentityAuthorityProperties,
  PalletProxyProxyDefinition,
  PalletProxyAnnouncement,
  PalletMultisigMultisig,
  PalletElectionProviderMultiPhasePhase,
  PalletElectionProviderMultiPhaseReadySolution,
  PalletElectionProviderMultiPhaseRoundSnapshot,
  PalletElectionProviderMultiPhaseSolutionOrSnapshotSize,
  SpNposElectionsElectionScore,
  PalletElectionProviderMultiPhaseSignedSignedSubmission,
  SpStakingOffenceOffenceDetails,
  PalletBountiesBounty,
  PalletChildBountiesChildBounty,
  PalletNominationPoolsPoolMember,
  PalletNominationPoolsBondedPoolInner,
  PalletNominationPoolsRewardPool,
  PalletNominationPoolsSubPools,
  PalletNominationPoolsClaimPermission,
  GearCoreCodeInstrumentedInstrumentedCode,
  GprimitivesCodeId,
  GearCoreCodeMetadataCodeMetadata,
  NumeratedTreeIntervalsTree,
  GprimitivesActorId,
  GearCoreProgram,
  GearCoreMemoryPageBuf,
  GearCoreProgramMemoryInfix,
  GearCorePagesPage,
  GearCommonStorageComplicatedDequeueLinkedNode,
  GprimitivesMessageId,
  GearCoreMessageUserUserStoredMessage,
  GearCommonStoragePrimitivesInterval,
  GearCoreMessageStoredStoredDispatch,
  GearCoreMessageStoredStoredDelayedDispatch,
  GearCoreTasksScheduledTask,
  GearCommonGasProviderNodeGasNode,
  GearCommonGasProviderNodeGasNodeId,
  PalletGearVoucherInternalVoucherInfo,
  PalletGearVoucherInternalVoucherId,
  PalletGearBankBankAccount,
  PalletGearEthBridgeInternalQueueInfo,
  PalletGrandpaSignerSigningRequest,
} from './types.js';

export interface ChainStorage extends GenericChainStorage {
  /**
   * Pallet `System`'s storage queries
   **/
  system: {
    /**
     * The full account information for a particular account ID.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<FrameSystemAccountInfo> =} callback
     **/
    account: GenericStorageQuery<(arg: AccountId32Like) => FrameSystemAccountInfo, AccountId32>;

    /**
     * Total extrinsics count for the current block.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    extrinsicCount: GenericStorageQuery<() => number | undefined>;

    /**
     * Whether all inherents have been applied.
     *
     * @param {Callback<boolean> =} callback
     **/
    inherentsApplied: GenericStorageQuery<() => boolean>;

    /**
     * The current weight for the block.
     *
     * @param {Callback<FrameSupportDispatchPerDispatchClass> =} callback
     **/
    blockWeight: GenericStorageQuery<() => FrameSupportDispatchPerDispatchClass>;

    /**
     * Total length (in bytes) for all extrinsics put together, for the current block.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    allExtrinsicsLen: GenericStorageQuery<() => number | undefined>;

    /**
     * Map of block numbers to block hashes.
     *
     * @param {number} arg
     * @param {Callback<H256> =} callback
     **/
    blockHash: GenericStorageQuery<(arg: number) => H256, number>;

    /**
     * Extrinsics data for the current block (maps an extrinsic's index to its data).
     *
     * @param {number} arg
     * @param {Callback<Bytes> =} callback
     **/
    extrinsicData: GenericStorageQuery<(arg: number) => Bytes, number>;

    /**
     * The current block number being processed. Set by `execute_block`.
     *
     * @param {Callback<number> =} callback
     **/
    number: GenericStorageQuery<() => number>;

    /**
     * Hash of the previous block.
     *
     * @param {Callback<H256> =} callback
     **/
    parentHash: GenericStorageQuery<() => H256>;

    /**
     * Digest of the current block, also part of the block header.
     *
     * @param {Callback<Digest> =} callback
     **/
    digest: GenericStorageQuery<() => Digest>;

    /**
     * Events deposited for the current block.
     *
     * NOTE: The item is unbound and should therefore never be read on chain.
     * It could otherwise inflate the PoV size of a block.
     *
     * Events have a large in-memory size. Box the events to not go out-of-memory
     * just in case someone still reads them from within the runtime.
     *
     * @param {Callback<Array<FrameSystemEventRecord>> =} callback
     **/
    events: GenericStorageQuery<() => Array<FrameSystemEventRecord>>;

    /**
     * The number of events in the `Events<T>` list.
     *
     * @param {Callback<number> =} callback
     **/
    eventCount: GenericStorageQuery<() => number>;

    /**
     * Mapping between a topic (represented by T::Hash) and a vector of indexes
     * of events in the `<Events<T>>` list.
     *
     * All topic vectors have deterministic storage locations depending on the topic. This
     * allows light-clients to leverage the changes trie storage tracking mechanism and
     * in case of changes fetch the list of events of interest.
     *
     * The value has the type `(BlockNumberFor<T>, EventIndex)` because if we used only just
     * the `EventIndex` then in case if the topic has the same contents on the next block
     * no notification will be triggered thus the event might be lost.
     *
     * @param {H256} arg
     * @param {Callback<Array<[number, number]>> =} callback
     **/
    eventTopics: GenericStorageQuery<(arg: H256) => Array<[number, number]>, H256>;

    /**
     * Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened.
     *
     * @param {Callback<FrameSystemLastRuntimeUpgradeInfo | undefined> =} callback
     **/
    lastRuntimeUpgrade: GenericStorageQuery<() => FrameSystemLastRuntimeUpgradeInfo | undefined>;

    /**
     * True if we have upgraded so that `type RefCount` is `u32`. False (default) if not.
     *
     * @param {Callback<boolean> =} callback
     **/
    upgradedToU32RefCount: GenericStorageQuery<() => boolean>;

    /**
     * True if we have upgraded so that AccountInfo contains three types of `RefCount`. False
     * (default) if not.
     *
     * @param {Callback<boolean> =} callback
     **/
    upgradedToTripleRefCount: GenericStorageQuery<() => boolean>;

    /**
     * The execution phase of the block.
     *
     * @param {Callback<Phase | undefined> =} callback
     **/
    executionPhase: GenericStorageQuery<() => Phase | undefined>;

    /**
     * `Some` if a code upgrade has been authorized.
     *
     * @param {Callback<FrameSystemCodeUpgradeAuthorization | undefined> =} callback
     **/
    authorizedUpgrade: GenericStorageQuery<() => FrameSystemCodeUpgradeAuthorization | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Timestamp`'s storage queries
   **/
  timestamp: {
    /**
     * The current time for the current block.
     *
     * @param {Callback<bigint> =} callback
     **/
    now: GenericStorageQuery<() => bigint>;

    /**
     * Whether the timestamp has been updated in this block.
     *
     * This value is updated to `true` upon successful submission of a timestamp by a node.
     * It is then checked at the end of each block execution in the `on_finalize` hook.
     *
     * @param {Callback<boolean> =} callback
     **/
    didUpdate: GenericStorageQuery<() => boolean>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Authorship`'s storage queries
   **/
  authorship: {
    /**
     * Author of current block.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    author: GenericStorageQuery<() => AccountId32 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Babe`'s storage queries
   **/
  babe: {
    /**
     * Current epoch index.
     *
     * @param {Callback<bigint> =} callback
     **/
    epochIndex: GenericStorageQuery<() => bigint>;

    /**
     * Current epoch authorities.
     *
     * @param {Callback<Array<[SpConsensusBabeAppPublic, bigint]>> =} callback
     **/
    authorities: GenericStorageQuery<() => Array<[SpConsensusBabeAppPublic, bigint]>>;

    /**
     * The slot at which the first epoch actually started. This is 0
     * until the first block of the chain.
     *
     * @param {Callback<SpConsensusSlotsSlot> =} callback
     **/
    genesisSlot: GenericStorageQuery<() => SpConsensusSlotsSlot>;

    /**
     * Current slot number.
     *
     * @param {Callback<SpConsensusSlotsSlot> =} callback
     **/
    currentSlot: GenericStorageQuery<() => SpConsensusSlotsSlot>;

    /**
     * The epoch randomness for the *current* epoch.
     *
     * # Security
     *
     * This MUST NOT be used for gambling, as it can be influenced by a
     * malicious validator in the short term. It MAY be used in many
     * cryptographic protocols, however, so long as one remembers that this
     * (like everything else on-chain) it is public. For example, it can be
     * used where a number is needed that cannot have been chosen by an
     * adversary, for purposes such as public-coin zero-knowledge proofs.
     *
     * @param {Callback<FixedBytes<32>> =} callback
     **/
    randomness: GenericStorageQuery<() => FixedBytes<32>>;

    /**
     * Pending epoch configuration change that will be applied when the next epoch is enacted.
     *
     * @param {Callback<SpConsensusBabeDigestsNextConfigDescriptor | undefined> =} callback
     **/
    pendingEpochConfigChange: GenericStorageQuery<() => SpConsensusBabeDigestsNextConfigDescriptor | undefined>;

    /**
     * Next epoch randomness.
     *
     * @param {Callback<FixedBytes<32>> =} callback
     **/
    nextRandomness: GenericStorageQuery<() => FixedBytes<32>>;

    /**
     * Next epoch authorities.
     *
     * @param {Callback<Array<[SpConsensusBabeAppPublic, bigint]>> =} callback
     **/
    nextAuthorities: GenericStorageQuery<() => Array<[SpConsensusBabeAppPublic, bigint]>>;

    /**
     * Randomness under construction.
     *
     * We make a trade-off between storage accesses and list length.
     * We store the under-construction randomness in segments of up to
     * `UNDER_CONSTRUCTION_SEGMENT_LENGTH`.
     *
     * Once a segment reaches this length, we begin the next one.
     * We reset all segments and return to `0` at the beginning of every
     * epoch.
     *
     * @param {Callback<number> =} callback
     **/
    segmentIndex: GenericStorageQuery<() => number>;

    /**
     * TWOX-NOTE: `SegmentIndex` is an increasing integer, so this is okay.
     *
     * @param {number} arg
     * @param {Callback<Array<FixedBytes<32>>> =} callback
     **/
    underConstruction: GenericStorageQuery<(arg: number) => Array<FixedBytes<32>>, number>;

    /**
     * Temporary value (cleared at block finalization) which is `Some`
     * if per-block initialization has already been called for current block.
     *
     * @param {Callback<SpConsensusBabeDigestsPreDigest | undefined | undefined> =} callback
     **/
    initialized: GenericStorageQuery<() => SpConsensusBabeDigestsPreDigest | undefined | undefined>;

    /**
     * This field should always be populated during block processing unless
     * secondary plain slots are enabled (which don't contain a VRF output).
     *
     * It is set in `on_finalize`, before it will contain the value from the last block.
     *
     * @param {Callback<FixedBytes<32> | undefined> =} callback
     **/
    authorVrfRandomness: GenericStorageQuery<() => FixedBytes<32> | undefined>;

    /**
     * The block numbers when the last and current epoch have started, respectively `N-1` and
     * `N`.
     * NOTE: We track this is in order to annotate the block number when a given pool of
     * entropy was fixed (i.e. it was known to chain observers). Since epochs are defined in
     * slots, which may be skipped, the block numbers may not line up with the slot numbers.
     *
     * @param {Callback<[number, number]> =} callback
     **/
    epochStart: GenericStorageQuery<() => [number, number]>;

    /**
     * How late the current block is compared to its parent.
     *
     * This entry is populated as part of block execution and is cleaned up
     * on block finalization. Querying this storage entry outside of block
     * execution context should always yield zero.
     *
     * @param {Callback<number> =} callback
     **/
    lateness: GenericStorageQuery<() => number>;

    /**
     * The configuration for the current epoch. Should never be `None` as it is initialized in
     * genesis.
     *
     * @param {Callback<SpConsensusBabeBabeEpochConfiguration | undefined> =} callback
     **/
    epochConfig: GenericStorageQuery<() => SpConsensusBabeBabeEpochConfiguration | undefined>;

    /**
     * The configuration for the next epoch, `None` if the config will not change
     * (you can fallback to `EpochConfig` instead in that case).
     *
     * @param {Callback<SpConsensusBabeBabeEpochConfiguration | undefined> =} callback
     **/
    nextEpochConfig: GenericStorageQuery<() => SpConsensusBabeBabeEpochConfiguration | undefined>;

    /**
     * A list of the last 100 skipped epochs and the corresponding session index
     * when the epoch was skipped.
     *
     * This is only used for validating equivocation proofs. An equivocation proof
     * must contains a key-ownership proof for a given session, therefore we need a
     * way to tie together sessions and epoch indices, i.e. we need to validate that
     * a validator was the owner of a given key on a given session, and what the
     * active epoch index was during that session.
     *
     * @param {Callback<Array<[bigint, number]>> =} callback
     **/
    skippedEpochs: GenericStorageQuery<() => Array<[bigint, number]>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Grandpa`'s storage queries
   **/
  grandpa: {
    /**
     * State of the current authority set.
     *
     * @param {Callback<PalletGrandpaStoredState> =} callback
     **/
    state: GenericStorageQuery<() => PalletGrandpaStoredState>;

    /**
     * Pending change: (signaled at, scheduled change).
     *
     * @param {Callback<PalletGrandpaStoredPendingChange | undefined> =} callback
     **/
    pendingChange: GenericStorageQuery<() => PalletGrandpaStoredPendingChange | undefined>;

    /**
     * next block number where we can force a change.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    nextForced: GenericStorageQuery<() => number | undefined>;

    /**
     * `true` if we are currently stalled.
     *
     * @param {Callback<[number, number] | undefined> =} callback
     **/
    stalled: GenericStorageQuery<() => [number, number] | undefined>;

    /**
     * The number of changes (both in terms of keys and underlying economic responsibilities)
     * in the "set" of Grandpa validators from genesis.
     *
     * @param {Callback<bigint> =} callback
     **/
    currentSetId: GenericStorageQuery<() => bigint>;

    /**
     * A mapping from grandpa set ID to the index of the *most recent* session for which its
     * members were responsible.
     *
     * This is only used for validating equivocation proofs. An equivocation proof must
     * contains a key-ownership proof for a given session, therefore we need a way to tie
     * together sessions and GRANDPA set ids, i.e. we need to validate that a validator
     * was the owner of a given key on a given session, and what the active set ID was
     * during that session.
     *
     * TWOX-NOTE: `SetId` is not under user control.
     *
     * @param {bigint} arg
     * @param {Callback<number | undefined> =} callback
     **/
    setIdSession: GenericStorageQuery<(arg: bigint) => number | undefined, bigint>;

    /**
     * The current list of authorities.
     *
     * @param {Callback<Array<[SpConsensusGrandpaAppPublic, bigint]>> =} callback
     **/
    authorities: GenericStorageQuery<() => Array<[SpConsensusGrandpaAppPublic, bigint]>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Balances`'s storage queries
   **/
  balances: {
    /**
     * The total units issued in the system.
     *
     * @param {Callback<bigint> =} callback
     **/
    totalIssuance: GenericStorageQuery<() => bigint>;

    /**
     * The total units of outstanding deactivated balance in the system.
     *
     * @param {Callback<bigint> =} callback
     **/
    inactiveIssuance: GenericStorageQuery<() => bigint>;

    /**
     * The Balances pallet example of storing the balance of an account.
     *
     * # Example
     *
     * ```nocompile
     * impl pallet_balances::Config for Runtime {
     * type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>
     * }
     * ```
     *
     * You can also store the balance of an account in the `System` pallet.
     *
     * # Example
     *
     * ```nocompile
     * impl pallet_balances::Config for Runtime {
     * type AccountStore = System
     * }
     * ```
     *
     * But this comes with tradeoffs, storing account balances in the system pallet stores
     * `frame_system` data alongside the account data contrary to storing account balances in the
     * `Balances` pallet, which uses a `StorageMap` to store balances data only.
     * NOTE: This is only used in the case that this pallet is used to store balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletBalancesAccountData> =} callback
     **/
    account: GenericStorageQuery<(arg: AccountId32Like) => PalletBalancesAccountData, AccountId32>;

    /**
     * Any liquidity locks on some account balances.
     * NOTE: Should only be accessed when setting, changing and freeing a lock.
     *
     * Use of locks is deprecated in favour of freezes. See `https://github.com/paritytech/substrate/pull/12951/`
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletBalancesBalanceLock>> =} callback
     **/
    locks: GenericStorageQuery<(arg: AccountId32Like) => Array<PalletBalancesBalanceLock>, AccountId32>;

    /**
     * Named reserves on some account balances.
     *
     * Use of reserves is deprecated in favour of holds. See `https://github.com/paritytech/substrate/pull/12951/`
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletBalancesReserveData>> =} callback
     **/
    reserves: GenericStorageQuery<(arg: AccountId32Like) => Array<PalletBalancesReserveData>, AccountId32>;

    /**
     * Holds on account balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<FrameSupportTokensMiscIdAmount>> =} callback
     **/
    holds: GenericStorageQuery<(arg: AccountId32Like) => Array<FrameSupportTokensMiscIdAmount>, AccountId32>;

    /**
     * Freeze locks on account balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<FrameSupportTokensMiscIdAmountRuntimeFreezeReason>> =} callback
     **/
    freezes: GenericStorageQuery<
      (arg: AccountId32Like) => Array<FrameSupportTokensMiscIdAmountRuntimeFreezeReason>,
      AccountId32
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `TransactionPayment`'s storage queries
   **/
  transactionPayment: {
    /**
     *
     * @param {Callback<FixedU128> =} callback
     **/
    nextFeeMultiplier: GenericStorageQuery<() => FixedU128>;

    /**
     *
     * @param {Callback<PalletTransactionPaymentReleases> =} callback
     **/
    storageVersion: GenericStorageQuery<() => PalletTransactionPaymentReleases>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Session`'s storage queries
   **/
  session: {
    /**
     * The current set of validators.
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    validators: GenericStorageQuery<() => Array<AccountId32>>;

    /**
     * Current index of the session.
     *
     * @param {Callback<number> =} callback
     **/
    currentIndex: GenericStorageQuery<() => number>;

    /**
     * True if the underlying economic identities or weighting behind the validators
     * has changed in the queued validator set.
     *
     * @param {Callback<boolean> =} callback
     **/
    queuedChanged: GenericStorageQuery<() => boolean>;

    /**
     * The queued keys for the next session. When the next session begins, these keys
     * will be used to determine the validator's session keys.
     *
     * @param {Callback<Array<[AccountId32, VaraRuntimeSessionKeys]>> =} callback
     **/
    queuedKeys: GenericStorageQuery<() => Array<[AccountId32, VaraRuntimeSessionKeys]>>;

    /**
     * Indices of disabled validators.
     *
     * The vec is always kept sorted so that we can find whether a given validator is
     * disabled using binary search. It gets cleared when `on_session_ending` returns
     * a new set of identities.
     *
     * @param {Callback<Array<number>> =} callback
     **/
    disabledValidators: GenericStorageQuery<() => Array<number>>;

    /**
     * The next session keys for a validator.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<VaraRuntimeSessionKeys | undefined> =} callback
     **/
    nextKeys: GenericStorageQuery<(arg: AccountId32Like) => VaraRuntimeSessionKeys | undefined, AccountId32>;

    /**
     * The owner of a key. The key is the `KeyTypeId` + the encoded key.
     *
     * @param {[SpCoreCryptoKeyTypeId, BytesLike]} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    keyOwner: GenericStorageQuery<
      (arg: [SpCoreCryptoKeyTypeId, BytesLike]) => AccountId32 | undefined,
      [SpCoreCryptoKeyTypeId, Bytes]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `AuthorityDiscovery`'s storage queries
   **/
  authorityDiscovery: {
    /**
     * Keys of the current authority set.
     *
     * @param {Callback<Array<SpAuthorityDiscoveryAppPublic>> =} callback
     **/
    keys: GenericStorageQuery<() => Array<SpAuthorityDiscoveryAppPublic>>;

    /**
     * Keys of the next authority set.
     *
     * @param {Callback<Array<SpAuthorityDiscoveryAppPublic>> =} callback
     **/
    nextKeys: GenericStorageQuery<() => Array<SpAuthorityDiscoveryAppPublic>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Vesting`'s storage queries
   **/
  vesting: {
    /**
     * Information regarding the vesting of a given account.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletVestingVestingInfo> | undefined> =} callback
     **/
    vesting: GenericStorageQuery<(arg: AccountId32Like) => Array<PalletVestingVestingInfo> | undefined, AccountId32>;

    /**
     * Storage version of the pallet.
     *
     * New networks start with latest version, as determined by the genesis build.
     *
     * @param {Callback<PalletVestingReleases> =} callback
     **/
    storageVersion: GenericStorageQuery<() => PalletVestingReleases>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `BagsList`'s storage queries
   **/
  bagsList: {
    /**
     * A single node, within some bag.
     *
     * Nodes store links forward and back within their respective bags.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletBagsListListNode | undefined> =} callback
     **/
    listNodes: GenericStorageQuery<(arg: AccountId32Like) => PalletBagsListListNode | undefined, AccountId32>;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForListNodes: GenericStorageQuery<() => number>;

    /**
     * A bag stored in storage.
     *
     * Stores a `Bag` struct, which stores head and tail pointers to itself.
     *
     * @param {bigint} arg
     * @param {Callback<PalletBagsListListBag | undefined> =} callback
     **/
    listBags: GenericStorageQuery<(arg: bigint) => PalletBagsListListBag | undefined, bigint>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `ImOnline`'s storage queries
   **/
  imOnline: {
    /**
     * The block number after which it's ok to send heartbeats in the current
     * session.
     *
     * At the beginning of each session we set this to a value that should fall
     * roughly in the middle of the session duration. The idea is to first wait for
     * the validators to produce a block in the current session, so that the
     * heartbeat later on will not be necessary.
     *
     * This value will only be used as a fallback if we fail to get a proper session
     * progress estimate from `NextSessionRotation`, as those estimates should be
     * more accurate then the value we calculate for `HeartbeatAfter`.
     *
     * @param {Callback<number> =} callback
     **/
    heartbeatAfter: GenericStorageQuery<() => number>;

    /**
     * The current set of keys that may issue a heartbeat.
     *
     * @param {Callback<Array<PalletImOnlineSr25519AppSr25519Public>> =} callback
     **/
    keys: GenericStorageQuery<() => Array<PalletImOnlineSr25519AppSr25519Public>>;

    /**
     * For each session index, we keep a mapping of `SessionIndex` and `AuthIndex`.
     *
     * @param {[number, number]} arg
     * @param {Callback<boolean | undefined> =} callback
     **/
    receivedHeartbeats: GenericStorageQuery<(arg: [number, number]) => boolean | undefined, [number, number]>;

    /**
     * For each session index, we keep a mapping of `ValidatorId<T>` to the
     * number of blocks authored by the given authority.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<number> =} callback
     **/
    authoredBlocks: GenericStorageQuery<(arg: [number, AccountId32Like]) => number, [number, AccountId32]>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Staking`'s storage queries
   **/
  staking: {
    /**
     * The ideal number of active validators.
     *
     * @param {Callback<number> =} callback
     **/
    validatorCount: GenericStorageQuery<() => number>;

    /**
     * Minimum number of staking participants before emergency conditions are imposed.
     *
     * @param {Callback<number> =} callback
     **/
    minimumValidatorCount: GenericStorageQuery<() => number>;

    /**
     * Any validators that may never be slashed or forcibly kicked. It's a Vec since they're
     * easy to initialize and the performance hit is minimal (we expect no more than four
     * invulnerables) and restricted to testnets.
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    invulnerables: GenericStorageQuery<() => Array<AccountId32>>;

    /**
     * Map from all locked "stash" accounts to the controller account.
     *
     * TWOX-NOTE: SAFE since `AccountId` is a secure hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    bonded: GenericStorageQuery<(arg: AccountId32Like) => AccountId32 | undefined, AccountId32>;

    /**
     * The minimum active bond to become and maintain the role of a nominator.
     *
     * @param {Callback<bigint> =} callback
     **/
    minNominatorBond: GenericStorageQuery<() => bigint>;

    /**
     * The minimum active bond to become and maintain the role of a validator.
     *
     * @param {Callback<bigint> =} callback
     **/
    minValidatorBond: GenericStorageQuery<() => bigint>;

    /**
     * The minimum active nominator stake of the last successful election.
     *
     * @param {Callback<bigint> =} callback
     **/
    minimumActiveStake: GenericStorageQuery<() => bigint>;

    /**
     * The minimum amount of commission that validators can set.
     *
     * If set to `0`, no limit exists.
     *
     * @param {Callback<Perbill> =} callback
     **/
    minCommission: GenericStorageQuery<() => Perbill>;

    /**
     * Map from all (unlocked) "controller" accounts to the info regarding the staking.
     *
     * Note: All the reads and mutations to this storage *MUST* be done through the methods exposed
     * by [`StakingLedger`] to ensure data and lock consistency.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletStakingStakingLedger | undefined> =} callback
     **/
    ledger: GenericStorageQuery<(arg: AccountId32Like) => PalletStakingStakingLedger | undefined, AccountId32>;

    /**
     * Where the reward payment should be made. Keyed by stash.
     *
     * TWOX-NOTE: SAFE since `AccountId` is a secure hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletStakingRewardDestination | undefined> =} callback
     **/
    payee: GenericStorageQuery<(arg: AccountId32Like) => PalletStakingRewardDestination | undefined, AccountId32>;

    /**
     * The map from (wannabe) validator stash key to the preferences of that validator.
     *
     * TWOX-NOTE: SAFE since `AccountId` is a secure hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletStakingValidatorPrefs> =} callback
     **/
    validators: GenericStorageQuery<(arg: AccountId32Like) => PalletStakingValidatorPrefs, AccountId32>;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForValidators: GenericStorageQuery<() => number>;

    /**
     * The maximum validator count before we stop allowing new validators to join.
     *
     * When this value is not set, no limits are enforced.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    maxValidatorsCount: GenericStorageQuery<() => number | undefined>;

    /**
     * The map from nominator stash key to their nomination preferences, namely the validators that
     * they wish to support.
     *
     * Note that the keys of this storage map might become non-decodable in case the
     * account's [`NominationsQuota::MaxNominations`] configuration is decreased.
     * In this rare case, these nominators
     * are still existent in storage, their key is correct and retrievable (i.e. `contains_key`
     * indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable
     * nominators will effectively not-exist, until they re-submit their preferences such that it
     * is within the bounds of the newly set `Config::MaxNominations`.
     *
     * This implies that `::iter_keys().count()` and `::iter().count()` might return different
     * values for this map. Moreover, the main `::count()` is aligned with the former, namely the
     * number of keys that exist.
     *
     * Lastly, if any of the nominators become non-decodable, they can be chilled immediately via
     * [`Call::chill_other`] dispatchable by anyone.
     *
     * TWOX-NOTE: SAFE since `AccountId` is a secure hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletStakingNominations | undefined> =} callback
     **/
    nominators: GenericStorageQuery<(arg: AccountId32Like) => PalletStakingNominations | undefined, AccountId32>;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForNominators: GenericStorageQuery<() => number>;

    /**
     * Stakers whose funds are managed by other pallets.
     *
     * This pallet does not apply any locks on them, therefore they are only virtually bonded. They
     * are expected to be keyless accounts and hence should not be allowed to mutate their ledger
     * directly via this pallet. Instead, these accounts are managed by other pallets and accessed
     * via low level apis. We keep track of them to do minimal integrity checks.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    virtualStakers: GenericStorageQuery<(arg: AccountId32Like) => [] | undefined, AccountId32>;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForVirtualStakers: GenericStorageQuery<() => number>;

    /**
     * The maximum nominator count before we stop allowing new validators to join.
     *
     * When this value is not set, no limits are enforced.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    maxNominatorsCount: GenericStorageQuery<() => number | undefined>;

    /**
     * The current era index.
     *
     * This is the latest planned era, depending on how the Session pallet queues the validator
     * set, it might be active or not.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    currentEra: GenericStorageQuery<() => number | undefined>;

    /**
     * The active era information, it holds index and start.
     *
     * The active era is the era being currently rewarded. Validator set of this era must be
     * equal to [`SessionInterface::validators`].
     *
     * @param {Callback<PalletStakingActiveEraInfo | undefined> =} callback
     **/
    activeEra: GenericStorageQuery<() => PalletStakingActiveEraInfo | undefined>;

    /**
     * The session index at which the era start for the last [`Config::HistoryDepth`] eras.
     *
     * Note: This tracks the starting session (i.e. session index when era start being active)
     * for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`.
     *
     * @param {number} arg
     * @param {Callback<number | undefined> =} callback
     **/
    erasStartSessionIndex: GenericStorageQuery<(arg: number) => number | undefined, number>;

    /**
     * Exposure of validator at era.
     *
     * This is keyed first by the era index to allow bulk deletion and then the stash account.
     *
     * Is it removed after [`Config::HistoryDepth`] eras.
     * If stakers hasn't been set or has been removed then empty exposure is returned.
     *
     * Note: Deprecated since v14. Use `EraInfo` instead to work with exposures.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<SpStakingExposure> =} callback
     **/
    erasStakers: GenericStorageQuery<(arg: [number, AccountId32Like]) => SpStakingExposure, [number, AccountId32]>;

    /**
     * Summary of validator exposure at a given era.
     *
     * This contains the total stake in support of the validator and their own stake. In addition,
     * it can also be used to get the number of nominators backing this validator and the number of
     * exposure pages they are divided into. The page count is useful to determine the number of
     * pages of rewards that needs to be claimed.
     *
     * This is keyed first by the era index to allow bulk deletion and then the stash account.
     * Should only be accessed through `EraInfo`.
     *
     * Is it removed after [`Config::HistoryDepth`] eras.
     * If stakers hasn't been set or has been removed then empty overview is returned.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<SpStakingPagedExposureMetadata | undefined> =} callback
     **/
    erasStakersOverview: GenericStorageQuery<
      (arg: [number, AccountId32Like]) => SpStakingPagedExposureMetadata | undefined,
      [number, AccountId32]
    >;

    /**
     * Clipped Exposure of validator at era.
     *
     * Note: This is deprecated, should be used as read-only and will be removed in the future.
     * New `Exposure`s are stored in a paged manner in `ErasStakersPaged` instead.
     *
     * This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the
     * `T::MaxExposurePageSize` biggest stakers.
     * (Note: the field `total` and `own` of the exposure remains unchanged).
     * This is used to limit the i/o cost for the nominator payout.
     *
     * This is keyed fist by the era index to allow bulk deletion and then the stash account.
     *
     * It is removed after [`Config::HistoryDepth`] eras.
     * If stakers hasn't been set or has been removed then empty exposure is returned.
     *
     * Note: Deprecated since v14. Use `EraInfo` instead to work with exposures.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<SpStakingExposure> =} callback
     **/
    erasStakersClipped: GenericStorageQuery<
      (arg: [number, AccountId32Like]) => SpStakingExposure,
      [number, AccountId32]
    >;

    /**
     * Paginated exposure of a validator at given era.
     *
     * This is keyed first by the era index to allow bulk deletion, then stash account and finally
     * the page. Should only be accessed through `EraInfo`.
     *
     * This is cleared after [`Config::HistoryDepth`] eras.
     *
     * @param {[number, AccountId32Like, number]} arg
     * @param {Callback<SpStakingExposurePage | undefined> =} callback
     **/
    erasStakersPaged: GenericStorageQuery<
      (arg: [number, AccountId32Like, number]) => SpStakingExposurePage | undefined,
      [number, AccountId32, number]
    >;

    /**
     * History of claimed paged rewards by era and validator.
     *
     * This is keyed by era and validator stash which maps to the set of page indexes which have
     * been claimed.
     *
     * It is removed after [`Config::HistoryDepth`] eras.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<Array<number>> =} callback
     **/
    claimedRewards: GenericStorageQuery<(arg: [number, AccountId32Like]) => Array<number>, [number, AccountId32]>;

    /**
     * Similar to `ErasStakers`, this holds the preferences of validators.
     *
     * This is keyed first by the era index to allow bulk deletion and then the stash account.
     *
     * Is it removed after [`Config::HistoryDepth`] eras.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<PalletStakingValidatorPrefs> =} callback
     **/
    erasValidatorPrefs: GenericStorageQuery<
      (arg: [number, AccountId32Like]) => PalletStakingValidatorPrefs,
      [number, AccountId32]
    >;

    /**
     * The total validator era payout for the last [`Config::HistoryDepth`] eras.
     *
     * Eras that haven't finished yet or has been removed doesn't have reward.
     *
     * @param {number} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    erasValidatorReward: GenericStorageQuery<(arg: number) => bigint | undefined, number>;

    /**
     * Rewards for the last [`Config::HistoryDepth`] eras.
     * If reward hasn't been set or has been removed then 0 reward is returned.
     *
     * @param {number} arg
     * @param {Callback<PalletStakingEraRewardPoints> =} callback
     **/
    erasRewardPoints: GenericStorageQuery<(arg: number) => PalletStakingEraRewardPoints, number>;

    /**
     * The total amount staked for the last [`Config::HistoryDepth`] eras.
     * If total hasn't been set or has been removed then 0 stake is returned.
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    erasTotalStake: GenericStorageQuery<(arg: number) => bigint, number>;

    /**
     * Mode of era forcing.
     *
     * @param {Callback<PalletStakingForcing> =} callback
     **/
    forceEra: GenericStorageQuery<() => PalletStakingForcing>;

    /**
     * Maximum staked rewards, i.e. the percentage of the era inflation that
     * is used for stake rewards.
     * See [Era payout](./index.html#era-payout).
     *
     * @param {Callback<Percent | undefined> =} callback
     **/
    maxStakedRewards: GenericStorageQuery<() => Percent | undefined>;

    /**
     * The percentage of the slash that is distributed to reporters.
     *
     * The rest of the slashed value is handled by the `Slash`.
     *
     * @param {Callback<Perbill> =} callback
     **/
    slashRewardFraction: GenericStorageQuery<() => Perbill>;

    /**
     * The amount of currency given to reporters of a slash event which was
     * canceled by extraordinary circumstances (e.g. governance).
     *
     * @param {Callback<bigint> =} callback
     **/
    canceledSlashPayout: GenericStorageQuery<() => bigint>;

    /**
     * All unapplied slashes that are queued for later.
     *
     * @param {number} arg
     * @param {Callback<Array<PalletStakingUnappliedSlash>> =} callback
     **/
    unappliedSlashes: GenericStorageQuery<(arg: number) => Array<PalletStakingUnappliedSlash>, number>;

    /**
     * A mapping from still-bonded eras to the first session index of that era.
     *
     * Must contains information for eras for the range:
     * `[active_era - bounding_duration; active_era]`
     *
     * @param {Callback<Array<[number, number]>> =} callback
     **/
    bondedEras: GenericStorageQuery<() => Array<[number, number]>>;

    /**
     * All slashing events on validators, mapped by era to the highest slash proportion
     * and slash value of the era.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<[Perbill, bigint] | undefined> =} callback
     **/
    validatorSlashInEra: GenericStorageQuery<
      (arg: [number, AccountId32Like]) => [Perbill, bigint] | undefined,
      [number, AccountId32]
    >;

    /**
     * All slashing events on nominators, mapped by era to the highest slash value of the era.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    nominatorSlashInEra: GenericStorageQuery<
      (arg: [number, AccountId32Like]) => bigint | undefined,
      [number, AccountId32]
    >;

    /**
     * Slashing spans for stash accounts.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletStakingSlashingSlashingSpans | undefined> =} callback
     **/
    slashingSpans: GenericStorageQuery<
      (arg: AccountId32Like) => PalletStakingSlashingSlashingSpans | undefined,
      AccountId32
    >;

    /**
     * Records information about the maximum slash of a stash within a slashing span,
     * as well as how much reward has been paid out.
     *
     * @param {[AccountId32Like, number]} arg
     * @param {Callback<PalletStakingSlashingSpanRecord> =} callback
     **/
    spanSlash: GenericStorageQuery<
      (arg: [AccountId32Like, number]) => PalletStakingSlashingSpanRecord,
      [AccountId32, number]
    >;

    /**
     * The last planned session scheduled by the session pallet.
     *
     * This is basically in sync with the call to [`pallet_session::SessionManager::new_session`].
     *
     * @param {Callback<number> =} callback
     **/
    currentPlannedSession: GenericStorageQuery<() => number>;

    /**
     * Indices of validators that have offended in the active era. The offenders are disabled for a
     * whole era. For this reason they are kept here - only staking pallet knows about eras. The
     * implementor of [`DisablingStrategy`] defines if a validator should be disabled which
     * implicitly means that the implementor also controls the max number of disabled validators.
     *
     * The vec is always kept sorted so that we can find whether a given validator has previously
     * offended using binary search.
     *
     * @param {Callback<Array<number>> =} callback
     **/
    disabledValidators: GenericStorageQuery<() => Array<number>>;

    /**
     * The threshold for when users can start calling `chill_other` for other validators /
     * nominators. The threshold is compared to the actual number of validators / nominators
     * (`CountFor*`) in the system compared to the configured max (`Max*Count`).
     *
     * @param {Callback<Percent | undefined> =} callback
     **/
    chillThreshold: GenericStorageQuery<() => Percent | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Treasury`'s storage queries
   **/
  treasury: {
    /**
     * Number of proposals that have been made.
     *
     * @param {Callback<number> =} callback
     **/
    proposalCount: GenericStorageQuery<() => number>;

    /**
     * Proposals that have been made.
     *
     * @param {number} arg
     * @param {Callback<PalletTreasuryProposal | undefined> =} callback
     **/
    proposals: GenericStorageQuery<(arg: number) => PalletTreasuryProposal | undefined, number>;

    /**
     * The amount which has been reported as inactive to Currency.
     *
     * @param {Callback<bigint> =} callback
     **/
    deactivated: GenericStorageQuery<() => bigint>;

    /**
     * Proposal indices that have been approved but not yet awarded.
     *
     * @param {Callback<Array<number>> =} callback
     **/
    approvals: GenericStorageQuery<() => Array<number>>;

    /**
     * The count of spends that have been made.
     *
     * @param {Callback<number> =} callback
     **/
    spendCount: GenericStorageQuery<() => number>;

    /**
     * Spends that have been approved and being processed.
     *
     * @param {number} arg
     * @param {Callback<PalletTreasurySpendStatus | undefined> =} callback
     **/
    spends: GenericStorageQuery<(arg: number) => PalletTreasurySpendStatus | undefined, number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Historical`'s storage queries
   **/
  historical: {
    /**
     * Mapping from historical session indices to session-data root hash and validator count.
     *
     * @param {number} arg
     * @param {Callback<[H256, number] | undefined> =} callback
     **/
    historicalSessions: GenericStorageQuery<(arg: number) => [H256, number] | undefined, number>;

    /**
     * The range of historical sessions we store. [first, last)
     *
     * @param {Callback<[number, number] | undefined> =} callback
     **/
    storedRange: GenericStorageQuery<() => [number, number] | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `ConvictionVoting`'s storage queries
   **/
  convictionVoting: {
    /**
     * All voting for a particular voter in a particular voting class. We store the balance for the
     * number of votes that we have recorded.
     *
     * @param {[AccountId32Like, number]} arg
     * @param {Callback<PalletConvictionVotingVoteVoting> =} callback
     **/
    votingFor: GenericStorageQuery<
      (arg: [AccountId32Like, number]) => PalletConvictionVotingVoteVoting,
      [AccountId32, number]
    >;

    /**
     * The voting classes which have a non-zero lock requirement and the lock amounts which they
     * require. The actual amount locked on behalf of this pallet should always be the maximum of
     * this list.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<[number, bigint]>> =} callback
     **/
    classLocksFor: GenericStorageQuery<(arg: AccountId32Like) => Array<[number, bigint]>, AccountId32>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Referenda`'s storage queries
   **/
  referenda: {
    /**
     * The next free referendum index, aka the number of referenda started so far.
     *
     * @param {Callback<number> =} callback
     **/
    referendumCount: GenericStorageQuery<() => number>;

    /**
     * Information concerning any given referendum.
     *
     * @param {number} arg
     * @param {Callback<PalletReferendaReferendumInfo | undefined> =} callback
     **/
    referendumInfoFor: GenericStorageQuery<(arg: number) => PalletReferendaReferendumInfo | undefined, number>;

    /**
     * The sorted list of referenda ready to be decided but not yet being decided, ordered by
     * conviction-weighted approvals.
     *
     * This should be empty if `DecidingCount` is less than `TrackInfo::max_deciding`.
     *
     * @param {number} arg
     * @param {Callback<Array<[number, bigint]>> =} callback
     **/
    trackQueue: GenericStorageQuery<(arg: number) => Array<[number, bigint]>, number>;

    /**
     * The number of referenda being decided currently.
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    decidingCount: GenericStorageQuery<(arg: number) => number, number>;

    /**
     * The metadata is a general information concerning the referendum.
     * The `Hash` refers to the preimage of the `Preimages` provider which can be a JSON
     * dump or IPFS hash of a JSON file.
     *
     * Consider a garbage collection for a metadata of finished referendums to `unrequest` (remove)
     * large preimages.
     *
     * @param {number} arg
     * @param {Callback<H256 | undefined> =} callback
     **/
    metadataOf: GenericStorageQuery<(arg: number) => H256 | undefined, number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `FellowshipCollective`'s storage queries
   **/
  fellowshipCollective: {
    /**
     * The number of members in the collective who have at least the rank according to the index
     * of the vec.
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    memberCount: GenericStorageQuery<(arg: number) => number, number>;

    /**
     * The current members of the collective.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletRankedCollectiveMemberRecord | undefined> =} callback
     **/
    members: GenericStorageQuery<(arg: AccountId32Like) => PalletRankedCollectiveMemberRecord | undefined, AccountId32>;

    /**
     * The index of each ranks's member into the group of members who have at least that rank.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<number | undefined> =} callback
     **/
    idToIndex: GenericStorageQuery<(arg: [number, AccountId32Like]) => number | undefined, [number, AccountId32]>;

    /**
     * The members in the collective by index. All indices in the range `0..MemberCount` will
     * return `Some`, however a member's index is not guaranteed to remain unchanged over time.
     *
     * @param {[number, number]} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    indexToId: GenericStorageQuery<(arg: [number, number]) => AccountId32 | undefined, [number, number]>;

    /**
     * Votes on a given proposal, if it is ongoing.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<PalletRankedCollectiveVoteRecord | undefined> =} callback
     **/
    voting: GenericStorageQuery<
      (arg: [number, AccountId32Like]) => PalletRankedCollectiveVoteRecord | undefined,
      [number, AccountId32]
    >;

    /**
     *
     * @param {number} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    votingCleanup: GenericStorageQuery<(arg: number) => Bytes | undefined, number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `FellowshipReferenda`'s storage queries
   **/
  fellowshipReferenda: {
    /**
     * The next free referendum index, aka the number of referenda started so far.
     *
     * @param {Callback<number> =} callback
     **/
    referendumCount: GenericStorageQuery<() => number>;

    /**
     * Information concerning any given referendum.
     *
     * @param {number} arg
     * @param {Callback<PalletReferendaReferendumInfoTally | undefined> =} callback
     **/
    referendumInfoFor: GenericStorageQuery<(arg: number) => PalletReferendaReferendumInfoTally | undefined, number>;

    /**
     * The sorted list of referenda ready to be decided but not yet being decided, ordered by
     * conviction-weighted approvals.
     *
     * This should be empty if `DecidingCount` is less than `TrackInfo::max_deciding`.
     *
     * @param {number} arg
     * @param {Callback<Array<[number, number]>> =} callback
     **/
    trackQueue: GenericStorageQuery<(arg: number) => Array<[number, number]>, number>;

    /**
     * The number of referenda being decided currently.
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    decidingCount: GenericStorageQuery<(arg: number) => number, number>;

    /**
     * The metadata is a general information concerning the referendum.
     * The `Hash` refers to the preimage of the `Preimages` provider which can be a JSON
     * dump or IPFS hash of a JSON file.
     *
     * Consider a garbage collection for a metadata of finished referendums to `unrequest` (remove)
     * large preimages.
     *
     * @param {number} arg
     * @param {Callback<H256 | undefined> =} callback
     **/
    metadataOf: GenericStorageQuery<(arg: number) => H256 | undefined, number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Whitelist`'s storage queries
   **/
  whitelist: {
    /**
     *
     * @param {H256} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    whitelistedCall: GenericStorageQuery<(arg: H256) => [] | undefined, H256>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Scheduler`'s storage queries
   **/
  scheduler: {
    /**
     *
     * @param {Callback<number | undefined> =} callback
     **/
    incompleteSince: GenericStorageQuery<() => number | undefined>;

    /**
     * Items to be executed, indexed by the block number that they should be executed on.
     *
     * @param {number} arg
     * @param {Callback<Array<PalletSchedulerScheduled | undefined>> =} callback
     **/
    agenda: GenericStorageQuery<(arg: number) => Array<PalletSchedulerScheduled | undefined>, number>;

    /**
     * Retry configurations for items to be executed, indexed by task address.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletSchedulerRetryConfig | undefined> =} callback
     **/
    retries: GenericStorageQuery<(arg: [number, number]) => PalletSchedulerRetryConfig | undefined, [number, number]>;

    /**
     * Lookup from a name to the block number and index of the task.
     *
     * For v3 -> v4 the previously unbounded identities are Blake2-256 hashed to form the v4
     * identities.
     *
     * @param {FixedBytes<32>} arg
     * @param {Callback<[number, number] | undefined> =} callback
     **/
    lookup: GenericStorageQuery<(arg: FixedBytes<32>) => [number, number] | undefined, FixedBytes<32>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Preimage`'s storage queries
   **/
  preimage: {
    /**
     * The request status of a given hash.
     *
     * @param {H256} arg
     * @param {Callback<PalletPreimageOldRequestStatus | undefined> =} callback
     **/
    statusFor: GenericStorageQuery<(arg: H256) => PalletPreimageOldRequestStatus | undefined, H256>;

    /**
     * The request status of a given hash.
     *
     * @param {H256} arg
     * @param {Callback<PalletPreimageRequestStatus | undefined> =} callback
     **/
    requestStatusFor: GenericStorageQuery<(arg: H256) => PalletPreimageRequestStatus | undefined, H256>;

    /**
     *
     * @param {[H256, number]} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    preimageFor: GenericStorageQuery<(arg: [H256, number]) => Bytes | undefined, [H256, number]>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Identity`'s storage queries
   **/
  identity: {
    /**
     * Information that is pertinent to identify the entity behind an account. First item is the
     * registration, second is the account's primary username.
     *
     * TWOX-NOTE: OK  `AccountId` is a secure hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[PalletIdentityRegistration, Bytes | undefined] | undefined> =} callback
     **/
    identityOf: GenericStorageQuery<
      (arg: AccountId32Like) => [PalletIdentityRegistration, Bytes | undefined] | undefined,
      AccountId32
    >;

    /**
     * The super-identity of an alternative "sub" identity together with its name, within that
     * context. If the account is not some other account's sub-identity, then just `None`.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[AccountId32, Data] | undefined> =} callback
     **/
    superOf: GenericStorageQuery<(arg: AccountId32Like) => [AccountId32, Data] | undefined, AccountId32>;

    /**
     * Alternative "sub" identities of this account.
     *
     * The first item is the deposit, the second is a vector of the accounts.
     *
     * TWOX-NOTE: OK  `AccountId` is a secure hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[bigint, Array<AccountId32>]> =} callback
     **/
    subsOf: GenericStorageQuery<(arg: AccountId32Like) => [bigint, Array<AccountId32>], AccountId32>;

    /**
     * The set of registrars. Not expected to get very big as can only be added through a
     * special origin (likely a council motion).
     *
     * The index into this can be cast to `RegistrarIndex` to get a valid value.
     *
     * @param {Callback<Array<PalletIdentityRegistrarInfo | undefined>> =} callback
     **/
    registrars: GenericStorageQuery<() => Array<PalletIdentityRegistrarInfo | undefined>>;

    /**
     * A map of the accounts who are authorized to grant usernames.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletIdentityAuthorityProperties | undefined> =} callback
     **/
    usernameAuthorities: GenericStorageQuery<
      (arg: AccountId32Like) => PalletIdentityAuthorityProperties | undefined,
      AccountId32
    >;

    /**
     * Reverse lookup from `username` to the `AccountId` that has registered it. The value should
     * be a key in the `IdentityOf` map, but it may not if the user has cleared their identity.
     *
     * Multiple usernames may map to the same `AccountId`, but `IdentityOf` will only map to one
     * primary username.
     *
     * @param {BytesLike} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    accountOfUsername: GenericStorageQuery<(arg: BytesLike) => AccountId32 | undefined, Bytes>;

    /**
     * Usernames that an authority has granted, but that the account controller has not confirmed
     * that they want it. Used primarily in cases where the `AccountId` cannot provide a signature
     * because they are a pure proxy, multisig, etc. In order to confirm it, they should call
     * [`Call::accept_username`].
     *
     * First tuple item is the account and second is the acceptance deadline.
     *
     * @param {BytesLike} arg
     * @param {Callback<[AccountId32, number] | undefined> =} callback
     **/
    pendingUsernames: GenericStorageQuery<(arg: BytesLike) => [AccountId32, number] | undefined, Bytes>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Proxy`'s storage queries
   **/
  proxy: {
    /**
     * The set of account proxies. Maps the account which has delegated to the accounts
     * which are being delegated to, together with the amount held on deposit.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[Array<PalletProxyProxyDefinition>, bigint]> =} callback
     **/
    proxies: GenericStorageQuery<(arg: AccountId32Like) => [Array<PalletProxyProxyDefinition>, bigint], AccountId32>;

    /**
     * The announcements made by the proxy (key).
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[Array<PalletProxyAnnouncement>, bigint]> =} callback
     **/
    announcements: GenericStorageQuery<(arg: AccountId32Like) => [Array<PalletProxyAnnouncement>, bigint], AccountId32>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Multisig`'s storage queries
   **/
  multisig: {
    /**
     * The set of open multisig operations.
     *
     * @param {[AccountId32Like, FixedBytes<32>]} arg
     * @param {Callback<PalletMultisigMultisig | undefined> =} callback
     **/
    multisigs: GenericStorageQuery<
      (arg: [AccountId32Like, FixedBytes<32>]) => PalletMultisigMultisig | undefined,
      [AccountId32, FixedBytes<32>]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `ElectionProviderMultiPhase`'s storage queries
   **/
  electionProviderMultiPhase: {
    /**
     * Internal counter for the number of rounds.
     *
     * This is useful for de-duplication of transactions submitted to the pool, and general
     * diagnostics of the pallet.
     *
     * This is merely incremented once per every time that an upstream `elect` is called.
     *
     * @param {Callback<number> =} callback
     **/
    round: GenericStorageQuery<() => number>;

    /**
     * Current phase.
     *
     * @param {Callback<PalletElectionProviderMultiPhasePhase> =} callback
     **/
    currentPhase: GenericStorageQuery<() => PalletElectionProviderMultiPhasePhase>;

    /**
     * Current best solution, signed or unsigned, queued to be returned upon `elect`.
     *
     * Always sorted by score.
     *
     * @param {Callback<PalletElectionProviderMultiPhaseReadySolution | undefined> =} callback
     **/
    queuedSolution: GenericStorageQuery<() => PalletElectionProviderMultiPhaseReadySolution | undefined>;

    /**
     * Snapshot data of the round.
     *
     * This is created at the beginning of the signed phase and cleared upon calling `elect`.
     * Note: This storage type must only be mutated through [`SnapshotWrapper`].
     *
     * @param {Callback<PalletElectionProviderMultiPhaseRoundSnapshot | undefined> =} callback
     **/
    snapshot: GenericStorageQuery<() => PalletElectionProviderMultiPhaseRoundSnapshot | undefined>;

    /**
     * Desired number of targets to elect for this round.
     *
     * Only exists when [`Snapshot`] is present.
     * Note: This storage type must only be mutated through [`SnapshotWrapper`].
     *
     * @param {Callback<number | undefined> =} callback
     **/
    desiredTargets: GenericStorageQuery<() => number | undefined>;

    /**
     * The metadata of the [`RoundSnapshot`]
     *
     * Only exists when [`Snapshot`] is present.
     * Note: This storage type must only be mutated through [`SnapshotWrapper`].
     *
     * @param {Callback<PalletElectionProviderMultiPhaseSolutionOrSnapshotSize | undefined> =} callback
     **/
    snapshotMetadata: GenericStorageQuery<() => PalletElectionProviderMultiPhaseSolutionOrSnapshotSize | undefined>;

    /**
     * The next index to be assigned to an incoming signed submission.
     *
     * Every accepted submission is assigned a unique index; that index is bound to that particular
     * submission for the duration of the election. On election finalization, the next index is
     * reset to 0.
     *
     * We can't just use `SignedSubmissionIndices.len()`, because that's a bounded set; past its
     * capacity, it will simply saturate. We can't just iterate over `SignedSubmissionsMap`,
     * because iteration is slow. Instead, we store the value here.
     *
     * @param {Callback<number> =} callback
     **/
    signedSubmissionNextIndex: GenericStorageQuery<() => number>;

    /**
     * A sorted, bounded vector of `(score, block_number, index)`, where each `index` points to a
     * value in `SignedSubmissions`.
     *
     * We never need to process more than a single signed submission at a time. Signed submissions
     * can be quite large, so we're willing to pay the cost of multiple database accesses to access
     * them one at a time instead of reading and decoding all of them at once.
     *
     * @param {Callback<Array<[SpNposElectionsElectionScore, number, number]>> =} callback
     **/
    signedSubmissionIndices: GenericStorageQuery<() => Array<[SpNposElectionsElectionScore, number, number]>>;

    /**
     * Unchecked, signed solutions.
     *
     * Together with `SubmissionIndices`, this stores a bounded set of `SignedSubmissions` while
     * allowing us to keep only a single one in memory at a time.
     *
     * Twox note: the key of the map is an auto-incrementing index which users cannot inspect or
     * affect; we shouldn't need a cryptographically secure hasher.
     *
     * @param {number} arg
     * @param {Callback<PalletElectionProviderMultiPhaseSignedSignedSubmission | undefined> =} callback
     **/
    signedSubmissionsMap: GenericStorageQuery<
      (arg: number) => PalletElectionProviderMultiPhaseSignedSignedSubmission | undefined,
      number
    >;

    /**
     * The minimum score that each 'untrusted' solution must attain in order to be considered
     * feasible.
     *
     * Can be set via `set_minimum_untrusted_score`.
     *
     * @param {Callback<SpNposElectionsElectionScore | undefined> =} callback
     **/
    minimumUntrustedScore: GenericStorageQuery<() => SpNposElectionsElectionScore | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Offences`'s storage queries
   **/
  offences: {
    /**
     * The primary structure that holds all offence records keyed by report identifiers.
     *
     * @param {H256} arg
     * @param {Callback<SpStakingOffenceOffenceDetails | undefined> =} callback
     **/
    reports: GenericStorageQuery<(arg: H256) => SpStakingOffenceOffenceDetails | undefined, H256>;

    /**
     * A vector of reports of the same kind that happened at the same time slot.
     *
     * @param {[FixedBytes<16>, BytesLike]} arg
     * @param {Callback<Array<H256>> =} callback
     **/
    concurrentReportsIndex: GenericStorageQuery<
      (arg: [FixedBytes<16>, BytesLike]) => Array<H256>,
      [FixedBytes<16>, Bytes]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Bounties`'s storage queries
   **/
  bounties: {
    /**
     * Number of bounty proposals that have been made.
     *
     * @param {Callback<number> =} callback
     **/
    bountyCount: GenericStorageQuery<() => number>;

    /**
     * Bounties that have been made.
     *
     * @param {number} arg
     * @param {Callback<PalletBountiesBounty | undefined> =} callback
     **/
    bounties: GenericStorageQuery<(arg: number) => PalletBountiesBounty | undefined, number>;

    /**
     * The description of each bounty.
     *
     * @param {number} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    bountyDescriptions: GenericStorageQuery<(arg: number) => Bytes | undefined, number>;

    /**
     * Bounty indices that have been approved but not yet funded.
     *
     * @param {Callback<Array<number>> =} callback
     **/
    bountyApprovals: GenericStorageQuery<() => Array<number>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `ChildBounties`'s storage queries
   **/
  childBounties: {
    /**
     * Number of total child bounties.
     *
     * @param {Callback<number> =} callback
     **/
    childBountyCount: GenericStorageQuery<() => number>;

    /**
     * Number of child bounties per parent bounty.
     * Map of parent bounty index to number of child bounties.
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    parentChildBounties: GenericStorageQuery<(arg: number) => number, number>;

    /**
     * Child bounties that have been added.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletChildBountiesChildBounty | undefined> =} callback
     **/
    childBounties: GenericStorageQuery<
      (arg: [number, number]) => PalletChildBountiesChildBounty | undefined,
      [number, number]
    >;

    /**
     * The description of each child-bounty.
     *
     * @param {number} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    childBountyDescriptions: GenericStorageQuery<(arg: number) => Bytes | undefined, number>;

    /**
     * The cumulative child-bounty curator fee for each parent bounty.
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    childrenCuratorFees: GenericStorageQuery<(arg: number) => bigint, number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `NominationPools`'s storage queries
   **/
  nominationPools: {
    /**
     * The sum of funds across all pools.
     *
     * This might be lower but never higher than the sum of `total_balance` of all [`PoolMembers`]
     * because calling `pool_withdraw_unbonded` might decrease the total stake of the pool's
     * `bonded_account` without adjusting the pallet-internal `UnbondingPool`'s.
     *
     * @param {Callback<bigint> =} callback
     **/
    totalValueLocked: GenericStorageQuery<() => bigint>;

    /**
     * Minimum amount to bond to join a pool.
     *
     * @param {Callback<bigint> =} callback
     **/
    minJoinBond: GenericStorageQuery<() => bigint>;

    /**
     * Minimum bond required to create a pool.
     *
     * This is the amount that the depositor must put as their initial stake in the pool, as an
     * indication of "skin in the game".
     *
     * This is the value that will always exist in the staking ledger of the pool bonded account
     * while all other accounts leave.
     *
     * @param {Callback<bigint> =} callback
     **/
    minCreateBond: GenericStorageQuery<() => bigint>;

    /**
     * Maximum number of nomination pools that can exist. If `None`, then an unbounded number of
     * pools can exist.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    maxPools: GenericStorageQuery<() => number | undefined>;

    /**
     * Maximum number of members that can exist in the system. If `None`, then the count
     * members are not bound on a system wide basis.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    maxPoolMembers: GenericStorageQuery<() => number | undefined>;

    /**
     * Maximum number of members that may belong to pool. If `None`, then the count of
     * members is not bound on a per pool basis.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    maxPoolMembersPerPool: GenericStorageQuery<() => number | undefined>;

    /**
     * The maximum commission that can be charged by a pool. Used on commission payouts to bound
     * pool commissions that are > `GlobalMaxCommission`, necessary if a future
     * `GlobalMaxCommission` is lower than some current pool commissions.
     *
     * @param {Callback<Perbill | undefined> =} callback
     **/
    globalMaxCommission: GenericStorageQuery<() => Perbill | undefined>;

    /**
     * Active members.
     *
     * TWOX-NOTE: SAFE since `AccountId` is a secure hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletNominationPoolsPoolMember | undefined> =} callback
     **/
    poolMembers: GenericStorageQuery<
      (arg: AccountId32Like) => PalletNominationPoolsPoolMember | undefined,
      AccountId32
    >;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForPoolMembers: GenericStorageQuery<() => number>;

    /**
     * Storage for bonded pools.
     *
     * @param {number} arg
     * @param {Callback<PalletNominationPoolsBondedPoolInner | undefined> =} callback
     **/
    bondedPools: GenericStorageQuery<(arg: number) => PalletNominationPoolsBondedPoolInner | undefined, number>;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForBondedPools: GenericStorageQuery<() => number>;

    /**
     * Reward pools. This is where there rewards for each pool accumulate. When a members payout is
     * claimed, the balance comes out of the reward pool. Keyed by the bonded pools account.
     *
     * @param {number} arg
     * @param {Callback<PalletNominationPoolsRewardPool | undefined> =} callback
     **/
    rewardPools: GenericStorageQuery<(arg: number) => PalletNominationPoolsRewardPool | undefined, number>;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForRewardPools: GenericStorageQuery<() => number>;

    /**
     * Groups of unbonding pools. Each group of unbonding pools belongs to a
     * bonded pool, hence the name sub-pools. Keyed by the bonded pools account.
     *
     * @param {number} arg
     * @param {Callback<PalletNominationPoolsSubPools | undefined> =} callback
     **/
    subPoolsStorage: GenericStorageQuery<(arg: number) => PalletNominationPoolsSubPools | undefined, number>;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForSubPoolsStorage: GenericStorageQuery<() => number>;

    /**
     * Metadata for the pool.
     *
     * @param {number} arg
     * @param {Callback<Bytes> =} callback
     **/
    metadata: GenericStorageQuery<(arg: number) => Bytes, number>;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForMetadata: GenericStorageQuery<() => number>;

    /**
     * Ever increasing number of all pools created so far.
     *
     * @param {Callback<number> =} callback
     **/
    lastPoolId: GenericStorageQuery<() => number>;

    /**
     * A reverse lookup from the pool's account id to its id.
     *
     * This is only used for slashing and on automatic withdraw update. In all other instances, the
     * pool id is used, and the accounts are deterministically derived from it.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<number | undefined> =} callback
     **/
    reversePoolIdLookup: GenericStorageQuery<(arg: AccountId32Like) => number | undefined, AccountId32>;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForReversePoolIdLookup: GenericStorageQuery<() => number>;

    /**
     * Map from a pool member account to their opted claim permission.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletNominationPoolsClaimPermission> =} callback
     **/
    claimPermissions: GenericStorageQuery<(arg: AccountId32Like) => PalletNominationPoolsClaimPermission, AccountId32>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `GearProgram`'s storage queries
   **/
  gearProgram: {
    /**
     *
     * @param {GprimitivesCodeId} arg
     * @param {Callback<GearCoreCodeInstrumentedInstrumentedCode | undefined> =} callback
     **/
    instrumentedCodeStorage: GenericStorageQuery<
      (arg: GprimitivesCodeId) => GearCoreCodeInstrumentedInstrumentedCode | undefined,
      GprimitivesCodeId
    >;

    /**
     *
     * @param {GprimitivesCodeId} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    originalCodeStorage: GenericStorageQuery<(arg: GprimitivesCodeId) => Bytes | undefined, GprimitivesCodeId>;

    /**
     *
     * @param {GprimitivesCodeId} arg
     * @param {Callback<GearCoreCodeMetadataCodeMetadata | undefined> =} callback
     **/
    codeMetadataStorage: GenericStorageQuery<
      (arg: GprimitivesCodeId) => GearCoreCodeMetadataCodeMetadata | undefined,
      GprimitivesCodeId
    >;

    /**
     *
     * @param {GprimitivesActorId} arg
     * @param {Callback<NumeratedTreeIntervalsTree | undefined> =} callback
     **/
    allocationsStorage: GenericStorageQuery<
      (arg: GprimitivesActorId) => NumeratedTreeIntervalsTree | undefined,
      GprimitivesActorId
    >;

    /**
     *
     * @param {GprimitivesActorId} arg
     * @param {Callback<GearCoreProgram | undefined> =} callback
     **/
    programStorage: GenericStorageQuery<(arg: GprimitivesActorId) => GearCoreProgram | undefined, GprimitivesActorId>;

    /**
     *
     * @param {[GprimitivesActorId, GearCoreProgramMemoryInfix, GearCorePagesPage]} arg
     * @param {Callback<GearCoreMemoryPageBuf | undefined> =} callback
     **/
    memoryPages: GenericStorageQuery<
      (arg: [GprimitivesActorId, GearCoreProgramMemoryInfix, GearCorePagesPage]) => GearCoreMemoryPageBuf | undefined,
      [GprimitivesActorId, GearCoreProgramMemoryInfix, GearCorePagesPage]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `GearMessenger`'s storage queries
   **/
  gearMessenger: {
    /**
     *
     * @param {Callback<number | undefined> =} callback
     **/
    dequeued: GenericStorageQuery<() => number | undefined>;

    /**
     *
     * @param {GprimitivesMessageId} arg
     * @param {Callback<GearCommonStorageComplicatedDequeueLinkedNode | undefined> =} callback
     **/
    dispatches: GenericStorageQuery<
      (arg: GprimitivesMessageId) => GearCommonStorageComplicatedDequeueLinkedNode | undefined,
      GprimitivesMessageId
    >;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForDispatches: GenericStorageQuery<() => number>;

    /**
     *
     * @param {Callback<GprimitivesMessageId | undefined> =} callback
     **/
    head: GenericStorageQuery<() => GprimitivesMessageId | undefined>;

    /**
     *
     * @param {[AccountId32Like, GprimitivesMessageId]} arg
     * @param {Callback<[GearCoreMessageUserUserStoredMessage, GearCommonStoragePrimitivesInterval] | undefined> =} callback
     **/
    mailbox: GenericStorageQuery<
      (
        arg: [AccountId32Like, GprimitivesMessageId],
      ) => [GearCoreMessageUserUserStoredMessage, GearCommonStoragePrimitivesInterval] | undefined,
      [AccountId32, GprimitivesMessageId]
    >;

    /**
     *
     * @param {Callback<boolean | undefined> =} callback
     **/
    queueProcessing: GenericStorageQuery<() => boolean | undefined>;

    /**
     *
     * @param {Callback<number | undefined> =} callback
     **/
    sent: GenericStorageQuery<() => number | undefined>;

    /**
     *
     * @param {Callback<GprimitivesMessageId | undefined> =} callback
     **/
    tail: GenericStorageQuery<() => GprimitivesMessageId | undefined>;

    /**
     *
     * @param {[GprimitivesActorId, GprimitivesMessageId]} arg
     * @param {Callback<[GearCoreMessageStoredStoredDispatch, GearCommonStoragePrimitivesInterval] | undefined> =} callback
     **/
    waitlist: GenericStorageQuery<
      (
        arg: [GprimitivesActorId, GprimitivesMessageId],
      ) => [GearCoreMessageStoredStoredDispatch, GearCommonStoragePrimitivesInterval] | undefined,
      [GprimitivesActorId, GprimitivesMessageId]
    >;

    /**
     *
     * @param {GprimitivesMessageId} arg
     * @param {Callback<[GearCoreMessageStoredStoredDelayedDispatch, GearCommonStoragePrimitivesInterval] | undefined> =} callback
     **/
    dispatchStash: GenericStorageQuery<
      (
        arg: GprimitivesMessageId,
      ) => [GearCoreMessageStoredStoredDelayedDispatch, GearCommonStoragePrimitivesInterval] | undefined,
      GprimitivesMessageId
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `GearScheduler`'s storage queries
   **/
  gearScheduler: {
    /**
     *
     * @param {Callback<number | undefined> =} callback
     **/
    firstIncompleteTasksBlock: GenericStorageQuery<() => number | undefined>;

    /**
     *
     * @param {[number, GearCoreTasksScheduledTask]} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    taskPool: GenericStorageQuery<
      (arg: [number, GearCoreTasksScheduledTask]) => [] | undefined,
      [number, GearCoreTasksScheduledTask]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `GearGas`'s storage queries
   **/
  gearGas: {
    /**
     *
     * @param {Callback<bigint | undefined> =} callback
     **/
    totalIssuance: GenericStorageQuery<() => bigint | undefined>;

    /**
     *
     * @param {GearCommonGasProviderNodeGasNodeId} arg
     * @param {Callback<GearCommonGasProviderNodeGasNode | undefined> =} callback
     **/
    gasNodes: GenericStorageQuery<
      (arg: GearCommonGasProviderNodeGasNodeId) => GearCommonGasProviderNodeGasNode | undefined,
      GearCommonGasProviderNodeGasNodeId
    >;

    /**
     *
     * @param {Callback<bigint> =} callback
     **/
    allowance: GenericStorageQuery<() => bigint>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Gear`'s storage queries
   **/
  gear: {
    /**
     * A flag indicating whether the message queue should be processed at the end of a block
     *
     * If not set, the inherent extrinsic that processes the queue will keep throwing an error
     * thereby making the block builder exclude it from the block.
     *
     * @param {Callback<boolean> =} callback
     **/
    executeInherent: GenericStorageQuery<() => boolean>;

    /**
     * The current block number being processed.
     *
     * It shows block number in which queue is processed.
     * May be less than system pallet block number if panic occurred previously.
     *
     * @param {Callback<number> =} callback
     **/
    blockNumber: GenericStorageQuery<() => number>;

    /**
     * A guard to prohibit all but the first execution of `pallet_gear::run()` call in a block.
     *
     * Set to `Some(())` if the extrinsic is executed for the first time in a block.
     * All subsequent attempts would fail with `Error::<T>::GearRunAlreadyInBlock` error.
     * Set back to `None` in the `on_finalize()` hook at the end of the block.
     *
     * @param {Callback<[] | undefined> =} callback
     **/
    gearRunInBlock: GenericStorageQuery<() => [] | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `StakingRewards`'s storage queries
   **/
  stakingRewards: {
    /**
     * Target inflation (at ideal stake)
     *
     * @param {Callback<Perquintill> =} callback
     **/
    targetInflation: GenericStorageQuery<() => Perquintill>;

    /**
     * Ideal staking ratio
     *
     * @param {Callback<Perquintill> =} callback
     **/
    idealStakingRatio: GenericStorageQuery<() => Perquintill>;

    /**
     * The current share of issued tokens that cannot be staked (e.g. being vested)
     * This value is guaranteed to remain unchanged for the first year until vesting kicks in.
     * Subsequently, the non-stakeable share should be calculated based on the vesting balances.
     *
     * @param {Callback<Perquintill> =} callback
     **/
    nonStakeableShare: GenericStorageQuery<() => Perquintill>;

    /**
     * List of accounts whose locked balance (due to incomplete vesting) should be excluded from
     * the total stakeable quantity.
     * During the 1st year the non-stakeable amount is accounted for as a fixed fraction of TTS.
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    filteredAccounts: GenericStorageQuery<() => Array<AccountId32>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `GearVoucher`'s storage queries
   **/
  gearVoucher: {
    /**
     * Storage containing amount of the total vouchers issued.
     *
     * Used as nonce in voucher creation.
     *
     * @param {Callback<bigint | undefined> =} callback
     **/
    issued: GenericStorageQuery<() => bigint | undefined>;

    /**
     * Double map storage containing data of the voucher,
     * associated with some spender and voucher ids.
     *
     * @param {[AccountId32Like, PalletGearVoucherInternalVoucherId]} arg
     * @param {Callback<PalletGearVoucherInternalVoucherInfo | undefined> =} callback
     **/
    vouchers: GenericStorageQuery<
      (arg: [AccountId32Like, PalletGearVoucherInternalVoucherId]) => PalletGearVoucherInternalVoucherInfo | undefined,
      [AccountId32, PalletGearVoucherInternalVoucherId]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `GearBank`'s storage queries
   **/
  gearBank: {
    /**
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletGearBankBankAccount | undefined> =} callback
     **/
    bank: GenericStorageQuery<(arg: AccountId32Like) => PalletGearBankBankAccount | undefined, AccountId32>;

    /**
     *
     * @param {Callback<AccountId32> =} callback
     **/
    bankAddress: GenericStorageQuery<() => AccountId32>;

    /**
     *
     * @param {Callback<bigint> =} callback
     **/
    unusedValue: GenericStorageQuery<() => bigint>;

    /**
     *
     * @param {AccountId32Like} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    onFinalizeTransfers: GenericStorageQuery<(arg: AccountId32Like) => bigint | undefined, AccountId32>;

    /**
     *
     * @param {Callback<bigint> =} callback
     **/
    onFinalizeValue: GenericStorageQuery<() => bigint>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `GearEthBridge`'s storage queries
   **/
  gearEthBridge: {
    /**
     * Lifecycle storage.
     *
     * Defines if pallet got initialized and focused on common session changes.
     *
     * @param {Callback<boolean> =} callback
     **/
    initialized: GenericStorageQuery<() => boolean>;

    /**
     * Lifecycle storage.
     *
     * Defines if pallet is accepting any mutable requests. Governance-ruled.
     *
     * @param {Callback<boolean> =} callback
     **/
    paused: GenericStorageQuery<() => boolean>;

    /**
     * Primary storage.
     *
     * Keeps hash of queued validator keys for the next era.
     *
     * **Invariant**: Key exists in storage since first block of some era's last
     * session, until initialization of the second block of the next era.
     *
     * @param {Callback<H256 | undefined> =} callback
     **/
    authoritySetHash: GenericStorageQuery<() => H256 | undefined>;

    /**
     * Primary storage.
     *
     * Keeps merkle root of the bridge's queued messages.
     *
     * **Invariant**: Key exists since pallet initialization. If queue is empty,
     * zeroed hash set in storage.
     *
     * @param {Callback<H256 | undefined> =} callback
     **/
    queueMerkleRoot: GenericStorageQuery<() => H256 | undefined>;

    /**
     * Primary storage.
     *
     * Keeps bridge's queued messages keccak hashes.
     *
     * @param {Callback<Array<H256>> =} callback
     **/
    queue: GenericStorageQuery<() => Array<H256>>;

    /**
     * Primary storage.
     *
     * Keeps the monotonic identifier of a bridge message queue.
     *
     * @param {Callback<bigint> =} callback
     **/
    queueId: GenericStorageQuery<() => bigint>;

    /**
     * Helper storage.
     *
     * Keeps queue infos to their ids. For details on info, see [`QueueInfo`].
     *
     * @param {bigint} arg
     * @param {Callback<PalletGearEthBridgeInternalQueueInfo | undefined> =} callback
     **/
    queuesInfo: GenericStorageQuery<(arg: bigint) => PalletGearEthBridgeInternalQueueInfo | undefined, bigint>;

    /**
     * Operational storage.
     *
     * Defines in how many on_initialize hooks queue, queue merkle root and
     * grandpa keys hash should be cleared.
     *
     * **Invariant**: set to 2 on_init hooks when new session with authorities
     * set change, then decreasing to zero on each new block hook. When equals
     * to zero, reset is performed.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    clearTimer: GenericStorageQuery<() => number | undefined>;

    /**
     * Operational storage.
     *
     * Keeps next message's nonce for bridging. Must be increased on each use.
     *
     * @param {Callback<U256> =} callback
     **/
    messageNonce: GenericStorageQuery<() => U256>;

    /**
     * Operational storage.
     *
     * Defines if queue was changed within the block, it's necessary to
     * update queue merkle root by the end of the block.
     *
     * @param {Callback<boolean> =} callback
     **/
    queueChanged: GenericStorageQuery<() => boolean>;

    /**
     * Operational storage.
     *
     * Defines since when queue was last pushed to that caused overflow.
     * Intended to support unlimited queue capacity.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    queueOverflowedSince: GenericStorageQuery<() => number | undefined>;

    /**
     * Operational storage.
     *
     * Defines the amount of fee to be paid for the transport of messages.
     *
     * @param {Callback<bigint> =} callback
     **/
    transportFee: GenericStorageQuery<() => bigint>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `GrandpaSigner`'s storage queries
   **/
  grandpaSigner: {
    /**
     *
     * @param {Callback<number> =} callback
     **/
    nextRequestId: GenericStorageQuery<() => number>;

    /**
     *
     * @param {number} arg
     * @param {Callback<PalletGrandpaSignerSigningRequest | undefined> =} callback
     **/
    requests: GenericStorageQuery<(arg: number) => PalletGrandpaSignerSigningRequest | undefined, number>;

    /**
     *
     * @param {[number, FixedBytes<32>]} arg
     * @param {Callback<FixedBytes<64> | undefined> =} callback
     **/
    signatures: GenericStorageQuery<
      (arg: [number, FixedBytes<32>]) => FixedBytes<64> | undefined,
      [number, FixedBytes<32>]
    >;

    /**
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    signatureCount: GenericStorageQuery<(arg: number) => number, number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
}
