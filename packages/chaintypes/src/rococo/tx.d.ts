// Generated by dedot cli

import type {
  GenericChainTx,
  GenericTxCall,
  ISubmittableExtrinsic,
  ISubmittableResult,
  IRuntimeTxCall,
  RpcVersion,
  RpcV2,
  ISubmittableExtrinsicLegacy,
  TxStatus,
} from 'dedot/types';
import type {
  MultiAddressLike,
  Extrinsic,
  BytesLike,
  H256,
  AccountId32Like,
  EthereumAddressLike,
  Data,
  FixedBytes,
  FixedU128,
  Perquintill,
  Perbill,
} from 'dedot/codecs';
import type {
  RococoRuntimeRuntimeCallLike,
  SpRuntimeMultiSignature,
  FrameSystemEventRecord,
  SpConsensusSlotsEquivocationProof,
  SpSessionMembershipProof,
  SpConsensusBabeDigestsNextConfigDescriptor,
  PalletBalancesAdjustmentDirection,
  RococoRuntimeRuntimeParameters,
  RococoRuntimeSessionKeys,
  SpConsensusGrandpaEquivocationProof,
  PolkadotRuntimeCommonImplsVersionedLocatableAsset,
  XcmVersionedLocation,
  PalletConvictionVotingVoteAccountVote,
  PalletConvictionVotingConviction,
  RococoRuntimeOriginCaller,
  FrameSupportPreimagesBounded,
  FrameSupportScheduleDispatchTime,
  SpWeightsWeightV2Weight,
  PolkadotRuntimeCommonClaimsEcdsaSignature,
  PolkadotRuntimeCommonClaimsStatementKind,
  PalletIdentityLegacyIdentityInfo,
  PalletIdentityJudgement,
  PalletVestingVestingInfo,
  RococoRuntimeProxyType,
  PalletMultisigTimepoint,
  PolkadotPrimitivesV7AsyncBackingAsyncBackingParams,
  PolkadotPrimitivesV7ExecutorParams,
  PolkadotPrimitivesV7ApprovalVotingParams,
  PolkadotPrimitivesVstagingSchedulerParams,
  PolkadotPrimitivesV7InherentData,
  PolkadotParachainPrimitivesPrimitivesId,
  PolkadotParachainPrimitivesPrimitivesValidationCode,
  PolkadotParachainPrimitivesPrimitivesHeadData,
  PolkadotParachainPrimitivesPrimitivesValidationCodeHash,
  PolkadotPrimitivesV7PvfCheckStatement,
  PolkadotPrimitivesV7ValidatorAppSignature,
  PolkadotParachainPrimitivesPrimitivesHrmpChannelId,
  PolkadotPrimitivesV7SlashingDisputeProof,
  PolkadotRuntimeParachainsInclusionAggregateMessageOrigin,
  SpRuntimeMultiSigner,
  PalletBrokerCoretimeInterfaceCoreAssignment,
  PolkadotRuntimeParachainsAssignerCoretimePartsOf57600,
  XcmVersionedXcm,
  XcmVersionedAssets,
  StagingXcmV4Location,
  XcmV3WeightLimit,
  StagingXcmExecutorAssetTransferTransferType,
  XcmVersionedAssetId,
  SpConsensusBeefyDoubleVotingProof,
  PolkadotRuntimeParachainsParasParaGenesisArgs,
  PolkadotRuntimeCommonAssignedSlotsSlotLeasePeriodStart,
  PalletStateTrieMigrationMigrationLimits,
  PalletStateTrieMigrationMigrationTask,
  PalletStateTrieMigrationProgress,
} from './types';

export type ChainSubmittableExtrinsic<
  Rv extends RpcVersion,
  T extends IRuntimeTxCall = RococoRuntimeRuntimeCallLike,
> = Extrinsic<MultiAddressLike, T, SpRuntimeMultiSignature, any[]> &
  (Rv extends RpcV2
    ? ISubmittableExtrinsic<ISubmittableResult<FrameSystemEventRecord, TxStatus>>
    : ISubmittableExtrinsicLegacy<ISubmittableResult<FrameSystemEventRecord, TxStatus>>);

export type TxCall<Rv extends RpcVersion> = (...args: any[]) => ChainSubmittableExtrinsic<Rv>;

export interface ChainTx<Rv extends RpcVersion> extends GenericChainTx<Rv, TxCall<Rv>> {
  /**
   * Pallet `System`'s transaction calls
   **/
  system: {
    /**
     * Make some on-chain remark.
     *
     * Can be executed by every `origin`.
     *
     * @param {BytesLike} remark
     **/
    remark: GenericTxCall<
      Rv,
      (remark: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'Remark';
            params: { remark: BytesLike };
          };
        }
      >
    >;

    /**
     * Set the number of pages in the WebAssembly environment's heap.
     *
     * @param {bigint} pages
     **/
    setHeapPages: GenericTxCall<
      Rv,
      (pages: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'SetHeapPages';
            params: { pages: bigint };
          };
        }
      >
    >;

    /**
     * Set the new runtime code.
     *
     * @param {BytesLike} code
     **/
    setCode: GenericTxCall<
      Rv,
      (code: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'SetCode';
            params: { code: BytesLike };
          };
        }
      >
    >;

    /**
     * Set the new runtime code without doing any checks of the given `code`.
     *
     * Note that runtime upgrades will not run if this is called with a not-increasing spec
     * version!
     *
     * @param {BytesLike} code
     **/
    setCodeWithoutChecks: GenericTxCall<
      Rv,
      (code: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'SetCodeWithoutChecks';
            params: { code: BytesLike };
          };
        }
      >
    >;

    /**
     * Set some items of storage.
     *
     * @param {Array<[BytesLike, BytesLike]>} items
     **/
    setStorage: GenericTxCall<
      Rv,
      (items: Array<[BytesLike, BytesLike]>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'SetStorage';
            params: { items: Array<[BytesLike, BytesLike]> };
          };
        }
      >
    >;

    /**
     * Kill some items from storage.
     *
     * @param {Array<BytesLike>} keys
     **/
    killStorage: GenericTxCall<
      Rv,
      (keys: Array<BytesLike>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'KillStorage';
            params: { keys: Array<BytesLike> };
          };
        }
      >
    >;

    /**
     * Kill all storage items with a key that starts with the given prefix.
     *
     * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
     * the prefix we are removing to accurately calculate the weight of this function.
     *
     * @param {BytesLike} prefix
     * @param {number} subkeys
     **/
    killPrefix: GenericTxCall<
      Rv,
      (
        prefix: BytesLike,
        subkeys: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'KillPrefix';
            params: { prefix: BytesLike; subkeys: number };
          };
        }
      >
    >;

    /**
     * Make some on-chain remark and emit event.
     *
     * @param {BytesLike} remark
     **/
    remarkWithEvent: GenericTxCall<
      Rv,
      (remark: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'RemarkWithEvent';
            params: { remark: BytesLike };
          };
        }
      >
    >;

    /**
     * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
     * later.
     *
     * This call requires Root origin.
     *
     * @param {H256} codeHash
     **/
    authorizeUpgrade: GenericTxCall<
      Rv,
      (codeHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'AuthorizeUpgrade';
            params: { codeHash: H256 };
          };
        }
      >
    >;

    /**
     * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
     * later.
     *
     * WARNING: This authorizes an upgrade that will take place without any safety checks, for
     * example that the spec name remains the same and that the version number increases. Not
     * recommended for normal use. Use `authorize_upgrade` instead.
     *
     * This call requires Root origin.
     *
     * @param {H256} codeHash
     **/
    authorizeUpgradeWithoutChecks: GenericTxCall<
      Rv,
      (codeHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'AuthorizeUpgradeWithoutChecks';
            params: { codeHash: H256 };
          };
        }
      >
    >;

    /**
     * Provide the preimage (runtime binary) `code` for an upgrade that has been authorized.
     *
     * If the authorization required a version check, this call will ensure the spec name
     * remains unchanged and that the spec version has increased.
     *
     * Depending on the runtime's `OnSetCode` configuration, this function may directly apply
     * the new `code` in the same block or attempt to schedule the upgrade.
     *
     * All origins are allowed.
     *
     * @param {BytesLike} code
     **/
    applyAuthorizedUpgrade: GenericTxCall<
      Rv,
      (code: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'ApplyAuthorizedUpgrade';
            params: { code: BytesLike };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Babe`'s transaction calls
   **/
  babe: {
    /**
     * Report authority equivocation/misbehavior. This method will verify
     * the equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence will
     * be reported.
     *
     * @param {SpConsensusSlotsEquivocationProof} equivocationProof
     * @param {SpSessionMembershipProof} keyOwnerProof
     **/
    reportEquivocation: GenericTxCall<
      Rv,
      (
        equivocationProof: SpConsensusSlotsEquivocationProof,
        keyOwnerProof: SpSessionMembershipProof,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Babe';
          palletCall: {
            name: 'ReportEquivocation';
            params: { equivocationProof: SpConsensusSlotsEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
          };
        }
      >
    >;

    /**
     * Report authority equivocation/misbehavior. This method will verify
     * the equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence will
     * be reported.
     * This extrinsic must be called unsigned and it is expected that only
     * block authors will call it (validated in `ValidateUnsigned`), as such
     * if the block author is defined it will be defined as the equivocation
     * reporter.
     *
     * @param {SpConsensusSlotsEquivocationProof} equivocationProof
     * @param {SpSessionMembershipProof} keyOwnerProof
     **/
    reportEquivocationUnsigned: GenericTxCall<
      Rv,
      (
        equivocationProof: SpConsensusSlotsEquivocationProof,
        keyOwnerProof: SpSessionMembershipProof,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Babe';
          palletCall: {
            name: 'ReportEquivocationUnsigned';
            params: { equivocationProof: SpConsensusSlotsEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
          };
        }
      >
    >;

    /**
     * Plan an epoch config change. The epoch config change is recorded and will be enacted on
     * the next call to `enact_epoch_change`. The config will be activated one epoch after.
     * Multiple calls to this method will replace any existing planned config change that had
     * not been enacted yet.
     *
     * @param {SpConsensusBabeDigestsNextConfigDescriptor} config
     **/
    planConfigChange: GenericTxCall<
      Rv,
      (config: SpConsensusBabeDigestsNextConfigDescriptor) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Babe';
          palletCall: {
            name: 'PlanConfigChange';
            params: { config: SpConsensusBabeDigestsNextConfigDescriptor };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Timestamp`'s transaction calls
   **/
  timestamp: {
    /**
     * Set the current time.
     *
     * This call should be invoked exactly once per block. It will panic at the finalization
     * phase, if this call hasn't been invoked by that time.
     *
     * The timestamp should be greater than the previous one by the amount specified by
     * [`Config::MinimumPeriod`].
     *
     * The dispatch origin for this call must be _None_.
     *
     * This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware
     * that changing the complexity of this call could result exhausting the resources in a
     * block to execute any other calls.
     *
     * ## Complexity
     * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
     * - 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in
     * `on_finalize`)
     * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
     *
     * @param {bigint} now
     **/
    set: GenericTxCall<
      Rv,
      (now: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Timestamp';
          palletCall: {
            name: 'Set';
            params: { now: bigint };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Indices`'s transaction calls
   **/
  indices: {
    /**
     * Assign an previously unassigned index.
     *
     * Payment: `Deposit` is reserved from the sender account.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `index`: the index to be claimed. This must not be in use.
     *
     * Emits `IndexAssigned` if successful.
     *
     * ## Complexity
     * - `O(1)`.
     *
     * @param {number} index
     **/
    claim: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Indices';
          palletCall: {
            name: 'Claim';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Assign an index already owned by the sender to another account. The balance reservation
     * is effectively transferred to the new account.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `index`: the index to be re-assigned. This must be owned by the sender.
     * - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
     *
     * Emits `IndexAssigned` if successful.
     *
     * ## Complexity
     * - `O(1)`.
     *
     * @param {MultiAddressLike} new_
     * @param {number} index
     **/
    transfer: GenericTxCall<
      Rv,
      (
        new_: MultiAddressLike,
        index: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Indices';
          palletCall: {
            name: 'Transfer';
            params: { new: MultiAddressLike; index: number };
          };
        }
      >
    >;

    /**
     * Free up an index owned by the sender.
     *
     * Payment: Any previous deposit placed for the index is unreserved in the sender account.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must own the index.
     *
     * - `index`: the index to be freed. This must be owned by the sender.
     *
     * Emits `IndexFreed` if successful.
     *
     * ## Complexity
     * - `O(1)`.
     *
     * @param {number} index
     **/
    free: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Indices';
          palletCall: {
            name: 'Free';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Force an index to an account. This doesn't require a deposit. If the index is already
     * held, then any deposit is reimbursed to its current owner.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * - `index`: the index to be (re-)assigned.
     * - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
     * - `freeze`: if set to `true`, will freeze the index so it cannot be transferred.
     *
     * Emits `IndexAssigned` if successful.
     *
     * ## Complexity
     * - `O(1)`.
     *
     * @param {MultiAddressLike} new_
     * @param {number} index
     * @param {boolean} freeze
     **/
    forceTransfer: GenericTxCall<
      Rv,
      (
        new_: MultiAddressLike,
        index: number,
        freeze: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Indices';
          palletCall: {
            name: 'ForceTransfer';
            params: { new: MultiAddressLike; index: number; freeze: boolean };
          };
        }
      >
    >;

    /**
     * Freeze an index so it will always point to the sender account. This consumes the
     * deposit.
     *
     * The dispatch origin for this call must be _Signed_ and the signing account must have a
     * non-frozen account `index`.
     *
     * - `index`: the index to be frozen in place.
     *
     * Emits `IndexFrozen` if successful.
     *
     * ## Complexity
     * - `O(1)`.
     *
     * @param {number} index
     **/
    freeze: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Indices';
          palletCall: {
            name: 'Freeze';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Balances`'s transaction calls
   **/
  balances: {
    /**
     * Transfer some liquid free balance to another account.
     *
     * `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
     * If the sender's account is below the existential deposit as a result
     * of the transfer, the account will be reaped.
     *
     * The dispatch origin for this call must be `Signed` by the transactor.
     *
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     **/
    transferAllowDeath: GenericTxCall<
      Rv,
      (
        dest: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'TransferAllowDeath';
            params: { dest: MultiAddressLike; value: bigint };
          };
        }
      >
    >;

    /**
     * Exactly as `transfer_allow_death`, except the origin must be root and the source account
     * may be specified.
     *
     * @param {MultiAddressLike} source
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     **/
    forceTransfer: GenericTxCall<
      Rv,
      (
        source: MultiAddressLike,
        dest: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'ForceTransfer';
            params: { source: MultiAddressLike; dest: MultiAddressLike; value: bigint };
          };
        }
      >
    >;

    /**
     * Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
     * kill the origin account.
     *
     * 99% of the time you want [`transfer_allow_death`] instead.
     *
     * [`transfer_allow_death`]: struct.Pallet.html#method.transfer
     *
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     **/
    transferKeepAlive: GenericTxCall<
      Rv,
      (
        dest: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'TransferKeepAlive';
            params: { dest: MultiAddressLike; value: bigint };
          };
        }
      >
    >;

    /**
     * Transfer the entire transferable balance from the caller account.
     *
     * NOTE: This function only attempts to transfer _transferable_ balances. This means that
     * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
     * transferred by this function. To ensure that this function results in a killed account,
     * you might need to prepare the account by removing any reference counters, storage
     * deposits, etc...
     *
     * The dispatch origin of this call must be Signed.
     *
     * - `dest`: The recipient of the transfer.
     * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
     * of the funds the account has, causing the sender account to be killed (false), or
     * transfer everything except at least the existential deposit, which will guarantee to
     * keep the sender account alive (true).
     *
     * @param {MultiAddressLike} dest
     * @param {boolean} keepAlive
     **/
    transferAll: GenericTxCall<
      Rv,
      (
        dest: MultiAddressLike,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'TransferAll';
            params: { dest: MultiAddressLike; keepAlive: boolean };
          };
        }
      >
    >;

    /**
     * Unreserve some balance from a user by force.
     *
     * Can only be called by ROOT.
     *
     * @param {MultiAddressLike} who
     * @param {bigint} amount
     **/
    forceUnreserve: GenericTxCall<
      Rv,
      (
        who: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'ForceUnreserve';
            params: { who: MultiAddressLike; amount: bigint };
          };
        }
      >
    >;

    /**
     * Upgrade a specified account.
     *
     * - `origin`: Must be `Signed`.
     * - `who`: The account to be upgraded.
     *
     * This will waive the transaction fee if at least all but 10% of the accounts needed to
     * be upgraded. (We let some not have to be upgraded just in order to allow for the
     * possibility of churn).
     *
     * @param {Array<AccountId32Like>} who
     **/
    upgradeAccounts: GenericTxCall<
      Rv,
      (who: Array<AccountId32Like>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'UpgradeAccounts';
            params: { who: Array<AccountId32Like> };
          };
        }
      >
    >;

    /**
     * Set the regular balance of a given account.
     *
     * The dispatch origin for this call is `root`.
     *
     * @param {MultiAddressLike} who
     * @param {bigint} newFree
     **/
    forceSetBalance: GenericTxCall<
      Rv,
      (
        who: MultiAddressLike,
        newFree: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'ForceSetBalance';
            params: { who: MultiAddressLike; newFree: bigint };
          };
        }
      >
    >;

    /**
     * Adjust the total issuance in a saturating way.
     *
     * Can only be called by root and always needs a positive `delta`.
     *
     * # Example
     *
     * @param {PalletBalancesAdjustmentDirection} direction
     * @param {bigint} delta
     **/
    forceAdjustTotalIssuance: GenericTxCall<
      Rv,
      (
        direction: PalletBalancesAdjustmentDirection,
        delta: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'ForceAdjustTotalIssuance';
            params: { direction: PalletBalancesAdjustmentDirection; delta: bigint };
          };
        }
      >
    >;

    /**
     * Burn the specified liquid free balance from the origin account.
     *
     * If the origin's account ends up below the existential deposit as a result
     * of the burn and `keep_alive` is false, the account will be reaped.
     *
     * Unlike sending funds to a _burn_ address, which merely makes the funds inaccessible,
     * this `burn` operation will reduce total issuance by the amount _burned_.
     *
     * @param {bigint} value
     * @param {boolean} keepAlive
     **/
    burn: GenericTxCall<
      Rv,
      (
        value: bigint,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'Burn';
            params: { value: bigint; keepAlive: boolean };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Parameters`'s transaction calls
   **/
  parameters: {
    /**
     * Set the value of a parameter.
     *
     * The dispatch origin of this call must be `AdminOrigin` for the given `key`. Values be
     * deleted by setting them to `None`.
     *
     * @param {RococoRuntimeRuntimeParameters} keyValue
     **/
    setParameter: GenericTxCall<
      Rv,
      (keyValue: RococoRuntimeRuntimeParameters) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Parameters';
          palletCall: {
            name: 'SetParameter';
            params: { keyValue: RococoRuntimeRuntimeParameters };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Session`'s transaction calls
   **/
  session: {
    /**
     * Sets the session key(s) of the function caller to `keys`.
     * Allows an account to set its session key prior to becoming a validator.
     * This doesn't take effect until the next session.
     *
     * The dispatch origin of this function must be signed.
     *
     * ## Complexity
     * - `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is
     * fixed.
     *
     * @param {RococoRuntimeSessionKeys} keys
     * @param {BytesLike} proof
     **/
    setKeys: GenericTxCall<
      Rv,
      (
        keys: RococoRuntimeSessionKeys,
        proof: BytesLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Session';
          palletCall: {
            name: 'SetKeys';
            params: { keys: RococoRuntimeSessionKeys; proof: BytesLike };
          };
        }
      >
    >;

    /**
     * Removes any session key(s) of the function caller.
     *
     * This doesn't take effect until the next session.
     *
     * The dispatch origin of this function must be Signed and the account must be either be
     * convertible to a validator ID using the chain's typical addressing system (this usually
     * means being a controller account) or directly convertible into a validator ID (which
     * usually means being a stash account).
     *
     * ## Complexity
     * - `O(1)` in number of key types. Actual cost depends on the number of length of
     * `T::Keys::key_ids()` which is fixed.
     *
     **/
    purgeKeys: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Session';
          palletCall: {
            name: 'PurgeKeys';
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Grandpa`'s transaction calls
   **/
  grandpa: {
    /**
     * Report voter equivocation/misbehavior. This method will verify the
     * equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence
     * will be reported.
     *
     * @param {SpConsensusGrandpaEquivocationProof} equivocationProof
     * @param {SpSessionMembershipProof} keyOwnerProof
     **/
    reportEquivocation: GenericTxCall<
      Rv,
      (
        equivocationProof: SpConsensusGrandpaEquivocationProof,
        keyOwnerProof: SpSessionMembershipProof,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Grandpa';
          palletCall: {
            name: 'ReportEquivocation';
            params: { equivocationProof: SpConsensusGrandpaEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
          };
        }
      >
    >;

    /**
     * Report voter equivocation/misbehavior. This method will verify the
     * equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence
     * will be reported.
     *
     * This extrinsic must be called unsigned and it is expected that only
     * block authors will call it (validated in `ValidateUnsigned`), as such
     * if the block author is defined it will be defined as the equivocation
     * reporter.
     *
     * @param {SpConsensusGrandpaEquivocationProof} equivocationProof
     * @param {SpSessionMembershipProof} keyOwnerProof
     **/
    reportEquivocationUnsigned: GenericTxCall<
      Rv,
      (
        equivocationProof: SpConsensusGrandpaEquivocationProof,
        keyOwnerProof: SpSessionMembershipProof,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Grandpa';
          palletCall: {
            name: 'ReportEquivocationUnsigned';
            params: { equivocationProof: SpConsensusGrandpaEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
          };
        }
      >
    >;

    /**
     * Note that the current authority set of the GRANDPA finality gadget has stalled.
     *
     * This will trigger a forced authority set change at the beginning of the next session, to
     * be enacted `delay` blocks after that. The `delay` should be high enough to safely assume
     * that the block signalling the forced change will not be re-orged e.g. 1000 blocks.
     * The block production rate (which may be slowed down because of finality lagging) should
     * be taken into account when choosing the `delay`. The GRANDPA voters based on the new
     * authority will start voting on top of `best_finalized_block_number` for new finalized
     * blocks. `best_finalized_block_number` should be the highest of the latest finalized
     * block of all validators of the new authority set.
     *
     * Only callable by root.
     *
     * @param {number} delay
     * @param {number} bestFinalizedBlockNumber
     **/
    noteStalled: GenericTxCall<
      Rv,
      (
        delay: number,
        bestFinalizedBlockNumber: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Grandpa';
          palletCall: {
            name: 'NoteStalled';
            params: { delay: number; bestFinalizedBlockNumber: number };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Treasury`'s transaction calls
   **/
  treasury: {
    /**
     * Propose and approve a spend of treasury funds.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::SpendOrigin`] with the `Success` value being at least `amount`.
     *
     * ### Details
     * NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
     * beneficiary.
     *
     * ### Parameters
     * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
     * - `beneficiary`: The destination account for the transfer.
     *
     * ## Events
     *
     * Emits [`Event::SpendApproved`] if successful.
     *
     * @param {bigint} amount
     * @param {MultiAddressLike} beneficiary
     **/
    spendLocal: GenericTxCall<
      Rv,
      (
        amount: bigint,
        beneficiary: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Treasury';
          palletCall: {
            name: 'SpendLocal';
            params: { amount: bigint; beneficiary: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Force a previously approved proposal to be removed from the approval queue.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::RejectOrigin`].
     *
     * ## Details
     *
     * The original deposit will no longer be returned.
     *
     * ### Parameters
     * - `proposal_id`: The index of a proposal
     *
     * ### Complexity
     * - O(A) where `A` is the number of approvals
     *
     * ### Errors
     * - [`Error::ProposalNotApproved`]: The `proposal_id` supplied was not found in the
     * approval queue, i.e., the proposal has not been approved. This could also mean the
     * proposal does not exist altogether, thus there is no way it would have been approved
     * in the first place.
     *
     * @param {number} proposalId
     **/
    removeApproval: GenericTxCall<
      Rv,
      (proposalId: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Treasury';
          palletCall: {
            name: 'RemoveApproval';
            params: { proposalId: number };
          };
        }
      >
    >;

    /**
     * Propose and approve a spend of treasury funds.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::SpendOrigin`] with the `Success` value being at least
     * `amount` of `asset_kind` in the native asset. The amount of `asset_kind` is converted
     * for assertion using the [`Config::BalanceConverter`].
     *
     * ## Details
     *
     * Create an approved spend for transferring a specific `amount` of `asset_kind` to a
     * designated beneficiary. The spend must be claimed using the `payout` dispatchable within
     * the [`Config::PayoutPeriod`].
     *
     * ### Parameters
     * - `asset_kind`: An indicator of the specific asset class to be spent.
     * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
     * - `beneficiary`: The beneficiary of the spend.
     * - `valid_from`: The block number from which the spend can be claimed. It can refer to
     * the past if the resulting spend has not yet expired according to the
     * [`Config::PayoutPeriod`]. If `None`, the spend can be claimed immediately after
     * approval.
     *
     * ## Events
     *
     * Emits [`Event::AssetSpendApproved`] if successful.
     *
     * @param {PolkadotRuntimeCommonImplsVersionedLocatableAsset} assetKind
     * @param {bigint} amount
     * @param {XcmVersionedLocation} beneficiary
     * @param {number | undefined} validFrom
     **/
    spend: GenericTxCall<
      Rv,
      (
        assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset,
        amount: bigint,
        beneficiary: XcmVersionedLocation,
        validFrom: number | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Treasury';
          palletCall: {
            name: 'Spend';
            params: {
              assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset;
              amount: bigint;
              beneficiary: XcmVersionedLocation;
              validFrom: number | undefined;
            };
          };
        }
      >
    >;

    /**
     * Claim a spend.
     *
     * ## Dispatch Origin
     *
     * Must be signed
     *
     * ## Details
     *
     * Spends must be claimed within some temporal bounds. A spend may be claimed within one
     * [`Config::PayoutPeriod`] from the `valid_from` block.
     * In case of a payout failure, the spend status must be updated with the `check_status`
     * dispatchable before retrying with the current function.
     *
     * ### Parameters
     * - `index`: The spend index.
     *
     * ## Events
     *
     * Emits [`Event::Paid`] if successful.
     *
     * @param {number} index
     **/
    payout: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Treasury';
          palletCall: {
            name: 'Payout';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Check the status of the spend and remove it from the storage if processed.
     *
     * ## Dispatch Origin
     *
     * Must be signed.
     *
     * ## Details
     *
     * The status check is a prerequisite for retrying a failed payout.
     * If a spend has either succeeded or expired, it is removed from the storage by this
     * function. In such instances, transaction fees are refunded.
     *
     * ### Parameters
     * - `index`: The spend index.
     *
     * ## Events
     *
     * Emits [`Event::PaymentFailed`] if the spend payout has failed.
     * Emits [`Event::SpendProcessed`] if the spend payout has succeed.
     *
     * @param {number} index
     **/
    checkStatus: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Treasury';
          palletCall: {
            name: 'CheckStatus';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Void previously approved spend.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::RejectOrigin`].
     *
     * ## Details
     *
     * A spend void is only possible if the payout has not been attempted yet.
     *
     * ### Parameters
     * - `index`: The spend index.
     *
     * ## Events
     *
     * Emits [`Event::AssetSpendVoided`] if successful.
     *
     * @param {number} index
     **/
    voidSpend: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Treasury';
          palletCall: {
            name: 'VoidSpend';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `ConvictionVoting`'s transaction calls
   **/
  convictionVoting: {
    /**
     * Vote in a poll. If `vote.is_aye()`, the vote is to enact the proposal;
     * otherwise it is a vote to keep the status quo.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `poll_index`: The index of the poll to vote for.
     * - `vote`: The vote configuration.
     *
     * Weight: `O(R)` where R is the number of polls the voter has voted on.
     *
     * @param {number} pollIndex
     * @param {PalletConvictionVotingVoteAccountVote} vote
     **/
    vote: GenericTxCall<
      Rv,
      (
        pollIndex: number,
        vote: PalletConvictionVotingVoteAccountVote,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ConvictionVoting';
          palletCall: {
            name: 'Vote';
            params: { pollIndex: number; vote: PalletConvictionVotingVoteAccountVote };
          };
        }
      >
    >;

    /**
     * Delegate the voting power (with some given conviction) of the sending account for a
     * particular class of polls.
     *
     * The balance delegated is locked for as long as it's delegated, and thereafter for the
     * time appropriate for the conviction's lock period.
     *
     * The dispatch origin of this call must be _Signed_, and the signing account must either:
     * - be delegating already; or
     * - have no voting activity (if there is, then it will need to be removed through
     * `remove_vote`).
     *
     * - `to`: The account whose voting the `target` account's voting power will follow.
     * - `class`: The class of polls to delegate. To delegate multiple classes, multiple calls
     * to this function are required.
     * - `conviction`: The conviction that will be attached to the delegated votes. When the
     * account is undelegated, the funds will be locked for the corresponding period.
     * - `balance`: The amount of the account's balance to be used in delegating. This must not
     * be more than the account's current balance.
     *
     * Emits `Delegated`.
     *
     * Weight: `O(R)` where R is the number of polls the voter delegating to has
     * voted on. Weight is initially charged as if maximum votes, but is refunded later.
     *
     * @param {number} class_
     * @param {MultiAddressLike} to
     * @param {PalletConvictionVotingConviction} conviction
     * @param {bigint} balance
     **/
    delegate: GenericTxCall<
      Rv,
      (
        class_: number,
        to: MultiAddressLike,
        conviction: PalletConvictionVotingConviction,
        balance: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ConvictionVoting';
          palletCall: {
            name: 'Delegate';
            params: {
              class: number;
              to: MultiAddressLike;
              conviction: PalletConvictionVotingConviction;
              balance: bigint;
            };
          };
        }
      >
    >;

    /**
     * Undelegate the voting power of the sending account for a particular class of polls.
     *
     * Tokens may be unlocked following once an amount of time consistent with the lock period
     * of the conviction with which the delegation was issued has passed.
     *
     * The dispatch origin of this call must be _Signed_ and the signing account must be
     * currently delegating.
     *
     * - `class`: The class of polls to remove the delegation from.
     *
     * Emits `Undelegated`.
     *
     * Weight: `O(R)` where R is the number of polls the voter delegating to has
     * voted on. Weight is initially charged as if maximum votes, but is refunded later.
     *
     * @param {number} class_
     **/
    undelegate: GenericTxCall<
      Rv,
      (class_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ConvictionVoting';
          palletCall: {
            name: 'Undelegate';
            params: { class: number };
          };
        }
      >
    >;

    /**
     * Remove the lock caused by prior voting/delegating which has expired within a particular
     * class.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `class`: The class of polls to unlock.
     * - `target`: The account to remove the lock on.
     *
     * Weight: `O(R)` with R number of vote of target.
     *
     * @param {number} class_
     * @param {MultiAddressLike} target
     **/
    unlock: GenericTxCall<
      Rv,
      (
        class_: number,
        target: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ConvictionVoting';
          palletCall: {
            name: 'Unlock';
            params: { class: number; target: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Remove a vote for a poll.
     *
     * If:
     * - the poll was cancelled, or
     * - the poll is ongoing, or
     * - the poll has ended such that
     * - the vote of the account was in opposition to the result; or
     * - there was no conviction to the account's vote; or
     * - the account made a split vote
     * ...then the vote is removed cleanly and a following call to `unlock` may result in more
     * funds being available.
     *
     * If, however, the poll has ended and:
     * - it finished corresponding to the vote of the account, and
     * - the account made a standard vote with conviction, and
     * - the lock period of the conviction is not over
     * ...then the lock will be aggregated into the overall account's lock, which may involve
     * *overlocking* (where the two locks are combined into a single lock that is the maximum
     * of both the amount locked and the time is it locked for).
     *
     * The dispatch origin of this call must be _Signed_, and the signer must have a vote
     * registered for poll `index`.
     *
     * - `index`: The index of poll of the vote to be removed.
     * - `class`: Optional parameter, if given it indicates the class of the poll. For polls
     * which have finished or are cancelled, this must be `Some`.
     *
     * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
     * Weight is calculated for the maximum number of vote.
     *
     * @param {number | undefined} class_
     * @param {number} index
     **/
    removeVote: GenericTxCall<
      Rv,
      (
        class_: number | undefined,
        index: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ConvictionVoting';
          palletCall: {
            name: 'RemoveVote';
            params: { class: number | undefined; index: number };
          };
        }
      >
    >;

    /**
     * Remove a vote for a poll.
     *
     * If the `target` is equal to the signer, then this function is exactly equivalent to
     * `remove_vote`. If not equal to the signer, then the vote must have expired,
     * either because the poll was cancelled, because the voter lost the poll or
     * because the conviction period is over.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `target`: The account of the vote to be removed; this account must have voted for poll
     * `index`.
     * - `index`: The index of poll of the vote to be removed.
     * - `class`: The class of the poll.
     *
     * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
     * Weight is calculated for the maximum number of vote.
     *
     * @param {MultiAddressLike} target
     * @param {number} class_
     * @param {number} index
     **/
    removeOtherVote: GenericTxCall<
      Rv,
      (
        target: MultiAddressLike,
        class_: number,
        index: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ConvictionVoting';
          palletCall: {
            name: 'RemoveOtherVote';
            params: { target: MultiAddressLike; class: number; index: number };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Referenda`'s transaction calls
   **/
  referenda: {
    /**
     * Propose a referendum on a privileged action.
     *
     * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
     * available.
     * - `proposal_origin`: The origin from which the proposal should be executed.
     * - `proposal`: The proposal.
     * - `enactment_moment`: The moment that the proposal should be enacted.
     *
     * Emits `Submitted`.
     *
     * @param {RococoRuntimeOriginCaller} proposalOrigin
     * @param {FrameSupportPreimagesBounded} proposal
     * @param {FrameSupportScheduleDispatchTime} enactmentMoment
     **/
    submit: GenericTxCall<
      Rv,
      (
        proposalOrigin: RococoRuntimeOriginCaller,
        proposal: FrameSupportPreimagesBounded,
        enactmentMoment: FrameSupportScheduleDispatchTime,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'Submit';
            params: {
              proposalOrigin: RococoRuntimeOriginCaller;
              proposal: FrameSupportPreimagesBounded;
              enactmentMoment: FrameSupportScheduleDispatchTime;
            };
          };
        }
      >
    >;

    /**
     * Post the Decision Deposit for a referendum.
     *
     * - `origin`: must be `Signed` and the account must have funds available for the
     * referendum's track's Decision Deposit.
     * - `index`: The index of the submitted referendum whose Decision Deposit is yet to be
     * posted.
     *
     * Emits `DecisionDepositPlaced`.
     *
     * @param {number} index
     **/
    placeDecisionDeposit: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'PlaceDecisionDeposit';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Refund the Decision Deposit for a closed referendum back to the depositor.
     *
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Decision Deposit has not yet been
     * refunded.
     *
     * Emits `DecisionDepositRefunded`.
     *
     * @param {number} index
     **/
    refundDecisionDeposit: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'RefundDecisionDeposit';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Cancel an ongoing referendum.
     *
     * - `origin`: must be the `CancelOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     *
     * Emits `Cancelled`.
     *
     * @param {number} index
     **/
    cancel: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'Cancel';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Cancel an ongoing referendum and slash the deposits.
     *
     * - `origin`: must be the `KillOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     *
     * Emits `Killed` and `DepositSlashed`.
     *
     * @param {number} index
     **/
    kill: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'Kill';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Advance a referendum onto its next logical state. Only used internally.
     *
     * - `origin`: must be `Root`.
     * - `index`: the referendum to be advanced.
     *
     * @param {number} index
     **/
    nudgeReferendum: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'NudgeReferendum';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Advance a track onto its next logical state. Only used internally.
     *
     * - `origin`: must be `Root`.
     * - `track`: the track to be advanced.
     *
     * Action item for when there is now one fewer referendum in the deciding phase and the
     * `DecidingCount` is not yet updated. This means that we should either:
     * - begin deciding another referendum (and leave `DecidingCount` alone); or
     * - decrement `DecidingCount`.
     *
     * @param {number} track
     **/
    oneFewerDeciding: GenericTxCall<
      Rv,
      (track: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'OneFewerDeciding';
            params: { track: number };
          };
        }
      >
    >;

    /**
     * Refund the Submission Deposit for a closed referendum back to the depositor.
     *
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Submission Deposit has not yet been
     * refunded.
     *
     * Emits `SubmissionDepositRefunded`.
     *
     * @param {number} index
     **/
    refundSubmissionDeposit: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'RefundSubmissionDeposit';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Set or clear metadata of a referendum.
     *
     * Parameters:
     * - `origin`: Must be `Signed` by a creator of a referendum or by anyone to clear a
     * metadata of a finished referendum.
     * - `index`: The index of a referendum to set or clear metadata for.
     * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
     *
     * @param {number} index
     * @param {H256 | undefined} maybeHash
     **/
    setMetadata: GenericTxCall<
      Rv,
      (
        index: number,
        maybeHash: H256 | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'SetMetadata';
            params: { index: number; maybeHash: H256 | undefined };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `FellowshipCollective`'s transaction calls
   **/
  fellowshipCollective: {
    /**
     * Introduce a new member.
     *
     * - `origin`: Must be the `AddOrigin`.
     * - `who`: Account of non-member which will become a member.
     *
     * Weight: `O(1)`
     *
     * @param {MultiAddressLike} who
     **/
    addMember: GenericTxCall<
      Rv,
      (who: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'FellowshipCollective';
          palletCall: {
            name: 'AddMember';
            params: { who: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Increment the rank of an existing member by one.
     *
     * - `origin`: Must be the `PromoteOrigin`.
     * - `who`: Account of existing member.
     *
     * Weight: `O(1)`
     *
     * @param {MultiAddressLike} who
     **/
    promoteMember: GenericTxCall<
      Rv,
      (who: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'FellowshipCollective';
          palletCall: {
            name: 'PromoteMember';
            params: { who: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Decrement the rank of an existing member by one. If the member is already at rank zero,
     * then they are removed entirely.
     *
     * - `origin`: Must be the `DemoteOrigin`.
     * - `who`: Account of existing member of rank greater than zero.
     *
     * Weight: `O(1)`, less if the member's index is highest in its rank.
     *
     * @param {MultiAddressLike} who
     **/
    demoteMember: GenericTxCall<
      Rv,
      (who: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'FellowshipCollective';
          palletCall: {
            name: 'DemoteMember';
            params: { who: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Remove the member entirely.
     *
     * - `origin`: Must be the `RemoveOrigin`.
     * - `who`: Account of existing member of rank greater than zero.
     * - `min_rank`: The rank of the member or greater.
     *
     * Weight: `O(min_rank)`.
     *
     * @param {MultiAddressLike} who
     * @param {number} minRank
     **/
    removeMember: GenericTxCall<
      Rv,
      (
        who: MultiAddressLike,
        minRank: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'FellowshipCollective';
          palletCall: {
            name: 'RemoveMember';
            params: { who: MultiAddressLike; minRank: number };
          };
        }
      >
    >;

    /**
     * Add an aye or nay vote for the sender to the given proposal.
     *
     * - `origin`: Must be `Signed` by a member account.
     * - `poll`: Index of a poll which is ongoing.
     * - `aye`: `true` if the vote is to approve the proposal, `false` otherwise.
     *
     * Transaction fees are be waived if the member is voting on any particular proposal
     * for the first time and the call is successful. Subsequent vote changes will charge a
     * fee.
     *
     * Weight: `O(1)`, less if there was no previous vote on the poll by the member.
     *
     * @param {number} poll
     * @param {boolean} aye
     **/
    vote: GenericTxCall<
      Rv,
      (
        poll: number,
        aye: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'FellowshipCollective';
          palletCall: {
            name: 'Vote';
            params: { poll: number; aye: boolean };
          };
        }
      >
    >;

    /**
     * Remove votes from the given poll. It must have ended.
     *
     * - `origin`: Must be `Signed` by any account.
     * - `poll_index`: Index of a poll which is completed and for which votes continue to
     * exist.
     * - `max`: Maximum number of vote items from remove in this call.
     *
     * Transaction fees are waived if the operation is successful.
     *
     * Weight `O(max)` (less if there are fewer items to remove than `max`).
     *
     * @param {number} pollIndex
     * @param {number} max
     **/
    cleanupPoll: GenericTxCall<
      Rv,
      (
        pollIndex: number,
        max: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'FellowshipCollective';
          palletCall: {
            name: 'CleanupPoll';
            params: { pollIndex: number; max: number };
          };
        }
      >
    >;

    /**
     * Exchanges a member with a new account and the same existing rank.
     *
     * - `origin`: Must be the `ExchangeOrigin`.
     * - `who`: Account of existing member of rank greater than zero to be exchanged.
     * - `new_who`: New Account of existing member of rank greater than zero to exchanged to.
     *
     * @param {MultiAddressLike} who
     * @param {MultiAddressLike} newWho
     **/
    exchangeMember: GenericTxCall<
      Rv,
      (
        who: MultiAddressLike,
        newWho: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'FellowshipCollective';
          palletCall: {
            name: 'ExchangeMember';
            params: { who: MultiAddressLike; newWho: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `FellowshipReferenda`'s transaction calls
   **/
  fellowshipReferenda: {
    /**
     * Propose a referendum on a privileged action.
     *
     * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
     * available.
     * - `proposal_origin`: The origin from which the proposal should be executed.
     * - `proposal`: The proposal.
     * - `enactment_moment`: The moment that the proposal should be enacted.
     *
     * Emits `Submitted`.
     *
     * @param {RococoRuntimeOriginCaller} proposalOrigin
     * @param {FrameSupportPreimagesBounded} proposal
     * @param {FrameSupportScheduleDispatchTime} enactmentMoment
     **/
    submit: GenericTxCall<
      Rv,
      (
        proposalOrigin: RococoRuntimeOriginCaller,
        proposal: FrameSupportPreimagesBounded,
        enactmentMoment: FrameSupportScheduleDispatchTime,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'FellowshipReferenda';
          palletCall: {
            name: 'Submit';
            params: {
              proposalOrigin: RococoRuntimeOriginCaller;
              proposal: FrameSupportPreimagesBounded;
              enactmentMoment: FrameSupportScheduleDispatchTime;
            };
          };
        }
      >
    >;

    /**
     * Post the Decision Deposit for a referendum.
     *
     * - `origin`: must be `Signed` and the account must have funds available for the
     * referendum's track's Decision Deposit.
     * - `index`: The index of the submitted referendum whose Decision Deposit is yet to be
     * posted.
     *
     * Emits `DecisionDepositPlaced`.
     *
     * @param {number} index
     **/
    placeDecisionDeposit: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'FellowshipReferenda';
          palletCall: {
            name: 'PlaceDecisionDeposit';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Refund the Decision Deposit for a closed referendum back to the depositor.
     *
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Decision Deposit has not yet been
     * refunded.
     *
     * Emits `DecisionDepositRefunded`.
     *
     * @param {number} index
     **/
    refundDecisionDeposit: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'FellowshipReferenda';
          palletCall: {
            name: 'RefundDecisionDeposit';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Cancel an ongoing referendum.
     *
     * - `origin`: must be the `CancelOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     *
     * Emits `Cancelled`.
     *
     * @param {number} index
     **/
    cancel: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'FellowshipReferenda';
          palletCall: {
            name: 'Cancel';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Cancel an ongoing referendum and slash the deposits.
     *
     * - `origin`: must be the `KillOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     *
     * Emits `Killed` and `DepositSlashed`.
     *
     * @param {number} index
     **/
    kill: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'FellowshipReferenda';
          palletCall: {
            name: 'Kill';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Advance a referendum onto its next logical state. Only used internally.
     *
     * - `origin`: must be `Root`.
     * - `index`: the referendum to be advanced.
     *
     * @param {number} index
     **/
    nudgeReferendum: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'FellowshipReferenda';
          palletCall: {
            name: 'NudgeReferendum';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Advance a track onto its next logical state. Only used internally.
     *
     * - `origin`: must be `Root`.
     * - `track`: the track to be advanced.
     *
     * Action item for when there is now one fewer referendum in the deciding phase and the
     * `DecidingCount` is not yet updated. This means that we should either:
     * - begin deciding another referendum (and leave `DecidingCount` alone); or
     * - decrement `DecidingCount`.
     *
     * @param {number} track
     **/
    oneFewerDeciding: GenericTxCall<
      Rv,
      (track: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'FellowshipReferenda';
          palletCall: {
            name: 'OneFewerDeciding';
            params: { track: number };
          };
        }
      >
    >;

    /**
     * Refund the Submission Deposit for a closed referendum back to the depositor.
     *
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Submission Deposit has not yet been
     * refunded.
     *
     * Emits `SubmissionDepositRefunded`.
     *
     * @param {number} index
     **/
    refundSubmissionDeposit: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'FellowshipReferenda';
          palletCall: {
            name: 'RefundSubmissionDeposit';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Set or clear metadata of a referendum.
     *
     * Parameters:
     * - `origin`: Must be `Signed` by a creator of a referendum or by anyone to clear a
     * metadata of a finished referendum.
     * - `index`: The index of a referendum to set or clear metadata for.
     * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
     *
     * @param {number} index
     * @param {H256 | undefined} maybeHash
     **/
    setMetadata: GenericTxCall<
      Rv,
      (
        index: number,
        maybeHash: H256 | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'FellowshipReferenda';
          palletCall: {
            name: 'SetMetadata';
            params: { index: number; maybeHash: H256 | undefined };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Whitelist`'s transaction calls
   **/
  whitelist: {
    /**
     *
     * @param {H256} callHash
     **/
    whitelistCall: GenericTxCall<
      Rv,
      (callHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Whitelist';
          palletCall: {
            name: 'WhitelistCall';
            params: { callHash: H256 };
          };
        }
      >
    >;

    /**
     *
     * @param {H256} callHash
     **/
    removeWhitelistedCall: GenericTxCall<
      Rv,
      (callHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Whitelist';
          palletCall: {
            name: 'RemoveWhitelistedCall';
            params: { callHash: H256 };
          };
        }
      >
    >;

    /**
     *
     * @param {H256} callHash
     * @param {number} callEncodedLen
     * @param {SpWeightsWeightV2Weight} callWeightWitness
     **/
    dispatchWhitelistedCall: GenericTxCall<
      Rv,
      (
        callHash: H256,
        callEncodedLen: number,
        callWeightWitness: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Whitelist';
          palletCall: {
            name: 'DispatchWhitelistedCall';
            params: { callHash: H256; callEncodedLen: number; callWeightWitness: SpWeightsWeightV2Weight };
          };
        }
      >
    >;

    /**
     *
     * @param {RococoRuntimeRuntimeCallLike} call
     **/
    dispatchWhitelistedCallWithPreimage: GenericTxCall<
      Rv,
      (call: RococoRuntimeRuntimeCallLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Whitelist';
          palletCall: {
            name: 'DispatchWhitelistedCallWithPreimage';
            params: { call: RococoRuntimeRuntimeCallLike };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Claims`'s transaction calls
   **/
  claims: {
    /**
     * Make a claim to collect your DOTs.
     *
     * The dispatch origin for this call must be _None_.
     *
     * Unsigned Validation:
     * A call to claim is deemed valid if the signature provided matches
     * the expected signed message of:
     *
     * > Ethereum Signed Message:
     * > (configured prefix string)(address)
     *
     * and `address` matches the `dest` account.
     *
     * Parameters:
     * - `dest`: The destination account to payout the claim.
     * - `ethereum_signature`: The signature of an ethereum signed message matching the format
     * described above.
     *
     * <weight>
     * The weight of this call is invariant over the input parameters.
     * Weight includes logic to validate unsigned `claim` call.
     *
     * Total Complexity: O(1)
     * </weight>
     *
     * @param {AccountId32Like} dest
     * @param {PolkadotRuntimeCommonClaimsEcdsaSignature} ethereumSignature
     **/
    claim: GenericTxCall<
      Rv,
      (
        dest: AccountId32Like,
        ethereumSignature: PolkadotRuntimeCommonClaimsEcdsaSignature,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Claims';
          palletCall: {
            name: 'Claim';
            params: { dest: AccountId32Like; ethereumSignature: PolkadotRuntimeCommonClaimsEcdsaSignature };
          };
        }
      >
    >;

    /**
     * Mint a new claim to collect DOTs.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * Parameters:
     * - `who`: The Ethereum address allowed to collect this claim.
     * - `value`: The number of DOTs that will be claimed.
     * - `vesting_schedule`: An optional vesting schedule for these DOTs.
     *
     * <weight>
     * The weight of this call is invariant over the input parameters.
     * We assume worst case that both vesting and statement is being inserted.
     *
     * Total Complexity: O(1)
     * </weight>
     *
     * @param {EthereumAddressLike} who
     * @param {bigint} value
     * @param {[bigint, bigint, number] | undefined} vestingSchedule
     * @param {PolkadotRuntimeCommonClaimsStatementKind | undefined} statement
     **/
    mintClaim: GenericTxCall<
      Rv,
      (
        who: EthereumAddressLike,
        value: bigint,
        vestingSchedule: [bigint, bigint, number] | undefined,
        statement: PolkadotRuntimeCommonClaimsStatementKind | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Claims';
          palletCall: {
            name: 'MintClaim';
            params: {
              who: EthereumAddressLike;
              value: bigint;
              vestingSchedule: [bigint, bigint, number] | undefined;
              statement: PolkadotRuntimeCommonClaimsStatementKind | undefined;
            };
          };
        }
      >
    >;

    /**
     * Make a claim to collect your DOTs by signing a statement.
     *
     * The dispatch origin for this call must be _None_.
     *
     * Unsigned Validation:
     * A call to `claim_attest` is deemed valid if the signature provided matches
     * the expected signed message of:
     *
     * > Ethereum Signed Message:
     * > (configured prefix string)(address)(statement)
     *
     * and `address` matches the `dest` account; the `statement` must match that which is
     * expected according to your purchase arrangement.
     *
     * Parameters:
     * - `dest`: The destination account to payout the claim.
     * - `ethereum_signature`: The signature of an ethereum signed message matching the format
     * described above.
     * - `statement`: The identity of the statement which is being attested to in the
     * signature.
     *
     * <weight>
     * The weight of this call is invariant over the input parameters.
     * Weight includes logic to validate unsigned `claim_attest` call.
     *
     * Total Complexity: O(1)
     * </weight>
     *
     * @param {AccountId32Like} dest
     * @param {PolkadotRuntimeCommonClaimsEcdsaSignature} ethereumSignature
     * @param {BytesLike} statement
     **/
    claimAttest: GenericTxCall<
      Rv,
      (
        dest: AccountId32Like,
        ethereumSignature: PolkadotRuntimeCommonClaimsEcdsaSignature,
        statement: BytesLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Claims';
          palletCall: {
            name: 'ClaimAttest';
            params: {
              dest: AccountId32Like;
              ethereumSignature: PolkadotRuntimeCommonClaimsEcdsaSignature;
              statement: BytesLike;
            };
          };
        }
      >
    >;

    /**
     * Attest to a statement, needed to finalize the claims process.
     *
     * WARNING: Insecure unless your chain includes `PrevalidateAttests` as a
     * `SignedExtension`.
     *
     * Unsigned Validation:
     * A call to attest is deemed valid if the sender has a `Preclaim` registered
     * and provides a `statement` which is expected for the account.
     *
     * Parameters:
     * - `statement`: The identity of the statement which is being attested to in the
     * signature.
     *
     * <weight>
     * The weight of this call is invariant over the input parameters.
     * Weight includes logic to do pre-validation on `attest` call.
     *
     * Total Complexity: O(1)
     * </weight>
     *
     * @param {BytesLike} statement
     **/
    attest: GenericTxCall<
      Rv,
      (statement: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Claims';
          palletCall: {
            name: 'Attest';
            params: { statement: BytesLike };
          };
        }
      >
    >;

    /**
     *
     * @param {EthereumAddressLike} old
     * @param {EthereumAddressLike} new_
     * @param {AccountId32Like | undefined} maybePreclaim
     **/
    moveClaim: GenericTxCall<
      Rv,
      (
        old: EthereumAddressLike,
        new_: EthereumAddressLike,
        maybePreclaim: AccountId32Like | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Claims';
          palletCall: {
            name: 'MoveClaim';
            params: { old: EthereumAddressLike; new: EthereumAddressLike; maybePreclaim: AccountId32Like | undefined };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Utility`'s transaction calls
   **/
  utility: {
    /**
     * Send a batch of dispatch calls.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     *
     * @param {Array<RococoRuntimeRuntimeCallLike>} calls
     **/
    batch: GenericTxCall<
      Rv,
      (calls: Array<RococoRuntimeRuntimeCallLike>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'Batch';
            params: { calls: Array<RococoRuntimeRuntimeCallLike> };
          };
        }
      >
    >;

    /**
     * Send a call through an indexed pseudonym of the sender.
     *
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     *
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     *
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * @param {number} index
     * @param {RococoRuntimeRuntimeCallLike} call
     **/
    asDerivative: GenericTxCall<
      Rv,
      (
        index: number,
        call: RococoRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'AsDerivative';
            params: { index: number; call: RococoRuntimeRuntimeCallLike };
          };
        }
      >
    >;

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * @param {Array<RococoRuntimeRuntimeCallLike>} calls
     **/
    batchAll: GenericTxCall<
      Rv,
      (calls: Array<RococoRuntimeRuntimeCallLike>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'BatchAll';
            params: { calls: Array<RococoRuntimeRuntimeCallLike> };
          };
        }
      >
    >;

    /**
     * Dispatches a function call with a provided origin.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {RococoRuntimeOriginCaller} asOrigin
     * @param {RococoRuntimeRuntimeCallLike} call
     **/
    dispatchAs: GenericTxCall<
      Rv,
      (
        asOrigin: RococoRuntimeOriginCaller,
        call: RococoRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'DispatchAs';
            params: { asOrigin: RococoRuntimeOriginCaller; call: RococoRuntimeRuntimeCallLike };
          };
        }
      >
    >;

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * @param {Array<RococoRuntimeRuntimeCallLike>} calls
     **/
    forceBatch: GenericTxCall<
      Rv,
      (calls: Array<RococoRuntimeRuntimeCallLike>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'ForceBatch';
            params: { calls: Array<RococoRuntimeRuntimeCallLike> };
          };
        }
      >
    >;

    /**
     * Dispatch a function call with a specified weight.
     *
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * @param {RococoRuntimeRuntimeCallLike} call
     * @param {SpWeightsWeightV2Weight} weight
     **/
    withWeight: GenericTxCall<
      Rv,
      (
        call: RococoRuntimeRuntimeCallLike,
        weight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'WithWeight';
            params: { call: RococoRuntimeRuntimeCallLike; weight: SpWeightsWeightV2Weight };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Identity`'s transaction calls
   **/
  identity: {
    /**
     * Add a registrar to the system.
     *
     * The dispatch origin for this call must be `T::RegistrarOrigin`.
     *
     * - `account`: the account of the registrar.
     *
     * Emits `RegistrarAdded` if successful.
     *
     * @param {MultiAddressLike} account
     **/
    addRegistrar: GenericTxCall<
      Rv,
      (account: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'AddRegistrar';
            params: { account: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Set an account's identity information and reserve the appropriate deposit.
     *
     * If the account already has identity information, the deposit is taken as part payment
     * for the new deposit.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `info`: The identity information.
     *
     * Emits `IdentitySet` if successful.
     *
     * @param {PalletIdentityLegacyIdentityInfo} info
     **/
    setIdentity: GenericTxCall<
      Rv,
      (info: PalletIdentityLegacyIdentityInfo) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetIdentity';
            params: { info: PalletIdentityLegacyIdentityInfo };
          };
        }
      >
    >;

    /**
     * Set the sub-accounts of the sender.
     *
     * Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
     * and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * identity.
     *
     * - `subs`: The identity's (new) sub-accounts.
     *
     * @param {Array<[AccountId32Like, Data]>} subs
     **/
    setSubs: GenericTxCall<
      Rv,
      (subs: Array<[AccountId32Like, Data]>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetSubs';
            params: { subs: Array<[AccountId32Like, Data]> };
          };
        }
      >
    >;

    /**
     * Clear an account's identity info and all sub-accounts and return all deposits.
     *
     * Payment: All reserved balances on the account are returned.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * identity.
     *
     * Emits `IdentityCleared` if successful.
     *
     **/
    clearIdentity: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'ClearIdentity';
          };
        }
      >
    >;

    /**
     * Request a judgement from a registrar.
     *
     * Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
     * given.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a
     * registered identity.
     *
     * - `reg_index`: The index of the registrar whose judgement is requested.
     * - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
     *
     * ```nocompile
     * Self::registrars().get(reg_index).unwrap().fee
     * ```
     *
     * Emits `JudgementRequested` if successful.
     *
     * @param {number} regIndex
     * @param {bigint} maxFee
     **/
    requestJudgement: GenericTxCall<
      Rv,
      (
        regIndex: number,
        maxFee: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RequestJudgement';
            params: { regIndex: number; maxFee: bigint };
          };
        }
      >
    >;

    /**
     * Cancel a previous request.
     *
     * Payment: A previously reserved deposit is returned on success.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a
     * registered identity.
     *
     * - `reg_index`: The index of the registrar whose judgement is no longer requested.
     *
     * Emits `JudgementUnrequested` if successful.
     *
     * @param {number} regIndex
     **/
    cancelRequest: GenericTxCall<
      Rv,
      (regIndex: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'CancelRequest';
            params: { regIndex: number };
          };
        }
      >
    >;

    /**
     * Set the fee required for a judgement to be requested from a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `fee`: the new fee.
     *
     * @param {number} index
     * @param {bigint} fee
     **/
    setFee: GenericTxCall<
      Rv,
      (
        index: number,
        fee: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetFee';
            params: { index: number; fee: bigint };
          };
        }
      >
    >;

    /**
     * Change the account associated with a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `new`: the new account ID.
     *
     * @param {number} index
     * @param {MultiAddressLike} new_
     **/
    setAccountId: GenericTxCall<
      Rv,
      (
        index: number,
        new_: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetAccountId';
            params: { index: number; new: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Set the field information for a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `fields`: the fields that the registrar concerns themselves with.
     *
     * @param {number} index
     * @param {bigint} fields
     **/
    setFields: GenericTxCall<
      Rv,
      (
        index: number,
        fields: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetFields';
            params: { index: number; fields: bigint };
          };
        }
      >
    >;

    /**
     * Provide a judgement for an account's identity.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `reg_index`.
     *
     * - `reg_index`: the index of the registrar whose judgement is being made.
     * - `target`: the account whose identity the judgement is upon. This must be an account
     * with a registered identity.
     * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
     * - `identity`: The hash of the [`IdentityInformationProvider`] for that the judgement is
     * provided.
     *
     * Note: Judgements do not apply to a username.
     *
     * Emits `JudgementGiven` if successful.
     *
     * @param {number} regIndex
     * @param {MultiAddressLike} target
     * @param {PalletIdentityJudgement} judgement
     * @param {H256} identity
     **/
    provideJudgement: GenericTxCall<
      Rv,
      (
        regIndex: number,
        target: MultiAddressLike,
        judgement: PalletIdentityJudgement,
        identity: H256,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'ProvideJudgement';
            params: { regIndex: number; target: MultiAddressLike; judgement: PalletIdentityJudgement; identity: H256 };
          };
        }
      >
    >;

    /**
     * Remove an account's identity and sub-account information and slash the deposits.
     *
     * Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
     * `Slash`. Verification request deposits are not returned; they should be cancelled
     * manually using `cancel_request`.
     *
     * The dispatch origin for this call must match `T::ForceOrigin`.
     *
     * - `target`: the account whose identity the judgement is upon. This must be an account
     * with a registered identity.
     *
     * Emits `IdentityKilled` if successful.
     *
     * @param {MultiAddressLike} target
     **/
    killIdentity: GenericTxCall<
      Rv,
      (target: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'KillIdentity';
            params: { target: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Add the given account to the sender's subs.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     *
     * @param {MultiAddressLike} sub
     * @param {Data} data
     **/
    addSub: GenericTxCall<
      Rv,
      (
        sub: MultiAddressLike,
        data: Data,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'AddSub';
            params: { sub: MultiAddressLike; data: Data };
          };
        }
      >
    >;

    /**
     * Alter the associated name of the given sub-account.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     *
     * @param {MultiAddressLike} sub
     * @param {Data} data
     **/
    renameSub: GenericTxCall<
      Rv,
      (
        sub: MultiAddressLike,
        data: Data,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RenameSub';
            params: { sub: MultiAddressLike; data: Data };
          };
        }
      >
    >;

    /**
     * Remove the given account from the sender's subs.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     *
     * @param {MultiAddressLike} sub
     **/
    removeSub: GenericTxCall<
      Rv,
      (sub: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RemoveSub';
            params: { sub: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Remove the sender as a sub-account.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender (*not* the original depositor).
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * super-identity.
     *
     * NOTE: This should not normally be used, but is provided in the case that the non-
     * controller of an account is maliciously registered as a sub-account.
     *
     **/
    quitSub: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'QuitSub';
          };
        }
      >
    >;

    /**
     * Add an `AccountId` with permission to grant usernames with a given `suffix` appended.
     *
     * The authority can grant up to `allocation` usernames. To top up their allocation, they
     * should just issue (or request via governance) a new `add_username_authority` call.
     *
     * @param {MultiAddressLike} authority
     * @param {BytesLike} suffix
     * @param {number} allocation
     **/
    addUsernameAuthority: GenericTxCall<
      Rv,
      (
        authority: MultiAddressLike,
        suffix: BytesLike,
        allocation: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'AddUsernameAuthority';
            params: { authority: MultiAddressLike; suffix: BytesLike; allocation: number };
          };
        }
      >
    >;

    /**
     * Remove `authority` from the username authorities.
     *
     * @param {MultiAddressLike} authority
     **/
    removeUsernameAuthority: GenericTxCall<
      Rv,
      (authority: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RemoveUsernameAuthority';
            params: { authority: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Set the username for `who`. Must be called by a username authority.
     *
     * The authority must have an `allocation`. Users can either pre-sign their usernames or
     * accept them later.
     *
     * Usernames must:
     * - Only contain lowercase ASCII characters or digits.
     * - When combined with the suffix of the issuing authority be _less than_ the
     * `MaxUsernameLength`.
     *
     * @param {MultiAddressLike} who
     * @param {BytesLike} username
     * @param {SpRuntimeMultiSignature | undefined} signature
     **/
    setUsernameFor: GenericTxCall<
      Rv,
      (
        who: MultiAddressLike,
        username: BytesLike,
        signature: SpRuntimeMultiSignature | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetUsernameFor';
            params: { who: MultiAddressLike; username: BytesLike; signature: SpRuntimeMultiSignature | undefined };
          };
        }
      >
    >;

    /**
     * Accept a given username that an `authority` granted. The call must include the full
     * username, as in `username.suffix`.
     *
     * @param {BytesLike} username
     **/
    acceptUsername: GenericTxCall<
      Rv,
      (username: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'AcceptUsername';
            params: { username: BytesLike };
          };
        }
      >
    >;

    /**
     * Remove an expired username approval. The username was approved by an authority but never
     * accepted by the user and must now be beyond its expiration. The call must include the
     * full username, as in `username.suffix`.
     *
     * @param {BytesLike} username
     **/
    removeExpiredApproval: GenericTxCall<
      Rv,
      (username: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RemoveExpiredApproval';
            params: { username: BytesLike };
          };
        }
      >
    >;

    /**
     * Set a given username as the primary. The username should include the suffix.
     *
     * @param {BytesLike} username
     **/
    setPrimaryUsername: GenericTxCall<
      Rv,
      (username: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetPrimaryUsername';
            params: { username: BytesLike };
          };
        }
      >
    >;

    /**
     * Remove a username that corresponds to an account with no identity. Exists when a user
     * gets a username but then calls `clear_identity`.
     *
     * @param {BytesLike} username
     **/
    removeDanglingUsername: GenericTxCall<
      Rv,
      (username: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RemoveDanglingUsername';
            params: { username: BytesLike };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Society`'s transaction calls
   **/
  society: {
    /**
     * A user outside of the society can make a bid for entry.
     *
     * Payment: The group's Candidate Deposit will be reserved for making a bid. It is returned
     * when the bid becomes a member, or if the bid calls `unbid`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `value`: A one time payment the bid would like to receive when joining the society.
     *
     * @param {bigint} value
     **/
    bid: GenericTxCall<
      Rv,
      (value: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Society';
          palletCall: {
            name: 'Bid';
            params: { value: bigint };
          };
        }
      >
    >;

    /**
     * A bidder can remove their bid for entry into society.
     * By doing so, they will have their candidate deposit returned or
     * they will unvouch their voucher.
     *
     * Payment: The bid deposit is unreserved if the user made a bid.
     *
     * The dispatch origin for this call must be _Signed_ and a bidder.
     *
     **/
    unbid: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Society';
          palletCall: {
            name: 'Unbid';
          };
        }
      >
    >;

    /**
     * As a member, vouch for someone to join society by placing a bid on their behalf.
     *
     * There is no deposit required to vouch for a new bid, but a member can only vouch for
     * one bid at a time. If the bid becomes a suspended candidate and ultimately rejected by
     * the suspension judgement origin, the member will be banned from vouching again.
     *
     * As a vouching member, you can claim a tip if the candidate is accepted. This tip will
     * be paid as a portion of the reward the member will receive for joining the society.
     *
     * The dispatch origin for this call must be _Signed_ and a member.
     *
     * Parameters:
     * - `who`: The user who you would like to vouch for.
     * - `value`: The total reward to be paid between you and the candidate if they become
     * a member in the society.
     * - `tip`: Your cut of the total `value` payout when the candidate is inducted into
     * the society. Tips larger than `value` will be saturated upon payout.
     *
     * @param {MultiAddressLike} who
     * @param {bigint} value
     * @param {bigint} tip
     **/
    vouch: GenericTxCall<
      Rv,
      (
        who: MultiAddressLike,
        value: bigint,
        tip: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Society';
          palletCall: {
            name: 'Vouch';
            params: { who: MultiAddressLike; value: bigint; tip: bigint };
          };
        }
      >
    >;

    /**
     * As a vouching member, unvouch a bid. This only works while vouched user is
     * only a bidder (and not a candidate).
     *
     * The dispatch origin for this call must be _Signed_ and a vouching member.
     *
     * Parameters:
     * - `pos`: Position in the `Bids` vector of the bid who should be unvouched.
     *
     **/
    unvouch: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Society';
          palletCall: {
            name: 'Unvouch';
          };
        }
      >
    >;

    /**
     * As a member, vote on a candidate.
     *
     * The dispatch origin for this call must be _Signed_ and a member.
     *
     * Parameters:
     * - `candidate`: The candidate that the member would like to bid on.
     * - `approve`: A boolean which says if the candidate should be approved (`true`) or
     * rejected (`false`).
     *
     * @param {MultiAddressLike} candidate
     * @param {boolean} approve
     **/
    vote: GenericTxCall<
      Rv,
      (
        candidate: MultiAddressLike,
        approve: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Society';
          palletCall: {
            name: 'Vote';
            params: { candidate: MultiAddressLike; approve: boolean };
          };
        }
      >
    >;

    /**
     * As a member, vote on the defender.
     *
     * The dispatch origin for this call must be _Signed_ and a member.
     *
     * Parameters:
     * - `approve`: A boolean which says if the candidate should be
     * approved (`true`) or rejected (`false`).
     *
     * @param {boolean} approve
     **/
    defenderVote: GenericTxCall<
      Rv,
      (approve: boolean) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Society';
          palletCall: {
            name: 'DefenderVote';
            params: { approve: boolean };
          };
        }
      >
    >;

    /**
     * Transfer the first matured payout for the sender and remove it from the records.
     *
     * NOTE: This extrinsic needs to be called multiple times to claim multiple matured
     * payouts.
     *
     * Payment: The member will receive a payment equal to their first matured
     * payout to their free balance.
     *
     * The dispatch origin for this call must be _Signed_ and a member with
     * payouts remaining.
     *
     **/
    payout: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Society';
          palletCall: {
            name: 'Payout';
          };
        }
      >
    >;

    /**
     * Repay the payment previously given to the member with the signed origin, remove any
     * pending payments, and elevate them from rank 0 to rank 1.
     *
     * @param {bigint} amount
     **/
    waiveRepay: GenericTxCall<
      Rv,
      (amount: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Society';
          palletCall: {
            name: 'WaiveRepay';
            params: { amount: bigint };
          };
        }
      >
    >;

    /**
     * Found the society.
     *
     * This is done as a discrete action in order to allow for the
     * pallet to be included into a running chain and can only be done once.
     *
     * The dispatch origin for this call must be from the _FounderSetOrigin_.
     *
     * Parameters:
     * - `founder` - The first member and head of the newly founded society.
     * - `max_members` - The initial max number of members for the society.
     * - `max_intake` - The maximum number of candidates per intake period.
     * - `max_strikes`: The maximum number of strikes a member may get before they become
     * suspended and may only be reinstated by the founder.
     * - `candidate_deposit`: The deposit required to make a bid for membership of the group.
     * - `rules` - The rules of this society concerning membership.
     *
     * Complexity: O(1)
     *
     * @param {MultiAddressLike} founder
     * @param {number} maxMembers
     * @param {number} maxIntake
     * @param {number} maxStrikes
     * @param {bigint} candidateDeposit
     * @param {BytesLike} rules
     **/
    foundSociety: GenericTxCall<
      Rv,
      (
        founder: MultiAddressLike,
        maxMembers: number,
        maxIntake: number,
        maxStrikes: number,
        candidateDeposit: bigint,
        rules: BytesLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Society';
          palletCall: {
            name: 'FoundSociety';
            params: {
              founder: MultiAddressLike;
              maxMembers: number;
              maxIntake: number;
              maxStrikes: number;
              candidateDeposit: bigint;
              rules: BytesLike;
            };
          };
        }
      >
    >;

    /**
     * Dissolve the society and remove all members.
     *
     * The dispatch origin for this call must be Signed, and the signing account must be both
     * the `Founder` and the `Head`. This implies that it may only be done when there is one
     * member.
     *
     **/
    dissolve: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Society';
          palletCall: {
            name: 'Dissolve';
          };
        }
      >
    >;

    /**
     * Allow suspension judgement origin to make judgement on a suspended member.
     *
     * If a suspended member is forgiven, we simply add them back as a member, not affecting
     * any of the existing storage items for that member.
     *
     * If a suspended member is rejected, remove all associated storage items, including
     * their payouts, and remove any vouched bids they currently have.
     *
     * The dispatch origin for this call must be Signed from the Founder.
     *
     * Parameters:
     * - `who` - The suspended member to be judged.
     * - `forgive` - A boolean representing whether the suspension judgement origin forgives
     * (`true`) or rejects (`false`) a suspended member.
     *
     * @param {MultiAddressLike} who
     * @param {boolean} forgive
     **/
    judgeSuspendedMember: GenericTxCall<
      Rv,
      (
        who: MultiAddressLike,
        forgive: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Society';
          palletCall: {
            name: 'JudgeSuspendedMember';
            params: { who: MultiAddressLike; forgive: boolean };
          };
        }
      >
    >;

    /**
     * Change the maximum number of members in society and the maximum number of new candidates
     * in a single intake period.
     *
     * The dispatch origin for this call must be Signed by the Founder.
     *
     * Parameters:
     * - `max_members` - The maximum number of members for the society. This must be no less
     * than the current number of members.
     * - `max_intake` - The maximum number of candidates per intake period.
     * - `max_strikes`: The maximum number of strikes a member may get before they become
     * suspended and may only be reinstated by the founder.
     * - `candidate_deposit`: The deposit required to make a bid for membership of the group.
     *
     * @param {number} maxMembers
     * @param {number} maxIntake
     * @param {number} maxStrikes
     * @param {bigint} candidateDeposit
     **/
    setParameters: GenericTxCall<
      Rv,
      (
        maxMembers: number,
        maxIntake: number,
        maxStrikes: number,
        candidateDeposit: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Society';
          palletCall: {
            name: 'SetParameters';
            params: { maxMembers: number; maxIntake: number; maxStrikes: number; candidateDeposit: bigint };
          };
        }
      >
    >;

    /**
     * Punish the skeptic with a strike if they did not vote on a candidate. Callable by the
     * candidate.
     *
     **/
    punishSkeptic: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Society';
          palletCall: {
            name: 'PunishSkeptic';
          };
        }
      >
    >;

    /**
     * Transform an approved candidate into a member. Callable only by the
     * the candidate, and only after the period for voting has ended.
     *
     **/
    claimMembership: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Society';
          palletCall: {
            name: 'ClaimMembership';
          };
        }
      >
    >;

    /**
     * Transform an approved candidate into a member. Callable only by the Signed origin of the
     * Founder, only after the period for voting has ended and only when the candidate is not
     * clearly rejected.
     *
     * @param {AccountId32Like} candidate
     **/
    bestowMembership: GenericTxCall<
      Rv,
      (candidate: AccountId32Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Society';
          palletCall: {
            name: 'BestowMembership';
            params: { candidate: AccountId32Like };
          };
        }
      >
    >;

    /**
     * Remove the candidate's application from the society. Callable only by the Signed origin
     * of the Founder, only after the period for voting has ended, and only when they do not
     * have a clear approval.
     *
     * Any bid deposit is lost and voucher is banned.
     *
     * @param {AccountId32Like} candidate
     **/
    kickCandidate: GenericTxCall<
      Rv,
      (candidate: AccountId32Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Society';
          palletCall: {
            name: 'KickCandidate';
            params: { candidate: AccountId32Like };
          };
        }
      >
    >;

    /**
     * Remove the candidate's application from the society. Callable only by the candidate.
     *
     * Any bid deposit is lost and voucher is banned.
     *
     **/
    resignCandidacy: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Society';
          palletCall: {
            name: 'ResignCandidacy';
          };
        }
      >
    >;

    /**
     * Remove a `candidate`'s failed application from the society. Callable by any
     * signed origin but only at the end of the subsequent round and only for
     * a candidate with more rejections than approvals.
     *
     * The bid deposit is lost and the voucher is banned.
     *
     * @param {AccountId32Like} candidate
     **/
    dropCandidate: GenericTxCall<
      Rv,
      (candidate: AccountId32Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Society';
          palletCall: {
            name: 'DropCandidate';
            params: { candidate: AccountId32Like };
          };
        }
      >
    >;

    /**
     * Remove up to `max` stale votes for the given `candidate`.
     *
     * May be called by any Signed origin, but only after the candidate's candidacy is ended.
     *
     * @param {AccountId32Like} candidate
     * @param {number} max
     **/
    cleanupCandidacy: GenericTxCall<
      Rv,
      (
        candidate: AccountId32Like,
        max: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Society';
          palletCall: {
            name: 'CleanupCandidacy';
            params: { candidate: AccountId32Like; max: number };
          };
        }
      >
    >;

    /**
     * Remove up to `max` stale votes for the defender in the given `challenge_round`.
     *
     * May be called by any Signed origin, but only after the challenge round is ended.
     *
     * @param {number} challengeRound
     * @param {number} max
     **/
    cleanupChallenge: GenericTxCall<
      Rv,
      (
        challengeRound: number,
        max: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Society';
          palletCall: {
            name: 'CleanupChallenge';
            params: { challengeRound: number; max: number };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Recovery`'s transaction calls
   **/
  recovery: {
    /**
     * Send a call through a recovered account.
     *
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     *
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     *
     * @param {MultiAddressLike} account
     * @param {RococoRuntimeRuntimeCallLike} call
     **/
    asRecovered: GenericTxCall<
      Rv,
      (
        account: MultiAddressLike,
        call: RococoRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Recovery';
          palletCall: {
            name: 'AsRecovered';
            params: { account: MultiAddressLike; call: RococoRuntimeRuntimeCallLike };
          };
        }
      >
    >;

    /**
     * Allow ROOT to bypass the recovery process and set an a rescuer account
     * for a lost account directly.
     *
     * The dispatch origin for this call must be _ROOT_.
     *
     * Parameters:
     * - `lost`: The "lost account" to be recovered.
     * - `rescuer`: The "rescuer account" which can call as the lost account.
     *
     * @param {MultiAddressLike} lost
     * @param {MultiAddressLike} rescuer
     **/
    setRecovered: GenericTxCall<
      Rv,
      (
        lost: MultiAddressLike,
        rescuer: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Recovery';
          palletCall: {
            name: 'SetRecovered';
            params: { lost: MultiAddressLike; rescuer: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Create a recovery configuration for your account. This makes your account recoverable.
     *
     * Payment: `ConfigDepositBase` + `FriendDepositFactor` * #_of_friends balance
     * will be reserved for storing the recovery configuration. This deposit is returned
     * in full when the user calls `remove_recovery`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `friends`: A list of friends you trust to vouch for recovery attempts. Should be
     * ordered and contain no duplicate values.
     * - `threshold`: The number of friends that must vouch for a recovery attempt before the
     * account can be recovered. Should be less than or equal to the length of the list of
     * friends.
     * - `delay_period`: The number of blocks after a recovery attempt is initialized that
     * needs to pass before the account can be recovered.
     *
     * @param {Array<AccountId32Like>} friends
     * @param {number} threshold
     * @param {number} delayPeriod
     **/
    createRecovery: GenericTxCall<
      Rv,
      (
        friends: Array<AccountId32Like>,
        threshold: number,
        delayPeriod: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Recovery';
          palletCall: {
            name: 'CreateRecovery';
            params: { friends: Array<AccountId32Like>; threshold: number; delayPeriod: number };
          };
        }
      >
    >;

    /**
     * Initiate the process for recovering a recoverable account.
     *
     * Payment: `RecoveryDeposit` balance will be reserved for initiating the
     * recovery process. This deposit will always be repatriated to the account
     * trying to be recovered. See `close_recovery`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `account`: The lost account that you want to recover. This account needs to be
     * recoverable (i.e. have a recovery configuration).
     *
     * @param {MultiAddressLike} account
     **/
    initiateRecovery: GenericTxCall<
      Rv,
      (account: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Recovery';
          palletCall: {
            name: 'InitiateRecovery';
            params: { account: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Allow a "friend" of a recoverable account to vouch for an active recovery
     * process for that account.
     *
     * The dispatch origin for this call must be _Signed_ and must be a "friend"
     * for the recoverable account.
     *
     * Parameters:
     * - `lost`: The lost account that you want to recover.
     * - `rescuer`: The account trying to rescue the lost account that you want to vouch for.
     *
     * The combination of these two parameters must point to an active recovery
     * process.
     *
     * @param {MultiAddressLike} lost
     * @param {MultiAddressLike} rescuer
     **/
    vouchRecovery: GenericTxCall<
      Rv,
      (
        lost: MultiAddressLike,
        rescuer: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Recovery';
          palletCall: {
            name: 'VouchRecovery';
            params: { lost: MultiAddressLike; rescuer: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Allow a successful rescuer to claim their recovered account.
     *
     * The dispatch origin for this call must be _Signed_ and must be a "rescuer"
     * who has successfully completed the account recovery process: collected
     * `threshold` or more vouches, waited `delay_period` blocks since initiation.
     *
     * Parameters:
     * - `account`: The lost account that you want to claim has been successfully recovered by
     * you.
     *
     * @param {MultiAddressLike} account
     **/
    claimRecovery: GenericTxCall<
      Rv,
      (account: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Recovery';
          palletCall: {
            name: 'ClaimRecovery';
            params: { account: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * As the controller of a recoverable account, close an active recovery
     * process for your account.
     *
     * Payment: By calling this function, the recoverable account will receive
     * the recovery deposit `RecoveryDeposit` placed by the rescuer.
     *
     * The dispatch origin for this call must be _Signed_ and must be a
     * recoverable account with an active recovery process for it.
     *
     * Parameters:
     * - `rescuer`: The account trying to rescue this recoverable account.
     *
     * @param {MultiAddressLike} rescuer
     **/
    closeRecovery: GenericTxCall<
      Rv,
      (rescuer: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Recovery';
          palletCall: {
            name: 'CloseRecovery';
            params: { rescuer: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Remove the recovery process for your account. Recovered accounts are still accessible.
     *
     * NOTE: The user must make sure to call `close_recovery` on all active
     * recovery attempts before calling this function else it will fail.
     *
     * Payment: By calling this function the recoverable account will unreserve
     * their recovery configuration deposit.
     * (`ConfigDepositBase` + `FriendDepositFactor` * #_of_friends)
     *
     * The dispatch origin for this call must be _Signed_ and must be a
     * recoverable account (i.e. has a recovery configuration).
     *
     **/
    removeRecovery: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Recovery';
          palletCall: {
            name: 'RemoveRecovery';
          };
        }
      >
    >;

    /**
     * Cancel the ability to use `as_recovered` for `account`.
     *
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     *
     * Parameters:
     * - `account`: The recovered account you are able to call on-behalf-of.
     *
     * @param {MultiAddressLike} account
     **/
    cancelRecovered: GenericTxCall<
      Rv,
      (account: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Recovery';
          palletCall: {
            name: 'CancelRecovered';
            params: { account: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Vesting`'s transaction calls
   **/
  vesting: {
    /**
     * Unlock any vested funds of the sender account.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have funds still
     * locked under this pallet.
     *
     * Emits either `VestingCompleted` or `VestingUpdated`.
     *
     * ## Complexity
     * - `O(1)`.
     *
     **/
    vest: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Vesting';
          palletCall: {
            name: 'Vest';
          };
        }
      >
    >;

    /**
     * Unlock any vested funds of a `target` account.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `target`: The account whose vested funds should be unlocked. Must have funds still
     * locked under this pallet.
     *
     * Emits either `VestingCompleted` or `VestingUpdated`.
     *
     * ## Complexity
     * - `O(1)`.
     *
     * @param {MultiAddressLike} target
     **/
    vestOther: GenericTxCall<
      Rv,
      (target: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Vesting';
          palletCall: {
            name: 'VestOther';
            params: { target: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Create a vested transfer.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `target`: The account receiving the vested funds.
     * - `schedule`: The vesting schedule attached to the transfer.
     *
     * Emits `VestingCreated`.
     *
     * NOTE: This will unlock all schedules through the current block.
     *
     * ## Complexity
     * - `O(1)`.
     *
     * @param {MultiAddressLike} target
     * @param {PalletVestingVestingInfo} schedule
     **/
    vestedTransfer: GenericTxCall<
      Rv,
      (
        target: MultiAddressLike,
        schedule: PalletVestingVestingInfo,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Vesting';
          palletCall: {
            name: 'VestedTransfer';
            params: { target: MultiAddressLike; schedule: PalletVestingVestingInfo };
          };
        }
      >
    >;

    /**
     * Force a vested transfer.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * - `source`: The account whose funds should be transferred.
     * - `target`: The account that should be transferred the vested funds.
     * - `schedule`: The vesting schedule attached to the transfer.
     *
     * Emits `VestingCreated`.
     *
     * NOTE: This will unlock all schedules through the current block.
     *
     * ## Complexity
     * - `O(1)`.
     *
     * @param {MultiAddressLike} source
     * @param {MultiAddressLike} target
     * @param {PalletVestingVestingInfo} schedule
     **/
    forceVestedTransfer: GenericTxCall<
      Rv,
      (
        source: MultiAddressLike,
        target: MultiAddressLike,
        schedule: PalletVestingVestingInfo,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Vesting';
          palletCall: {
            name: 'ForceVestedTransfer';
            params: { source: MultiAddressLike; target: MultiAddressLike; schedule: PalletVestingVestingInfo };
          };
        }
      >
    >;

    /**
     * Merge two vesting schedules together, creating a new vesting schedule that unlocks over
     * the highest possible start and end blocks. If both schedules have already started the
     * current block will be used as the schedule start; with the caveat that if one schedule
     * is finished by the current block, the other will be treated as the new merged schedule,
     * unmodified.
     *
     * NOTE: If `schedule1_index == schedule2_index` this is a no-op.
     * NOTE: This will unlock all schedules through the current block prior to merging.
     * NOTE: If both schedules have ended by the current block, no new schedule will be created
     * and both will be removed.
     *
     * Merged schedule attributes:
     * - `starting_block`: `MAX(schedule1.starting_block, scheduled2.starting_block,
     * current_block)`.
     * - `ending_block`: `MAX(schedule1.ending_block, schedule2.ending_block)`.
     * - `locked`: `schedule1.locked_at(current_block) + schedule2.locked_at(current_block)`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `schedule1_index`: index of the first schedule to merge.
     * - `schedule2_index`: index of the second schedule to merge.
     *
     * @param {number} schedule1Index
     * @param {number} schedule2Index
     **/
    mergeSchedules: GenericTxCall<
      Rv,
      (
        schedule1Index: number,
        schedule2Index: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Vesting';
          palletCall: {
            name: 'MergeSchedules';
            params: { schedule1Index: number; schedule2Index: number };
          };
        }
      >
    >;

    /**
     * Force remove a vesting schedule
     *
     * The dispatch origin for this call must be _Root_.
     *
     * - `target`: An account that has a vesting schedule
     * - `schedule_index`: The vesting schedule index that should be removed
     *
     * @param {MultiAddressLike} target
     * @param {number} scheduleIndex
     **/
    forceRemoveVestingSchedule: GenericTxCall<
      Rv,
      (
        target: MultiAddressLike,
        scheduleIndex: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Vesting';
          palletCall: {
            name: 'ForceRemoveVestingSchedule';
            params: { target: MultiAddressLike; scheduleIndex: number };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Scheduler`'s transaction calls
   **/
  scheduler: {
    /**
     * Anonymously schedule a task.
     *
     * @param {number} when
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {RococoRuntimeRuntimeCallLike} call
     **/
    schedule: GenericTxCall<
      Rv,
      (
        when: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: RococoRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'Schedule';
            params: {
              when: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: RococoRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Cancel an anonymously scheduled task.
     *
     * @param {number} when
     * @param {number} index
     **/
    cancel: GenericTxCall<
      Rv,
      (
        when: number,
        index: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'Cancel';
            params: { when: number; index: number };
          };
        }
      >
    >;

    /**
     * Schedule a named task.
     *
     * @param {FixedBytes<32>} id
     * @param {number} when
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {RococoRuntimeRuntimeCallLike} call
     **/
    scheduleNamed: GenericTxCall<
      Rv,
      (
        id: FixedBytes<32>,
        when: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: RococoRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'ScheduleNamed';
            params: {
              id: FixedBytes<32>;
              when: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: RococoRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Cancel a named scheduled task.
     *
     * @param {FixedBytes<32>} id
     **/
    cancelNamed: GenericTxCall<
      Rv,
      (id: FixedBytes<32>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'CancelNamed';
            params: { id: FixedBytes<32> };
          };
        }
      >
    >;

    /**
     * Anonymously schedule a task after a delay.
     *
     * @param {number} after
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {RococoRuntimeRuntimeCallLike} call
     **/
    scheduleAfter: GenericTxCall<
      Rv,
      (
        after: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: RococoRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'ScheduleAfter';
            params: {
              after: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: RococoRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Schedule a named task after a delay.
     *
     * @param {FixedBytes<32>} id
     * @param {number} after
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {RococoRuntimeRuntimeCallLike} call
     **/
    scheduleNamedAfter: GenericTxCall<
      Rv,
      (
        id: FixedBytes<32>,
        after: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: RococoRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'ScheduleNamedAfter';
            params: {
              id: FixedBytes<32>;
              after: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: RococoRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Set a retry configuration for a task so that, in case its scheduled run fails, it will
     * be retried after `period` blocks, for a total amount of `retries` retries or until it
     * succeeds.
     *
     * Tasks which need to be scheduled for a retry are still subject to weight metering and
     * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
     * normally while the task is retrying.
     *
     * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
     * clones of the original task. Their retry configuration will be derived from the
     * original task's configuration, but will have a lower value for `remaining` than the
     * original `total_retries`.
     *
     * @param {[number, number]} task
     * @param {number} retries
     * @param {number} period
     **/
    setRetry: GenericTxCall<
      Rv,
      (
        task: [number, number],
        retries: number,
        period: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'SetRetry';
            params: { task: [number, number]; retries: number; period: number };
          };
        }
      >
    >;

    /**
     * Set a retry configuration for a named task so that, in case its scheduled run fails, it
     * will be retried after `period` blocks, for a total amount of `retries` retries or until
     * it succeeds.
     *
     * Tasks which need to be scheduled for a retry are still subject to weight metering and
     * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
     * normally while the task is retrying.
     *
     * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
     * clones of the original task. Their retry configuration will be derived from the
     * original task's configuration, but will have a lower value for `remaining` than the
     * original `total_retries`.
     *
     * @param {FixedBytes<32>} id
     * @param {number} retries
     * @param {number} period
     **/
    setRetryNamed: GenericTxCall<
      Rv,
      (
        id: FixedBytes<32>,
        retries: number,
        period: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'SetRetryNamed';
            params: { id: FixedBytes<32>; retries: number; period: number };
          };
        }
      >
    >;

    /**
     * Removes the retry configuration of a task.
     *
     * @param {[number, number]} task
     **/
    cancelRetry: GenericTxCall<
      Rv,
      (task: [number, number]) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'CancelRetry';
            params: { task: [number, number] };
          };
        }
      >
    >;

    /**
     * Cancel the retry configuration of a named task.
     *
     * @param {FixedBytes<32>} id
     **/
    cancelRetryNamed: GenericTxCall<
      Rv,
      (id: FixedBytes<32>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'CancelRetryNamed';
            params: { id: FixedBytes<32> };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Proxy`'s transaction calls
   **/
  proxy: {
    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     *
     * @param {MultiAddressLike} real
     * @param {RococoRuntimeProxyType | undefined} forceProxyType
     * @param {RococoRuntimeRuntimeCallLike} call
     **/
    proxy: GenericTxCall<
      Rv,
      (
        real: MultiAddressLike,
        forceProxyType: RococoRuntimeProxyType | undefined,
        call: RococoRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'Proxy';
            params: {
              real: MultiAddressLike;
              forceProxyType: RococoRuntimeProxyType | undefined;
              call: RococoRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Register a proxy account for the sender that is able to make calls on its behalf.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `proxy`: The account that the `caller` would like to make a proxy.
     * - `proxy_type`: The permissions allowed for this proxy account.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     *
     * @param {MultiAddressLike} delegate
     * @param {RococoRuntimeProxyType} proxyType
     * @param {number} delay
     **/
    addProxy: GenericTxCall<
      Rv,
      (
        delegate: MultiAddressLike,
        proxyType: RococoRuntimeProxyType,
        delay: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'AddProxy';
            params: { delegate: MultiAddressLike; proxyType: RococoRuntimeProxyType; delay: number };
          };
        }
      >
    >;

    /**
     * Unregister a proxy account for the sender.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `proxy`: The account that the `caller` would like to remove as a proxy.
     * - `proxy_type`: The permissions currently enabled for the removed proxy account.
     *
     * @param {MultiAddressLike} delegate
     * @param {RococoRuntimeProxyType} proxyType
     * @param {number} delay
     **/
    removeProxy: GenericTxCall<
      Rv,
      (
        delegate: MultiAddressLike,
        proxyType: RococoRuntimeProxyType,
        delay: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'RemoveProxy';
            params: { delegate: MultiAddressLike; proxyType: RococoRuntimeProxyType; delay: number };
          };
        }
      >
    >;

    /**
     * Unregister all proxy accounts for the sender.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * WARNING: This may be called on accounts created by `pure`, however if done, then
     * the unreserved fees will be inaccessible. **All access to this account will be lost.**
     *
     **/
    removeProxies: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'RemoveProxies';
          };
        }
      >
    >;

    /**
     * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
     * initialize it with a proxy of `proxy_type` for `origin` sender.
     *
     * Requires a `Signed` origin.
     *
     * - `proxy_type`: The type of the proxy that the sender will be registered as over the
     * new account. This will almost always be the most permissive `ProxyType` possible to
     * allow for maximum flexibility.
     * - `index`: A disambiguation index, in case this is called multiple times in the same
     * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
     * want to use `0`.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     *
     * Fails with `Duplicate` if this has already been called in this transaction, from the
     * same sender, with the same parameters.
     *
     * Fails if there are insufficient funds to pay for deposit.
     *
     * @param {RococoRuntimeProxyType} proxyType
     * @param {number} delay
     * @param {number} index
     **/
    createPure: GenericTxCall<
      Rv,
      (
        proxyType: RococoRuntimeProxyType,
        delay: number,
        index: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'CreatePure';
            params: { proxyType: RococoRuntimeProxyType; delay: number; index: number };
          };
        }
      >
    >;

    /**
     * Removes a previously spawned pure proxy.
     *
     * WARNING: **All access to this account will be lost.** Any funds held in it will be
     * inaccessible.
     *
     * Requires a `Signed` origin, and the sender account must have been created by a call to
     * `pure` with corresponding parameters.
     *
     * - `spawner`: The account that originally called `pure` to create this account.
     * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
     * - `proxy_type`: The proxy type originally passed to `pure`.
     * - `height`: The height of the chain when the call to `pure` was processed.
     * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
     *
     * Fails with `NoPermission` in case the caller is not a previously created pure
     * account whose `pure` call has corresponding parameters.
     *
     * @param {MultiAddressLike} spawner
     * @param {RococoRuntimeProxyType} proxyType
     * @param {number} index
     * @param {number} height
     * @param {number} extIndex
     **/
    killPure: GenericTxCall<
      Rv,
      (
        spawner: MultiAddressLike,
        proxyType: RococoRuntimeProxyType,
        index: number,
        height: number,
        extIndex: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'KillPure';
            params: {
              spawner: MultiAddressLike;
              proxyType: RococoRuntimeProxyType;
              index: number;
              height: number;
              extIndex: number;
            };
          };
        }
      >
    >;

    /**
     * Publish the hash of a proxy-call that will be made in the future.
     *
     * This must be called some number of blocks before the corresponding `proxy` is attempted
     * if the delay associated with the proxy relationship is greater than zero.
     *
     * No more than `MaxPending` announcements may be made at any one time.
     *
     * This will take a deposit of `AnnouncementDepositFactor` as well as
     * `AnnouncementDepositBase` if there are no other pending announcements.
     *
     * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     *
     * @param {MultiAddressLike} real
     * @param {H256} callHash
     **/
    announce: GenericTxCall<
      Rv,
      (
        real: MultiAddressLike,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'Announce';
            params: { real: MultiAddressLike; callHash: H256 };
          };
        }
      >
    >;

    /**
     * Remove a given announcement.
     *
     * May be called by a proxy account to remove a call they previously announced and return
     * the deposit.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     *
     * @param {MultiAddressLike} real
     * @param {H256} callHash
     **/
    removeAnnouncement: GenericTxCall<
      Rv,
      (
        real: MultiAddressLike,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'RemoveAnnouncement';
            params: { real: MultiAddressLike; callHash: H256 };
          };
        }
      >
    >;

    /**
     * Remove the given announcement of a delegate.
     *
     * May be called by a target (proxied) account to remove a call that one of their delegates
     * (`delegate`) has announced they want to execute. The deposit is returned.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `delegate`: The account that previously announced the call.
     * - `call_hash`: The hash of the call to be made.
     *
     * @param {MultiAddressLike} delegate
     * @param {H256} callHash
     **/
    rejectAnnouncement: GenericTxCall<
      Rv,
      (
        delegate: MultiAddressLike,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'RejectAnnouncement';
            params: { delegate: MultiAddressLike; callHash: H256 };
          };
        }
      >
    >;

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     *
     * Removes any corresponding announcement(s).
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     *
     * @param {MultiAddressLike} delegate
     * @param {MultiAddressLike} real
     * @param {RococoRuntimeProxyType | undefined} forceProxyType
     * @param {RococoRuntimeRuntimeCallLike} call
     **/
    proxyAnnounced: GenericTxCall<
      Rv,
      (
        delegate: MultiAddressLike,
        real: MultiAddressLike,
        forceProxyType: RococoRuntimeProxyType | undefined,
        call: RococoRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'ProxyAnnounced';
            params: {
              delegate: MultiAddressLike;
              real: MultiAddressLike;
              forceProxyType: RococoRuntimeProxyType | undefined;
              call: RococoRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Multisig`'s transaction calls
   **/
  multisig: {
    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     *
     * Result is equivalent to the dispatched result.
     *
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     *
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {RococoRuntimeRuntimeCallLike} call
     **/
    asMultiThreshold1: GenericTxCall<
      Rv,
      (
        otherSignatories: Array<AccountId32Like>,
        call: RococoRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'AsMultiThreshold1';
            params: { otherSignatories: Array<AccountId32Like>; call: RococoRuntimeRuntimeCallLike };
          };
        }
      >
    >;

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     *
     * If there are enough, then dispatch the call.
     *
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     *
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     *
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     *
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     *
     * @param {number} threshold
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {PalletMultisigTimepoint | undefined} maybeTimepoint
     * @param {RococoRuntimeRuntimeCallLike} call
     * @param {SpWeightsWeightV2Weight} maxWeight
     **/
    asMulti: GenericTxCall<
      Rv,
      (
        threshold: number,
        otherSignatories: Array<AccountId32Like>,
        maybeTimepoint: PalletMultisigTimepoint | undefined,
        call: RococoRuntimeRuntimeCallLike,
        maxWeight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'AsMulti';
            params: {
              threshold: number;
              otherSignatories: Array<AccountId32Like>;
              maybeTimepoint: PalletMultisigTimepoint | undefined;
              call: RococoRuntimeRuntimeCallLike;
              maxWeight: SpWeightsWeightV2Weight;
            };
          };
        }
      >
    >;

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     *
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call_hash`: The hash of the call to be executed.
     *
     * NOTE: If this is the final approval, you will want to use `as_multi` instead.
     *
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     *
     * @param {number} threshold
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {PalletMultisigTimepoint | undefined} maybeTimepoint
     * @param {FixedBytes<32>} callHash
     * @param {SpWeightsWeightV2Weight} maxWeight
     **/
    approveAsMulti: GenericTxCall<
      Rv,
      (
        threshold: number,
        otherSignatories: Array<AccountId32Like>,
        maybeTimepoint: PalletMultisigTimepoint | undefined,
        callHash: FixedBytes<32>,
        maxWeight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'ApproveAsMulti';
            params: {
              threshold: number;
              otherSignatories: Array<AccountId32Like>;
              maybeTimepoint: PalletMultisigTimepoint | undefined;
              callHash: FixedBytes<32>;
              maxWeight: SpWeightsWeightV2Weight;
            };
          };
        }
      >
    >;

    /**
     * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
     * for this operation will be unreserved on success.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `timepoint`: The timepoint (block number and transaction index) of the first approval
     * transaction for this dispatch.
     * - `call_hash`: The hash of the call to be executed.
     *
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - One event.
     * - I/O: 1 read `O(S)`, one remove.
     * - Storage: removes one item.
     *
     * @param {number} threshold
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {PalletMultisigTimepoint} timepoint
     * @param {FixedBytes<32>} callHash
     **/
    cancelAsMulti: GenericTxCall<
      Rv,
      (
        threshold: number,
        otherSignatories: Array<AccountId32Like>,
        timepoint: PalletMultisigTimepoint,
        callHash: FixedBytes<32>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'CancelAsMulti';
            params: {
              threshold: number;
              otherSignatories: Array<AccountId32Like>;
              timepoint: PalletMultisigTimepoint;
              callHash: FixedBytes<32>;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Preimage`'s transaction calls
   **/
  preimage: {
    /**
     * Register a preimage on-chain.
     *
     * If the preimage was previously requested, no fees or deposits are taken for providing
     * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
     *
     * @param {BytesLike} bytes
     **/
    notePreimage: GenericTxCall<
      Rv,
      (bytes: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'NotePreimage';
            params: { bytes: BytesLike };
          };
        }
      >
    >;

    /**
     * Clear an unrequested preimage from the runtime storage.
     *
     * If `len` is provided, then it will be a much cheaper operation.
     *
     * - `hash`: The hash of the preimage to be removed from the store.
     * - `len`: The length of the preimage of `hash`.
     *
     * @param {H256} hash
     **/
    unnotePreimage: GenericTxCall<
      Rv,
      (hash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'UnnotePreimage';
            params: { hash: H256 };
          };
        }
      >
    >;

    /**
     * Request a preimage be uploaded to the chain without paying any fees or deposits.
     *
     * If the preimage requests has already been provided on-chain, we unreserve any deposit
     * a user may have paid, and take the control of the preimage out of their hands.
     *
     * @param {H256} hash
     **/
    requestPreimage: GenericTxCall<
      Rv,
      (hash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'RequestPreimage';
            params: { hash: H256 };
          };
        }
      >
    >;

    /**
     * Clear a previously made request for a preimage.
     *
     * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
     *
     * @param {H256} hash
     **/
    unrequestPreimage: GenericTxCall<
      Rv,
      (hash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'UnrequestPreimage';
            params: { hash: H256 };
          };
        }
      >
    >;

    /**
     * Ensure that the a bulk of pre-images is upgraded.
     *
     * The caller pays no fee if at least 90% of pre-images were successfully updated.
     *
     * @param {Array<H256>} hashes
     **/
    ensureUpdated: GenericTxCall<
      Rv,
      (hashes: Array<H256>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'EnsureUpdated';
            params: { hashes: Array<H256> };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `AssetRate`'s transaction calls
   **/
  assetRate: {
    /**
     * Initialize a conversion rate to native balance for the given asset.
     *
     * ## Complexity
     * - O(1)
     *
     * @param {PolkadotRuntimeCommonImplsVersionedLocatableAsset} assetKind
     * @param {FixedU128} rate
     **/
    create: GenericTxCall<
      Rv,
      (
        assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset,
        rate: FixedU128,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'AssetRate';
          palletCall: {
            name: 'Create';
            params: { assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset; rate: FixedU128 };
          };
        }
      >
    >;

    /**
     * Update the conversion rate to native balance for the given asset.
     *
     * ## Complexity
     * - O(1)
     *
     * @param {PolkadotRuntimeCommonImplsVersionedLocatableAsset} assetKind
     * @param {FixedU128} rate
     **/
    update: GenericTxCall<
      Rv,
      (
        assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset,
        rate: FixedU128,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'AssetRate';
          palletCall: {
            name: 'Update';
            params: { assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset; rate: FixedU128 };
          };
        }
      >
    >;

    /**
     * Remove an existing conversion rate to native balance for the given asset.
     *
     * ## Complexity
     * - O(1)
     *
     * @param {PolkadotRuntimeCommonImplsVersionedLocatableAsset} assetKind
     **/
    remove: GenericTxCall<
      Rv,
      (assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'AssetRate';
          palletCall: {
            name: 'Remove';
            params: { assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Bounties`'s transaction calls
   **/
  bounties: {
    /**
     * Propose a new bounty.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
     * `DataDepositPerByte` for each byte in `reason`. It will be unreserved upon approval,
     * or slashed when rejected.
     *
     * - `curator`: The curator account whom will manage this bounty.
     * - `fee`: The curator fee.
     * - `value`: The total payment amount of this bounty, curator fee included.
     * - `description`: The description of this bounty.
     *
     * @param {bigint} value
     * @param {BytesLike} description
     **/
    proposeBounty: GenericTxCall<
      Rv,
      (
        value: bigint,
        description: BytesLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Bounties';
          palletCall: {
            name: 'ProposeBounty';
            params: { value: bigint; description: BytesLike };
          };
        }
      >
    >;

    /**
     * Approve a bounty proposal. At a later time, the bounty will be funded and become active
     * and the original deposit will be returned.
     *
     * May only be called from `T::SpendOrigin`.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {number} bountyId
     **/
    approveBounty: GenericTxCall<
      Rv,
      (bountyId: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Bounties';
          palletCall: {
            name: 'ApproveBounty';
            params: { bountyId: number };
          };
        }
      >
    >;

    /**
     * Propose a curator to a funded bounty.
     *
     * May only be called from `T::SpendOrigin`.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {number} bountyId
     * @param {MultiAddressLike} curator
     * @param {bigint} fee
     **/
    proposeCurator: GenericTxCall<
      Rv,
      (
        bountyId: number,
        curator: MultiAddressLike,
        fee: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Bounties';
          palletCall: {
            name: 'ProposeCurator';
            params: { bountyId: number; curator: MultiAddressLike; fee: bigint };
          };
        }
      >
    >;

    /**
     * Unassign curator from a bounty.
     *
     * This function can only be called by the `RejectOrigin` a signed origin.
     *
     * If this function is called by the `RejectOrigin`, we assume that the curator is
     * malicious or inactive. As a result, we will slash the curator when possible.
     *
     * If the origin is the curator, we take this as a sign they are unable to do their job and
     * they willingly give up. We could slash them, but for now we allow them to recover their
     * deposit and exit without issue. (We may want to change this if it is abused.)
     *
     * Finally, the origin can be anyone if and only if the curator is "inactive". This allows
     * anyone in the community to call out that a curator is not doing their due diligence, and
     * we should pick a new curator. In this case the curator should also be slashed.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {number} bountyId
     **/
    unassignCurator: GenericTxCall<
      Rv,
      (bountyId: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Bounties';
          palletCall: {
            name: 'UnassignCurator';
            params: { bountyId: number };
          };
        }
      >
    >;

    /**
     * Accept the curator role for a bounty.
     * A deposit will be reserved from curator and refund upon successful payout.
     *
     * May only be called from the curator.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {number} bountyId
     **/
    acceptCurator: GenericTxCall<
      Rv,
      (bountyId: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Bounties';
          palletCall: {
            name: 'AcceptCurator';
            params: { bountyId: number };
          };
        }
      >
    >;

    /**
     * Award bounty to a beneficiary account. The beneficiary will be able to claim the funds
     * after a delay.
     *
     * The dispatch origin for this call must be the curator of this bounty.
     *
     * - `bounty_id`: Bounty ID to award.
     * - `beneficiary`: The beneficiary account whom will receive the payout.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {number} bountyId
     * @param {MultiAddressLike} beneficiary
     **/
    awardBounty: GenericTxCall<
      Rv,
      (
        bountyId: number,
        beneficiary: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Bounties';
          palletCall: {
            name: 'AwardBounty';
            params: { bountyId: number; beneficiary: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Claim the payout from an awarded bounty after payout delay.
     *
     * The dispatch origin for this call must be the beneficiary of this bounty.
     *
     * - `bounty_id`: Bounty ID to claim.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {number} bountyId
     **/
    claimBounty: GenericTxCall<
      Rv,
      (bountyId: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Bounties';
          palletCall: {
            name: 'ClaimBounty';
            params: { bountyId: number };
          };
        }
      >
    >;

    /**
     * Cancel a proposed or active bounty. All the funds will be sent to treasury and
     * the curator deposit will be unreserved if possible.
     *
     * Only `T::RejectOrigin` is able to cancel a bounty.
     *
     * - `bounty_id`: Bounty ID to cancel.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {number} bountyId
     **/
    closeBounty: GenericTxCall<
      Rv,
      (bountyId: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Bounties';
          palletCall: {
            name: 'CloseBounty';
            params: { bountyId: number };
          };
        }
      >
    >;

    /**
     * Extend the expiry time of an active bounty.
     *
     * The dispatch origin for this call must be the curator of this bounty.
     *
     * - `bounty_id`: Bounty ID to extend.
     * - `remark`: additional information.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {number} bountyId
     * @param {BytesLike} remark
     **/
    extendBountyExpiry: GenericTxCall<
      Rv,
      (
        bountyId: number,
        remark: BytesLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Bounties';
          palletCall: {
            name: 'ExtendBountyExpiry';
            params: { bountyId: number; remark: BytesLike };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `ChildBounties`'s transaction calls
   **/
  childBounties: {
    /**
     * Add a new child-bounty.
     *
     * The dispatch origin for this call must be the curator of parent
     * bounty and the parent bounty must be in "active" state.
     *
     * Child-bounty gets added successfully & fund gets transferred from
     * parent bounty to child-bounty account, if parent bounty has enough
     * funds, else the call fails.
     *
     * Upper bound to maximum number of active child bounties that can be
     * added are managed via runtime trait config
     * [`Config::MaxActiveChildBountyCount`].
     *
     * If the call is success, the status of child-bounty is updated to
     * "Added".
     *
     * - `parent_bounty_id`: Index of parent bounty for which child-bounty is being added.
     * - `value`: Value for executing the proposal.
     * - `description`: Text description for the child-bounty.
     *
     * @param {number} parentBountyId
     * @param {bigint} value
     * @param {BytesLike} description
     **/
    addChildBounty: GenericTxCall<
      Rv,
      (
        parentBountyId: number,
        value: bigint,
        description: BytesLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ChildBounties';
          palletCall: {
            name: 'AddChildBounty';
            params: { parentBountyId: number; value: bigint; description: BytesLike };
          };
        }
      >
    >;

    /**
     * Propose curator for funded child-bounty.
     *
     * The dispatch origin for this call must be curator of parent bounty.
     *
     * Parent bounty must be in active state, for this child-bounty call to
     * work.
     *
     * Child-bounty must be in "Added" state, for processing the call. And
     * state of child-bounty is moved to "CuratorProposed" on successful
     * call completion.
     *
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     * - `curator`: Address of child-bounty curator.
     * - `fee`: payment fee to child-bounty curator for execution.
     *
     * @param {number} parentBountyId
     * @param {number} childBountyId
     * @param {MultiAddressLike} curator
     * @param {bigint} fee
     **/
    proposeCurator: GenericTxCall<
      Rv,
      (
        parentBountyId: number,
        childBountyId: number,
        curator: MultiAddressLike,
        fee: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ChildBounties';
          palletCall: {
            name: 'ProposeCurator';
            params: { parentBountyId: number; childBountyId: number; curator: MultiAddressLike; fee: bigint };
          };
        }
      >
    >;

    /**
     * Accept the curator role for the child-bounty.
     *
     * The dispatch origin for this call must be the curator of this
     * child-bounty.
     *
     * A deposit will be reserved from the curator and refund upon
     * successful payout or cancellation.
     *
     * Fee for curator is deducted from curator fee of parent bounty.
     *
     * Parent bounty must be in active state, for this child-bounty call to
     * work.
     *
     * Child-bounty must be in "CuratorProposed" state, for processing the
     * call. And state of child-bounty is moved to "Active" on successful
     * call completion.
     *
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     *
     * @param {number} parentBountyId
     * @param {number} childBountyId
     **/
    acceptCurator: GenericTxCall<
      Rv,
      (
        parentBountyId: number,
        childBountyId: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ChildBounties';
          palletCall: {
            name: 'AcceptCurator';
            params: { parentBountyId: number; childBountyId: number };
          };
        }
      >
    >;

    /**
     * Unassign curator from a child-bounty.
     *
     * The dispatch origin for this call can be either `RejectOrigin`, or
     * the curator of the parent bounty, or any signed origin.
     *
     * For the origin other than T::RejectOrigin and the child-bounty
     * curator, parent bounty must be in active state, for this call to
     * work. We allow child-bounty curator and T::RejectOrigin to execute
     * this call irrespective of the parent bounty state.
     *
     * If this function is called by the `RejectOrigin` or the
     * parent bounty curator, we assume that the child-bounty curator is
     * malicious or inactive. As a result, child-bounty curator deposit is
     * slashed.
     *
     * If the origin is the child-bounty curator, we take this as a sign
     * that they are unable to do their job, and are willingly giving up.
     * We could slash the deposit, but for now we allow them to unreserve
     * their deposit and exit without issue. (We may want to change this if
     * it is abused.)
     *
     * Finally, the origin can be anyone iff the child-bounty curator is
     * "inactive". Expiry update due of parent bounty is used to estimate
     * inactive state of child-bounty curator.
     *
     * This allows anyone in the community to call out that a child-bounty
     * curator is not doing their due diligence, and we should pick a new
     * one. In this case the child-bounty curator deposit is slashed.
     *
     * State of child-bounty is moved to Added state on successful call
     * completion.
     *
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     *
     * @param {number} parentBountyId
     * @param {number} childBountyId
     **/
    unassignCurator: GenericTxCall<
      Rv,
      (
        parentBountyId: number,
        childBountyId: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ChildBounties';
          palletCall: {
            name: 'UnassignCurator';
            params: { parentBountyId: number; childBountyId: number };
          };
        }
      >
    >;

    /**
     * Award child-bounty to a beneficiary.
     *
     * The beneficiary will be able to claim the funds after a delay.
     *
     * The dispatch origin for this call must be the parent curator or
     * curator of this child-bounty.
     *
     * Parent bounty must be in active state, for this child-bounty call to
     * work.
     *
     * Child-bounty must be in active state, for processing the call. And
     * state of child-bounty is moved to "PendingPayout" on successful call
     * completion.
     *
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     * - `beneficiary`: Beneficiary account.
     *
     * @param {number} parentBountyId
     * @param {number} childBountyId
     * @param {MultiAddressLike} beneficiary
     **/
    awardChildBounty: GenericTxCall<
      Rv,
      (
        parentBountyId: number,
        childBountyId: number,
        beneficiary: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ChildBounties';
          palletCall: {
            name: 'AwardChildBounty';
            params: { parentBountyId: number; childBountyId: number; beneficiary: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Claim the payout from an awarded child-bounty after payout delay.
     *
     * The dispatch origin for this call may be any signed origin.
     *
     * Call works independent of parent bounty state, No need for parent
     * bounty to be in active state.
     *
     * The Beneficiary is paid out with agreed bounty value. Curator fee is
     * paid & curator deposit is unreserved.
     *
     * Child-bounty must be in "PendingPayout" state, for processing the
     * call. And instance of child-bounty is removed from the state on
     * successful call completion.
     *
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     *
     * @param {number} parentBountyId
     * @param {number} childBountyId
     **/
    claimChildBounty: GenericTxCall<
      Rv,
      (
        parentBountyId: number,
        childBountyId: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ChildBounties';
          palletCall: {
            name: 'ClaimChildBounty';
            params: { parentBountyId: number; childBountyId: number };
          };
        }
      >
    >;

    /**
     * Cancel a proposed or active child-bounty. Child-bounty account funds
     * are transferred to parent bounty account. The child-bounty curator
     * deposit may be unreserved if possible.
     *
     * The dispatch origin for this call must be either parent curator or
     * `T::RejectOrigin`.
     *
     * If the state of child-bounty is `Active`, curator deposit is
     * unreserved.
     *
     * If the state of child-bounty is `PendingPayout`, call fails &
     * returns `PendingPayout` error.
     *
     * For the origin other than T::RejectOrigin, parent bounty must be in
     * active state, for this child-bounty call to work. For origin
     * T::RejectOrigin execution is forced.
     *
     * Instance of child-bounty is removed from the state on successful
     * call completion.
     *
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     *
     * @param {number} parentBountyId
     * @param {number} childBountyId
     **/
    closeChildBounty: GenericTxCall<
      Rv,
      (
        parentBountyId: number,
        childBountyId: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ChildBounties';
          palletCall: {
            name: 'CloseChildBounty';
            params: { parentBountyId: number; childBountyId: number };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Nis`'s transaction calls
   **/
  nis: {
    /**
     * Place a bid.
     *
     * Origin must be Signed, and account must have at least `amount` in free balance.
     *
     * - `amount`: The amount of the bid; these funds will be reserved, and if/when
     * consolidated, removed. Must be at least `MinBid`.
     * - `duration`: The number of periods before which the newly consolidated bid may be
     * thawed. Must be greater than 1 and no more than `QueueCount`.
     *
     * Complexities:
     * - `Queues[duration].len()` (just take max).
     *
     * @param {bigint} amount
     * @param {number} duration
     **/
    placeBid: GenericTxCall<
      Rv,
      (
        amount: bigint,
        duration: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Nis';
          palletCall: {
            name: 'PlaceBid';
            params: { amount: bigint; duration: number };
          };
        }
      >
    >;

    /**
     * Retract a previously placed bid.
     *
     * Origin must be Signed, and the account should have previously issued a still-active bid
     * of `amount` for `duration`.
     *
     * - `amount`: The amount of the previous bid.
     * - `duration`: The duration of the previous bid.
     *
     * @param {bigint} amount
     * @param {number} duration
     **/
    retractBid: GenericTxCall<
      Rv,
      (
        amount: bigint,
        duration: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Nis';
          palletCall: {
            name: 'RetractBid';
            params: { amount: bigint; duration: number };
          };
        }
      >
    >;

    /**
     * Ensure we have sufficient funding for all potential payouts.
     *
     * - `origin`: Must be accepted by `FundOrigin`.
     *
     **/
    fundDeficit: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Nis';
          palletCall: {
            name: 'FundDeficit';
          };
        }
      >
    >;

    /**
     * Reduce or remove an outstanding receipt, placing the according proportion of funds into
     * the account of the owner.
     *
     * - `origin`: Must be Signed and the account must be the owner of the receipt `index` as
     * well as any fungible counterpart.
     * - `index`: The index of the receipt.
     * - `portion`: If `Some`, then only the given portion of the receipt should be thawed. If
     * `None`, then all of it should be.
     *
     * @param {number} index
     * @param {Perquintill | undefined} maybeProportion
     **/
    thawPrivate: GenericTxCall<
      Rv,
      (
        index: number,
        maybeProportion: Perquintill | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Nis';
          palletCall: {
            name: 'ThawPrivate';
            params: { index: number; maybeProportion: Perquintill | undefined };
          };
        }
      >
    >;

    /**
     * Reduce or remove an outstanding receipt, placing the according proportion of funds into
     * the account of the owner.
     *
     * - `origin`: Must be Signed and the account must be the owner of the fungible counterpart
     * for receipt `index`.
     * - `index`: The index of the receipt.
     *
     * @param {number} index
     **/
    thawCommunal: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Nis';
          palletCall: {
            name: 'ThawCommunal';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Make a private receipt communal and create fungible counterparts for its owner.
     *
     * @param {number} index
     **/
    communify: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Nis';
          palletCall: {
            name: 'Communify';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Make a communal receipt private and burn fungible counterparts from its owner.
     *
     * @param {number} index
     **/
    privatize: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Nis';
          palletCall: {
            name: 'Privatize';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `NisCounterpartBalances`'s transaction calls
   **/
  nisCounterpartBalances: {
    /**
     * Transfer some liquid free balance to another account.
     *
     * `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
     * If the sender's account is below the existential deposit as a result
     * of the transfer, the account will be reaped.
     *
     * The dispatch origin for this call must be `Signed` by the transactor.
     *
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     **/
    transferAllowDeath: GenericTxCall<
      Rv,
      (
        dest: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NisCounterpartBalances';
          palletCall: {
            name: 'TransferAllowDeath';
            params: { dest: MultiAddressLike; value: bigint };
          };
        }
      >
    >;

    /**
     * Exactly as `transfer_allow_death`, except the origin must be root and the source account
     * may be specified.
     *
     * @param {MultiAddressLike} source
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     **/
    forceTransfer: GenericTxCall<
      Rv,
      (
        source: MultiAddressLike,
        dest: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NisCounterpartBalances';
          palletCall: {
            name: 'ForceTransfer';
            params: { source: MultiAddressLike; dest: MultiAddressLike; value: bigint };
          };
        }
      >
    >;

    /**
     * Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
     * kill the origin account.
     *
     * 99% of the time you want [`transfer_allow_death`] instead.
     *
     * [`transfer_allow_death`]: struct.Pallet.html#method.transfer
     *
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     **/
    transferKeepAlive: GenericTxCall<
      Rv,
      (
        dest: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NisCounterpartBalances';
          palletCall: {
            name: 'TransferKeepAlive';
            params: { dest: MultiAddressLike; value: bigint };
          };
        }
      >
    >;

    /**
     * Transfer the entire transferable balance from the caller account.
     *
     * NOTE: This function only attempts to transfer _transferable_ balances. This means that
     * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
     * transferred by this function. To ensure that this function results in a killed account,
     * you might need to prepare the account by removing any reference counters, storage
     * deposits, etc...
     *
     * The dispatch origin of this call must be Signed.
     *
     * - `dest`: The recipient of the transfer.
     * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
     * of the funds the account has, causing the sender account to be killed (false), or
     * transfer everything except at least the existential deposit, which will guarantee to
     * keep the sender account alive (true).
     *
     * @param {MultiAddressLike} dest
     * @param {boolean} keepAlive
     **/
    transferAll: GenericTxCall<
      Rv,
      (
        dest: MultiAddressLike,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NisCounterpartBalances';
          palletCall: {
            name: 'TransferAll';
            params: { dest: MultiAddressLike; keepAlive: boolean };
          };
        }
      >
    >;

    /**
     * Unreserve some balance from a user by force.
     *
     * Can only be called by ROOT.
     *
     * @param {MultiAddressLike} who
     * @param {bigint} amount
     **/
    forceUnreserve: GenericTxCall<
      Rv,
      (
        who: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NisCounterpartBalances';
          palletCall: {
            name: 'ForceUnreserve';
            params: { who: MultiAddressLike; amount: bigint };
          };
        }
      >
    >;

    /**
     * Upgrade a specified account.
     *
     * - `origin`: Must be `Signed`.
     * - `who`: The account to be upgraded.
     *
     * This will waive the transaction fee if at least all but 10% of the accounts needed to
     * be upgraded. (We let some not have to be upgraded just in order to allow for the
     * possibility of churn).
     *
     * @param {Array<AccountId32Like>} who
     **/
    upgradeAccounts: GenericTxCall<
      Rv,
      (who: Array<AccountId32Like>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NisCounterpartBalances';
          palletCall: {
            name: 'UpgradeAccounts';
            params: { who: Array<AccountId32Like> };
          };
        }
      >
    >;

    /**
     * Set the regular balance of a given account.
     *
     * The dispatch origin for this call is `root`.
     *
     * @param {MultiAddressLike} who
     * @param {bigint} newFree
     **/
    forceSetBalance: GenericTxCall<
      Rv,
      (
        who: MultiAddressLike,
        newFree: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NisCounterpartBalances';
          palletCall: {
            name: 'ForceSetBalance';
            params: { who: MultiAddressLike; newFree: bigint };
          };
        }
      >
    >;

    /**
     * Adjust the total issuance in a saturating way.
     *
     * Can only be called by root and always needs a positive `delta`.
     *
     * # Example
     *
     * @param {PalletBalancesAdjustmentDirection} direction
     * @param {bigint} delta
     **/
    forceAdjustTotalIssuance: GenericTxCall<
      Rv,
      (
        direction: PalletBalancesAdjustmentDirection,
        delta: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NisCounterpartBalances';
          palletCall: {
            name: 'ForceAdjustTotalIssuance';
            params: { direction: PalletBalancesAdjustmentDirection; delta: bigint };
          };
        }
      >
    >;

    /**
     * Burn the specified liquid free balance from the origin account.
     *
     * If the origin's account ends up below the existential deposit as a result
     * of the burn and `keep_alive` is false, the account will be reaped.
     *
     * Unlike sending funds to a _burn_ address, which merely makes the funds inaccessible,
     * this `burn` operation will reduce total issuance by the amount _burned_.
     *
     * @param {bigint} value
     * @param {boolean} keepAlive
     **/
    burn: GenericTxCall<
      Rv,
      (
        value: bigint,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NisCounterpartBalances';
          palletCall: {
            name: 'Burn';
            params: { value: bigint; keepAlive: boolean };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Configuration`'s transaction calls
   **/
  configuration: {
    /**
     * Set the validation upgrade cooldown.
     *
     * @param {number} new_
     **/
    setValidationUpgradeCooldown: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetValidationUpgradeCooldown';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Set the validation upgrade delay.
     *
     * @param {number} new_
     **/
    setValidationUpgradeDelay: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetValidationUpgradeDelay';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Set the acceptance period for an included candidate.
     *
     * @param {number} new_
     **/
    setCodeRetentionPeriod: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetCodeRetentionPeriod';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Set the max validation code size for incoming upgrades.
     *
     * @param {number} new_
     **/
    setMaxCodeSize: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetMaxCodeSize';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Set the max POV block size for incoming upgrades.
     *
     * @param {number} new_
     **/
    setMaxPovSize: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetMaxPovSize';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Set the max head data size for paras.
     *
     * @param {number} new_
     **/
    setMaxHeadDataSize: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetMaxHeadDataSize';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Set the number of coretime execution cores.
     *
     * NOTE: that this configuration is managed by the coretime chain. Only manually change
     * this, if you really know what you are doing!
     *
     * @param {number} new_
     **/
    setCoretimeCores: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetCoretimeCores';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Set the max number of times a claim may timeout on a core before it is abandoned
     *
     * @param {number} new_
     **/
    setMaxAvailabilityTimeouts: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetMaxAvailabilityTimeouts';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Set the parachain validator-group rotation frequency
     *
     * @param {number} new_
     **/
    setGroupRotationFrequency: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetGroupRotationFrequency';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Set the availability period for paras.
     *
     * @param {number} new_
     **/
    setParasAvailabilityPeriod: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetParasAvailabilityPeriod';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Set the scheduling lookahead, in expected number of blocks at peak throughput.
     *
     * @param {number} new_
     **/
    setSchedulingLookahead: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetSchedulingLookahead';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Set the maximum number of validators to assign to any core.
     *
     * @param {number | undefined} new_
     **/
    setMaxValidatorsPerCore: GenericTxCall<
      Rv,
      (new_: number | undefined) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetMaxValidatorsPerCore';
            params: { new: number | undefined };
          };
        }
      >
    >;

    /**
     * Set the maximum number of validators to use in parachain consensus.
     *
     * @param {number | undefined} new_
     **/
    setMaxValidators: GenericTxCall<
      Rv,
      (new_: number | undefined) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetMaxValidators';
            params: { new: number | undefined };
          };
        }
      >
    >;

    /**
     * Set the dispute period, in number of sessions to keep for disputes.
     *
     * @param {number} new_
     **/
    setDisputePeriod: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetDisputePeriod';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Set the dispute post conclusion acceptance period.
     *
     * @param {number} new_
     **/
    setDisputePostConclusionAcceptancePeriod: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetDisputePostConclusionAcceptancePeriod';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Set the no show slots, in number of number of consensus slots.
     * Must be at least 1.
     *
     * @param {number} new_
     **/
    setNoShowSlots: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetNoShowSlots';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Set the total number of delay tranches.
     *
     * @param {number} new_
     **/
    setNDelayTranches: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetNDelayTranches';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Set the zeroth delay tranche width.
     *
     * @param {number} new_
     **/
    setZerothDelayTrancheWidth: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetZerothDelayTrancheWidth';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Set the number of validators needed to approve a block.
     *
     * @param {number} new_
     **/
    setNeededApprovals: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetNeededApprovals';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Set the number of samples to do of the `RelayVRFModulo` approval assignment criterion.
     *
     * @param {number} new_
     **/
    setRelayVrfModuloSamples: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetRelayVrfModuloSamples';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Sets the maximum items that can present in a upward dispatch queue at once.
     *
     * @param {number} new_
     **/
    setMaxUpwardQueueCount: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetMaxUpwardQueueCount';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Sets the maximum total size of items that can present in a upward dispatch queue at
     * once.
     *
     * @param {number} new_
     **/
    setMaxUpwardQueueSize: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetMaxUpwardQueueSize';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Set the critical downward message size.
     *
     * @param {number} new_
     **/
    setMaxDownwardMessageSize: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetMaxDownwardMessageSize';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Sets the maximum size of an upward message that can be sent by a candidate.
     *
     * @param {number} new_
     **/
    setMaxUpwardMessageSize: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetMaxUpwardMessageSize';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Sets the maximum number of messages that a candidate can contain.
     *
     * @param {number} new_
     **/
    setMaxUpwardMessageNumPerCandidate: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetMaxUpwardMessageNumPerCandidate';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Sets the number of sessions after which an HRMP open channel request expires.
     *
     * @param {number} new_
     **/
    setHrmpOpenRequestTtl: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetHrmpOpenRequestTtl';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Sets the amount of funds that the sender should provide for opening an HRMP channel.
     *
     * @param {bigint} new_
     **/
    setHrmpSenderDeposit: GenericTxCall<
      Rv,
      (new_: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetHrmpSenderDeposit';
            params: { new: bigint };
          };
        }
      >
    >;

    /**
     * Sets the amount of funds that the recipient should provide for accepting opening an HRMP
     * channel.
     *
     * @param {bigint} new_
     **/
    setHrmpRecipientDeposit: GenericTxCall<
      Rv,
      (new_: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetHrmpRecipientDeposit';
            params: { new: bigint };
          };
        }
      >
    >;

    /**
     * Sets the maximum number of messages allowed in an HRMP channel at once.
     *
     * @param {number} new_
     **/
    setHrmpChannelMaxCapacity: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetHrmpChannelMaxCapacity';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Sets the maximum total size of messages in bytes allowed in an HRMP channel at once.
     *
     * @param {number} new_
     **/
    setHrmpChannelMaxTotalSize: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetHrmpChannelMaxTotalSize';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Sets the maximum number of inbound HRMP channels a parachain is allowed to accept.
     *
     * @param {number} new_
     **/
    setHrmpMaxParachainInboundChannels: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetHrmpMaxParachainInboundChannels';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Sets the maximum size of a message that could ever be put into an HRMP channel.
     *
     * @param {number} new_
     **/
    setHrmpChannelMaxMessageSize: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetHrmpChannelMaxMessageSize';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Sets the maximum number of outbound HRMP channels a parachain is allowed to open.
     *
     * @param {number} new_
     **/
    setHrmpMaxParachainOutboundChannels: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetHrmpMaxParachainOutboundChannels';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Sets the maximum number of outbound HRMP messages can be sent by a candidate.
     *
     * @param {number} new_
     **/
    setHrmpMaxMessageNumPerCandidate: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetHrmpMaxMessageNumPerCandidate';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Set the number of session changes after which a PVF pre-checking voting is rejected.
     *
     * @param {number} new_
     **/
    setPvfVotingTtl: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetPvfVotingTtl';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Sets the minimum delay between announcing the upgrade block for a parachain until the
     * upgrade taking place.
     *
     * See the field documentation for information and constraints for the new value.
     *
     * @param {number} new_
     **/
    setMinimumValidationUpgradeDelay: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetMinimumValidationUpgradeDelay';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Setting this to true will disable consistency checks for the configuration setters.
     * Use with caution.
     *
     * @param {boolean} new_
     **/
    setBypassConsistencyCheck: GenericTxCall<
      Rv,
      (new_: boolean) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetBypassConsistencyCheck';
            params: { new: boolean };
          };
        }
      >
    >;

    /**
     * Set the asynchronous backing parameters.
     *
     * @param {PolkadotPrimitivesV7AsyncBackingAsyncBackingParams} new_
     **/
    setAsyncBackingParams: GenericTxCall<
      Rv,
      (new_: PolkadotPrimitivesV7AsyncBackingAsyncBackingParams) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetAsyncBackingParams';
            params: { new: PolkadotPrimitivesV7AsyncBackingAsyncBackingParams };
          };
        }
      >
    >;

    /**
     * Set PVF executor parameters.
     *
     * @param {PolkadotPrimitivesV7ExecutorParams} new_
     **/
    setExecutorParams: GenericTxCall<
      Rv,
      (new_: PolkadotPrimitivesV7ExecutorParams) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetExecutorParams';
            params: { new: PolkadotPrimitivesV7ExecutorParams };
          };
        }
      >
    >;

    /**
     * Set the on demand (parathreads) base fee.
     *
     * @param {bigint} new_
     **/
    setOnDemandBaseFee: GenericTxCall<
      Rv,
      (new_: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetOnDemandBaseFee';
            params: { new: bigint };
          };
        }
      >
    >;

    /**
     * Set the on demand (parathreads) fee variability.
     *
     * @param {Perbill} new_
     **/
    setOnDemandFeeVariability: GenericTxCall<
      Rv,
      (new_: Perbill) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetOnDemandFeeVariability';
            params: { new: Perbill };
          };
        }
      >
    >;

    /**
     * Set the on demand (parathreads) queue max size.
     *
     * @param {number} new_
     **/
    setOnDemandQueueMaxSize: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetOnDemandQueueMaxSize';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Set the on demand (parathreads) fee variability.
     *
     * @param {Perbill} new_
     **/
    setOnDemandTargetQueueUtilization: GenericTxCall<
      Rv,
      (new_: Perbill) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetOnDemandTargetQueueUtilization';
            params: { new: Perbill };
          };
        }
      >
    >;

    /**
     * Set the on demand (parathreads) ttl in the claimqueue.
     *
     * @param {number} new_
     **/
    setOnDemandTtl: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetOnDemandTtl';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Set the minimum backing votes threshold.
     *
     * @param {number} new_
     **/
    setMinimumBackingVotes: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetMinimumBackingVotes';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Set/Unset a node feature.
     *
     * @param {number} index
     * @param {boolean} value
     **/
    setNodeFeature: GenericTxCall<
      Rv,
      (
        index: number,
        value: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetNodeFeature';
            params: { index: number; value: boolean };
          };
        }
      >
    >;

    /**
     * Set approval-voting-params.
     *
     * @param {PolkadotPrimitivesV7ApprovalVotingParams} new_
     **/
    setApprovalVotingParams: GenericTxCall<
      Rv,
      (new_: PolkadotPrimitivesV7ApprovalVotingParams) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetApprovalVotingParams';
            params: { new: PolkadotPrimitivesV7ApprovalVotingParams };
          };
        }
      >
    >;

    /**
     * Set scheduler-params.
     *
     * @param {PolkadotPrimitivesVstagingSchedulerParams} new_
     **/
    setSchedulerParams: GenericTxCall<
      Rv,
      (new_: PolkadotPrimitivesVstagingSchedulerParams) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Configuration';
          palletCall: {
            name: 'SetSchedulerParams';
            params: { new: PolkadotPrimitivesVstagingSchedulerParams };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `ParasShared`'s transaction calls
   **/
  parasShared: {
    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `ParaInclusion`'s transaction calls
   **/
  paraInclusion: {
    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `ParaInherent`'s transaction calls
   **/
  paraInherent: {
    /**
     * Enter the paras inherent. This will process bitfields and backed candidates.
     *
     * @param {PolkadotPrimitivesV7InherentData} data
     **/
    enter: GenericTxCall<
      Rv,
      (data: PolkadotPrimitivesV7InherentData) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParaInherent';
          palletCall: {
            name: 'Enter';
            params: { data: PolkadotPrimitivesV7InherentData };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Paras`'s transaction calls
   **/
  paras: {
    /**
     * Set the storage for the parachain validation code immediately.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} para
     * @param {PolkadotParachainPrimitivesPrimitivesValidationCode} newCode
     **/
    forceSetCurrentCode: GenericTxCall<
      Rv,
      (
        para: PolkadotParachainPrimitivesPrimitivesId,
        newCode: PolkadotParachainPrimitivesPrimitivesValidationCode,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Paras';
          palletCall: {
            name: 'ForceSetCurrentCode';
            params: {
              para: PolkadotParachainPrimitivesPrimitivesId;
              newCode: PolkadotParachainPrimitivesPrimitivesValidationCode;
            };
          };
        }
      >
    >;

    /**
     * Set the storage for the current parachain head data immediately.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} para
     * @param {PolkadotParachainPrimitivesPrimitivesHeadData} newHead
     **/
    forceSetCurrentHead: GenericTxCall<
      Rv,
      (
        para: PolkadotParachainPrimitivesPrimitivesId,
        newHead: PolkadotParachainPrimitivesPrimitivesHeadData,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Paras';
          palletCall: {
            name: 'ForceSetCurrentHead';
            params: {
              para: PolkadotParachainPrimitivesPrimitivesId;
              newHead: PolkadotParachainPrimitivesPrimitivesHeadData;
            };
          };
        }
      >
    >;

    /**
     * Schedule an upgrade as if it was scheduled in the given relay parent block.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} para
     * @param {PolkadotParachainPrimitivesPrimitivesValidationCode} newCode
     * @param {number} relayParentNumber
     **/
    forceScheduleCodeUpgrade: GenericTxCall<
      Rv,
      (
        para: PolkadotParachainPrimitivesPrimitivesId,
        newCode: PolkadotParachainPrimitivesPrimitivesValidationCode,
        relayParentNumber: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Paras';
          palletCall: {
            name: 'ForceScheduleCodeUpgrade';
            params: {
              para: PolkadotParachainPrimitivesPrimitivesId;
              newCode: PolkadotParachainPrimitivesPrimitivesValidationCode;
              relayParentNumber: number;
            };
          };
        }
      >
    >;

    /**
     * Note a new block head for para within the context of the current block.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} para
     * @param {PolkadotParachainPrimitivesPrimitivesHeadData} newHead
     **/
    forceNoteNewHead: GenericTxCall<
      Rv,
      (
        para: PolkadotParachainPrimitivesPrimitivesId,
        newHead: PolkadotParachainPrimitivesPrimitivesHeadData,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Paras';
          palletCall: {
            name: 'ForceNoteNewHead';
            params: {
              para: PolkadotParachainPrimitivesPrimitivesId;
              newHead: PolkadotParachainPrimitivesPrimitivesHeadData;
            };
          };
        }
      >
    >;

    /**
     * Put a parachain directly into the next session's action queue.
     * We can't queue it any sooner than this without going into the
     * initializer...
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} para
     **/
    forceQueueAction: GenericTxCall<
      Rv,
      (para: PolkadotParachainPrimitivesPrimitivesId) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Paras';
          palletCall: {
            name: 'ForceQueueAction';
            params: { para: PolkadotParachainPrimitivesPrimitivesId };
          };
        }
      >
    >;

    /**
     * Adds the validation code to the storage.
     *
     * The code will not be added if it is already present. Additionally, if PVF pre-checking
     * is running for that code, it will be instantly accepted.
     *
     * Otherwise, the code will be added into the storage. Note that the code will be added
     * into storage with reference count 0. This is to account the fact that there are no users
     * for this code yet. The caller will have to make sure that this code eventually gets
     * used by some parachain or removed from the storage to avoid storage leaks. For the
     * latter prefer to use the `poke_unused_validation_code` dispatchable to raw storage
     * manipulation.
     *
     * This function is mainly meant to be used for upgrading parachains that do not follow
     * the go-ahead signal while the PVF pre-checking feature is enabled.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesValidationCode} validationCode
     **/
    addTrustedValidationCode: GenericTxCall<
      Rv,
      (validationCode: PolkadotParachainPrimitivesPrimitivesValidationCode) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Paras';
          palletCall: {
            name: 'AddTrustedValidationCode';
            params: { validationCode: PolkadotParachainPrimitivesPrimitivesValidationCode };
          };
        }
      >
    >;

    /**
     * Remove the validation code from the storage iff the reference count is 0.
     *
     * This is better than removing the storage directly, because it will not remove the code
     * that was suddenly got used by some parachain while this dispatchable was pending
     * dispatching.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesValidationCodeHash} validationCodeHash
     **/
    pokeUnusedValidationCode: GenericTxCall<
      Rv,
      (validationCodeHash: PolkadotParachainPrimitivesPrimitivesValidationCodeHash) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Paras';
          palletCall: {
            name: 'PokeUnusedValidationCode';
            params: { validationCodeHash: PolkadotParachainPrimitivesPrimitivesValidationCodeHash };
          };
        }
      >
    >;

    /**
     * Includes a statement for a PVF pre-checking vote. Potentially, finalizes the vote and
     * enacts the results if that was the last vote before achieving the supermajority.
     *
     * @param {PolkadotPrimitivesV7PvfCheckStatement} stmt
     * @param {PolkadotPrimitivesV7ValidatorAppSignature} signature
     **/
    includePvfCheckStatement: GenericTxCall<
      Rv,
      (
        stmt: PolkadotPrimitivesV7PvfCheckStatement,
        signature: PolkadotPrimitivesV7ValidatorAppSignature,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Paras';
          palletCall: {
            name: 'IncludePvfCheckStatement';
            params: {
              stmt: PolkadotPrimitivesV7PvfCheckStatement;
              signature: PolkadotPrimitivesV7ValidatorAppSignature;
            };
          };
        }
      >
    >;

    /**
     * Set the storage for the current parachain head data immediately.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} para
     * @param {number} context
     **/
    forceSetMostRecentContext: GenericTxCall<
      Rv,
      (
        para: PolkadotParachainPrimitivesPrimitivesId,
        context: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Paras';
          palletCall: {
            name: 'ForceSetMostRecentContext';
            params: { para: PolkadotParachainPrimitivesPrimitivesId; context: number };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Initializer`'s transaction calls
   **/
  initializer: {
    /**
     * Issue a signal to the consensus engine to forcibly act as though all parachain
     * blocks in all relay chain blocks up to and including the given number in the current
     * chain are valid and should be finalized.
     *
     * @param {number} upTo
     **/
    forceApprove: GenericTxCall<
      Rv,
      (upTo: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Initializer';
          palletCall: {
            name: 'ForceApprove';
            params: { upTo: number };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Hrmp`'s transaction calls
   **/
  hrmp: {
    /**
     * Initiate opening a channel from a parachain to a given recipient with given channel
     * parameters.
     *
     * - `proposed_max_capacity` - specifies how many messages can be in the channel at once.
     * - `proposed_max_message_size` - specifies the maximum size of the messages.
     *
     * These numbers are a subject to the relay-chain configuration limits.
     *
     * The channel can be opened only after the recipient confirms it and only on a session
     * change.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} recipient
     * @param {number} proposedMaxCapacity
     * @param {number} proposedMaxMessageSize
     **/
    hrmpInitOpenChannel: GenericTxCall<
      Rv,
      (
        recipient: PolkadotParachainPrimitivesPrimitivesId,
        proposedMaxCapacity: number,
        proposedMaxMessageSize: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Hrmp';
          palletCall: {
            name: 'HrmpInitOpenChannel';
            params: {
              recipient: PolkadotParachainPrimitivesPrimitivesId;
              proposedMaxCapacity: number;
              proposedMaxMessageSize: number;
            };
          };
        }
      >
    >;

    /**
     * Accept a pending open channel request from the given sender.
     *
     * The channel will be opened only on the next session boundary.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} sender
     **/
    hrmpAcceptOpenChannel: GenericTxCall<
      Rv,
      (sender: PolkadotParachainPrimitivesPrimitivesId) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Hrmp';
          palletCall: {
            name: 'HrmpAcceptOpenChannel';
            params: { sender: PolkadotParachainPrimitivesPrimitivesId };
          };
        }
      >
    >;

    /**
     * Initiate unilateral closing of a channel. The origin must be either the sender or the
     * recipient in the channel being closed.
     *
     * The closure can only happen on a session change.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesHrmpChannelId} channelId
     **/
    hrmpCloseChannel: GenericTxCall<
      Rv,
      (channelId: PolkadotParachainPrimitivesPrimitivesHrmpChannelId) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Hrmp';
          palletCall: {
            name: 'HrmpCloseChannel';
            params: { channelId: PolkadotParachainPrimitivesPrimitivesHrmpChannelId };
          };
        }
      >
    >;

    /**
     * This extrinsic triggers the cleanup of all the HRMP storage items that a para may have.
     * Normally this happens once per session, but this allows you to trigger the cleanup
     * immediately for a specific parachain.
     *
     * Number of inbound and outbound channels for `para` must be provided as witness data.
     *
     * Origin must be the `ChannelManager`.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} para
     * @param {number} numInbound
     * @param {number} numOutbound
     **/
    forceCleanHrmp: GenericTxCall<
      Rv,
      (
        para: PolkadotParachainPrimitivesPrimitivesId,
        numInbound: number,
        numOutbound: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Hrmp';
          palletCall: {
            name: 'ForceCleanHrmp';
            params: { para: PolkadotParachainPrimitivesPrimitivesId; numInbound: number; numOutbound: number };
          };
        }
      >
    >;

    /**
     * Force process HRMP open channel requests.
     *
     * If there are pending HRMP open channel requests, you can use this function to process
     * all of those requests immediately.
     *
     * Total number of opening channels must be provided as witness data.
     *
     * Origin must be the `ChannelManager`.
     *
     * @param {number} channels
     **/
    forceProcessHrmpOpen: GenericTxCall<
      Rv,
      (channels: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Hrmp';
          palletCall: {
            name: 'ForceProcessHrmpOpen';
            params: { channels: number };
          };
        }
      >
    >;

    /**
     * Force process HRMP close channel requests.
     *
     * If there are pending HRMP close channel requests, you can use this function to process
     * all of those requests immediately.
     *
     * Total number of closing channels must be provided as witness data.
     *
     * Origin must be the `ChannelManager`.
     *
     * @param {number} channels
     **/
    forceProcessHrmpClose: GenericTxCall<
      Rv,
      (channels: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Hrmp';
          palletCall: {
            name: 'ForceProcessHrmpClose';
            params: { channels: number };
          };
        }
      >
    >;

    /**
     * This cancels a pending open channel request. It can be canceled by either of the sender
     * or the recipient for that request. The origin must be either of those.
     *
     * The cancellation happens immediately. It is not possible to cancel the request if it is
     * already accepted.
     *
     * Total number of open requests (i.e. `HrmpOpenChannelRequestsList`) must be provided as
     * witness data.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesHrmpChannelId} channelId
     * @param {number} openRequests
     **/
    hrmpCancelOpenRequest: GenericTxCall<
      Rv,
      (
        channelId: PolkadotParachainPrimitivesPrimitivesHrmpChannelId,
        openRequests: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Hrmp';
          palletCall: {
            name: 'HrmpCancelOpenRequest';
            params: { channelId: PolkadotParachainPrimitivesPrimitivesHrmpChannelId; openRequests: number };
          };
        }
      >
    >;

    /**
     * Open a channel from a `sender` to a `recipient` `ParaId`. Although opened by governance,
     * the `max_capacity` and `max_message_size` are still subject to the Relay Chain's
     * configured limits.
     *
     * Expected use is when one (and only one) of the `ParaId`s involved in the channel is
     * governed by the system, e.g. a system parachain.
     *
     * Origin must be the `ChannelManager`.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} sender
     * @param {PolkadotParachainPrimitivesPrimitivesId} recipient
     * @param {number} maxCapacity
     * @param {number} maxMessageSize
     **/
    forceOpenHrmpChannel: GenericTxCall<
      Rv,
      (
        sender: PolkadotParachainPrimitivesPrimitivesId,
        recipient: PolkadotParachainPrimitivesPrimitivesId,
        maxCapacity: number,
        maxMessageSize: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Hrmp';
          palletCall: {
            name: 'ForceOpenHrmpChannel';
            params: {
              sender: PolkadotParachainPrimitivesPrimitivesId;
              recipient: PolkadotParachainPrimitivesPrimitivesId;
              maxCapacity: number;
              maxMessageSize: number;
            };
          };
        }
      >
    >;

    /**
     * Establish an HRMP channel between two system chains. If the channel does not already
     * exist, the transaction fees will be refunded to the caller. The system does not take
     * deposits for channels between system chains, and automatically sets the message number
     * and size limits to the maximum allowed by the network's configuration.
     *
     * Arguments:
     *
     * - `sender`: A system chain, `ParaId`.
     * - `recipient`: A system chain, `ParaId`.
     *
     * Any signed origin can call this function, but _both_ inputs MUST be system chains. If
     * the channel does not exist yet, there is no fee.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} sender
     * @param {PolkadotParachainPrimitivesPrimitivesId} recipient
     **/
    establishSystemChannel: GenericTxCall<
      Rv,
      (
        sender: PolkadotParachainPrimitivesPrimitivesId,
        recipient: PolkadotParachainPrimitivesPrimitivesId,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Hrmp';
          palletCall: {
            name: 'EstablishSystemChannel';
            params: {
              sender: PolkadotParachainPrimitivesPrimitivesId;
              recipient: PolkadotParachainPrimitivesPrimitivesId;
            };
          };
        }
      >
    >;

    /**
     * Update the deposits held for an HRMP channel to the latest `Configuration`. Channels
     * with system chains do not require a deposit.
     *
     * Arguments:
     *
     * - `sender`: A chain, `ParaId`.
     * - `recipient`: A chain, `ParaId`.
     *
     * Any signed origin can call this function.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} sender
     * @param {PolkadotParachainPrimitivesPrimitivesId} recipient
     **/
    pokeChannelDeposits: GenericTxCall<
      Rv,
      (
        sender: PolkadotParachainPrimitivesPrimitivesId,
        recipient: PolkadotParachainPrimitivesPrimitivesId,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Hrmp';
          palletCall: {
            name: 'PokeChannelDeposits';
            params: {
              sender: PolkadotParachainPrimitivesPrimitivesId;
              recipient: PolkadotParachainPrimitivesPrimitivesId;
            };
          };
        }
      >
    >;

    /**
     * Establish a bidirectional HRMP channel between a parachain and a system chain.
     *
     * Arguments:
     *
     * - `target_system_chain`: A system chain, `ParaId`.
     *
     * The origin needs to be the parachain origin.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} targetSystemChain
     **/
    establishChannelWithSystem: GenericTxCall<
      Rv,
      (targetSystemChain: PolkadotParachainPrimitivesPrimitivesId) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Hrmp';
          palletCall: {
            name: 'EstablishChannelWithSystem';
            params: { targetSystemChain: PolkadotParachainPrimitivesPrimitivesId };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `ParasDisputes`'s transaction calls
   **/
  parasDisputes: {
    /**
     *
     **/
    forceUnfreeze: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParasDisputes';
          palletCall: 'ForceUnfreeze';
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `ParasSlashing`'s transaction calls
   **/
  parasSlashing: {
    /**
     *
     * @param {PolkadotPrimitivesV7SlashingDisputeProof} disputeProof
     * @param {SpSessionMembershipProof} keyOwnerProof
     **/
    reportDisputeLostUnsigned: GenericTxCall<
      Rv,
      (
        disputeProof: PolkadotPrimitivesV7SlashingDisputeProof,
        keyOwnerProof: SpSessionMembershipProof,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParasSlashing';
          palletCall: {
            name: 'ReportDisputeLostUnsigned';
            params: { disputeProof: PolkadotPrimitivesV7SlashingDisputeProof; keyOwnerProof: SpSessionMembershipProof };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `MessageQueue`'s transaction calls
   **/
  messageQueue: {
    /**
     * Remove a page which has no more messages remaining to be processed or is stale.
     *
     * @param {PolkadotRuntimeParachainsInclusionAggregateMessageOrigin} messageOrigin
     * @param {number} pageIndex
     **/
    reapPage: GenericTxCall<
      Rv,
      (
        messageOrigin: PolkadotRuntimeParachainsInclusionAggregateMessageOrigin,
        pageIndex: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'MessageQueue';
          palletCall: {
            name: 'ReapPage';
            params: { messageOrigin: PolkadotRuntimeParachainsInclusionAggregateMessageOrigin; pageIndex: number };
          };
        }
      >
    >;

    /**
     * Execute an overweight message.
     *
     * Temporary processing errors will be propagated whereas permanent errors are treated
     * as success condition.
     *
     * - `origin`: Must be `Signed`.
     * - `message_origin`: The origin from which the message to be executed arrived.
     * - `page`: The page in the queue in which the message to be executed is sitting.
     * - `index`: The index into the queue of the message to be executed.
     * - `weight_limit`: The maximum amount of weight allowed to be consumed in the execution
     * of the message.
     *
     * Benchmark complexity considerations: O(index + weight_limit).
     *
     * @param {PolkadotRuntimeParachainsInclusionAggregateMessageOrigin} messageOrigin
     * @param {number} page
     * @param {number} index
     * @param {SpWeightsWeightV2Weight} weightLimit
     **/
    executeOverweight: GenericTxCall<
      Rv,
      (
        messageOrigin: PolkadotRuntimeParachainsInclusionAggregateMessageOrigin,
        page: number,
        index: number,
        weightLimit: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'MessageQueue';
          palletCall: {
            name: 'ExecuteOverweight';
            params: {
              messageOrigin: PolkadotRuntimeParachainsInclusionAggregateMessageOrigin;
              page: number;
              index: number;
              weightLimit: SpWeightsWeightV2Weight;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `OnDemandAssignmentProvider`'s transaction calls
   **/
  onDemandAssignmentProvider: {
    /**
     * Create a single on demand core order.
     * Will use the spot price for the current block and will reap the account if needed.
     *
     * Parameters:
     * - `origin`: The sender of the call, funds will be withdrawn from this account.
     * - `max_amount`: The maximum balance to withdraw from the origin to place an order.
     * - `para_id`: A `ParaId` the origin wants to provide blockspace for.
     *
     * Errors:
     * - `InsufficientBalance`: from the Currency implementation
     * - `QueueFull`
     * - `SpotPriceHigherThanMaxAmount`
     *
     * Events:
     * - `OnDemandOrderPlaced`
     *
     * @param {bigint} maxAmount
     * @param {PolkadotParachainPrimitivesPrimitivesId} paraId
     **/
    placeOrderAllowDeath: GenericTxCall<
      Rv,
      (
        maxAmount: bigint,
        paraId: PolkadotParachainPrimitivesPrimitivesId,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'OnDemandAssignmentProvider';
          palletCall: {
            name: 'PlaceOrderAllowDeath';
            params: { maxAmount: bigint; paraId: PolkadotParachainPrimitivesPrimitivesId };
          };
        }
      >
    >;

    /**
     * Same as the [`place_order_allow_death`](Self::place_order_allow_death) call , but with a
     * check that placing the order will not reap the account.
     *
     * Parameters:
     * - `origin`: The sender of the call, funds will be withdrawn from this account.
     * - `max_amount`: The maximum balance to withdraw from the origin to place an order.
     * - `para_id`: A `ParaId` the origin wants to provide blockspace for.
     *
     * Errors:
     * - `InsufficientBalance`: from the Currency implementation
     * - `QueueFull`
     * - `SpotPriceHigherThanMaxAmount`
     *
     * Events:
     * - `OnDemandOrderPlaced`
     *
     * @param {bigint} maxAmount
     * @param {PolkadotParachainPrimitivesPrimitivesId} paraId
     **/
    placeOrderKeepAlive: GenericTxCall<
      Rv,
      (
        maxAmount: bigint,
        paraId: PolkadotParachainPrimitivesPrimitivesId,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'OnDemandAssignmentProvider';
          palletCall: {
            name: 'PlaceOrderKeepAlive';
            params: { maxAmount: bigint; paraId: PolkadotParachainPrimitivesPrimitivesId };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Registrar`'s transaction calls
   **/
  registrar: {
    /**
     * Register head data and validation code for a reserved Para Id.
     *
     * ## Arguments
     * - `origin`: Must be called by a `Signed` origin.
     * - `id`: The para ID. Must be owned/managed by the `origin` signing account.
     * - `genesis_head`: The genesis head data of the parachain/thread.
     * - `validation_code`: The initial validation code of the parachain/thread.
     *
     * ## Deposits/Fees
     * The account with the originating signature must reserve a deposit.
     *
     * The deposit is required to cover the costs associated with storing the genesis head
     * data and the validation code.
     * This accounts for the potential to store validation code of a size up to the
     * `max_code_size`, as defined in the configuration pallet
     *
     * Anything already reserved previously for this para ID is accounted for.
     *
     * ## Events
     * The `Registered` event is emitted in case of success.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} id
     * @param {PolkadotParachainPrimitivesPrimitivesHeadData} genesisHead
     * @param {PolkadotParachainPrimitivesPrimitivesValidationCode} validationCode
     **/
    register: GenericTxCall<
      Rv,
      (
        id: PolkadotParachainPrimitivesPrimitivesId,
        genesisHead: PolkadotParachainPrimitivesPrimitivesHeadData,
        validationCode: PolkadotParachainPrimitivesPrimitivesValidationCode,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Registrar';
          palletCall: {
            name: 'Register';
            params: {
              id: PolkadotParachainPrimitivesPrimitivesId;
              genesisHead: PolkadotParachainPrimitivesPrimitivesHeadData;
              validationCode: PolkadotParachainPrimitivesPrimitivesValidationCode;
            };
          };
        }
      >
    >;

    /**
     * Force the registration of a Para Id on the relay chain.
     *
     * This function must be called by a Root origin.
     *
     * The deposit taken can be specified for this registration. Any `ParaId`
     * can be registered, including sub-1000 IDs which are System Parachains.
     *
     * @param {AccountId32Like} who
     * @param {bigint} deposit
     * @param {PolkadotParachainPrimitivesPrimitivesId} id
     * @param {PolkadotParachainPrimitivesPrimitivesHeadData} genesisHead
     * @param {PolkadotParachainPrimitivesPrimitivesValidationCode} validationCode
     **/
    forceRegister: GenericTxCall<
      Rv,
      (
        who: AccountId32Like,
        deposit: bigint,
        id: PolkadotParachainPrimitivesPrimitivesId,
        genesisHead: PolkadotParachainPrimitivesPrimitivesHeadData,
        validationCode: PolkadotParachainPrimitivesPrimitivesValidationCode,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Registrar';
          palletCall: {
            name: 'ForceRegister';
            params: {
              who: AccountId32Like;
              deposit: bigint;
              id: PolkadotParachainPrimitivesPrimitivesId;
              genesisHead: PolkadotParachainPrimitivesPrimitivesHeadData;
              validationCode: PolkadotParachainPrimitivesPrimitivesValidationCode;
            };
          };
        }
      >
    >;

    /**
     * Deregister a Para Id, freeing all data and returning any deposit.
     *
     * The caller must be Root, the `para` owner, or the `para` itself. The para must be an
     * on-demand parachain.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} id
     **/
    deregister: GenericTxCall<
      Rv,
      (id: PolkadotParachainPrimitivesPrimitivesId) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Registrar';
          palletCall: {
            name: 'Deregister';
            params: { id: PolkadotParachainPrimitivesPrimitivesId };
          };
        }
      >
    >;

    /**
     * Swap a lease holding parachain with another parachain, either on-demand or lease
     * holding.
     *
     * The origin must be Root, the `para` owner, or the `para` itself.
     *
     * The swap will happen only if there is already an opposite swap pending. If there is not,
     * the swap will be stored in the pending swaps map, ready for a later confirmatory swap.
     *
     * The `ParaId`s remain mapped to the same head data and code so external code can rely on
     * `ParaId` to be a long-term identifier of a notional "parachain". However, their
     * scheduling info (i.e. whether they're an on-demand parachain or lease holding
     * parachain), auction information and the auction deposit are switched.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} id
     * @param {PolkadotParachainPrimitivesPrimitivesId} other
     **/
    swap: GenericTxCall<
      Rv,
      (
        id: PolkadotParachainPrimitivesPrimitivesId,
        other: PolkadotParachainPrimitivesPrimitivesId,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Registrar';
          palletCall: {
            name: 'Swap';
            params: { id: PolkadotParachainPrimitivesPrimitivesId; other: PolkadotParachainPrimitivesPrimitivesId };
          };
        }
      >
    >;

    /**
     * Remove a manager lock from a para. This will allow the manager of a
     * previously locked para to deregister or swap a para without using governance.
     *
     * Can only be called by the Root origin or the parachain.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} para
     **/
    removeLock: GenericTxCall<
      Rv,
      (para: PolkadotParachainPrimitivesPrimitivesId) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Registrar';
          palletCall: {
            name: 'RemoveLock';
            params: { para: PolkadotParachainPrimitivesPrimitivesId };
          };
        }
      >
    >;

    /**
     * Reserve a Para Id on the relay chain.
     *
     * This function will reserve a new Para Id to be owned/managed by the origin account.
     * The origin account is able to register head data and validation code using `register` to
     * create an on-demand parachain. Using the Slots pallet, an on-demand parachain can then
     * be upgraded to a lease holding parachain.
     *
     * ## Arguments
     * - `origin`: Must be called by a `Signed` origin. Becomes the manager/owner of the new
     * para ID.
     *
     * ## Deposits/Fees
     * The origin must reserve a deposit of `ParaDeposit` for the registration.
     *
     * ## Events
     * The `Reserved` event is emitted in case of success, which provides the ID reserved for
     * use.
     *
     **/
    reserve: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Registrar';
          palletCall: {
            name: 'Reserve';
          };
        }
      >
    >;

    /**
     * Add a manager lock from a para. This will prevent the manager of a
     * para to deregister or swap a para.
     *
     * Can be called by Root, the parachain, or the parachain manager if the parachain is
     * unlocked.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} para
     **/
    addLock: GenericTxCall<
      Rv,
      (para: PolkadotParachainPrimitivesPrimitivesId) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Registrar';
          palletCall: {
            name: 'AddLock';
            params: { para: PolkadotParachainPrimitivesPrimitivesId };
          };
        }
      >
    >;

    /**
     * Schedule a parachain upgrade.
     *
     * This will kick off a check of `new_code` by all validators. After the majority of the
     * validators have reported on the validity of the code, the code will either be enacted
     * or the upgrade will be rejected. If the code will be enacted, the current code of the
     * parachain will be overwritten directly. This means that any PoV will be checked by this
     * new code. The parachain itself will not be informed explicitly that the validation code
     * has changed.
     *
     * Can be called by Root, the parachain, or the parachain manager if the parachain is
     * unlocked.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} para
     * @param {PolkadotParachainPrimitivesPrimitivesValidationCode} newCode
     **/
    scheduleCodeUpgrade: GenericTxCall<
      Rv,
      (
        para: PolkadotParachainPrimitivesPrimitivesId,
        newCode: PolkadotParachainPrimitivesPrimitivesValidationCode,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Registrar';
          palletCall: {
            name: 'ScheduleCodeUpgrade';
            params: {
              para: PolkadotParachainPrimitivesPrimitivesId;
              newCode: PolkadotParachainPrimitivesPrimitivesValidationCode;
            };
          };
        }
      >
    >;

    /**
     * Set the parachain's current head.
     *
     * Can be called by Root, the parachain, or the parachain manager if the parachain is
     * unlocked.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} para
     * @param {PolkadotParachainPrimitivesPrimitivesHeadData} newHead
     **/
    setCurrentHead: GenericTxCall<
      Rv,
      (
        para: PolkadotParachainPrimitivesPrimitivesId,
        newHead: PolkadotParachainPrimitivesPrimitivesHeadData,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Registrar';
          palletCall: {
            name: 'SetCurrentHead';
            params: {
              para: PolkadotParachainPrimitivesPrimitivesId;
              newHead: PolkadotParachainPrimitivesPrimitivesHeadData;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Slots`'s transaction calls
   **/
  slots: {
    /**
     * Just a connect into the `lease_out` call, in case Root wants to force some lease to
     * happen independently of any other on-chain mechanism to use it.
     *
     * The dispatch origin for this call must match `T::ForceOrigin`.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} para
     * @param {AccountId32Like} leaser
     * @param {bigint} amount
     * @param {number} periodBegin
     * @param {number} periodCount
     **/
    forceLease: GenericTxCall<
      Rv,
      (
        para: PolkadotParachainPrimitivesPrimitivesId,
        leaser: AccountId32Like,
        amount: bigint,
        periodBegin: number,
        periodCount: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Slots';
          palletCall: {
            name: 'ForceLease';
            params: {
              para: PolkadotParachainPrimitivesPrimitivesId;
              leaser: AccountId32Like;
              amount: bigint;
              periodBegin: number;
              periodCount: number;
            };
          };
        }
      >
    >;

    /**
     * Clear all leases for a Para Id, refunding any deposits back to the original owners.
     *
     * The dispatch origin for this call must match `T::ForceOrigin`.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} para
     **/
    clearAllLeases: GenericTxCall<
      Rv,
      (para: PolkadotParachainPrimitivesPrimitivesId) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Slots';
          palletCall: {
            name: 'ClearAllLeases';
            params: { para: PolkadotParachainPrimitivesPrimitivesId };
          };
        }
      >
    >;

    /**
     * Try to onboard a parachain that has a lease for the current lease period.
     *
     * This function can be useful if there was some state issue with a para that should
     * have onboarded, but was unable to. As long as they have a lease period, we can
     * let them onboard from here.
     *
     * Origin must be signed, but can be called by anyone.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} para
     **/
    triggerOnboard: GenericTxCall<
      Rv,
      (para: PolkadotParachainPrimitivesPrimitivesId) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Slots';
          palletCall: {
            name: 'TriggerOnboard';
            params: { para: PolkadotParachainPrimitivesPrimitivesId };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Auctions`'s transaction calls
   **/
  auctions: {
    /**
     * Create a new auction.
     *
     * This can only happen when there isn't already an auction in progress and may only be
     * called by the root origin. Accepts the `duration` of this auction and the
     * `lease_period_index` of the initial lease period of the four that are to be auctioned.
     *
     * @param {number} duration
     * @param {number} leasePeriodIndex
     **/
    newAuction: GenericTxCall<
      Rv,
      (
        duration: number,
        leasePeriodIndex: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Auctions';
          palletCall: {
            name: 'NewAuction';
            params: { duration: number; leasePeriodIndex: number };
          };
        }
      >
    >;

    /**
     * Make a new bid from an account (including a parachain account) for deploying a new
     * parachain.
     *
     * Multiple simultaneous bids from the same bidder are allowed only as long as all active
     * bids overlap each other (i.e. are mutually exclusive). Bids cannot be redacted.
     *
     * - `sub` is the sub-bidder ID, allowing for multiple competing bids to be made by (and
     * funded by) the same account.
     * - `auction_index` is the index of the auction to bid on. Should just be the present
     * value of `AuctionCounter`.
     * - `first_slot` is the first lease period index of the range to bid on. This is the
     * absolute lease period index value, not an auction-specific offset.
     * - `last_slot` is the last lease period index of the range to bid on. This is the
     * absolute lease period index value, not an auction-specific offset.
     * - `amount` is the amount to bid to be held as deposit for the parachain should the
     * bid win. This amount is held throughout the range.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} para
     * @param {number} auctionIndex
     * @param {number} firstSlot
     * @param {number} lastSlot
     * @param {bigint} amount
     **/
    bid: GenericTxCall<
      Rv,
      (
        para: PolkadotParachainPrimitivesPrimitivesId,
        auctionIndex: number,
        firstSlot: number,
        lastSlot: number,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Auctions';
          palletCall: {
            name: 'Bid';
            params: {
              para: PolkadotParachainPrimitivesPrimitivesId;
              auctionIndex: number;
              firstSlot: number;
              lastSlot: number;
              amount: bigint;
            };
          };
        }
      >
    >;

    /**
     * Cancel an in-progress auction.
     *
     * Can only be called by Root origin.
     *
     **/
    cancelAuction: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Auctions';
          palletCall: {
            name: 'CancelAuction';
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Crowdloan`'s transaction calls
   **/
  crowdloan: {
    /**
     * Create a new crowdloaning campaign for a parachain slot with the given lease period
     * range.
     *
     * This applies a lock to your parachain configuration, ensuring that it cannot be changed
     * by the parachain manager.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} index
     * @param {bigint} cap
     * @param {number} firstPeriod
     * @param {number} lastPeriod
     * @param {number} end
     * @param {SpRuntimeMultiSigner | undefined} verifier
     **/
    create: GenericTxCall<
      Rv,
      (
        index: PolkadotParachainPrimitivesPrimitivesId,
        cap: bigint,
        firstPeriod: number,
        lastPeriod: number,
        end: number,
        verifier: SpRuntimeMultiSigner | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Crowdloan';
          palletCall: {
            name: 'Create';
            params: {
              index: PolkadotParachainPrimitivesPrimitivesId;
              cap: bigint;
              firstPeriod: number;
              lastPeriod: number;
              end: number;
              verifier: SpRuntimeMultiSigner | undefined;
            };
          };
        }
      >
    >;

    /**
     * Contribute to a crowd sale. This will transfer some balance over to fund a parachain
     * slot. It will be withdrawable when the crowdloan has ended and the funds are unused.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} index
     * @param {bigint} value
     * @param {SpRuntimeMultiSignature | undefined} signature
     **/
    contribute: GenericTxCall<
      Rv,
      (
        index: PolkadotParachainPrimitivesPrimitivesId,
        value: bigint,
        signature: SpRuntimeMultiSignature | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Crowdloan';
          palletCall: {
            name: 'Contribute';
            params: {
              index: PolkadotParachainPrimitivesPrimitivesId;
              value: bigint;
              signature: SpRuntimeMultiSignature | undefined;
            };
          };
        }
      >
    >;

    /**
     * Withdraw full balance of a specific contributor.
     *
     * Origin must be signed, but can come from anyone.
     *
     * The fund must be either in, or ready for, retirement. For a fund to be *in* retirement,
     * then the retirement flag must be set. For a fund to be ready for retirement, then:
     * - it must not already be in retirement;
     * - the amount of raised funds must be bigger than the _free_ balance of the account;
     * - and either:
     * - the block number must be at least `end`; or
     * - the current lease period must be greater than the fund's `last_period`.
     *
     * In this case, the fund's retirement flag is set and its `end` is reset to the current
     * block number.
     *
     * - `who`: The account whose contribution should be withdrawn.
     * - `index`: The parachain to whose crowdloan the contribution was made.
     *
     * @param {AccountId32Like} who
     * @param {PolkadotParachainPrimitivesPrimitivesId} index
     **/
    withdraw: GenericTxCall<
      Rv,
      (
        who: AccountId32Like,
        index: PolkadotParachainPrimitivesPrimitivesId,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Crowdloan';
          palletCall: {
            name: 'Withdraw';
            params: { who: AccountId32Like; index: PolkadotParachainPrimitivesPrimitivesId };
          };
        }
      >
    >;

    /**
     * Automatically refund contributors of an ended crowdloan.
     * Due to weight restrictions, this function may need to be called multiple
     * times to fully refund all users. We will refund `RemoveKeysLimit` users at a time.
     *
     * Origin must be signed, but can come from anyone.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} index
     **/
    refund: GenericTxCall<
      Rv,
      (index: PolkadotParachainPrimitivesPrimitivesId) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Crowdloan';
          palletCall: {
            name: 'Refund';
            params: { index: PolkadotParachainPrimitivesPrimitivesId };
          };
        }
      >
    >;

    /**
     * Remove a fund after the retirement period has ended and all funds have been returned.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} index
     **/
    dissolve: GenericTxCall<
      Rv,
      (index: PolkadotParachainPrimitivesPrimitivesId) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Crowdloan';
          palletCall: {
            name: 'Dissolve';
            params: { index: PolkadotParachainPrimitivesPrimitivesId };
          };
        }
      >
    >;

    /**
     * Edit the configuration for an in-progress crowdloan.
     *
     * Can only be called by Root origin.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} index
     * @param {bigint} cap
     * @param {number} firstPeriod
     * @param {number} lastPeriod
     * @param {number} end
     * @param {SpRuntimeMultiSigner | undefined} verifier
     **/
    edit: GenericTxCall<
      Rv,
      (
        index: PolkadotParachainPrimitivesPrimitivesId,
        cap: bigint,
        firstPeriod: number,
        lastPeriod: number,
        end: number,
        verifier: SpRuntimeMultiSigner | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Crowdloan';
          palletCall: {
            name: 'Edit';
            params: {
              index: PolkadotParachainPrimitivesPrimitivesId;
              cap: bigint;
              firstPeriod: number;
              lastPeriod: number;
              end: number;
              verifier: SpRuntimeMultiSigner | undefined;
            };
          };
        }
      >
    >;

    /**
     * Add an optional memo to an existing crowdloan contribution.
     *
     * Origin must be Signed, and the user must have contributed to the crowdloan.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} index
     * @param {BytesLike} memo
     **/
    addMemo: GenericTxCall<
      Rv,
      (
        index: PolkadotParachainPrimitivesPrimitivesId,
        memo: BytesLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Crowdloan';
          palletCall: {
            name: 'AddMemo';
            params: { index: PolkadotParachainPrimitivesPrimitivesId; memo: BytesLike };
          };
        }
      >
    >;

    /**
     * Poke the fund into `NewRaise`
     *
     * Origin must be Signed, and the fund has non-zero raise.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} index
     **/
    poke: GenericTxCall<
      Rv,
      (index: PolkadotParachainPrimitivesPrimitivesId) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Crowdloan';
          palletCall: {
            name: 'Poke';
            params: { index: PolkadotParachainPrimitivesPrimitivesId };
          };
        }
      >
    >;

    /**
     * Contribute your entire balance to a crowd sale. This will transfer the entire balance of
     * a user over to fund a parachain slot. It will be withdrawable when the crowdloan has
     * ended and the funds are unused.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} index
     * @param {SpRuntimeMultiSignature | undefined} signature
     **/
    contributeAll: GenericTxCall<
      Rv,
      (
        index: PolkadotParachainPrimitivesPrimitivesId,
        signature: SpRuntimeMultiSignature | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Crowdloan';
          palletCall: {
            name: 'ContributeAll';
            params: { index: PolkadotParachainPrimitivesPrimitivesId; signature: SpRuntimeMultiSignature | undefined };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Coretime`'s transaction calls
   **/
  coretime: {
    /**
     * Request the configuration to be updated with the specified number of cores. Warning:
     * Since this only schedules a configuration update, it takes two sessions to come into
     * effect.
     *
     * - `origin`: Root or the Coretime Chain
     * - `count`: total number of cores
     *
     * @param {number} count
     **/
    requestCoreCount: GenericTxCall<
      Rv,
      (count: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Coretime';
          palletCall: {
            name: 'RequestCoreCount';
            params: { count: number };
          };
        }
      >
    >;

    /**
     * Request to claim the instantaneous coretime sales revenue starting from the block it was
     * last claimed until and up to the block specified. The claimed amount value is sent back
     * to the Coretime chain in a `notify_revenue` message. At the same time, the amount is
     * teleported to the Coretime chain.
     *
     * @param {number} when
     **/
    requestRevenueAt: GenericTxCall<
      Rv,
      (when: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Coretime';
          palletCall: {
            name: 'RequestRevenueAt';
            params: { when: number };
          };
        }
      >
    >;

    /**
     * Receive instructions from the `ExternalBrokerOrigin`, detailing how a specific core is
     * to be used.
     *
     * Parameters:
     * -`origin`: The `ExternalBrokerOrigin`, assumed to be the coretime chain.
     * -`core`: The core that should be scheduled.
     * -`begin`: The starting blockheight of the instruction.
     * -`assignment`: How the blockspace should be utilised.
     * -`end_hint`: An optional hint as to when this particular set of instructions will end.
     *
     * @param {number} core
     * @param {number} begin
     * @param {Array<[PalletBrokerCoretimeInterfaceCoreAssignment, PolkadotRuntimeParachainsAssignerCoretimePartsOf57600]>} assignment
     * @param {number | undefined} endHint
     **/
    assignCore: GenericTxCall<
      Rv,
      (
        core: number,
        begin: number,
        assignment: Array<
          [PalletBrokerCoretimeInterfaceCoreAssignment, PolkadotRuntimeParachainsAssignerCoretimePartsOf57600]
        >,
        endHint: number | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Coretime';
          palletCall: {
            name: 'AssignCore';
            params: {
              core: number;
              begin: number;
              assignment: Array<
                [PalletBrokerCoretimeInterfaceCoreAssignment, PolkadotRuntimeParachainsAssignerCoretimePartsOf57600]
              >;
              endHint: number | undefined;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `XcmPallet`'s transaction calls
   **/
  xcmPallet: {
    /**
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedXcm} message
     **/
    send: GenericTxCall<
      Rv,
      (
        dest: XcmVersionedLocation,
        message: XcmVersionedXcm,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmPallet';
          palletCall: {
            name: 'Send';
            params: { dest: XcmVersionedLocation; message: XcmVersionedXcm };
          };
        }
      >
    >;

    /**
     * Teleport some assets from the local chain to some destination chain.
     *
     * **This function is deprecated: Use `limited_teleport_assets` instead.**
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` chain.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedLocation} beneficiary
     * @param {XcmVersionedAssets} assets
     * @param {number} feeAssetItem
     **/
    teleportAssets: GenericTxCall<
      Rv,
      (
        dest: XcmVersionedLocation,
        beneficiary: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        feeAssetItem: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmPallet';
          palletCall: {
            name: 'TeleportAssets';
            params: {
              dest: XcmVersionedLocation;
              beneficiary: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              feeAssetItem: number;
            };
          };
        }
      >
    >;

    /**
     * Transfer some assets from the local chain to the destination chain through their local,
     * destination or remote reserve.
     *
     * `assets` must have same reserve location and may not be teleportable to `dest`.
     * - `assets` have local reserve: transfer assets to sovereign account of destination
     * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
     * assets to `beneficiary`.
     * - `assets` have destination reserve: burn local assets and forward a notification to
     * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
     * deposit them to `beneficiary`.
     * - `assets` have remote reserve: burn local assets, forward XCM to reserve chain to move
     * reserves from this chain's SA to `dest` chain's SA, and forward another XCM to `dest`
     * to mint and deposit reserve-based assets to `beneficiary`.
     *
     * **This function is deprecated: Use `limited_reserve_transfer_assets` instead.**
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` (and possibly reserve) chains.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedLocation} beneficiary
     * @param {XcmVersionedAssets} assets
     * @param {number} feeAssetItem
     **/
    reserveTransferAssets: GenericTxCall<
      Rv,
      (
        dest: XcmVersionedLocation,
        beneficiary: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        feeAssetItem: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmPallet';
          palletCall: {
            name: 'ReserveTransferAssets';
            params: {
              dest: XcmVersionedLocation;
              beneficiary: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              feeAssetItem: number;
            };
          };
        }
      >
    >;

    /**
     * Execute an XCM message from a local, signed, origin.
     *
     * An event is deposited indicating whether `msg` could be executed completely or only
     * partially.
     *
     * No more than `max_weight` will be used in its attempted execution. If this is less than
     * the maximum amount of weight that the message could take to be executed, then no
     * execution attempt will be made.
     *
     * @param {XcmVersionedXcm} message
     * @param {SpWeightsWeightV2Weight} maxWeight
     **/
    execute: GenericTxCall<
      Rv,
      (
        message: XcmVersionedXcm,
        maxWeight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmPallet';
          palletCall: {
            name: 'Execute';
            params: { message: XcmVersionedXcm; maxWeight: SpWeightsWeightV2Weight };
          };
        }
      >
    >;

    /**
     * Extoll that a particular destination can be communicated with through a particular
     * version of XCM.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The destination that is being described.
     * - `xcm_version`: The latest version of XCM that `location` supports.
     *
     * @param {StagingXcmV4Location} location
     * @param {number} version
     **/
    forceXcmVersion: GenericTxCall<
      Rv,
      (
        location: StagingXcmV4Location,
        version: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmPallet';
          palletCall: {
            name: 'ForceXcmVersion';
            params: { location: StagingXcmV4Location; version: number };
          };
        }
      >
    >;

    /**
     * Set a safe XCM version (the version that XCM should be encoded with if the most recent
     * version a destination can accept is unknown).
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `maybe_xcm_version`: The default XCM encoding version, or `None` to disable.
     *
     * @param {number | undefined} maybeXcmVersion
     **/
    forceDefaultXcmVersion: GenericTxCall<
      Rv,
      (maybeXcmVersion: number | undefined) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmPallet';
          palletCall: {
            name: 'ForceDefaultXcmVersion';
            params: { maybeXcmVersion: number | undefined };
          };
        }
      >
    >;

    /**
     * Ask a location to notify us regarding their XCM version and any changes to it.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The location to which we should subscribe for XCM version notifications.
     *
     * @param {XcmVersionedLocation} location
     **/
    forceSubscribeVersionNotify: GenericTxCall<
      Rv,
      (location: XcmVersionedLocation) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmPallet';
          palletCall: {
            name: 'ForceSubscribeVersionNotify';
            params: { location: XcmVersionedLocation };
          };
        }
      >
    >;

    /**
     * Require that a particular destination should no longer notify us regarding any XCM
     * version changes.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The location to which we are currently subscribed for XCM version
     * notifications which we no longer desire.
     *
     * @param {XcmVersionedLocation} location
     **/
    forceUnsubscribeVersionNotify: GenericTxCall<
      Rv,
      (location: XcmVersionedLocation) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmPallet';
          palletCall: {
            name: 'ForceUnsubscribeVersionNotify';
            params: { location: XcmVersionedLocation };
          };
        }
      >
    >;

    /**
     * Transfer some assets from the local chain to the destination chain through their local,
     * destination or remote reserve.
     *
     * `assets` must have same reserve location and may not be teleportable to `dest`.
     * - `assets` have local reserve: transfer assets to sovereign account of destination
     * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
     * assets to `beneficiary`.
     * - `assets` have destination reserve: burn local assets and forward a notification to
     * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
     * deposit them to `beneficiary`.
     * - `assets` have remote reserve: burn local assets, forward XCM to reserve chain to move
     * reserves from this chain's SA to `dest` chain's SA, and forward another XCM to `dest`
     * to mint and deposit reserve-based assets to `beneficiary`.
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the sent assets may be
     * at risk.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` (and possibly reserve) chains.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedLocation} beneficiary
     * @param {XcmVersionedAssets} assets
     * @param {number} feeAssetItem
     * @param {XcmV3WeightLimit} weightLimit
     **/
    limitedReserveTransferAssets: GenericTxCall<
      Rv,
      (
        dest: XcmVersionedLocation,
        beneficiary: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        feeAssetItem: number,
        weightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmPallet';
          palletCall: {
            name: 'LimitedReserveTransferAssets';
            params: {
              dest: XcmVersionedLocation;
              beneficiary: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              feeAssetItem: number;
              weightLimit: XcmV3WeightLimit;
            };
          };
        }
      >
    >;

    /**
     * Teleport some assets from the local chain to some destination chain.
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the sent assets may be
     * at risk.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` chain.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedLocation} beneficiary
     * @param {XcmVersionedAssets} assets
     * @param {number} feeAssetItem
     * @param {XcmV3WeightLimit} weightLimit
     **/
    limitedTeleportAssets: GenericTxCall<
      Rv,
      (
        dest: XcmVersionedLocation,
        beneficiary: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        feeAssetItem: number,
        weightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmPallet';
          palletCall: {
            name: 'LimitedTeleportAssets';
            params: {
              dest: XcmVersionedLocation;
              beneficiary: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              feeAssetItem: number;
              weightLimit: XcmV3WeightLimit;
            };
          };
        }
      >
    >;

    /**
     * Set or unset the global suspension state of the XCM executor.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `suspended`: `true` to suspend, `false` to resume.
     *
     * @param {boolean} suspended
     **/
    forceSuspension: GenericTxCall<
      Rv,
      (suspended: boolean) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmPallet';
          palletCall: {
            name: 'ForceSuspension';
            params: { suspended: boolean };
          };
        }
      >
    >;

    /**
     * Transfer some assets from the local chain to the destination chain through their local,
     * destination or remote reserve, or through teleports.
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item` (hence referred to as `fees`), up to enough to pay for
     * `weight_limit` of weight. If more weight is needed than `weight_limit`, then the
     * operation will fail and the sent assets may be at risk.
     *
     * `assets` (excluding `fees`) must have same reserve location or otherwise be teleportable
     * to `dest`, no limitations imposed on `fees`.
     * - for local reserve: transfer assets to sovereign account of destination chain and
     * forward a notification XCM to `dest` to mint and deposit reserve-based assets to
     * `beneficiary`.
     * - for destination reserve: burn local assets and forward a notification to `dest` chain
     * to withdraw the reserve assets from this chain's sovereign account and deposit them
     * to `beneficiary`.
     * - for remote reserve: burn local assets, forward XCM to reserve chain to move reserves
     * from this chain's SA to `dest` chain's SA, and forward another XCM to `dest` to mint
     * and deposit reserve-based assets to `beneficiary`.
     * - for teleports: burn local assets and forward XCM to `dest` chain to mint/teleport
     * assets and deposit them to `beneficiary`.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent,
     * Parachain(..))` to send from parachain to parachain, or `X1(Parachain(..))` to send
     * from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` (and possibly reserve) chains.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedLocation} beneficiary
     * @param {XcmVersionedAssets} assets
     * @param {number} feeAssetItem
     * @param {XcmV3WeightLimit} weightLimit
     **/
    transferAssets: GenericTxCall<
      Rv,
      (
        dest: XcmVersionedLocation,
        beneficiary: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        feeAssetItem: number,
        weightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmPallet';
          palletCall: {
            name: 'TransferAssets';
            params: {
              dest: XcmVersionedLocation;
              beneficiary: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              feeAssetItem: number;
              weightLimit: XcmV3WeightLimit;
            };
          };
        }
      >
    >;

    /**
     * Claims assets trapped on this pallet because of leftover assets during XCM execution.
     *
     * - `origin`: Anyone can call this extrinsic.
     * - `assets`: The exact assets that were trapped. Use the version to specify what version
     * was the latest when they were trapped.
     * - `beneficiary`: The location/account where the claimed assets will be deposited.
     *
     * @param {XcmVersionedAssets} assets
     * @param {XcmVersionedLocation} beneficiary
     **/
    claimAssets: GenericTxCall<
      Rv,
      (
        assets: XcmVersionedAssets,
        beneficiary: XcmVersionedLocation,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmPallet';
          palletCall: {
            name: 'ClaimAssets';
            params: { assets: XcmVersionedAssets; beneficiary: XcmVersionedLocation };
          };
        }
      >
    >;

    /**
     * Transfer assets from the local chain to the destination chain using explicit transfer
     * types for assets and fees.
     *
     * `assets` must have same reserve location or may be teleportable to `dest`. Caller must
     * provide the `assets_transfer_type` to be used for `assets`:
     * - `TransferType::LocalReserve`: transfer assets to sovereign account of destination
     * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
     * assets to `beneficiary`.
     * - `TransferType::DestinationReserve`: burn local assets and forward a notification to
     * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
     * deposit them to `beneficiary`.
     * - `TransferType::RemoteReserve(reserve)`: burn local assets, forward XCM to `reserve`
     * chain to move reserves from this chain's SA to `dest` chain's SA, and forward another
     * XCM to `dest` to mint and deposit reserve-based assets to `beneficiary`. Typically
     * the remote `reserve` is Asset Hub.
     * - `TransferType::Teleport`: burn local assets and forward XCM to `dest` chain to
     * mint/teleport assets and deposit them to `beneficiary`.
     *
     * On the destination chain, as well as any intermediary hops, `BuyExecution` is used to
     * buy execution using transferred `assets` identified by `remote_fees_id`.
     * Make sure enough of the specified `remote_fees_id` asset is included in the given list
     * of `assets`. `remote_fees_id` should be enough to pay for `weight_limit`. If more weight
     * is needed than `weight_limit`, then the operation will fail and the sent assets may be
     * at risk.
     *
     * `remote_fees_id` may use different transfer type than rest of `assets` and can be
     * specified through `fees_transfer_type`.
     *
     * The caller needs to specify what should happen to the transferred assets once they reach
     * the `dest` chain. This is done through the `custom_xcm_on_dest` parameter, which
     * contains the instructions to execute on `dest` as a final step.
     * This is usually as simple as:
     * `Xcm(vec![DepositAsset { assets: Wild(AllCounted(assets.len())), beneficiary }])`,
     * but could be something more exotic like sending the `assets` even further.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain, or `(parents: 2, (GlobalConsensus(..), ..))` to send from
     * parachain across a bridge to another ecosystem destination.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` (and possibly reserve) chains.
     * - `assets_transfer_type`: The XCM `TransferType` used to transfer the `assets`.
     * - `remote_fees_id`: One of the included `assets` to be used to pay fees.
     * - `fees_transfer_type`: The XCM `TransferType` used to transfer the `fees` assets.
     * - `custom_xcm_on_dest`: The XCM to be executed on `dest` chain as the last step of the
     * transfer, which also determines what happens to the assets on the destination chain.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedAssets} assets
     * @param {StagingXcmExecutorAssetTransferTransferType} assetsTransferType
     * @param {XcmVersionedAssetId} remoteFeesId
     * @param {StagingXcmExecutorAssetTransferTransferType} feesTransferType
     * @param {XcmVersionedXcm} customXcmOnDest
     * @param {XcmV3WeightLimit} weightLimit
     **/
    transferAssetsUsingTypeAndThen: GenericTxCall<
      Rv,
      (
        dest: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        assetsTransferType: StagingXcmExecutorAssetTransferTransferType,
        remoteFeesId: XcmVersionedAssetId,
        feesTransferType: StagingXcmExecutorAssetTransferTransferType,
        customXcmOnDest: XcmVersionedXcm,
        weightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmPallet';
          palletCall: {
            name: 'TransferAssetsUsingTypeAndThen';
            params: {
              dest: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              assetsTransferType: StagingXcmExecutorAssetTransferTransferType;
              remoteFeesId: XcmVersionedAssetId;
              feesTransferType: StagingXcmExecutorAssetTransferTransferType;
              customXcmOnDest: XcmVersionedXcm;
              weightLimit: XcmV3WeightLimit;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Beefy`'s transaction calls
   **/
  beefy: {
    /**
     * Report voter equivocation/misbehavior. This method will verify the
     * equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence
     * will be reported.
     *
     * @param {SpConsensusBeefyDoubleVotingProof} equivocationProof
     * @param {SpSessionMembershipProof} keyOwnerProof
     **/
    reportEquivocation: GenericTxCall<
      Rv,
      (
        equivocationProof: SpConsensusBeefyDoubleVotingProof,
        keyOwnerProof: SpSessionMembershipProof,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Beefy';
          palletCall: {
            name: 'ReportEquivocation';
            params: { equivocationProof: SpConsensusBeefyDoubleVotingProof; keyOwnerProof: SpSessionMembershipProof };
          };
        }
      >
    >;

    /**
     * Report voter equivocation/misbehavior. This method will verify the
     * equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence
     * will be reported.
     *
     * This extrinsic must be called unsigned and it is expected that only
     * block authors will call it (validated in `ValidateUnsigned`), as such
     * if the block author is defined it will be defined as the equivocation
     * reporter.
     *
     * @param {SpConsensusBeefyDoubleVotingProof} equivocationProof
     * @param {SpSessionMembershipProof} keyOwnerProof
     **/
    reportEquivocationUnsigned: GenericTxCall<
      Rv,
      (
        equivocationProof: SpConsensusBeefyDoubleVotingProof,
        keyOwnerProof: SpSessionMembershipProof,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Beefy';
          palletCall: {
            name: 'ReportEquivocationUnsigned';
            params: { equivocationProof: SpConsensusBeefyDoubleVotingProof; keyOwnerProof: SpSessionMembershipProof };
          };
        }
      >
    >;

    /**
     * Reset BEEFY consensus by setting a new BEEFY genesis at `delay_in_blocks` blocks in the
     * future.
     *
     * Note: `delay_in_blocks` has to be at least 1.
     *
     * @param {number} delayInBlocks
     **/
    setNewGenesis: GenericTxCall<
      Rv,
      (delayInBlocks: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Beefy';
          palletCall: {
            name: 'SetNewGenesis';
            params: { delayInBlocks: number };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `IdentityMigrator`'s transaction calls
   **/
  identityMigrator: {
    /**
     * Reap the `IdentityInfo` of `who` from the Identity pallet of `T`, unreserving any
     * deposits held and removing storage items associated with `who`.
     *
     * @param {AccountId32Like} who
     **/
    reapIdentity: GenericTxCall<
      Rv,
      (who: AccountId32Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'IdentityMigrator';
          palletCall: {
            name: 'ReapIdentity';
            params: { who: AccountId32Like };
          };
        }
      >
    >;

    /**
     * Update the deposit of `who`. Meant to be called by the system with an XCM `Transact`
     * Instruction.
     *
     * @param {AccountId32Like} who
     **/
    pokeDeposit: GenericTxCall<
      Rv,
      (who: AccountId32Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'IdentityMigrator';
          palletCall: {
            name: 'PokeDeposit';
            params: { who: AccountId32Like };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `ParasSudoWrapper`'s transaction calls
   **/
  parasSudoWrapper: {
    /**
     * Schedule a para to be initialized at the start of the next session.
     *
     * This should only be used for TESTING and not on PRODUCTION chains. It automatically
     * assigns Coretime to the chain and increases the number of cores. Thus, there is no
     * running coretime chain required.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} id
     * @param {PolkadotRuntimeParachainsParasParaGenesisArgs} genesis
     **/
    sudoScheduleParaInitialize: GenericTxCall<
      Rv,
      (
        id: PolkadotParachainPrimitivesPrimitivesId,
        genesis: PolkadotRuntimeParachainsParasParaGenesisArgs,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParasSudoWrapper';
          palletCall: {
            name: 'SudoScheduleParaInitialize';
            params: {
              id: PolkadotParachainPrimitivesPrimitivesId;
              genesis: PolkadotRuntimeParachainsParasParaGenesisArgs;
            };
          };
        }
      >
    >;

    /**
     * Schedule a para to be cleaned up at the start of the next session.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} id
     **/
    sudoScheduleParaCleanup: GenericTxCall<
      Rv,
      (id: PolkadotParachainPrimitivesPrimitivesId) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParasSudoWrapper';
          palletCall: {
            name: 'SudoScheduleParaCleanup';
            params: { id: PolkadotParachainPrimitivesPrimitivesId };
          };
        }
      >
    >;

    /**
     * Upgrade a parathread (on-demand parachain) to a lease holding parachain
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} id
     **/
    sudoScheduleParathreadUpgrade: GenericTxCall<
      Rv,
      (id: PolkadotParachainPrimitivesPrimitivesId) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParasSudoWrapper';
          palletCall: {
            name: 'SudoScheduleParathreadUpgrade';
            params: { id: PolkadotParachainPrimitivesPrimitivesId };
          };
        }
      >
    >;

    /**
     * Downgrade a lease holding parachain to an on-demand parachain
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} id
     **/
    sudoScheduleParachainDowngrade: GenericTxCall<
      Rv,
      (id: PolkadotParachainPrimitivesPrimitivesId) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParasSudoWrapper';
          palletCall: {
            name: 'SudoScheduleParachainDowngrade';
            params: { id: PolkadotParachainPrimitivesPrimitivesId };
          };
        }
      >
    >;

    /**
     * Send a downward XCM to the given para.
     *
     * The given parachain should exist and the payload should not exceed the preconfigured
     * size `config.max_downward_message_size`.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} id
     * @param {XcmVersionedXcm} xcm
     **/
    sudoQueueDownwardXcm: GenericTxCall<
      Rv,
      (
        id: PolkadotParachainPrimitivesPrimitivesId,
        xcm: XcmVersionedXcm,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParasSudoWrapper';
          palletCall: {
            name: 'SudoQueueDownwardXcm';
            params: { id: PolkadotParachainPrimitivesPrimitivesId; xcm: XcmVersionedXcm };
          };
        }
      >
    >;

    /**
     * Forcefully establish a channel from the sender to the recipient.
     *
     * This is equivalent to sending an `Hrmp::hrmp_init_open_channel` extrinsic followed by
     * `Hrmp::hrmp_accept_open_channel`.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} sender
     * @param {PolkadotParachainPrimitivesPrimitivesId} recipient
     * @param {number} maxCapacity
     * @param {number} maxMessageSize
     **/
    sudoEstablishHrmpChannel: GenericTxCall<
      Rv,
      (
        sender: PolkadotParachainPrimitivesPrimitivesId,
        recipient: PolkadotParachainPrimitivesPrimitivesId,
        maxCapacity: number,
        maxMessageSize: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParasSudoWrapper';
          palletCall: {
            name: 'SudoEstablishHrmpChannel';
            params: {
              sender: PolkadotParachainPrimitivesPrimitivesId;
              recipient: PolkadotParachainPrimitivesPrimitivesId;
              maxCapacity: number;
              maxMessageSize: number;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `AssignedSlots`'s transaction calls
   **/
  assignedSlots: {
    /**
     * Assign a permanent parachain slot and immediately create a lease for it.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} id
     **/
    assignPermParachainSlot: GenericTxCall<
      Rv,
      (id: PolkadotParachainPrimitivesPrimitivesId) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'AssignedSlots';
          palletCall: {
            name: 'AssignPermParachainSlot';
            params: { id: PolkadotParachainPrimitivesPrimitivesId };
          };
        }
      >
    >;

    /**
     * Assign a temporary parachain slot. The function tries to create a lease for it
     * immediately if `SlotLeasePeriodStart::Current` is specified, and if the number
     * of currently active temporary slots is below `MaxTemporarySlotPerLeasePeriod`.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} id
     * @param {PolkadotRuntimeCommonAssignedSlotsSlotLeasePeriodStart} leasePeriodStart
     **/
    assignTempParachainSlot: GenericTxCall<
      Rv,
      (
        id: PolkadotParachainPrimitivesPrimitivesId,
        leasePeriodStart: PolkadotRuntimeCommonAssignedSlotsSlotLeasePeriodStart,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'AssignedSlots';
          palletCall: {
            name: 'AssignTempParachainSlot';
            params: {
              id: PolkadotParachainPrimitivesPrimitivesId;
              leasePeriodStart: PolkadotRuntimeCommonAssignedSlotsSlotLeasePeriodStart;
            };
          };
        }
      >
    >;

    /**
     * Unassign a permanent or temporary parachain slot
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} id
     **/
    unassignParachainSlot: GenericTxCall<
      Rv,
      (id: PolkadotParachainPrimitivesPrimitivesId) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'AssignedSlots';
          palletCall: {
            name: 'UnassignParachainSlot';
            params: { id: PolkadotParachainPrimitivesPrimitivesId };
          };
        }
      >
    >;

    /**
     * Sets the storage value [`MaxPermanentSlots`].
     *
     * @param {number} slots
     **/
    setMaxPermanentSlots: GenericTxCall<
      Rv,
      (slots: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'AssignedSlots';
          palletCall: {
            name: 'SetMaxPermanentSlots';
            params: { slots: number };
          };
        }
      >
    >;

    /**
     * Sets the storage value [`MaxTemporarySlots`].
     *
     * @param {number} slots
     **/
    setMaxTemporarySlots: GenericTxCall<
      Rv,
      (slots: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'AssignedSlots';
          palletCall: {
            name: 'SetMaxTemporarySlots';
            params: { slots: number };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `ValidatorManager`'s transaction calls
   **/
  validatorManager: {
    /**
     * Add new validators to the set.
     *
     * The new validators will be active from current session + 2.
     *
     * @param {Array<AccountId32Like>} validators
     **/
    registerValidators: GenericTxCall<
      Rv,
      (validators: Array<AccountId32Like>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ValidatorManager';
          palletCall: {
            name: 'RegisterValidators';
            params: { validators: Array<AccountId32Like> };
          };
        }
      >
    >;

    /**
     * Remove validators from the set.
     *
     * The removed validators will be deactivated from current session + 2.
     *
     * @param {Array<AccountId32Like>} validators
     **/
    deregisterValidators: GenericTxCall<
      Rv,
      (validators: Array<AccountId32Like>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ValidatorManager';
          palletCall: {
            name: 'DeregisterValidators';
            params: { validators: Array<AccountId32Like> };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `StateTrieMigration`'s transaction calls
   **/
  stateTrieMigration: {
    /**
     * Control the automatic migration.
     *
     * The dispatch origin of this call must be [`Config::ControlOrigin`].
     *
     * @param {PalletStateTrieMigrationMigrationLimits | undefined} maybeConfig
     **/
    controlAutoMigration: GenericTxCall<
      Rv,
      (maybeConfig: PalletStateTrieMigrationMigrationLimits | undefined) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'StateTrieMigration';
          palletCall: {
            name: 'ControlAutoMigration';
            params: { maybeConfig: PalletStateTrieMigrationMigrationLimits | undefined };
          };
        }
      >
    >;

    /**
     * Continue the migration for the given `limits`.
     *
     * The dispatch origin of this call can be any signed account.
     *
     * This transaction has NO MONETARY INCENTIVES. calling it will not reward anyone. Albeit,
     * Upon successful execution, the transaction fee is returned.
     *
     * The (potentially over-estimated) of the byte length of all the data read must be
     * provided for up-front fee-payment and weighing. In essence, the caller is guaranteeing
     * that executing the current `MigrationTask` with the given `limits` will not exceed
     * `real_size_upper` bytes of read data.
     *
     * The `witness_task` is merely a helper to prevent the caller from being slashed or
     * generally trigger a migration that they do not intend. This parameter is just a message
     * from caller, saying that they believed `witness_task` was the last state of the
     * migration, and they only wish for their transaction to do anything, if this assumption
     * holds. In case `witness_task` does not match, the transaction fails.
     *
     * Based on the documentation of [`MigrationTask::migrate_until_exhaustion`], the
     * recommended way of doing this is to pass a `limit` that only bounds `count`, as the
     * `size` limit can always be overwritten.
     *
     * @param {PalletStateTrieMigrationMigrationLimits} limits
     * @param {number} realSizeUpper
     * @param {PalletStateTrieMigrationMigrationTask} witnessTask
     **/
    continueMigrate: GenericTxCall<
      Rv,
      (
        limits: PalletStateTrieMigrationMigrationLimits,
        realSizeUpper: number,
        witnessTask: PalletStateTrieMigrationMigrationTask,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'StateTrieMigration';
          palletCall: {
            name: 'ContinueMigrate';
            params: {
              limits: PalletStateTrieMigrationMigrationLimits;
              realSizeUpper: number;
              witnessTask: PalletStateTrieMigrationMigrationTask;
            };
          };
        }
      >
    >;

    /**
     * Migrate the list of top keys by iterating each of them one by one.
     *
     * This does not affect the global migration process tracker ([`MigrationProcess`]), and
     * should only be used in case any keys are leftover due to a bug.
     *
     * @param {Array<BytesLike>} keys
     * @param {number} witnessSize
     **/
    migrateCustomTop: GenericTxCall<
      Rv,
      (
        keys: Array<BytesLike>,
        witnessSize: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'StateTrieMigration';
          palletCall: {
            name: 'MigrateCustomTop';
            params: { keys: Array<BytesLike>; witnessSize: number };
          };
        }
      >
    >;

    /**
     * Migrate the list of child keys by iterating each of them one by one.
     *
     * All of the given child keys must be present under one `child_root`.
     *
     * This does not affect the global migration process tracker ([`MigrationProcess`]), and
     * should only be used in case any keys are leftover due to a bug.
     *
     * @param {BytesLike} root
     * @param {Array<BytesLike>} childKeys
     * @param {number} totalSize
     **/
    migrateCustomChild: GenericTxCall<
      Rv,
      (
        root: BytesLike,
        childKeys: Array<BytesLike>,
        totalSize: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'StateTrieMigration';
          palletCall: {
            name: 'MigrateCustomChild';
            params: { root: BytesLike; childKeys: Array<BytesLike>; totalSize: number };
          };
        }
      >
    >;

    /**
     * Set the maximum limit of the signed migration.
     *
     * @param {PalletStateTrieMigrationMigrationLimits} limits
     **/
    setSignedMaxLimits: GenericTxCall<
      Rv,
      (limits: PalletStateTrieMigrationMigrationLimits) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'StateTrieMigration';
          palletCall: {
            name: 'SetSignedMaxLimits';
            params: { limits: PalletStateTrieMigrationMigrationLimits };
          };
        }
      >
    >;

    /**
     * Forcefully set the progress the running migration.
     *
     * This is only useful in one case: the next key to migrate is too big to be migrated with
     * a signed account, in a parachain context, and we simply want to skip it. A reasonable
     * example of this would be `:code:`, which is both very expensive to migrate, and commonly
     * used, so probably it is already migrated.
     *
     * In case you mess things up, you can also, in principle, use this to reset the migration
     * process.
     *
     * @param {PalletStateTrieMigrationProgress} progressTop
     * @param {PalletStateTrieMigrationProgress} progressChild
     **/
    forceSetProgress: GenericTxCall<
      Rv,
      (
        progressTop: PalletStateTrieMigrationProgress,
        progressChild: PalletStateTrieMigrationProgress,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'StateTrieMigration';
          palletCall: {
            name: 'ForceSetProgress';
            params: { progressTop: PalletStateTrieMigrationProgress; progressChild: PalletStateTrieMigrationProgress };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `RootTesting`'s transaction calls
   **/
  rootTesting: {
    /**
     * A dispatch that will fill the block weight up to the given ratio.
     *
     * @param {Perbill} ratio
     **/
    fillBlock: GenericTxCall<
      Rv,
      (ratio: Perbill) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'RootTesting';
          palletCall: {
            name: 'FillBlock';
            params: { ratio: Perbill };
          };
        }
      >
    >;

    /**
     *
     **/
    triggerDefensive: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'RootTesting';
          palletCall: {
            name: 'TriggerDefensive';
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Sudo`'s transaction calls
   **/
  sudo: {
    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     *
     * @param {RococoRuntimeRuntimeCallLike} call
     **/
    sudo: GenericTxCall<
      Rv,
      (call: RococoRuntimeRuntimeCallLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Sudo';
          palletCall: {
            name: 'Sudo';
            params: { call: RococoRuntimeRuntimeCallLike };
          };
        }
      >
    >;

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * This function does not check the weight of the call, and instead allows the
     * Sudo user to specify the weight of the call.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * @param {RococoRuntimeRuntimeCallLike} call
     * @param {SpWeightsWeightV2Weight} weight
     **/
    sudoUncheckedWeight: GenericTxCall<
      Rv,
      (
        call: RococoRuntimeRuntimeCallLike,
        weight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Sudo';
          palletCall: {
            name: 'SudoUncheckedWeight';
            params: { call: RococoRuntimeRuntimeCallLike; weight: SpWeightsWeightV2Weight };
          };
        }
      >
    >;

    /**
     * Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo
     * key.
     *
     * @param {MultiAddressLike} new_
     **/
    setKey: GenericTxCall<
      Rv,
      (new_: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Sudo';
          palletCall: {
            name: 'SetKey';
            params: { new: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Authenticates the sudo key and dispatches a function call with `Signed` origin from
     * a given account.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * @param {MultiAddressLike} who
     * @param {RococoRuntimeRuntimeCallLike} call
     **/
    sudoAs: GenericTxCall<
      Rv,
      (
        who: MultiAddressLike,
        call: RococoRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Sudo';
          palletCall: {
            name: 'SudoAs';
            params: { who: MultiAddressLike; call: RococoRuntimeRuntimeCallLike };
          };
        }
      >
    >;

    /**
     * Permanently removes the sudo key.
     *
     * **This cannot be un-done.**
     *
     **/
    removeKey: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Sudo';
          palletCall: {
            name: 'RemoveKey';
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
}
