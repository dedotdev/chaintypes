// Generated by dedot cli

import type {
  GenericChainTx,
  GenericTxCall,
  GenericChainKnownTypes,
  ISubmittableExtrinsic,
  ISubmittableResult,
  IRuntimeTxCall,
} from 'dedot/types';
import type {
  MultiAddressLike,
  Extrinsic,
  BytesLike,
  H256,
  FixedBytes,
  AccountId32Like,
  EthereumAddressLike,
  FixedU128,
  Perbill,
  Percent,
} from 'dedot/codecs';
import type {
  AssetHubPolkadotRuntimeRuntimeCallLike,
  SpRuntimeMultiSignature,
  FrameSystemEventRecord,
  AssetHubPolkadotRuntimeRuntimeTask,
  CumulusPalletParachainSystemParachainInherentBasicParachainInherentData,
  CumulusPalletParachainSystemParachainInherentInboundMessagesData,
  AssetHubPolkadotRuntimeRuntimeParameters,
  PalletBalancesAdjustmentDirection,
  PalletVestingVestingInfo,
  PolkadotRuntimeCommonClaimsEcdsaSignature,
  PolkadotRuntimeCommonClaimsStatementKind,
  AssetHubPolkadotRuntimeSessionKeys,
  XcmVersionedLocation,
  XcmVersionedXcm,
  XcmVersionedAssets,
  SpWeightsWeightV2Weight,
  StagingXcmV5Location,
  XcmV3WeightLimit,
  StagingXcmExecutorAssetTransferTransferType,
  XcmVersionedAssetId,
  CumulusPrimitivesCoreAggregateMessageOrigin,
  SnowbridgeCoreOperatingModeBasicOperatingMode,
  SnowbridgeCoreAssetMetadata,
  StagingXcmV5Asset,
  SnowbridgeCoreRewardMessageId,
  AssetHubPolkadotRuntimeOriginCaller,
  PalletMultisigTimepoint,
  AssetHubPolkadotRuntimeProxyType,
  PalletUniquesDestroyWitness,
  PalletNftsCollectionConfig,
  PalletNftsDestroyWitness,
  PalletNftsMintWitness,
  PalletNftsItemConfig,
  PalletNftsBitFlags,
  PalletNftsAttributeNamespace,
  PalletNftsCancelAttributesApprovalWitness,
  PalletNftsMintSettings,
  PalletNftsItemTip,
  PalletNftsPriceWithDirection,
  PalletNftsPreSignedMint,
  PalletNftsPreSignedAttributes,
  PolkadotRuntimeCommonImplsVersionedLocatableAsset,
  ParachainsCommonPayVersionedLocatableAccount,
  PalletConvictionVotingVoteAccountVote,
  PalletConvictionVotingConviction,
  FrameSupportPreimagesBounded,
  FrameSupportScheduleDispatchTime,
  PalletStateTrieMigrationMigrationLimits,
  PalletStateTrieMigrationMigrationTask,
  PalletStateTrieMigrationProgress,
  PalletNominationPoolsBondExtra,
  PalletNominationPoolsPoolState,
  PalletNominationPoolsConfigOp,
  PalletNominationPoolsConfigOpU32,
  PalletNominationPoolsConfigOpPerbill,
  PalletNominationPoolsConfigOp004,
  PalletNominationPoolsClaimPermission,
  PalletNominationPoolsCommissionChangeRate,
  PalletNominationPoolsCommissionClaimPermission,
  PalletStakingAsyncRcClientSessionReport,
  PalletStakingAsyncRcClientOffence,
  PalletElectionProviderMultiBlockAdminOperation,
  PalletElectionProviderMultiBlockPagedRawSolution,
  SpNposElectionsElectionScore,
  AssetHubPolkadotRuntimeStakingNposCompactSolution16,
  PalletStakingAsyncRewardDestination,
  PalletStakingAsyncValidatorPrefs,
  PalletStakingAsyncPalletConfigOp,
  PalletStakingAsyncPalletConfigOpU32,
  PalletStakingAsyncPalletConfigOpPercent,
  PalletStakingAsyncPalletConfigOpPerbill,
  PalletStakingAsyncLedgerUnlockChunk,
  PolkadotParachainPrimitivesPrimitivesId,
  PalletRcMigratorAccountsAccount,
  PalletRcMigratorMultisigRcMultisig,
  PalletRcMigratorProxyRcProxy,
  PalletRcMigratorProxyRcProxyAnnouncement,
  PalletRcMigratorPreimageChunksRcPreimageChunk,
  PalletRcMigratorPreimageRequestStatusPortableRequestStatus,
  PalletRcMigratorPreimageLegacyRequestStatusRcPreimageLegacyStatus,
  PalletRcMigratorStakingNomPoolsRcNomPoolsMessage,
  PalletRcMigratorVestingRcVestingSchedule,
  PalletRcMigratorReferendaReferendaMessage,
  PalletReferendaReferendumInfo,
  PalletRcMigratorClaimsRcClaimsMessage,
  PalletRcMigratorStakingBagsListPortableBagsListMessage,
  PalletRcMigratorSchedulerRcSchedulerMessage,
  PalletRcMigratorIndicesRcIndicesIndex,
  PalletRcMigratorConvictionVotingRcConvictionVotingMessage,
  PalletRcMigratorBountiesRcBountiesMessage,
  PalletRcMigratorCrowdloanRcCrowdloanMessage,
  PalletRcMigratorTreasuryPortableTreasuryMessage,
  PalletRcMigratorSchedulerSchedulerAgendaMessage,
  PalletRcMigratorStakingDelegatedStakingPortableDelegatedStakingMessage,
  PalletRcMigratorChildBountiesPortableChildBountiesMessage,
  PalletRcMigratorStakingMessagePortableStakingMessage,
  PalletAhMigratorMigrationStage,
  PalletRcMigratorQueuePriority,
  PalletRcMigratorMigrationFinishedData,
} from './types.js';

export type ChainSubmittableExtrinsic<
  T extends IRuntimeTxCall = AssetHubPolkadotRuntimeRuntimeCallLike,
  ChainKnownTypes extends GenericChainKnownTypes = GenericChainKnownTypes,
> = Extrinsic<MultiAddressLike, T, SpRuntimeMultiSignature, ChainKnownTypes['Extra']> &
  ISubmittableExtrinsic<ISubmittableResult<FrameSystemEventRecord>, ChainKnownTypes['AssetId']>;

export type TxCall<ChainKnownTypes extends GenericChainKnownTypes = GenericChainKnownTypes> = (
  ...args: any[]
) => ChainSubmittableExtrinsic<AssetHubPolkadotRuntimeRuntimeCallLike, ChainKnownTypes>;

export interface ChainTx<
  ChainKnownTypes extends GenericChainKnownTypes = GenericChainKnownTypes,
> extends GenericChainTx<TxCall<ChainKnownTypes>> {
  /**
   * Pallet `System`'s transaction calls
   **/
  system: {
    /**
     * Make some on-chain remark.
     *
     * Can be executed by every `origin`.
     *
     * @param {BytesLike} remark
     **/
    remark: GenericTxCall<
      (remark: BytesLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'System';
          palletCall: {
            name: 'Remark';
            params: { remark: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the number of pages in the WebAssembly environment's heap.
     *
     * @param {bigint} pages
     **/
    setHeapPages: GenericTxCall<
      (pages: bigint) => ChainSubmittableExtrinsic<
        {
          pallet: 'System';
          palletCall: {
            name: 'SetHeapPages';
            params: { pages: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the new runtime code.
     *
     * @param {BytesLike} code
     **/
    setCode: GenericTxCall<
      (code: BytesLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'System';
          palletCall: {
            name: 'SetCode';
            params: { code: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the new runtime code without doing any checks of the given `code`.
     *
     * Note that runtime upgrades will not run if this is called with a not-increasing spec
     * version!
     *
     * @param {BytesLike} code
     **/
    setCodeWithoutChecks: GenericTxCall<
      (code: BytesLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'System';
          palletCall: {
            name: 'SetCodeWithoutChecks';
            params: { code: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set some items of storage.
     *
     * @param {Array<[BytesLike, BytesLike]>} items
     **/
    setStorage: GenericTxCall<
      (items: Array<[BytesLike, BytesLike]>) => ChainSubmittableExtrinsic<
        {
          pallet: 'System';
          palletCall: {
            name: 'SetStorage';
            params: { items: Array<[BytesLike, BytesLike]> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Kill some items from storage.
     *
     * @param {Array<BytesLike>} keys
     **/
    killStorage: GenericTxCall<
      (keys: Array<BytesLike>) => ChainSubmittableExtrinsic<
        {
          pallet: 'System';
          palletCall: {
            name: 'KillStorage';
            params: { keys: Array<BytesLike> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Kill all storage items with a key that starts with the given prefix.
     *
     * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
     * the prefix we are removing to accurately calculate the weight of this function.
     *
     * @param {BytesLike} prefix
     * @param {number} subkeys
     **/
    killPrefix: GenericTxCall<
      (
        prefix: BytesLike,
        subkeys: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'System';
          palletCall: {
            name: 'KillPrefix';
            params: { prefix: BytesLike; subkeys: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Make some on-chain remark and emit event.
     *
     * @param {BytesLike} remark
     **/
    remarkWithEvent: GenericTxCall<
      (remark: BytesLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'System';
          palletCall: {
            name: 'RemarkWithEvent';
            params: { remark: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {AssetHubPolkadotRuntimeRuntimeTask} task
     **/
    doTask: GenericTxCall<
      (task: AssetHubPolkadotRuntimeRuntimeTask) => ChainSubmittableExtrinsic<
        {
          pallet: 'System';
          palletCall: {
            name: 'DoTask';
            params: { task: AssetHubPolkadotRuntimeRuntimeTask };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
     * later.
     *
     * This call requires Root origin.
     *
     * @param {H256} codeHash
     **/
    authorizeUpgrade: GenericTxCall<
      (codeHash: H256) => ChainSubmittableExtrinsic<
        {
          pallet: 'System';
          palletCall: {
            name: 'AuthorizeUpgrade';
            params: { codeHash: H256 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
     * later.
     *
     * WARNING: This authorizes an upgrade that will take place without any safety checks, for
     * example that the spec name remains the same and that the version number increases. Not
     * recommended for normal use. Use `authorize_upgrade` instead.
     *
     * This call requires Root origin.
     *
     * @param {H256} codeHash
     **/
    authorizeUpgradeWithoutChecks: GenericTxCall<
      (codeHash: H256) => ChainSubmittableExtrinsic<
        {
          pallet: 'System';
          palletCall: {
            name: 'AuthorizeUpgradeWithoutChecks';
            params: { codeHash: H256 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Provide the preimage (runtime binary) `code` for an upgrade that has been authorized.
     *
     * If the authorization required a version check, this call will ensure the spec name
     * remains unchanged and that the spec version has increased.
     *
     * Depending on the runtime's `OnSetCode` configuration, this function may directly apply
     * the new `code` in the same block or attempt to schedule the upgrade.
     *
     * All origins are allowed.
     *
     * @param {BytesLike} code
     **/
    applyAuthorizedUpgrade: GenericTxCall<
      (code: BytesLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'System';
          palletCall: {
            name: 'ApplyAuthorizedUpgrade';
            params: { code: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `ParachainSystem`'s transaction calls
   **/
  parachainSystem: {
    /**
     * Set the current validation data.
     *
     * This should be invoked exactly once per block. It will panic at the finalization
     * phase if the call was not invoked.
     *
     * The dispatch origin for this call must be `Inherent`
     *
     * As a side effect, this function upgrades the current validation function
     * if the appropriate time has come.
     *
     * @param {CumulusPalletParachainSystemParachainInherentBasicParachainInherentData} data
     * @param {CumulusPalletParachainSystemParachainInherentInboundMessagesData} inboundMessagesData
     **/
    setValidationData: GenericTxCall<
      (
        data: CumulusPalletParachainSystemParachainInherentBasicParachainInherentData,
        inboundMessagesData: CumulusPalletParachainSystemParachainInherentInboundMessagesData,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ParachainSystem';
          palletCall: {
            name: 'SetValidationData';
            params: {
              data: CumulusPalletParachainSystemParachainInherentBasicParachainInherentData;
              inboundMessagesData: CumulusPalletParachainSystemParachainInherentInboundMessagesData;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {BytesLike} message
     **/
    sudoSendUpwardMessage: GenericTxCall<
      (message: BytesLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'ParachainSystem';
          palletCall: {
            name: 'SudoSendUpwardMessage';
            params: { message: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Timestamp`'s transaction calls
   **/
  timestamp: {
    /**
     * Set the current time.
     *
     * This call should be invoked exactly once per block. It will panic at the finalization
     * phase, if this call hasn't been invoked by that time.
     *
     * The timestamp should be greater than the previous one by the amount specified by
     * [`Config::MinimumPeriod`].
     *
     * The dispatch origin for this call must be _None_.
     *
     * This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware
     * that changing the complexity of this call could result exhausting the resources in a
     * block to execute any other calls.
     *
     * ## Complexity
     * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
     * - 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in
     * `on_finalize`)
     * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
     *
     * @param {bigint} now
     **/
    set: GenericTxCall<
      (now: bigint) => ChainSubmittableExtrinsic<
        {
          pallet: 'Timestamp';
          palletCall: {
            name: 'Set';
            params: { now: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `ParachainInfo`'s transaction calls
   **/
  parachainInfo: {
    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Preimage`'s transaction calls
   **/
  preimage: {
    /**
     * Register a preimage on-chain.
     *
     * If the preimage was previously requested, no fees or deposits are taken for providing
     * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
     *
     * @param {BytesLike} bytes
     **/
    notePreimage: GenericTxCall<
      (bytes: BytesLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'NotePreimage';
            params: { bytes: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Clear an unrequested preimage from the runtime storage.
     *
     * If `len` is provided, then it will be a much cheaper operation.
     *
     * - `hash`: The hash of the preimage to be removed from the store.
     * - `len`: The length of the preimage of `hash`.
     *
     * @param {H256} hash
     **/
    unnotePreimage: GenericTxCall<
      (hash: H256) => ChainSubmittableExtrinsic<
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'UnnotePreimage';
            params: { hash: H256 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Request a preimage be uploaded to the chain without paying any fees or deposits.
     *
     * If the preimage requests has already been provided on-chain, we unreserve any deposit
     * a user may have paid, and take the control of the preimage out of their hands.
     *
     * @param {H256} hash
     **/
    requestPreimage: GenericTxCall<
      (hash: H256) => ChainSubmittableExtrinsic<
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'RequestPreimage';
            params: { hash: H256 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Clear a previously made request for a preimage.
     *
     * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
     *
     * @param {H256} hash
     **/
    unrequestPreimage: GenericTxCall<
      (hash: H256) => ChainSubmittableExtrinsic<
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'UnrequestPreimage';
            params: { hash: H256 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Ensure that the bulk of pre-images is upgraded.
     *
     * The caller pays no fee if at least 90% of pre-images were successfully updated.
     *
     * @param {Array<H256>} hashes
     **/
    ensureUpdated: GenericTxCall<
      (hashes: Array<H256>) => ChainSubmittableExtrinsic<
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'EnsureUpdated';
            params: { hashes: Array<H256> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Scheduler`'s transaction calls
   **/
  scheduler: {
    /**
     * Anonymously schedule a task.
     *
     * @param {number} when
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {AssetHubPolkadotRuntimeRuntimeCallLike} call
     **/
    schedule: GenericTxCall<
      (
        when: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: AssetHubPolkadotRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'Schedule';
            params: {
              when: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: AssetHubPolkadotRuntimeRuntimeCallLike;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Cancel an anonymously scheduled task.
     *
     * @param {number} when
     * @param {number} index
     **/
    cancel: GenericTxCall<
      (
        when: number,
        index: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'Cancel';
            params: { when: number; index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Schedule a named task.
     *
     * @param {FixedBytes<32>} id
     * @param {number} when
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {AssetHubPolkadotRuntimeRuntimeCallLike} call
     **/
    scheduleNamed: GenericTxCall<
      (
        id: FixedBytes<32>,
        when: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: AssetHubPolkadotRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'ScheduleNamed';
            params: {
              id: FixedBytes<32>;
              when: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: AssetHubPolkadotRuntimeRuntimeCallLike;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Cancel a named scheduled task.
     *
     * @param {FixedBytes<32>} id
     **/
    cancelNamed: GenericTxCall<
      (id: FixedBytes<32>) => ChainSubmittableExtrinsic<
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'CancelNamed';
            params: { id: FixedBytes<32> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Anonymously schedule a task after a delay.
     *
     * @param {number} after
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {AssetHubPolkadotRuntimeRuntimeCallLike} call
     **/
    scheduleAfter: GenericTxCall<
      (
        after: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: AssetHubPolkadotRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'ScheduleAfter';
            params: {
              after: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: AssetHubPolkadotRuntimeRuntimeCallLike;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Schedule a named task after a delay.
     *
     * @param {FixedBytes<32>} id
     * @param {number} after
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {AssetHubPolkadotRuntimeRuntimeCallLike} call
     **/
    scheduleNamedAfter: GenericTxCall<
      (
        id: FixedBytes<32>,
        after: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: AssetHubPolkadotRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'ScheduleNamedAfter';
            params: {
              id: FixedBytes<32>;
              after: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: AssetHubPolkadotRuntimeRuntimeCallLike;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set a retry configuration for a task so that, in case its scheduled run fails, it will
     * be retried after `period` blocks, for a total amount of `retries` retries or until it
     * succeeds.
     *
     * Tasks which need to be scheduled for a retry are still subject to weight metering and
     * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
     * normally while the task is retrying.
     *
     * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
     * clones of the original task. Their retry configuration will be derived from the
     * original task's configuration, but will have a lower value for `remaining` than the
     * original `total_retries`.
     *
     * @param {[number, number]} task
     * @param {number} retries
     * @param {number} period
     **/
    setRetry: GenericTxCall<
      (
        task: [number, number],
        retries: number,
        period: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'SetRetry';
            params: { task: [number, number]; retries: number; period: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set a retry configuration for a named task so that, in case its scheduled run fails, it
     * will be retried after `period` blocks, for a total amount of `retries` retries or until
     * it succeeds.
     *
     * Tasks which need to be scheduled for a retry are still subject to weight metering and
     * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
     * normally while the task is retrying.
     *
     * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
     * clones of the original task. Their retry configuration will be derived from the
     * original task's configuration, but will have a lower value for `remaining` than the
     * original `total_retries`.
     *
     * @param {FixedBytes<32>} id
     * @param {number} retries
     * @param {number} period
     **/
    setRetryNamed: GenericTxCall<
      (
        id: FixedBytes<32>,
        retries: number,
        period: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'SetRetryNamed';
            params: { id: FixedBytes<32>; retries: number; period: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Removes the retry configuration of a task.
     *
     * @param {[number, number]} task
     **/
    cancelRetry: GenericTxCall<
      (task: [number, number]) => ChainSubmittableExtrinsic<
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'CancelRetry';
            params: { task: [number, number] };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Cancel the retry configuration of a named task.
     *
     * @param {FixedBytes<32>} id
     **/
    cancelRetryNamed: GenericTxCall<
      (id: FixedBytes<32>) => ChainSubmittableExtrinsic<
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'CancelRetryNamed';
            params: { id: FixedBytes<32> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Parameters`'s transaction calls
   **/
  parameters: {
    /**
     * Set the value of a parameter.
     *
     * The dispatch origin of this call must be `AdminOrigin` for the given `key`. Values be
     * deleted by setting them to `None`.
     *
     * @param {AssetHubPolkadotRuntimeRuntimeParameters} keyValue
     **/
    setParameter: GenericTxCall<
      (keyValue: AssetHubPolkadotRuntimeRuntimeParameters) => ChainSubmittableExtrinsic<
        {
          pallet: 'Parameters';
          palletCall: {
            name: 'SetParameter';
            params: { keyValue: AssetHubPolkadotRuntimeRuntimeParameters };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Balances`'s transaction calls
   **/
  balances: {
    /**
     * Transfer some liquid free balance to another account.
     *
     * `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
     * If the sender's account is below the existential deposit as a result
     * of the transfer, the account will be reaped.
     *
     * The dispatch origin for this call must be `Signed` by the transactor.
     *
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     **/
    transferAllowDeath: GenericTxCall<
      (
        dest: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Balances';
          palletCall: {
            name: 'TransferAllowDeath';
            params: { dest: MultiAddressLike; value: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Exactly as `transfer_allow_death`, except the origin must be root and the source account
     * may be specified.
     *
     * @param {MultiAddressLike} source
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     **/
    forceTransfer: GenericTxCall<
      (
        source: MultiAddressLike,
        dest: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Balances';
          palletCall: {
            name: 'ForceTransfer';
            params: { source: MultiAddressLike; dest: MultiAddressLike; value: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
     * kill the origin account.
     *
     * 99% of the time you want [`transfer_allow_death`] instead.
     *
     * [`transfer_allow_death`]: struct.Pallet.html#method.transfer
     *
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     **/
    transferKeepAlive: GenericTxCall<
      (
        dest: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Balances';
          palletCall: {
            name: 'TransferKeepAlive';
            params: { dest: MultiAddressLike; value: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Transfer the entire transferable balance from the caller account.
     *
     * NOTE: This function only attempts to transfer _transferable_ balances. This means that
     * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
     * transferred by this function. To ensure that this function results in a killed account,
     * you might need to prepare the account by removing any reference counters, storage
     * deposits, etc...
     *
     * The dispatch origin of this call must be Signed.
     *
     * - `dest`: The recipient of the transfer.
     * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
     * of the funds the account has, causing the sender account to be killed (false), or
     * transfer everything except at least the existential deposit, which will guarantee to
     * keep the sender account alive (true).
     *
     * @param {MultiAddressLike} dest
     * @param {boolean} keepAlive
     **/
    transferAll: GenericTxCall<
      (
        dest: MultiAddressLike,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Balances';
          palletCall: {
            name: 'TransferAll';
            params: { dest: MultiAddressLike; keepAlive: boolean };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Unreserve some balance from a user by force.
     *
     * Can only be called by ROOT.
     *
     * @param {MultiAddressLike} who
     * @param {bigint} amount
     **/
    forceUnreserve: GenericTxCall<
      (
        who: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Balances';
          palletCall: {
            name: 'ForceUnreserve';
            params: { who: MultiAddressLike; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Upgrade a specified account.
     *
     * - `origin`: Must be `Signed`.
     * - `who`: The account to be upgraded.
     *
     * This will waive the transaction fee if at least all but 10% of the accounts needed to
     * be upgraded. (We let some not have to be upgraded just in order to allow for the
     * possibility of churn).
     *
     * @param {Array<AccountId32Like>} who
     **/
    upgradeAccounts: GenericTxCall<
      (who: Array<AccountId32Like>) => ChainSubmittableExtrinsic<
        {
          pallet: 'Balances';
          palletCall: {
            name: 'UpgradeAccounts';
            params: { who: Array<AccountId32Like> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the regular balance of a given account.
     *
     * The dispatch origin for this call is `root`.
     *
     * @param {MultiAddressLike} who
     * @param {bigint} newFree
     **/
    forceSetBalance: GenericTxCall<
      (
        who: MultiAddressLike,
        newFree: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Balances';
          palletCall: {
            name: 'ForceSetBalance';
            params: { who: MultiAddressLike; newFree: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Adjust the total issuance in a saturating way.
     *
     * Can only be called by root and always needs a positive `delta`.
     *
     * # Example
     *
     * @param {PalletBalancesAdjustmentDirection} direction
     * @param {bigint} delta
     **/
    forceAdjustTotalIssuance: GenericTxCall<
      (
        direction: PalletBalancesAdjustmentDirection,
        delta: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Balances';
          palletCall: {
            name: 'ForceAdjustTotalIssuance';
            params: { direction: PalletBalancesAdjustmentDirection; delta: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Burn the specified liquid free balance from the origin account.
     *
     * If the origin's account ends up below the existential deposit as a result
     * of the burn and `keep_alive` is false, the account will be reaped.
     *
     * Unlike sending funds to a _burn_ address, which merely makes the funds inaccessible,
     * this `burn` operation will reduce total issuance by the amount _burned_.
     *
     * @param {bigint} value
     * @param {boolean} keepAlive
     **/
    burn: GenericTxCall<
      (
        value: bigint,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Balances';
          palletCall: {
            name: 'Burn';
            params: { value: bigint; keepAlive: boolean };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Vesting`'s transaction calls
   **/
  vesting: {
    /**
     * Unlock any vested funds of the sender account.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have funds still
     * locked under this pallet.
     *
     * Emits either `VestingCompleted` or `VestingUpdated`.
     *
     * ## Complexity
     * - `O(1)`.
     *
     **/
    vest: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'Vesting';
          palletCall: {
            name: 'Vest';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Unlock any vested funds of a `target` account.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `target`: The account whose vested funds should be unlocked. Must have funds still
     * locked under this pallet.
     *
     * Emits either `VestingCompleted` or `VestingUpdated`.
     *
     * ## Complexity
     * - `O(1)`.
     *
     * @param {MultiAddressLike} target
     **/
    vestOther: GenericTxCall<
      (target: MultiAddressLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'Vesting';
          palletCall: {
            name: 'VestOther';
            params: { target: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Create a vested transfer.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `target`: The account receiving the vested funds.
     * - `schedule`: The vesting schedule attached to the transfer.
     *
     * Emits `VestingCreated`.
     *
     * NOTE: This will unlock all schedules through the current block.
     *
     * ## Complexity
     * - `O(1)`.
     *
     * @param {MultiAddressLike} target
     * @param {PalletVestingVestingInfo} schedule
     **/
    vestedTransfer: GenericTxCall<
      (
        target: MultiAddressLike,
        schedule: PalletVestingVestingInfo,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Vesting';
          palletCall: {
            name: 'VestedTransfer';
            params: { target: MultiAddressLike; schedule: PalletVestingVestingInfo };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Force a vested transfer.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * - `source`: The account whose funds should be transferred.
     * - `target`: The account that should be transferred the vested funds.
     * - `schedule`: The vesting schedule attached to the transfer.
     *
     * Emits `VestingCreated`.
     *
     * NOTE: This will unlock all schedules through the current block.
     *
     * ## Complexity
     * - `O(1)`.
     *
     * @param {MultiAddressLike} source
     * @param {MultiAddressLike} target
     * @param {PalletVestingVestingInfo} schedule
     **/
    forceVestedTransfer: GenericTxCall<
      (
        source: MultiAddressLike,
        target: MultiAddressLike,
        schedule: PalletVestingVestingInfo,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Vesting';
          palletCall: {
            name: 'ForceVestedTransfer';
            params: { source: MultiAddressLike; target: MultiAddressLike; schedule: PalletVestingVestingInfo };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Merge two vesting schedules together, creating a new vesting schedule that unlocks over
     * the highest possible start and end blocks. If both schedules have already started the
     * current block will be used as the schedule start; with the caveat that if one schedule
     * is finished by the current block, the other will be treated as the new merged schedule,
     * unmodified.
     *
     * NOTE: If `schedule1_index == schedule2_index` this is a no-op.
     * NOTE: This will unlock all schedules through the current block prior to merging.
     * NOTE: If both schedules have ended by the current block, no new schedule will be created
     * and both will be removed.
     *
     * Merged schedule attributes:
     * - `starting_block`: `MAX(schedule1.starting_block, scheduled2.starting_block,
     * current_block)`.
     * - `ending_block`: `MAX(schedule1.ending_block, schedule2.ending_block)`.
     * - `locked`: `schedule1.locked_at(current_block) + schedule2.locked_at(current_block)`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `schedule1_index`: index of the first schedule to merge.
     * - `schedule2_index`: index of the second schedule to merge.
     *
     * @param {number} schedule1Index
     * @param {number} schedule2Index
     **/
    mergeSchedules: GenericTxCall<
      (
        schedule1Index: number,
        schedule2Index: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Vesting';
          palletCall: {
            name: 'MergeSchedules';
            params: { schedule1Index: number; schedule2Index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Force remove a vesting schedule
     *
     * The dispatch origin for this call must be _Root_.
     *
     * - `target`: An account that has a vesting schedule
     * - `schedule_index`: The vesting schedule index that should be removed
     *
     * @param {MultiAddressLike} target
     * @param {number} scheduleIndex
     **/
    forceRemoveVestingSchedule: GenericTxCall<
      (
        target: MultiAddressLike,
        scheduleIndex: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Vesting';
          palletCall: {
            name: 'ForceRemoveVestingSchedule';
            params: { target: MultiAddressLike; scheduleIndex: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Claims`'s transaction calls
   **/
  claims: {
    /**
     * Make a claim to collect your DOTs.
     *
     * The dispatch origin for this call must be _None_.
     *
     * Unsigned Validation:
     * A call to claim is deemed valid if the signature provided matches
     * the expected signed message of:
     *
     * > Ethereum Signed Message:
     * > (configured prefix string)(address)
     *
     * and `address` matches the `dest` account.
     *
     * Parameters:
     * - `dest`: The destination account to payout the claim.
     * - `ethereum_signature`: The signature of an ethereum signed message matching the format
     * described above.
     *
     * <weight>
     * The weight of this call is invariant over the input parameters.
     * Weight includes logic to validate unsigned `claim` call.
     *
     * Total Complexity: O(1)
     * </weight>
     *
     * @param {AccountId32Like} dest
     * @param {PolkadotRuntimeCommonClaimsEcdsaSignature} ethereumSignature
     **/
    claim: GenericTxCall<
      (
        dest: AccountId32Like,
        ethereumSignature: PolkadotRuntimeCommonClaimsEcdsaSignature,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Claims';
          palletCall: {
            name: 'Claim';
            params: { dest: AccountId32Like; ethereumSignature: PolkadotRuntimeCommonClaimsEcdsaSignature };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Mint a new claim to collect DOTs.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * Parameters:
     * - `who`: The Ethereum address allowed to collect this claim.
     * - `value`: The number of DOTs that will be claimed.
     * - `vesting_schedule`: An optional vesting schedule for these DOTs.
     *
     * <weight>
     * The weight of this call is invariant over the input parameters.
     * We assume worst case that both vesting and statement is being inserted.
     *
     * Total Complexity: O(1)
     * </weight>
     *
     * @param {EthereumAddressLike} who
     * @param {bigint} value
     * @param {[bigint, bigint, number] | undefined} vestingSchedule
     * @param {PolkadotRuntimeCommonClaimsStatementKind | undefined} statement
     **/
    mintClaim: GenericTxCall<
      (
        who: EthereumAddressLike,
        value: bigint,
        vestingSchedule: [bigint, bigint, number] | undefined,
        statement: PolkadotRuntimeCommonClaimsStatementKind | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Claims';
          palletCall: {
            name: 'MintClaim';
            params: {
              who: EthereumAddressLike;
              value: bigint;
              vestingSchedule: [bigint, bigint, number] | undefined;
              statement: PolkadotRuntimeCommonClaimsStatementKind | undefined;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Make a claim to collect your DOTs by signing a statement.
     *
     * The dispatch origin for this call must be _None_.
     *
     * Unsigned Validation:
     * A call to `claim_attest` is deemed valid if the signature provided matches
     * the expected signed message of:
     *
     * > Ethereum Signed Message:
     * > (configured prefix string)(address)(statement)
     *
     * and `address` matches the `dest` account; the `statement` must match that which is
     * expected according to your purchase arrangement.
     *
     * Parameters:
     * - `dest`: The destination account to payout the claim.
     * - `ethereum_signature`: The signature of an ethereum signed message matching the format
     * described above.
     * - `statement`: The identity of the statement which is being attested to in the
     * signature.
     *
     * <weight>
     * The weight of this call is invariant over the input parameters.
     * Weight includes logic to validate unsigned `claim_attest` call.
     *
     * Total Complexity: O(1)
     * </weight>
     *
     * @param {AccountId32Like} dest
     * @param {PolkadotRuntimeCommonClaimsEcdsaSignature} ethereumSignature
     * @param {BytesLike} statement
     **/
    claimAttest: GenericTxCall<
      (
        dest: AccountId32Like,
        ethereumSignature: PolkadotRuntimeCommonClaimsEcdsaSignature,
        statement: BytesLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Claims';
          palletCall: {
            name: 'ClaimAttest';
            params: {
              dest: AccountId32Like;
              ethereumSignature: PolkadotRuntimeCommonClaimsEcdsaSignature;
              statement: BytesLike;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Attest to a statement, needed to finalize the claims process.
     *
     * WARNING: Insecure unless your chain includes `PrevalidateAttests` as a
     * `TransactionExtension`.
     *
     * Unsigned Validation:
     * A call to attest is deemed valid if the sender has a `Preclaim` registered
     * and provides a `statement` which is expected for the account.
     *
     * Parameters:
     * - `statement`: The identity of the statement which is being attested to in the
     * signature.
     *
     * <weight>
     * The weight of this call is invariant over the input parameters.
     * Weight includes logic to do pre-validation on `attest` call.
     *
     * Total Complexity: O(1)
     * </weight>
     *
     * @param {BytesLike} statement
     **/
    attest: GenericTxCall<
      (statement: BytesLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'Claims';
          palletCall: {
            name: 'Attest';
            params: { statement: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {EthereumAddressLike} old
     * @param {EthereumAddressLike} new_
     * @param {AccountId32Like | undefined} maybePreclaim
     **/
    moveClaim: GenericTxCall<
      (
        old: EthereumAddressLike,
        new_: EthereumAddressLike,
        maybePreclaim: AccountId32Like | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Claims';
          palletCall: {
            name: 'MoveClaim';
            params: { old: EthereumAddressLike; new: EthereumAddressLike; maybePreclaim: AccountId32Like | undefined };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `CollatorSelection`'s transaction calls
   **/
  collatorSelection: {
    /**
     * Set the list of invulnerable (fixed) collators. These collators must do some
     * preparation, namely to have registered session keys.
     *
     * The call will remove any accounts that have not registered keys from the set. That is,
     * it is non-atomic; the caller accepts all `AccountId`s passed in `new` _individually_ as
     * acceptable Invulnerables, and is not proposing a _set_ of new Invulnerables.
     *
     * This call does not maintain mutual exclusivity of `Invulnerables` and `Candidates`. It
     * is recommended to use a batch of `add_invulnerable` and `remove_invulnerable` instead. A
     * `batch_all` can also be used to enforce atomicity. If any candidates are included in
     * `new`, they should be removed with `remove_invulnerable_candidate` after execution.
     *
     * Must be called by the `UpdateOrigin`.
     *
     * @param {Array<AccountId32Like>} new_
     **/
    setInvulnerables: GenericTxCall<
      (new_: Array<AccountId32Like>) => ChainSubmittableExtrinsic<
        {
          pallet: 'CollatorSelection';
          palletCall: {
            name: 'SetInvulnerables';
            params: { new: Array<AccountId32Like> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the ideal number of non-invulnerable collators. If lowering this number, then the
     * number of running collators could be higher than this figure. Aside from that edge case,
     * there should be no other way to have more candidates than the desired number.
     *
     * The origin for this call must be the `UpdateOrigin`.
     *
     * @param {number} max
     **/
    setDesiredCandidates: GenericTxCall<
      (max: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'CollatorSelection';
          palletCall: {
            name: 'SetDesiredCandidates';
            params: { max: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the candidacy bond amount.
     *
     * If the candidacy bond is increased by this call, all current candidates which have a
     * deposit lower than the new bond will be kicked from the list and get their deposits
     * back.
     *
     * The origin for this call must be the `UpdateOrigin`.
     *
     * @param {bigint} bond
     **/
    setCandidacyBond: GenericTxCall<
      (bond: bigint) => ChainSubmittableExtrinsic<
        {
          pallet: 'CollatorSelection';
          palletCall: {
            name: 'SetCandidacyBond';
            params: { bond: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Register this account as a collator candidate. The account must (a) already have
     * registered session keys and (b) be able to reserve the `CandidacyBond`.
     *
     * This call is not available to `Invulnerable` collators.
     *
     **/
    registerAsCandidate: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'CollatorSelection';
          palletCall: {
            name: 'RegisterAsCandidate';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Deregister `origin` as a collator candidate. Note that the collator can only leave on
     * session change. The `CandidacyBond` will be unreserved immediately.
     *
     * This call will fail if the total number of candidates would drop below
     * `MinEligibleCollators`.
     *
     **/
    leaveIntent: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'CollatorSelection';
          palletCall: {
            name: 'LeaveIntent';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Add a new account `who` to the list of `Invulnerables` collators. `who` must have
     * registered session keys. If `who` is a candidate, they will be removed.
     *
     * The origin for this call must be the `UpdateOrigin`.
     *
     * @param {AccountId32Like} who
     **/
    addInvulnerable: GenericTxCall<
      (who: AccountId32Like) => ChainSubmittableExtrinsic<
        {
          pallet: 'CollatorSelection';
          palletCall: {
            name: 'AddInvulnerable';
            params: { who: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove an account `who` from the list of `Invulnerables` collators. `Invulnerables` must
     * be sorted.
     *
     * The origin for this call must be the `UpdateOrigin`.
     *
     * @param {AccountId32Like} who
     **/
    removeInvulnerable: GenericTxCall<
      (who: AccountId32Like) => ChainSubmittableExtrinsic<
        {
          pallet: 'CollatorSelection';
          palletCall: {
            name: 'RemoveInvulnerable';
            params: { who: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Update the candidacy bond of collator candidate `origin` to a new amount `new_deposit`.
     *
     * Setting a `new_deposit` that is lower than the current deposit while `origin` is
     * occupying a top-`DesiredCandidates` slot is not allowed.
     *
     * This call will fail if `origin` is not a collator candidate, the updated bond is lower
     * than the minimum candidacy bond, and/or the amount cannot be reserved.
     *
     * @param {bigint} newDeposit
     **/
    updateBond: GenericTxCall<
      (newDeposit: bigint) => ChainSubmittableExtrinsic<
        {
          pallet: 'CollatorSelection';
          palletCall: {
            name: 'UpdateBond';
            params: { newDeposit: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * The caller `origin` replaces a candidate `target` in the collator candidate list by
     * reserving `deposit`. The amount `deposit` reserved by the caller must be greater than
     * the existing bond of the target it is trying to replace.
     *
     * This call will fail if the caller is already a collator candidate or invulnerable, the
     * caller does not have registered session keys, the target is not a collator candidate,
     * and/or the `deposit` amount cannot be reserved.
     *
     * @param {bigint} deposit
     * @param {AccountId32Like} target
     **/
    takeCandidateSlot: GenericTxCall<
      (
        deposit: bigint,
        target: AccountId32Like,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'CollatorSelection';
          palletCall: {
            name: 'TakeCandidateSlot';
            params: { deposit: bigint; target: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Session`'s transaction calls
   **/
  session: {
    /**
     * Sets the session key(s) of the function caller to `keys`.
     * Allows an account to set its session key prior to becoming a validator.
     * This doesn't take effect until the next session.
     *
     * The dispatch origin of this function must be signed.
     *
     * ## Complexity
     * - `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is
     * fixed.
     *
     * @param {AssetHubPolkadotRuntimeSessionKeys} keys
     * @param {BytesLike} proof
     **/
    setKeys: GenericTxCall<
      (
        keys: AssetHubPolkadotRuntimeSessionKeys,
        proof: BytesLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Session';
          palletCall: {
            name: 'SetKeys';
            params: { keys: AssetHubPolkadotRuntimeSessionKeys; proof: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Removes any session key(s) of the function caller.
     *
     * This doesn't take effect until the next session.
     *
     * The dispatch origin of this function must be Signed and the account must be either be
     * convertible to a validator ID using the chain's typical addressing system (this usually
     * means being a controller account) or directly convertible into a validator ID (which
     * usually means being a stash account).
     *
     * ## Complexity
     * - `O(1)` in number of key types. Actual cost depends on the number of length of
     * `T::Keys::key_ids()` which is fixed.
     *
     **/
    purgeKeys: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'Session';
          palletCall: {
            name: 'PurgeKeys';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `XcmpQueue`'s transaction calls
   **/
  xcmpQueue: {
    /**
     * Suspends all XCM executions for the XCMP queue, regardless of the sender's origin.
     *
     * - `origin`: Must pass `ControllerOrigin`.
     *
     **/
    suspendXcmExecution: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'XcmpQueue';
          palletCall: {
            name: 'SuspendXcmExecution';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Resumes all XCM executions for the XCMP queue.
     *
     * Note that this function doesn't change the status of the in/out bound channels.
     *
     * - `origin`: Must pass `ControllerOrigin`.
     *
     **/
    resumeXcmExecution: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'XcmpQueue';
          palletCall: {
            name: 'ResumeXcmExecution';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Overwrites the number of pages which must be in the queue for the other side to be
     * told to suspend their sending.
     *
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.suspend_value`
     *
     * @param {number} new_
     **/
    updateSuspendThreshold: GenericTxCall<
      (new_: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'XcmpQueue';
          palletCall: {
            name: 'UpdateSuspendThreshold';
            params: { new: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Overwrites the number of pages which must be in the queue after which we drop any
     * further messages from the channel.
     *
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.drop_threshold`
     *
     * @param {number} new_
     **/
    updateDropThreshold: GenericTxCall<
      (new_: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'XcmpQueue';
          palletCall: {
            name: 'UpdateDropThreshold';
            params: { new: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Overwrites the number of pages which the queue must be reduced to before it signals
     * that message sending may recommence after it has been suspended.
     *
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.resume_threshold`
     *
     * @param {number} new_
     **/
    updateResumeThreshold: GenericTxCall<
      (new_: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'XcmpQueue';
          palletCall: {
            name: 'UpdateResumeThreshold';
            params: { new: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `PolkadotXcm`'s transaction calls
   **/
  polkadotXcm: {
    /**
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedXcm} message
     **/
    send: GenericTxCall<
      (
        dest: XcmVersionedLocation,
        message: XcmVersionedXcm,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'Send';
            params: { dest: XcmVersionedLocation; message: XcmVersionedXcm };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Teleport some assets from the local chain to some destination chain.
     *
     * **This function is deprecated: Use `limited_teleport_assets` instead.**
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` chain.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedLocation} beneficiary
     * @param {XcmVersionedAssets} assets
     * @param {number} feeAssetItem
     *
     * @deprecated This extrinsic uses `WeightLimit::Unlimited`, please migrate to `limited_teleport_assets` or `transfer_assets`
     **/
    teleportAssets: GenericTxCall<
      (
        dest: XcmVersionedLocation,
        beneficiary: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        feeAssetItem: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'TeleportAssets';
            params: {
              dest: XcmVersionedLocation;
              beneficiary: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              feeAssetItem: number;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Transfer some assets from the local chain to the destination chain through their local,
     * destination or remote reserve.
     *
     * `assets` must have same reserve location and may not be teleportable to `dest`.
     * - `assets` have local reserve: transfer assets to sovereign account of destination
     * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
     * assets to `beneficiary`.
     * - `assets` have destination reserve: burn local assets and forward a notification to
     * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
     * deposit them to `beneficiary`.
     * - `assets` have remote reserve: burn local assets, forward XCM to reserve chain to move
     * reserves from this chain's SA to `dest` chain's SA, and forward another XCM to `dest`
     * to mint and deposit reserve-based assets to `beneficiary`.
     *
     * **This function is deprecated: Use `limited_reserve_transfer_assets` instead.**
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` (and possibly reserve) chains.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedLocation} beneficiary
     * @param {XcmVersionedAssets} assets
     * @param {number} feeAssetItem
     *
     * @deprecated This extrinsic uses `WeightLimit::Unlimited`, please migrate to `limited_reserve_transfer_assets` or `transfer_assets`
     **/
    reserveTransferAssets: GenericTxCall<
      (
        dest: XcmVersionedLocation,
        beneficiary: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        feeAssetItem: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'ReserveTransferAssets';
            params: {
              dest: XcmVersionedLocation;
              beneficiary: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              feeAssetItem: number;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Execute an XCM message from a local, signed, origin.
     *
     * An event is deposited indicating whether `msg` could be executed completely or only
     * partially.
     *
     * No more than `max_weight` will be used in its attempted execution. If this is less than
     * the maximum amount of weight that the message could take to be executed, then no
     * execution attempt will be made.
     *
     * @param {XcmVersionedXcm} message
     * @param {SpWeightsWeightV2Weight} maxWeight
     **/
    execute: GenericTxCall<
      (
        message: XcmVersionedXcm,
        maxWeight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'Execute';
            params: { message: XcmVersionedXcm; maxWeight: SpWeightsWeightV2Weight };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Extoll that a particular destination can be communicated with through a particular
     * version of XCM.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The destination that is being described.
     * - `xcm_version`: The latest version of XCM that `location` supports.
     *
     * @param {StagingXcmV5Location} location
     * @param {number} version
     **/
    forceXcmVersion: GenericTxCall<
      (
        location: StagingXcmV5Location,
        version: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'ForceXcmVersion';
            params: { location: StagingXcmV5Location; version: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set a safe XCM version (the version that XCM should be encoded with if the most recent
     * version a destination can accept is unknown).
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `maybe_xcm_version`: The default XCM encoding version, or `None` to disable.
     *
     * @param {number | undefined} maybeXcmVersion
     **/
    forceDefaultXcmVersion: GenericTxCall<
      (maybeXcmVersion: number | undefined) => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'ForceDefaultXcmVersion';
            params: { maybeXcmVersion: number | undefined };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Ask a location to notify us regarding their XCM version and any changes to it.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The location to which we should subscribe for XCM version notifications.
     *
     * @param {XcmVersionedLocation} location
     **/
    forceSubscribeVersionNotify: GenericTxCall<
      (location: XcmVersionedLocation) => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'ForceSubscribeVersionNotify';
            params: { location: XcmVersionedLocation };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Require that a particular destination should no longer notify us regarding any XCM
     * version changes.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The location to which we are currently subscribed for XCM version
     * notifications which we no longer desire.
     *
     * @param {XcmVersionedLocation} location
     **/
    forceUnsubscribeVersionNotify: GenericTxCall<
      (location: XcmVersionedLocation) => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'ForceUnsubscribeVersionNotify';
            params: { location: XcmVersionedLocation };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Transfer some assets from the local chain to the destination chain through their local,
     * destination or remote reserve.
     *
     * `assets` must have same reserve location and may not be teleportable to `dest`.
     * - `assets` have local reserve: transfer assets to sovereign account of destination
     * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
     * assets to `beneficiary`.
     * - `assets` have destination reserve: burn local assets and forward a notification to
     * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
     * deposit them to `beneficiary`.
     * - `assets` have remote reserve: burn local assets, forward XCM to reserve chain to move
     * reserves from this chain's SA to `dest` chain's SA, and forward another XCM to `dest`
     * to mint and deposit reserve-based assets to `beneficiary`.
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the sent assets may be
     * at risk.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` (and possibly reserve) chains.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedLocation} beneficiary
     * @param {XcmVersionedAssets} assets
     * @param {number} feeAssetItem
     * @param {XcmV3WeightLimit} weightLimit
     **/
    limitedReserveTransferAssets: GenericTxCall<
      (
        dest: XcmVersionedLocation,
        beneficiary: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        feeAssetItem: number,
        weightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'LimitedReserveTransferAssets';
            params: {
              dest: XcmVersionedLocation;
              beneficiary: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              feeAssetItem: number;
              weightLimit: XcmV3WeightLimit;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Teleport some assets from the local chain to some destination chain.
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the sent assets may be
     * at risk.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` chain.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedLocation} beneficiary
     * @param {XcmVersionedAssets} assets
     * @param {number} feeAssetItem
     * @param {XcmV3WeightLimit} weightLimit
     **/
    limitedTeleportAssets: GenericTxCall<
      (
        dest: XcmVersionedLocation,
        beneficiary: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        feeAssetItem: number,
        weightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'LimitedTeleportAssets';
            params: {
              dest: XcmVersionedLocation;
              beneficiary: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              feeAssetItem: number;
              weightLimit: XcmV3WeightLimit;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set or unset the global suspension state of the XCM executor.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `suspended`: `true` to suspend, `false` to resume.
     *
     * @param {boolean} suspended
     **/
    forceSuspension: GenericTxCall<
      (suspended: boolean) => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'ForceSuspension';
            params: { suspended: boolean };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Transfer some assets from the local chain to the destination chain through their local,
     * destination or remote reserve, or through teleports.
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item` (hence referred to as `fees`), up to enough to pay for
     * `weight_limit` of weight. If more weight is needed than `weight_limit`, then the
     * operation will fail and the sent assets may be at risk.
     *
     * `assets` (excluding `fees`) must have same reserve location or otherwise be teleportable
     * to `dest`, no limitations imposed on `fees`.
     * - for local reserve: transfer assets to sovereign account of destination chain and
     * forward a notification XCM to `dest` to mint and deposit reserve-based assets to
     * `beneficiary`.
     * - for destination reserve: burn local assets and forward a notification to `dest` chain
     * to withdraw the reserve assets from this chain's sovereign account and deposit them
     * to `beneficiary`.
     * - for remote reserve: burn local assets, forward XCM to reserve chain to move reserves
     * from this chain's SA to `dest` chain's SA, and forward another XCM to `dest` to mint
     * and deposit reserve-based assets to `beneficiary`.
     * - for teleports: burn local assets and forward XCM to `dest` chain to mint/teleport
     * assets and deposit them to `beneficiary`.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent,
     * Parachain(..))` to send from parachain to parachain, or `X1(Parachain(..))` to send
     * from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` (and possibly reserve) chains.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedLocation} beneficiary
     * @param {XcmVersionedAssets} assets
     * @param {number} feeAssetItem
     * @param {XcmV3WeightLimit} weightLimit
     **/
    transferAssets: GenericTxCall<
      (
        dest: XcmVersionedLocation,
        beneficiary: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        feeAssetItem: number,
        weightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'TransferAssets';
            params: {
              dest: XcmVersionedLocation;
              beneficiary: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              feeAssetItem: number;
              weightLimit: XcmV3WeightLimit;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Claims assets trapped on this pallet because of leftover assets during XCM execution.
     *
     * - `origin`: Anyone can call this extrinsic.
     * - `assets`: The exact assets that were trapped. Use the version to specify what version
     * was the latest when they were trapped.
     * - `beneficiary`: The location/account where the claimed assets will be deposited.
     *
     * @param {XcmVersionedAssets} assets
     * @param {XcmVersionedLocation} beneficiary
     **/
    claimAssets: GenericTxCall<
      (
        assets: XcmVersionedAssets,
        beneficiary: XcmVersionedLocation,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'ClaimAssets';
            params: { assets: XcmVersionedAssets; beneficiary: XcmVersionedLocation };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Transfer assets from the local chain to the destination chain using explicit transfer
     * types for assets and fees.
     *
     * `assets` must have same reserve location or may be teleportable to `dest`. Caller must
     * provide the `assets_transfer_type` to be used for `assets`:
     * - `TransferType::LocalReserve`: transfer assets to sovereign account of destination
     * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
     * assets to `beneficiary`.
     * - `TransferType::DestinationReserve`: burn local assets and forward a notification to
     * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
     * deposit them to `beneficiary`.
     * - `TransferType::RemoteReserve(reserve)`: burn local assets, forward XCM to `reserve`
     * chain to move reserves from this chain's SA to `dest` chain's SA, and forward another
     * XCM to `dest` to mint and deposit reserve-based assets to `beneficiary`. Typically
     * the remote `reserve` is Asset Hub.
     * - `TransferType::Teleport`: burn local assets and forward XCM to `dest` chain to
     * mint/teleport assets and deposit them to `beneficiary`.
     *
     * On the destination chain, as well as any intermediary hops, `BuyExecution` is used to
     * buy execution using transferred `assets` identified by `remote_fees_id`.
     * Make sure enough of the specified `remote_fees_id` asset is included in the given list
     * of `assets`. `remote_fees_id` should be enough to pay for `weight_limit`. If more weight
     * is needed than `weight_limit`, then the operation will fail and the sent assets may be
     * at risk.
     *
     * `remote_fees_id` may use different transfer type than rest of `assets` and can be
     * specified through `fees_transfer_type`.
     *
     * The caller needs to specify what should happen to the transferred assets once they reach
     * the `dest` chain. This is done through the `custom_xcm_on_dest` parameter, which
     * contains the instructions to execute on `dest` as a final step.
     * This is usually as simple as:
     * `Xcm(vec![DepositAsset { assets: Wild(AllCounted(assets.len())), beneficiary }])`,
     * but could be something more exotic like sending the `assets` even further.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain, or `(parents: 2, (GlobalConsensus(..), ..))` to send from
     * parachain across a bridge to another ecosystem destination.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` (and possibly reserve) chains.
     * - `assets_transfer_type`: The XCM `TransferType` used to transfer the `assets`.
     * - `remote_fees_id`: One of the included `assets` to be used to pay fees.
     * - `fees_transfer_type`: The XCM `TransferType` used to transfer the `fees` assets.
     * - `custom_xcm_on_dest`: The XCM to be executed on `dest` chain as the last step of the
     * transfer, which also determines what happens to the assets on the destination chain.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedAssets} assets
     * @param {StagingXcmExecutorAssetTransferTransferType} assetsTransferType
     * @param {XcmVersionedAssetId} remoteFeesId
     * @param {StagingXcmExecutorAssetTransferTransferType} feesTransferType
     * @param {XcmVersionedXcm} customXcmOnDest
     * @param {XcmV3WeightLimit} weightLimit
     **/
    transferAssetsUsingTypeAndThen: GenericTxCall<
      (
        dest: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        assetsTransferType: StagingXcmExecutorAssetTransferTransferType,
        remoteFeesId: XcmVersionedAssetId,
        feesTransferType: StagingXcmExecutorAssetTransferTransferType,
        customXcmOnDest: XcmVersionedXcm,
        weightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'TransferAssetsUsingTypeAndThen';
            params: {
              dest: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              assetsTransferType: StagingXcmExecutorAssetTransferTransferType;
              remoteFeesId: XcmVersionedAssetId;
              feesTransferType: StagingXcmExecutorAssetTransferTransferType;
              customXcmOnDest: XcmVersionedXcm;
              weightLimit: XcmV3WeightLimit;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Authorize another `aliaser` location to alias into the local `origin` making this call.
     * The `aliaser` is only authorized until the provided `expiry` block number.
     * The call can also be used for a previously authorized alias in order to update its
     * `expiry` block number.
     *
     * Usually useful to allow your local account to be aliased into from a remote location
     * also under your control (like your account on another chain).
     *
     * WARNING: make sure the caller `origin` (you) trusts the `aliaser` location to act in
     * their/your name. Once authorized using this call, the `aliaser` can freely impersonate
     * `origin` in XCM programs executed on the local chain.
     *
     * @param {XcmVersionedLocation} aliaser
     * @param {bigint | undefined} expires
     **/
    addAuthorizedAlias: GenericTxCall<
      (
        aliaser: XcmVersionedLocation,
        expires: bigint | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'AddAuthorizedAlias';
            params: { aliaser: XcmVersionedLocation; expires: bigint | undefined };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove a previously authorized `aliaser` from the list of locations that can alias into
     * the local `origin` making this call.
     *
     * @param {XcmVersionedLocation} aliaser
     **/
    removeAuthorizedAlias: GenericTxCall<
      (aliaser: XcmVersionedLocation) => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'RemoveAuthorizedAlias';
            params: { aliaser: XcmVersionedLocation };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove all previously authorized `aliaser`s that can alias into the local `origin`
     * making this call.
     *
     **/
    removeAllAuthorizedAliases: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'RemoveAllAuthorizedAliases';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `CumulusXcm`'s transaction calls
   **/
  cumulusXcm: {
    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `ToKusamaXcmRouter`'s transaction calls
   **/
  toKusamaXcmRouter: {
    /**
     * Notification about congested bridge queue.
     *
     * @param {H256} bridgeId
     * @param {boolean} isCongested
     **/
    reportBridgeStatus: GenericTxCall<
      (
        bridgeId: H256,
        isCongested: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ToKusamaXcmRouter';
          palletCall: {
            name: 'ReportBridgeStatus';
            params: { bridgeId: H256; isCongested: boolean };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `MessageQueue`'s transaction calls
   **/
  messageQueue: {
    /**
     * Remove a page which has no more messages remaining to be processed or is stale.
     *
     * @param {CumulusPrimitivesCoreAggregateMessageOrigin} messageOrigin
     * @param {number} pageIndex
     **/
    reapPage: GenericTxCall<
      (
        messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin,
        pageIndex: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'MessageQueue';
          palletCall: {
            name: 'ReapPage';
            params: { messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin; pageIndex: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Execute an overweight message.
     *
     * Temporary processing errors will be propagated whereas permanent errors are treated
     * as success condition.
     *
     * - `origin`: Must be `Signed`.
     * - `message_origin`: The origin from which the message to be executed arrived.
     * - `page`: The page in the queue in which the message to be executed is sitting.
     * - `index`: The index into the queue of the message to be executed.
     * - `weight_limit`: The maximum amount of weight allowed to be consumed in the execution
     * of the message.
     *
     * Benchmark complexity considerations: O(index + weight_limit).
     *
     * @param {CumulusPrimitivesCoreAggregateMessageOrigin} messageOrigin
     * @param {number} page
     * @param {number} index
     * @param {SpWeightsWeightV2Weight} weightLimit
     **/
    executeOverweight: GenericTxCall<
      (
        messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin,
        page: number,
        index: number,
        weightLimit: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'MessageQueue';
          palletCall: {
            name: 'ExecuteOverweight';
            params: {
              messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin;
              page: number;
              index: number;
              weightLimit: SpWeightsWeightV2Weight;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `SnowbridgeSystemFrontend`'s transaction calls
   **/
  snowbridgeSystemFrontend: {
    /**
     * Set the operating mode for exporting messages to Ethereum.
     *
     * @param {SnowbridgeCoreOperatingModeBasicOperatingMode} mode
     **/
    setOperatingMode: GenericTxCall<
      (mode: SnowbridgeCoreOperatingModeBasicOperatingMode) => ChainSubmittableExtrinsic<
        {
          pallet: 'SnowbridgeSystemFrontend';
          palletCall: {
            name: 'SetOperatingMode';
            params: { mode: SnowbridgeCoreOperatingModeBasicOperatingMode };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Initiates the registration for a Polkadot-native token as a wrapped ERC20 token on
     * Ethereum.
     * - `asset_id`: Location of the asset
     * - `metadata`: Metadata to include in the instantiated ERC20 contract on Ethereum
     *
     * All origins are allowed, however `asset_id` must be a location nested within the origin
     * consensus system.
     *
     * @param {XcmVersionedLocation} assetId
     * @param {SnowbridgeCoreAssetMetadata} metadata
     * @param {StagingXcmV5Asset} feeAsset
     **/
    registerToken: GenericTxCall<
      (
        assetId: XcmVersionedLocation,
        metadata: SnowbridgeCoreAssetMetadata,
        feeAsset: StagingXcmV5Asset,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'SnowbridgeSystemFrontend';
          palletCall: {
            name: 'RegisterToken';
            params: {
              assetId: XcmVersionedLocation;
              metadata: SnowbridgeCoreAssetMetadata;
              feeAsset: StagingXcmV5Asset;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Add an additional relayer tip for a committed message identified by `message_id`.
     * The tip asset will be swapped for ether.
     *
     * @param {SnowbridgeCoreRewardMessageId} messageId
     * @param {StagingXcmV5Asset} asset
     **/
    addTip: GenericTxCall<
      (
        messageId: SnowbridgeCoreRewardMessageId,
        asset: StagingXcmV5Asset,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'SnowbridgeSystemFrontend';
          palletCall: {
            name: 'AddTip';
            params: { messageId: SnowbridgeCoreRewardMessageId; asset: StagingXcmV5Asset };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Utility`'s transaction calls
   **/
  utility: {
    /**
     * Send a batch of dispatch calls.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     *
     * @param {Array<AssetHubPolkadotRuntimeRuntimeCallLike>} calls
     **/
    batch: GenericTxCall<
      (calls: Array<AssetHubPolkadotRuntimeRuntimeCallLike>) => ChainSubmittableExtrinsic<
        {
          pallet: 'Utility';
          palletCall: {
            name: 'Batch';
            params: { calls: Array<AssetHubPolkadotRuntimeRuntimeCallLike> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Send a call through an indexed pseudonym of the sender.
     *
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     *
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     *
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * @param {number} index
     * @param {AssetHubPolkadotRuntimeRuntimeCallLike} call
     **/
    asDerivative: GenericTxCall<
      (
        index: number,
        call: AssetHubPolkadotRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Utility';
          palletCall: {
            name: 'AsDerivative';
            params: { index: number; call: AssetHubPolkadotRuntimeRuntimeCallLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * @param {Array<AssetHubPolkadotRuntimeRuntimeCallLike>} calls
     **/
    batchAll: GenericTxCall<
      (calls: Array<AssetHubPolkadotRuntimeRuntimeCallLike>) => ChainSubmittableExtrinsic<
        {
          pallet: 'Utility';
          palletCall: {
            name: 'BatchAll';
            params: { calls: Array<AssetHubPolkadotRuntimeRuntimeCallLike> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Dispatches a function call with a provided origin.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {AssetHubPolkadotRuntimeOriginCaller} asOrigin
     * @param {AssetHubPolkadotRuntimeRuntimeCallLike} call
     **/
    dispatchAs: GenericTxCall<
      (
        asOrigin: AssetHubPolkadotRuntimeOriginCaller,
        call: AssetHubPolkadotRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Utility';
          palletCall: {
            name: 'DispatchAs';
            params: { asOrigin: AssetHubPolkadotRuntimeOriginCaller; call: AssetHubPolkadotRuntimeRuntimeCallLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * @param {Array<AssetHubPolkadotRuntimeRuntimeCallLike>} calls
     **/
    forceBatch: GenericTxCall<
      (calls: Array<AssetHubPolkadotRuntimeRuntimeCallLike>) => ChainSubmittableExtrinsic<
        {
          pallet: 'Utility';
          palletCall: {
            name: 'ForceBatch';
            params: { calls: Array<AssetHubPolkadotRuntimeRuntimeCallLike> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Dispatch a function call with a specified weight.
     *
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * @param {AssetHubPolkadotRuntimeRuntimeCallLike} call
     * @param {SpWeightsWeightV2Weight} weight
     **/
    withWeight: GenericTxCall<
      (
        call: AssetHubPolkadotRuntimeRuntimeCallLike,
        weight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Utility';
          palletCall: {
            name: 'WithWeight';
            params: { call: AssetHubPolkadotRuntimeRuntimeCallLike; weight: SpWeightsWeightV2Weight };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Dispatch a fallback call in the event the main call fails to execute.
     * May be called from any origin except `None`.
     *
     * This function first attempts to dispatch the `main` call.
     * If the `main` call fails, the `fallback` is attemted.
     * if the fallback is successfully dispatched, the weights of both calls
     * are accumulated and an event containing the main call error is deposited.
     *
     * In the event of a fallback failure the whole call fails
     * with the weights returned.
     *
     * - `main`: The main call to be dispatched. This is the primary action to execute.
     * - `fallback`: The fallback call to be dispatched in case the `main` call fails.
     *
     * ## Dispatch Logic
     * - If the origin is `root`, both the main and fallback calls are executed without
     * applying any origin filters.
     * - If the origin is not `root`, the origin filter is applied to both the `main` and
     * `fallback` calls.
     *
     * ## Use Case
     * - Some use cases might involve submitting a `batch` type call in either main, fallback
     * or both.
     *
     * @param {AssetHubPolkadotRuntimeRuntimeCallLike} main
     * @param {AssetHubPolkadotRuntimeRuntimeCallLike} fallback
     **/
    ifElse: GenericTxCall<
      (
        main: AssetHubPolkadotRuntimeRuntimeCallLike,
        fallback: AssetHubPolkadotRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Utility';
          palletCall: {
            name: 'IfElse';
            params: { main: AssetHubPolkadotRuntimeRuntimeCallLike; fallback: AssetHubPolkadotRuntimeRuntimeCallLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Dispatches a function call with a provided origin.
     *
     * Almost the same as [`Pallet::dispatch_as`] but forwards any error of the inner call.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * @param {AssetHubPolkadotRuntimeOriginCaller} asOrigin
     * @param {AssetHubPolkadotRuntimeRuntimeCallLike} call
     **/
    dispatchAsFallible: GenericTxCall<
      (
        asOrigin: AssetHubPolkadotRuntimeOriginCaller,
        call: AssetHubPolkadotRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Utility';
          palletCall: {
            name: 'DispatchAsFallible';
            params: { asOrigin: AssetHubPolkadotRuntimeOriginCaller; call: AssetHubPolkadotRuntimeRuntimeCallLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Multisig`'s transaction calls
   **/
  multisig: {
    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     *
     * Result is equivalent to the dispatched result.
     *
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     *
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {AssetHubPolkadotRuntimeRuntimeCallLike} call
     **/
    asMultiThreshold1: GenericTxCall<
      (
        otherSignatories: Array<AccountId32Like>,
        call: AssetHubPolkadotRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'AsMultiThreshold1';
            params: { otherSignatories: Array<AccountId32Like>; call: AssetHubPolkadotRuntimeRuntimeCallLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     *
     * If there are enough, then dispatch the call.
     *
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     *
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     *
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     *
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     *
     * @param {number} threshold
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {PalletMultisigTimepoint | undefined} maybeTimepoint
     * @param {AssetHubPolkadotRuntimeRuntimeCallLike} call
     * @param {SpWeightsWeightV2Weight} maxWeight
     **/
    asMulti: GenericTxCall<
      (
        threshold: number,
        otherSignatories: Array<AccountId32Like>,
        maybeTimepoint: PalletMultisigTimepoint | undefined,
        call: AssetHubPolkadotRuntimeRuntimeCallLike,
        maxWeight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'AsMulti';
            params: {
              threshold: number;
              otherSignatories: Array<AccountId32Like>;
              maybeTimepoint: PalletMultisigTimepoint | undefined;
              call: AssetHubPolkadotRuntimeRuntimeCallLike;
              maxWeight: SpWeightsWeightV2Weight;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     *
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call_hash`: The hash of the call to be executed.
     *
     * NOTE: If this is the final approval, you will want to use `as_multi` instead.
     *
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     *
     * @param {number} threshold
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {PalletMultisigTimepoint | undefined} maybeTimepoint
     * @param {FixedBytes<32>} callHash
     * @param {SpWeightsWeightV2Weight} maxWeight
     **/
    approveAsMulti: GenericTxCall<
      (
        threshold: number,
        otherSignatories: Array<AccountId32Like>,
        maybeTimepoint: PalletMultisigTimepoint | undefined,
        callHash: FixedBytes<32>,
        maxWeight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'ApproveAsMulti';
            params: {
              threshold: number;
              otherSignatories: Array<AccountId32Like>;
              maybeTimepoint: PalletMultisigTimepoint | undefined;
              callHash: FixedBytes<32>;
              maxWeight: SpWeightsWeightV2Weight;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
     * for this operation will be unreserved on success.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `timepoint`: The timepoint (block number and transaction index) of the first approval
     * transaction for this dispatch.
     * - `call_hash`: The hash of the call to be executed.
     *
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - One event.
     * - I/O: 1 read `O(S)`, one remove.
     * - Storage: removes one item.
     *
     * @param {number} threshold
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {PalletMultisigTimepoint} timepoint
     * @param {FixedBytes<32>} callHash
     **/
    cancelAsMulti: GenericTxCall<
      (
        threshold: number,
        otherSignatories: Array<AccountId32Like>,
        timepoint: PalletMultisigTimepoint,
        callHash: FixedBytes<32>,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'CancelAsMulti';
            params: {
              threshold: number;
              otherSignatories: Array<AccountId32Like>;
              timepoint: PalletMultisigTimepoint;
              callHash: FixedBytes<32>;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Poke the deposit reserved for an existing multisig operation.
     *
     * The dispatch origin for this call must be _Signed_ and must be the original depositor of
     * the multisig operation.
     *
     * The transaction fee is waived if the deposit amount has changed.
     *
     * - `threshold`: The total number of approvals needed for this multisig.
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multisig.
     * - `call_hash`: The hash of the call this deposit is reserved for.
     *
     * Emits `DepositPoked` if successful.
     *
     * @param {number} threshold
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {FixedBytes<32>} callHash
     **/
    pokeDeposit: GenericTxCall<
      (
        threshold: number,
        otherSignatories: Array<AccountId32Like>,
        callHash: FixedBytes<32>,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'PokeDeposit';
            params: { threshold: number; otherSignatories: Array<AccountId32Like>; callHash: FixedBytes<32> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Proxy`'s transaction calls
   **/
  proxy: {
    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     *
     * @param {MultiAddressLike} real
     * @param {AssetHubPolkadotRuntimeProxyType | undefined} forceProxyType
     * @param {AssetHubPolkadotRuntimeRuntimeCallLike} call
     **/
    proxy: GenericTxCall<
      (
        real: MultiAddressLike,
        forceProxyType: AssetHubPolkadotRuntimeProxyType | undefined,
        call: AssetHubPolkadotRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'Proxy';
            params: {
              real: MultiAddressLike;
              forceProxyType: AssetHubPolkadotRuntimeProxyType | undefined;
              call: AssetHubPolkadotRuntimeRuntimeCallLike;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Register a proxy account for the sender that is able to make calls on its behalf.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `proxy`: The account that the `caller` would like to make a proxy.
     * - `proxy_type`: The permissions allowed for this proxy account.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     *
     * @param {MultiAddressLike} delegate
     * @param {AssetHubPolkadotRuntimeProxyType} proxyType
     * @param {number} delay
     **/
    addProxy: GenericTxCall<
      (
        delegate: MultiAddressLike,
        proxyType: AssetHubPolkadotRuntimeProxyType,
        delay: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'AddProxy';
            params: { delegate: MultiAddressLike; proxyType: AssetHubPolkadotRuntimeProxyType; delay: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Unregister a proxy account for the sender.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `proxy`: The account that the `caller` would like to remove as a proxy.
     * - `proxy_type`: The permissions currently enabled for the removed proxy account.
     *
     * @param {MultiAddressLike} delegate
     * @param {AssetHubPolkadotRuntimeProxyType} proxyType
     * @param {number} delay
     **/
    removeProxy: GenericTxCall<
      (
        delegate: MultiAddressLike,
        proxyType: AssetHubPolkadotRuntimeProxyType,
        delay: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'RemoveProxy';
            params: { delegate: MultiAddressLike; proxyType: AssetHubPolkadotRuntimeProxyType; delay: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Unregister all proxy accounts for the sender.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * WARNING: This may be called on accounts created by `create_pure`, however if done, then
     * the unreserved fees will be inaccessible. **All access to this account will be lost.**
     *
     **/
    removeProxies: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'RemoveProxies';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
     * initialize it with a proxy of `proxy_type` for `origin` sender.
     *
     * Requires a `Signed` origin.
     *
     * - `proxy_type`: The type of the proxy that the sender will be registered as over the
     * new account. This will almost always be the most permissive `ProxyType` possible to
     * allow for maximum flexibility.
     * - `index`: A disambiguation index, in case this is called multiple times in the same
     * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
     * want to use `0`.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     *
     * Fails with `Duplicate` if this has already been called in this transaction, from the
     * same sender, with the same parameters.
     *
     * Fails if there are insufficient funds to pay for deposit.
     *
     * @param {AssetHubPolkadotRuntimeProxyType} proxyType
     * @param {number} delay
     * @param {number} index
     **/
    createPure: GenericTxCall<
      (
        proxyType: AssetHubPolkadotRuntimeProxyType,
        delay: number,
        index: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'CreatePure';
            params: { proxyType: AssetHubPolkadotRuntimeProxyType; delay: number; index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Removes a previously spawned pure proxy.
     *
     * WARNING: **All access to this account will be lost.** Any funds held in it will be
     * inaccessible.
     *
     * Requires a `Signed` origin, and the sender account must have been created by a call to
     * `create_pure` with corresponding parameters.
     *
     * - `spawner`: The account that originally called `create_pure` to create this account.
     * - `index`: The disambiguation index originally passed to `create_pure`. Probably `0`.
     * - `proxy_type`: The proxy type originally passed to `create_pure`.
     * - `height`: The height of the chain when the call to `create_pure` was processed.
     * - `ext_index`: The extrinsic index in which the call to `create_pure` was processed.
     *
     * Fails with `NoPermission` in case the caller is not a previously created pure
     * account whose `create_pure` call has corresponding parameters.
     *
     * @param {MultiAddressLike} spawner
     * @param {AssetHubPolkadotRuntimeProxyType} proxyType
     * @param {number} index
     * @param {number} height
     * @param {number} extIndex
     **/
    killPure: GenericTxCall<
      (
        spawner: MultiAddressLike,
        proxyType: AssetHubPolkadotRuntimeProxyType,
        index: number,
        height: number,
        extIndex: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'KillPure';
            params: {
              spawner: MultiAddressLike;
              proxyType: AssetHubPolkadotRuntimeProxyType;
              index: number;
              height: number;
              extIndex: number;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Publish the hash of a proxy-call that will be made in the future.
     *
     * This must be called some number of blocks before the corresponding `proxy` is attempted
     * if the delay associated with the proxy relationship is greater than zero.
     *
     * No more than `MaxPending` announcements may be made at any one time.
     *
     * This will take a deposit of `AnnouncementDepositFactor` as well as
     * `AnnouncementDepositBase` if there are no other pending announcements.
     *
     * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     *
     * @param {MultiAddressLike} real
     * @param {H256} callHash
     **/
    announce: GenericTxCall<
      (
        real: MultiAddressLike,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'Announce';
            params: { real: MultiAddressLike; callHash: H256 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove a given announcement.
     *
     * May be called by a proxy account to remove a call they previously announced and return
     * the deposit.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     *
     * @param {MultiAddressLike} real
     * @param {H256} callHash
     **/
    removeAnnouncement: GenericTxCall<
      (
        real: MultiAddressLike,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'RemoveAnnouncement';
            params: { real: MultiAddressLike; callHash: H256 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove the given announcement of a delegate.
     *
     * May be called by a target (proxied) account to remove a call that one of their delegates
     * (`delegate`) has announced they want to execute. The deposit is returned.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `delegate`: The account that previously announced the call.
     * - `call_hash`: The hash of the call to be made.
     *
     * @param {MultiAddressLike} delegate
     * @param {H256} callHash
     **/
    rejectAnnouncement: GenericTxCall<
      (
        delegate: MultiAddressLike,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'RejectAnnouncement';
            params: { delegate: MultiAddressLike; callHash: H256 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     *
     * Removes any corresponding announcement(s).
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     *
     * @param {MultiAddressLike} delegate
     * @param {MultiAddressLike} real
     * @param {AssetHubPolkadotRuntimeProxyType | undefined} forceProxyType
     * @param {AssetHubPolkadotRuntimeRuntimeCallLike} call
     **/
    proxyAnnounced: GenericTxCall<
      (
        delegate: MultiAddressLike,
        real: MultiAddressLike,
        forceProxyType: AssetHubPolkadotRuntimeProxyType | undefined,
        call: AssetHubPolkadotRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'ProxyAnnounced';
            params: {
              delegate: MultiAddressLike;
              real: MultiAddressLike;
              forceProxyType: AssetHubPolkadotRuntimeProxyType | undefined;
              call: AssetHubPolkadotRuntimeRuntimeCallLike;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Poke / Adjust deposits made for proxies and announcements based on current values.
     * This can be used by accounts to possibly lower their locked amount.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * The transaction fee is waived if the deposit amount has changed.
     *
     * Emits `DepositPoked` if successful.
     *
     **/
    pokeDeposit: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'PokeDeposit';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Indices`'s transaction calls
   **/
  indices: {
    /**
     * Assign an previously unassigned index.
     *
     * Payment: `Deposit` is reserved from the sender account.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `index`: the index to be claimed. This must not be in use.
     *
     * Emits `IndexAssigned` if successful.
     *
     * ## Complexity
     * - `O(1)`.
     *
     * @param {number} index
     **/
    claim: GenericTxCall<
      (index: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Indices';
          palletCall: {
            name: 'Claim';
            params: { index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Assign an index already owned by the sender to another account. The balance reservation
     * is effectively transferred to the new account.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `index`: the index to be re-assigned. This must be owned by the sender.
     * - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
     *
     * Emits `IndexAssigned` if successful.
     *
     * ## Complexity
     * - `O(1)`.
     *
     * @param {MultiAddressLike} new_
     * @param {number} index
     **/
    transfer: GenericTxCall<
      (
        new_: MultiAddressLike,
        index: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Indices';
          palletCall: {
            name: 'Transfer';
            params: { new: MultiAddressLike; index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Free up an index owned by the sender.
     *
     * Payment: Any previous deposit placed for the index is unreserved in the sender account.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must own the index.
     *
     * - `index`: the index to be freed. This must be owned by the sender.
     *
     * Emits `IndexFreed` if successful.
     *
     * ## Complexity
     * - `O(1)`.
     *
     * @param {number} index
     **/
    free: GenericTxCall<
      (index: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Indices';
          palletCall: {
            name: 'Free';
            params: { index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Force an index to an account. This doesn't require a deposit. If the index is already
     * held, then any deposit is reimbursed to its current owner.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * - `index`: the index to be (re-)assigned.
     * - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
     * - `freeze`: if set to `true`, will freeze the index so it cannot be transferred.
     *
     * Emits `IndexAssigned` if successful.
     *
     * ## Complexity
     * - `O(1)`.
     *
     * @param {MultiAddressLike} new_
     * @param {number} index
     * @param {boolean} freeze
     **/
    forceTransfer: GenericTxCall<
      (
        new_: MultiAddressLike,
        index: number,
        freeze: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Indices';
          palletCall: {
            name: 'ForceTransfer';
            params: { new: MultiAddressLike; index: number; freeze: boolean };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Freeze an index so it will always point to the sender account. This consumes the
     * deposit.
     *
     * The dispatch origin for this call must be _Signed_ and the signing account must have a
     * non-frozen account `index`.
     *
     * - `index`: the index to be frozen in place.
     *
     * Emits `IndexFrozen` if successful.
     *
     * ## Complexity
     * - `O(1)`.
     *
     * @param {number} index
     **/
    freeze: GenericTxCall<
      (index: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Indices';
          palletCall: {
            name: 'Freeze';
            params: { index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Poke the deposit reserved for an index.
     *
     * The dispatch origin for this call must be _Signed_ and the signing account must have a
     * non-frozen account `index`.
     *
     * The transaction fees is waived if the deposit is changed after poking/reconsideration.
     *
     * - `index`: the index whose deposit is to be poked/reconsidered.
     *
     * Emits `DepositPoked` if successful.
     *
     * @param {number} index
     **/
    pokeDeposit: GenericTxCall<
      (index: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Indices';
          palletCall: {
            name: 'PokeDeposit';
            params: { index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Assets`'s transaction calls
   **/
  assets: {
    /**
     * Issue a new class of fungible assets from a public origin.
     *
     * This new asset class has no assets initially and its owner is the origin.
     *
     * The origin must conform to the configured `CreateOrigin` and have sufficient funds free.
     *
     * Funds of sender are reserved by `AssetDeposit`.
     *
     * Parameters:
     * - `id`: The identifier of the new asset. This must not be currently in use to identify
     * an existing asset. If [`NextAssetId`] is set, then this must be equal to it.
     * - `admin`: The admin of this class of assets. The admin is the initial address of each
     * member of the asset class's admin team.
     * - `min_balance`: The minimum balance of this new asset that any single account must
     * have. If an account's balance is reduced below this, then it collapses to zero.
     *
     * Emits `Created` event when successful.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} admin
     * @param {bigint} minBalance
     **/
    create: GenericTxCall<
      (
        id: number,
        admin: MultiAddressLike,
        minBalance: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'Create';
            params: { id: number; admin: MultiAddressLike; minBalance: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Issue a new class of fungible assets from a privileged origin.
     *
     * This new asset class has no assets initially.
     *
     * The origin must conform to `ForceOrigin`.
     *
     * Unlike `create`, no funds are reserved.
     *
     * - `id`: The identifier of the new asset. This must not be currently in use to identify
     * an existing asset. If [`NextAssetId`] is set, then this must be equal to it.
     * - `owner`: The owner of this class of assets. The owner has full superuser permissions
     * over this asset, but may later change and configure the permissions using
     * `transfer_ownership` and `set_team`.
     * - `min_balance`: The minimum balance of this new asset that any single account must
     * have. If an account's balance is reduced below this, then it collapses to zero.
     *
     * Emits `ForceCreated` event when successful.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} owner
     * @param {boolean} isSufficient
     * @param {bigint} minBalance
     **/
    forceCreate: GenericTxCall<
      (
        id: number,
        owner: MultiAddressLike,
        isSufficient: boolean,
        minBalance: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'ForceCreate';
            params: { id: number; owner: MultiAddressLike; isSufficient: boolean; minBalance: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Start the process of destroying a fungible asset class.
     *
     * `start_destroy` is the first in a series of extrinsics that should be called, to allow
     * destruction of an asset class.
     *
     * The origin must conform to `ForceOrigin` or must be `Signed` by the asset's `owner`.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * It will fail with either [`Error::ContainsHolds`] or [`Error::ContainsFreezes`] if
     * an account contains holds or freezes in place.
     *
     * @param {number} id
     **/
    startDestroy: GenericTxCall<
      (id: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'StartDestroy';
            params: { id: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Destroy all accounts associated with a given asset.
     *
     * `destroy_accounts` should only be called after `start_destroy` has been called, and the
     * asset is in a `Destroying` state.
     *
     * Due to weight restrictions, this function may need to be called multiple times to fully
     * destroy all accounts. It will destroy `RemoveItemsLimit` accounts at a time.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * Each call emits the `Event::DestroyedAccounts` event.
     *
     * @param {number} id
     **/
    destroyAccounts: GenericTxCall<
      (id: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'DestroyAccounts';
            params: { id: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Destroy all approvals associated with a given asset up to the max (T::RemoveItemsLimit).
     *
     * `destroy_approvals` should only be called after `start_destroy` has been called, and the
     * asset is in a `Destroying` state.
     *
     * Due to weight restrictions, this function may need to be called multiple times to fully
     * destroy all approvals. It will destroy `RemoveItemsLimit` approvals at a time.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * Each call emits the `Event::DestroyedApprovals` event.
     *
     * @param {number} id
     **/
    destroyApprovals: GenericTxCall<
      (id: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'DestroyApprovals';
            params: { id: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Complete destroying asset and unreserve currency.
     *
     * `finish_destroy` should only be called after `start_destroy` has been called, and the
     * asset is in a `Destroying` state. All accounts or approvals should be destroyed before
     * hand.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * Each successful call emits the `Event::Destroyed` event.
     *
     * @param {number} id
     **/
    finishDestroy: GenericTxCall<
      (id: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'FinishDestroy';
            params: { id: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Mint assets of a particular class.
     *
     * The origin must be Signed and the sender must be the Issuer of the asset `id`.
     *
     * - `id`: The identifier of the asset to have some amount minted.
     * - `beneficiary`: The account to be credited with the minted assets.
     * - `amount`: The amount of the asset to be minted.
     *
     * Emits `Issued` event when successful.
     *
     * Weight: `O(1)`
     * Modes: Pre-existing balance of `beneficiary`; Account pre-existence of `beneficiary`.
     *
     * @param {number} id
     * @param {MultiAddressLike} beneficiary
     * @param {bigint} amount
     **/
    mint: GenericTxCall<
      (
        id: number,
        beneficiary: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'Mint';
            params: { id: number; beneficiary: MultiAddressLike; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Reduce the balance of `who` by as much as possible up to `amount` assets of `id`.
     *
     * Origin must be Signed and the sender should be the Manager of the asset `id`.
     *
     * Bails with `NoAccount` if the `who` is already dead.
     *
     * - `id`: The identifier of the asset to have some amount burned.
     * - `who`: The account to be debited from.
     * - `amount`: The maximum amount by which `who`'s balance should be reduced.
     *
     * Emits `Burned` with the actual amount burned. If this takes the balance to below the
     * minimum for the asset, then the amount burned is increased to take it to zero.
     *
     * Weight: `O(1)`
     * Modes: Post-existence of `who`; Pre & post Zombie-status of `who`.
     *
     * @param {number} id
     * @param {MultiAddressLike} who
     * @param {bigint} amount
     **/
    burn: GenericTxCall<
      (
        id: number,
        who: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'Burn';
            params: { id: number; who: MultiAddressLike; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Move some assets from the sender account to another.
     *
     * Origin must be Signed.
     *
     * - `id`: The identifier of the asset to have some amount transferred.
     * - `target`: The account to be credited.
     * - `amount`: The amount by which the sender's balance of assets should be reduced and
     * `target`'s balance increased. The amount actually transferred may be slightly greater in
     * the case that the transfer would otherwise take the sender balance above zero but below
     * the minimum balance. Must be greater than zero.
     *
     * Emits `Transferred` with the actual amount transferred. If this takes the source balance
     * to below the minimum for the asset, then the amount transferred is increased to take it
     * to zero.
     *
     * Weight: `O(1)`
     * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
     * `target`.
     *
     * @param {number} id
     * @param {MultiAddressLike} target
     * @param {bigint} amount
     **/
    transfer: GenericTxCall<
      (
        id: number,
        target: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'Transfer';
            params: { id: number; target: MultiAddressLike; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Move some assets from the sender account to another, keeping the sender account alive.
     *
     * Origin must be Signed.
     *
     * - `id`: The identifier of the asset to have some amount transferred.
     * - `target`: The account to be credited.
     * - `amount`: The amount by which the sender's balance of assets should be reduced and
     * `target`'s balance increased. The amount actually transferred may be slightly greater in
     * the case that the transfer would otherwise take the sender balance above zero but below
     * the minimum balance. Must be greater than zero.
     *
     * Emits `Transferred` with the actual amount transferred. If this takes the source balance
     * to below the minimum for the asset, then the amount transferred is increased to take it
     * to zero.
     *
     * Weight: `O(1)`
     * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
     * `target`.
     *
     * @param {number} id
     * @param {MultiAddressLike} target
     * @param {bigint} amount
     **/
    transferKeepAlive: GenericTxCall<
      (
        id: number,
        target: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'TransferKeepAlive';
            params: { id: number; target: MultiAddressLike; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Move some assets from one account to another.
     *
     * Origin must be Signed and the sender should be the Admin of the asset `id`.
     *
     * - `id`: The identifier of the asset to have some amount transferred.
     * - `source`: The account to be debited.
     * - `dest`: The account to be credited.
     * - `amount`: The amount by which the `source`'s balance of assets should be reduced and
     * `dest`'s balance increased. The amount actually transferred may be slightly greater in
     * the case that the transfer would otherwise take the `source` balance above zero but
     * below the minimum balance. Must be greater than zero.
     *
     * Emits `Transferred` with the actual amount transferred. If this takes the source balance
     * to below the minimum for the asset, then the amount transferred is increased to take it
     * to zero.
     *
     * Weight: `O(1)`
     * Modes: Pre-existence of `dest`; Post-existence of `source`; Account pre-existence of
     * `dest`.
     *
     * @param {number} id
     * @param {MultiAddressLike} source
     * @param {MultiAddressLike} dest
     * @param {bigint} amount
     **/
    forceTransfer: GenericTxCall<
      (
        id: number,
        source: MultiAddressLike,
        dest: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'ForceTransfer';
            params: { id: number; source: MultiAddressLike; dest: MultiAddressLike; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Disallow further unprivileged transfers of an asset `id` from an account `who`. `who`
     * must already exist as an entry in `Account`s of the asset. If you want to freeze an
     * account that does not have an entry, use `touch_other` first.
     *
     * Origin must be Signed and the sender should be the Freezer of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     * - `who`: The account to be frozen.
     *
     * Emits `Frozen`.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} who
     **/
    freeze: GenericTxCall<
      (
        id: number,
        who: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'Freeze';
            params: { id: number; who: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Allow unprivileged transfers to and from an account again.
     *
     * Origin must be Signed and the sender should be the Admin of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     * - `who`: The account to be unfrozen.
     *
     * Emits `Thawed`.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} who
     **/
    thaw: GenericTxCall<
      (
        id: number,
        who: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'Thaw';
            params: { id: number; who: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Disallow further unprivileged transfers for the asset class.
     *
     * Origin must be Signed and the sender should be the Freezer of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     *
     * Emits `Frozen`.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     **/
    freezeAsset: GenericTxCall<
      (id: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'FreezeAsset';
            params: { id: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Allow unprivileged transfers for the asset again.
     *
     * Origin must be Signed and the sender should be the Admin of the asset `id`.
     *
     * - `id`: The identifier of the asset to be thawed.
     *
     * Emits `Thawed`.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     **/
    thawAsset: GenericTxCall<
      (id: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'ThawAsset';
            params: { id: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Change the Owner of an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * - `id`: The identifier of the asset.
     * - `owner`: The new Owner of this asset.
     *
     * Emits `OwnerChanged`.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} owner
     **/
    transferOwnership: GenericTxCall<
      (
        id: number,
        owner: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'TransferOwnership';
            params: { id: number; owner: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Change the Issuer, Admin and Freezer of an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     * - `issuer`: The new Issuer of this asset.
     * - `admin`: The new Admin of this asset.
     * - `freezer`: The new Freezer of this asset.
     *
     * Emits `TeamChanged`.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} issuer
     * @param {MultiAddressLike} admin
     * @param {MultiAddressLike} freezer
     **/
    setTeam: GenericTxCall<
      (
        id: number,
        issuer: MultiAddressLike,
        admin: MultiAddressLike,
        freezer: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'SetTeam';
            params: { id: number; issuer: MultiAddressLike; admin: MultiAddressLike; freezer: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the metadata for an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * Funds of sender are reserved according to the formula:
     * `MetadataDepositBase + MetadataDepositPerByte * (name.len + symbol.len)` taking into
     * account any already reserved funds.
     *
     * - `id`: The identifier of the asset to update.
     * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
     * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
     * - `decimals`: The number of decimals this asset uses to represent one unit.
     *
     * Emits `MetadataSet`.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {BytesLike} name
     * @param {BytesLike} symbol
     * @param {number} decimals
     **/
    setMetadata: GenericTxCall<
      (
        id: number,
        name: BytesLike,
        symbol: BytesLike,
        decimals: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'SetMetadata';
            params: { id: number; name: BytesLike; symbol: BytesLike; decimals: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Clear the metadata for an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * Any deposit is freed for the asset owner.
     *
     * - `id`: The identifier of the asset to clear.
     *
     * Emits `MetadataCleared`.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     **/
    clearMetadata: GenericTxCall<
      (id: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'ClearMetadata';
            params: { id: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Force the metadata for an asset to some value.
     *
     * Origin must be ForceOrigin.
     *
     * Any deposit is left alone.
     *
     * - `id`: The identifier of the asset to update.
     * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
     * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
     * - `decimals`: The number of decimals this asset uses to represent one unit.
     *
     * Emits `MetadataSet`.
     *
     * Weight: `O(N + S)` where N and S are the length of the name and symbol respectively.
     *
     * @param {number} id
     * @param {BytesLike} name
     * @param {BytesLike} symbol
     * @param {number} decimals
     * @param {boolean} isFrozen
     **/
    forceSetMetadata: GenericTxCall<
      (
        id: number,
        name: BytesLike,
        symbol: BytesLike,
        decimals: number,
        isFrozen: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'ForceSetMetadata';
            params: { id: number; name: BytesLike; symbol: BytesLike; decimals: number; isFrozen: boolean };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Clear the metadata for an asset.
     *
     * Origin must be ForceOrigin.
     *
     * Any deposit is returned.
     *
     * - `id`: The identifier of the asset to clear.
     *
     * Emits `MetadataCleared`.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     **/
    forceClearMetadata: GenericTxCall<
      (id: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'ForceClearMetadata';
            params: { id: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Alter the attributes of a given asset.
     *
     * Origin must be `ForceOrigin`.
     *
     * - `id`: The identifier of the asset.
     * - `owner`: The new Owner of this asset.
     * - `issuer`: The new Issuer of this asset.
     * - `admin`: The new Admin of this asset.
     * - `freezer`: The new Freezer of this asset.
     * - `min_balance`: The minimum balance of this new asset that any single account must
     * have. If an account's balance is reduced below this, then it collapses to zero.
     * - `is_sufficient`: Whether a non-zero balance of this asset is deposit of sufficient
     * value to account for the state bloat associated with its balance storage. If set to
     * `true`, then non-zero balances may be stored without a `consumer` reference (and thus
     * an ED in the Balances pallet or whatever else is used to control user-account state
     * growth).
     * - `is_frozen`: Whether this asset class is frozen except for permissioned/admin
     * instructions.
     *
     * Emits `AssetStatusChanged` with the identity of the asset.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} owner
     * @param {MultiAddressLike} issuer
     * @param {MultiAddressLike} admin
     * @param {MultiAddressLike} freezer
     * @param {bigint} minBalance
     * @param {boolean} isSufficient
     * @param {boolean} isFrozen
     **/
    forceAssetStatus: GenericTxCall<
      (
        id: number,
        owner: MultiAddressLike,
        issuer: MultiAddressLike,
        admin: MultiAddressLike,
        freezer: MultiAddressLike,
        minBalance: bigint,
        isSufficient: boolean,
        isFrozen: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'ForceAssetStatus';
            params: {
              id: number;
              owner: MultiAddressLike;
              issuer: MultiAddressLike;
              admin: MultiAddressLike;
              freezer: MultiAddressLike;
              minBalance: bigint;
              isSufficient: boolean;
              isFrozen: boolean;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Approve an amount of asset for transfer by a delegated third-party account.
     *
     * Origin must be Signed.
     *
     * Ensures that `ApprovalDeposit` worth of `Currency` is reserved from signing account
     * for the purpose of holding the approval. If some non-zero amount of assets is already
     * approved from signing account to `delegate`, then it is topped up or unreserved to
     * meet the right value.
     *
     * NOTE: The signing account does not need to own `amount` of assets at the point of
     * making this call.
     *
     * - `id`: The identifier of the asset.
     * - `delegate`: The account to delegate permission to transfer asset.
     * - `amount`: The amount of asset that may be transferred by `delegate`. If there is
     * already an approval in place, then this acts additively.
     *
     * Emits `ApprovedTransfer` on success.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} delegate
     * @param {bigint} amount
     **/
    approveTransfer: GenericTxCall<
      (
        id: number,
        delegate: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'ApproveTransfer';
            params: { id: number; delegate: MultiAddressLike; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Cancel all of some asset approved for delegated transfer by a third-party account.
     *
     * Origin must be Signed and there must be an approval in place between signer and
     * `delegate`.
     *
     * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
     *
     * - `id`: The identifier of the asset.
     * - `delegate`: The account delegated permission to transfer asset.
     *
     * Emits `ApprovalCancelled` on success.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} delegate
     **/
    cancelApproval: GenericTxCall<
      (
        id: number,
        delegate: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'CancelApproval';
            params: { id: number; delegate: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Cancel all of some asset approved for delegated transfer by a third-party account.
     *
     * Origin must be either ForceOrigin or Signed origin with the signer being the Admin
     * account of the asset `id`.
     *
     * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
     *
     * - `id`: The identifier of the asset.
     * - `delegate`: The account delegated permission to transfer asset.
     *
     * Emits `ApprovalCancelled` on success.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} owner
     * @param {MultiAddressLike} delegate
     **/
    forceCancelApproval: GenericTxCall<
      (
        id: number,
        owner: MultiAddressLike,
        delegate: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'ForceCancelApproval';
            params: { id: number; owner: MultiAddressLike; delegate: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Transfer some asset balance from a previously delegated account to some third-party
     * account.
     *
     * Origin must be Signed and there must be an approval in place by the `owner` to the
     * signer.
     *
     * If the entire amount approved for transfer is transferred, then any deposit previously
     * reserved by `approve_transfer` is unreserved.
     *
     * - `id`: The identifier of the asset.
     * - `owner`: The account which previously approved for a transfer of at least `amount` and
     * from which the asset balance will be withdrawn.
     * - `destination`: The account to which the asset balance of `amount` will be transferred.
     * - `amount`: The amount of assets to transfer.
     *
     * Emits `TransferredApproved` on success.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} owner
     * @param {MultiAddressLike} destination
     * @param {bigint} amount
     **/
    transferApproved: GenericTxCall<
      (
        id: number,
        owner: MultiAddressLike,
        destination: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'TransferApproved';
            params: { id: number; owner: MultiAddressLike; destination: MultiAddressLike; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Create an asset account for non-provider assets.
     *
     * A deposit will be taken from the signer account.
     *
     * - `origin`: Must be Signed; the signer account must have sufficient funds for a deposit
     * to be taken.
     * - `id`: The identifier of the asset for the account to be created.
     *
     * Emits `Touched` event when successful.
     *
     * @param {number} id
     **/
    touch: GenericTxCall<
      (id: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'Touch';
            params: { id: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Return the deposit (if any) of an asset account or a consumer reference (if any) of an
     * account.
     *
     * The origin must be Signed.
     *
     * - `id`: The identifier of the asset for which the caller would like the deposit
     * refunded.
     * - `allow_burn`: If `true` then assets may be destroyed in order to complete the refund.
     *
     * It will fail with either [`Error::ContainsHolds`] or [`Error::ContainsFreezes`] if
     * the asset account contains holds or freezes in place.
     *
     * Emits `Refunded` event when successful.
     *
     * @param {number} id
     * @param {boolean} allowBurn
     **/
    refund: GenericTxCall<
      (
        id: number,
        allowBurn: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'Refund';
            params: { id: number; allowBurn: boolean };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Sets the minimum balance of an asset.
     *
     * Only works if there aren't any accounts that are holding the asset or if
     * the new value of `min_balance` is less than the old one.
     *
     * Origin must be Signed and the sender has to be the Owner of the
     * asset `id`.
     *
     * - `id`: The identifier of the asset.
     * - `min_balance`: The new value of `min_balance`.
     *
     * Emits `AssetMinBalanceChanged` event when successful.
     *
     * @param {number} id
     * @param {bigint} minBalance
     **/
    setMinBalance: GenericTxCall<
      (
        id: number,
        minBalance: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'SetMinBalance';
            params: { id: number; minBalance: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Create an asset account for `who`.
     *
     * A deposit will be taken from the signer account.
     *
     * - `origin`: Must be Signed by `Freezer` or `Admin` of the asset `id`; the signer account
     * must have sufficient funds for a deposit to be taken.
     * - `id`: The identifier of the asset for the account to be created.
     * - `who`: The account to be created.
     *
     * Emits `Touched` event when successful.
     *
     * @param {number} id
     * @param {MultiAddressLike} who
     **/
    touchOther: GenericTxCall<
      (
        id: number,
        who: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'TouchOther';
            params: { id: number; who: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Return the deposit (if any) of a target asset account. Useful if you are the depositor.
     *
     * The origin must be Signed and either the account owner, depositor, or asset `Admin`. In
     * order to burn a non-zero balance of the asset, the caller must be the account and should
     * use `refund`.
     *
     * - `id`: The identifier of the asset for the account holding a deposit.
     * - `who`: The account to refund.
     *
     * It will fail with either [`Error::ContainsHolds`] or [`Error::ContainsFreezes`] if
     * the asset account contains holds or freezes in place.
     *
     * Emits `Refunded` event when successful.
     *
     * @param {number} id
     * @param {MultiAddressLike} who
     **/
    refundOther: GenericTxCall<
      (
        id: number,
        who: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'RefundOther';
            params: { id: number; who: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Disallow further unprivileged transfers of an asset `id` to and from an account `who`.
     *
     * Origin must be Signed and the sender should be the Freezer of the asset `id`.
     *
     * - `id`: The identifier of the account's asset.
     * - `who`: The account to be unblocked.
     *
     * Emits `Blocked`.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} who
     **/
    block: GenericTxCall<
      (
        id: number,
        who: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'Block';
            params: { id: number; who: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Transfer the entire transferable balance from the caller asset account.
     *
     * NOTE: This function only attempts to transfer _transferable_ balances. This means that
     * any held, frozen, or minimum balance (when `keep_alive` is `true`), will not be
     * transferred by this function. To ensure that this function results in a killed account,
     * you might need to prepare the account by removing any reference counters, storage
     * deposits, etc...
     *
     * The dispatch origin of this call must be Signed.
     *
     * - `id`: The identifier of the asset for the account holding a deposit.
     * - `dest`: The recipient of the transfer.
     * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
     * of the funds the asset account has, causing the sender asset account to be killed
     * (false), or transfer everything except at least the minimum balance, which will
     * guarantee to keep the sender asset account alive (true).
     *
     * @param {number} id
     * @param {MultiAddressLike} dest
     * @param {boolean} keepAlive
     **/
    transferAll: GenericTxCall<
      (
        id: number,
        dest: MultiAddressLike,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Assets';
          palletCall: {
            name: 'TransferAll';
            params: { id: number; dest: MultiAddressLike; keepAlive: boolean };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Uniques`'s transaction calls
   **/
  uniques: {
    /**
     * Issue a new collection of non-fungible items from a public origin.
     *
     * This new collection has no items initially and its owner is the origin.
     *
     * The origin must conform to the configured `CreateOrigin` and have sufficient funds free.
     *
     * `ItemDeposit` funds of sender are reserved.
     *
     * Parameters:
     * - `collection`: The identifier of the new collection. This must not be currently in use.
     * - `admin`: The admin of this collection. The admin is the initial address of each
     * member of the collection's admin team.
     *
     * Emits `Created` event when successful.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {MultiAddressLike} admin
     **/
    create: GenericTxCall<
      (
        collection: number,
        admin: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'Create';
            params: { collection: number; admin: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Issue a new collection of non-fungible items from a privileged origin.
     *
     * This new collection has no items initially.
     *
     * The origin must conform to `ForceOrigin`.
     *
     * Unlike `create`, no funds are reserved.
     *
     * - `collection`: The identifier of the new item. This must not be currently in use.
     * - `owner`: The owner of this collection of items. The owner has full superuser
     * permissions
     * over this item, but may later change and configure the permissions using
     * `transfer_ownership` and `set_team`.
     *
     * Emits `ForceCreated` event when successful.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {MultiAddressLike} owner
     * @param {boolean} freeHolding
     **/
    forceCreate: GenericTxCall<
      (
        collection: number,
        owner: MultiAddressLike,
        freeHolding: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'ForceCreate';
            params: { collection: number; owner: MultiAddressLike; freeHolding: boolean };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Destroy a collection of fungible items.
     *
     * The origin must conform to `ForceOrigin` or must be `Signed` and the sender must be the
     * owner of the `collection`.
     *
     * - `collection`: The identifier of the collection to be destroyed.
     * - `witness`: Information on the items minted in the collection. This must be
     * correct.
     *
     * Emits `Destroyed` event when successful.
     *
     * Weight: `O(n + m)` where:
     * - `n = witness.items`
     * - `m = witness.item_metadatas`
     * - `a = witness.attributes`
     *
     * @param {number} collection
     * @param {PalletUniquesDestroyWitness} witness
     **/
    destroy: GenericTxCall<
      (
        collection: number,
        witness: PalletUniquesDestroyWitness,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'Destroy';
            params: { collection: number; witness: PalletUniquesDestroyWitness };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Mint an item of a particular collection.
     *
     * The origin must be Signed and the sender must be the Issuer of the `collection`.
     *
     * - `collection`: The collection of the item to be minted.
     * - `item`: The item value of the item to be minted.
     * - `beneficiary`: The initial owner of the minted item.
     *
     * Emits `Issued` event when successful.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {number} item
     * @param {MultiAddressLike} owner
     **/
    mint: GenericTxCall<
      (
        collection: number,
        item: number,
        owner: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'Mint';
            params: { collection: number; item: number; owner: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Destroy a single item.
     *
     * Origin must be Signed and the signing account must be either:
     * - the Admin of the `collection`;
     * - the Owner of the `item`;
     *
     * - `collection`: The collection of the item to be burned.
     * - `item`: The item of the item to be burned.
     * - `check_owner`: If `Some` then the operation will fail with `WrongOwner` unless the
     * item is owned by this value.
     *
     * Emits `Burned` with the actual amount burned.
     *
     * Weight: `O(1)`
     * Modes: `check_owner.is_some()`.
     *
     * @param {number} collection
     * @param {number} item
     * @param {MultiAddressLike | undefined} checkOwner
     **/
    burn: GenericTxCall<
      (
        collection: number,
        item: number,
        checkOwner: MultiAddressLike | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'Burn';
            params: { collection: number; item: number; checkOwner: MultiAddressLike | undefined };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Move an item from the sender account to another.
     *
     * This resets the approved account of the item.
     *
     * Origin must be Signed and the signing account must be either:
     * - the Admin of the `collection`;
     * - the Owner of the `item`;
     * - the approved delegate for the `item` (in this case, the approval is reset).
     *
     * Arguments:
     * - `collection`: The collection of the item to be transferred.
     * - `item`: The item of the item to be transferred.
     * - `dest`: The account to receive ownership of the item.
     *
     * Emits `Transferred`.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {number} item
     * @param {MultiAddressLike} dest
     **/
    transfer: GenericTxCall<
      (
        collection: number,
        item: number,
        dest: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'Transfer';
            params: { collection: number; item: number; dest: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Reevaluate the deposits on some items.
     *
     * Origin must be Signed and the sender should be the Owner of the `collection`.
     *
     * - `collection`: The collection to be frozen.
     * - `items`: The items of the collection whose deposits will be reevaluated.
     *
     * NOTE: This exists as a best-effort function. Any items which are unknown or
     * in the case that the owner account does not have reservable funds to pay for a
     * deposit increase are ignored. Generally the owner isn't going to call this on items
     * whose existing deposit is less than the refreshed deposit as it would only cost them,
     * so it's of little consequence.
     *
     * It will still return an error in the case that the collection is unknown of the signer
     * is not permitted to call it.
     *
     * Weight: `O(items.len())`
     *
     * @param {number} collection
     * @param {Array<number>} items
     **/
    redeposit: GenericTxCall<
      (
        collection: number,
        items: Array<number>,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'Redeposit';
            params: { collection: number; items: Array<number> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Disallow further unprivileged transfer of an item.
     *
     * Origin must be Signed and the sender should be the Freezer of the `collection`.
     *
     * - `collection`: The collection of the item to be frozen.
     * - `item`: The item of the item to be frozen.
     *
     * Emits `Frozen`.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {number} item
     **/
    freeze: GenericTxCall<
      (
        collection: number,
        item: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'Freeze';
            params: { collection: number; item: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Re-allow unprivileged transfer of an item.
     *
     * Origin must be Signed and the sender should be the Freezer of the `collection`.
     *
     * - `collection`: The collection of the item to be thawed.
     * - `item`: The item of the item to be thawed.
     *
     * Emits `Thawed`.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {number} item
     **/
    thaw: GenericTxCall<
      (
        collection: number,
        item: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'Thaw';
            params: { collection: number; item: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Disallow further unprivileged transfers for a whole collection.
     *
     * Origin must be Signed and the sender should be the Freezer of the `collection`.
     *
     * - `collection`: The collection to be frozen.
     *
     * Emits `CollectionFrozen`.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     **/
    freezeCollection: GenericTxCall<
      (collection: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'FreezeCollection';
            params: { collection: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Re-allow unprivileged transfers for a whole collection.
     *
     * Origin must be Signed and the sender should be the Admin of the `collection`.
     *
     * - `collection`: The collection to be thawed.
     *
     * Emits `CollectionThawed`.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     **/
    thawCollection: GenericTxCall<
      (collection: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'ThawCollection';
            params: { collection: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Change the Owner of a collection.
     *
     * Origin must be Signed and the sender should be the Owner of the `collection`.
     *
     * - `collection`: The collection whose owner should be changed.
     * - `owner`: The new Owner of this collection. They must have called
     * `set_accept_ownership` with `collection` in order for this operation to succeed.
     *
     * Emits `OwnerChanged`.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {MultiAddressLike} newOwner
     **/
    transferOwnership: GenericTxCall<
      (
        collection: number,
        newOwner: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'TransferOwnership';
            params: { collection: number; newOwner: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Change the Issuer, Admin and Freezer of a collection.
     *
     * Origin must be Signed and the sender should be the Owner of the `collection`.
     *
     * - `collection`: The collection whose team should be changed.
     * - `issuer`: The new Issuer of this collection.
     * - `admin`: The new Admin of this collection.
     * - `freezer`: The new Freezer of this collection.
     *
     * Emits `TeamChanged`.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {MultiAddressLike} issuer
     * @param {MultiAddressLike} admin
     * @param {MultiAddressLike} freezer
     **/
    setTeam: GenericTxCall<
      (
        collection: number,
        issuer: MultiAddressLike,
        admin: MultiAddressLike,
        freezer: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'SetTeam';
            params: {
              collection: number;
              issuer: MultiAddressLike;
              admin: MultiAddressLike;
              freezer: MultiAddressLike;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Approve an item to be transferred by a delegated third-party account.
     *
     * The origin must conform to `ForceOrigin` or must be `Signed` and the sender must be
     * either the owner of the `item` or the admin of the collection.
     *
     * - `collection`: The collection of the item to be approved for delegated transfer.
     * - `item`: The item of the item to be approved for delegated transfer.
     * - `delegate`: The account to delegate permission to transfer the item.
     *
     * Important NOTE: The `approved` account gets reset after each transfer.
     *
     * Emits `ApprovedTransfer` on success.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {number} item
     * @param {MultiAddressLike} delegate
     **/
    approveTransfer: GenericTxCall<
      (
        collection: number,
        item: number,
        delegate: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'ApproveTransfer';
            params: { collection: number; item: number; delegate: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Cancel the prior approval for the transfer of an item by a delegate.
     *
     * Origin must be either:
     * - the `Force` origin;
     * - `Signed` with the signer being the Admin of the `collection`;
     * - `Signed` with the signer being the Owner of the `item`;
     *
     * Arguments:
     * - `collection`: The collection of the item of whose approval will be cancelled.
     * - `item`: The item of the item of whose approval will be cancelled.
     * - `maybe_check_delegate`: If `Some` will ensure that the given account is the one to
     * which permission of transfer is delegated.
     *
     * Emits `ApprovalCancelled` on success.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {number} item
     * @param {MultiAddressLike | undefined} maybeCheckDelegate
     **/
    cancelApproval: GenericTxCall<
      (
        collection: number,
        item: number,
        maybeCheckDelegate: MultiAddressLike | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'CancelApproval';
            params: { collection: number; item: number; maybeCheckDelegate: MultiAddressLike | undefined };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Alter the attributes of a given item.
     *
     * Origin must be `ForceOrigin`.
     *
     * - `collection`: The identifier of the item.
     * - `owner`: The new Owner of this item.
     * - `issuer`: The new Issuer of this item.
     * - `admin`: The new Admin of this item.
     * - `freezer`: The new Freezer of this item.
     * - `free_holding`: Whether a deposit is taken for holding an item of this collection.
     * - `is_frozen`: Whether this collection is frozen except for permissioned/admin
     * instructions.
     *
     * Emits `ItemStatusChanged` with the identity of the item.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {MultiAddressLike} owner
     * @param {MultiAddressLike} issuer
     * @param {MultiAddressLike} admin
     * @param {MultiAddressLike} freezer
     * @param {boolean} freeHolding
     * @param {boolean} isFrozen
     **/
    forceItemStatus: GenericTxCall<
      (
        collection: number,
        owner: MultiAddressLike,
        issuer: MultiAddressLike,
        admin: MultiAddressLike,
        freezer: MultiAddressLike,
        freeHolding: boolean,
        isFrozen: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'ForceItemStatus';
            params: {
              collection: number;
              owner: MultiAddressLike;
              issuer: MultiAddressLike;
              admin: MultiAddressLike;
              freezer: MultiAddressLike;
              freeHolding: boolean;
              isFrozen: boolean;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set an attribute for a collection or item.
     *
     * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
     * `collection`.
     *
     * If the origin is Signed, then funds of signer are reserved according to the formula:
     * `MetadataDepositBase + DepositPerByte * (key.len + value.len)` taking into
     * account any already reserved funds.
     *
     * - `collection`: The identifier of the collection whose item's metadata to set.
     * - `maybe_item`: The identifier of the item whose metadata to set.
     * - `key`: The key of the attribute.
     * - `value`: The value to which to set the attribute.
     *
     * Emits `AttributeSet`.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {number | undefined} maybeItem
     * @param {BytesLike} key
     * @param {BytesLike} value
     **/
    setAttribute: GenericTxCall<
      (
        collection: number,
        maybeItem: number | undefined,
        key: BytesLike,
        value: BytesLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'SetAttribute';
            params: { collection: number; maybeItem: number | undefined; key: BytesLike; value: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Clear an attribute for a collection or item.
     *
     * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
     * `collection`.
     *
     * Any deposit is freed for the collection's owner.
     *
     * - `collection`: The identifier of the collection whose item's metadata to clear.
     * - `maybe_item`: The identifier of the item whose metadata to clear.
     * - `key`: The key of the attribute.
     *
     * Emits `AttributeCleared`.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {number | undefined} maybeItem
     * @param {BytesLike} key
     **/
    clearAttribute: GenericTxCall<
      (
        collection: number,
        maybeItem: number | undefined,
        key: BytesLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'ClearAttribute';
            params: { collection: number; maybeItem: number | undefined; key: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the metadata for an item.
     *
     * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
     * `collection`.
     *
     * If the origin is Signed, then funds of signer are reserved according to the formula:
     * `MetadataDepositBase + DepositPerByte * data.len` taking into
     * account any already reserved funds.
     *
     * - `collection`: The identifier of the collection whose item's metadata to set.
     * - `item`: The identifier of the item whose metadata to set.
     * - `data`: The general information of this item. Limited in length by `StringLimit`.
     * - `is_frozen`: Whether the metadata should be frozen against further changes.
     *
     * Emits `MetadataSet`.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {number} item
     * @param {BytesLike} data
     * @param {boolean} isFrozen
     **/
    setMetadata: GenericTxCall<
      (
        collection: number,
        item: number,
        data: BytesLike,
        isFrozen: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'SetMetadata';
            params: { collection: number; item: number; data: BytesLike; isFrozen: boolean };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Clear the metadata for an item.
     *
     * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
     * `item`.
     *
     * Any deposit is freed for the collection's owner.
     *
     * - `collection`: The identifier of the collection whose item's metadata to clear.
     * - `item`: The identifier of the item whose metadata to clear.
     *
     * Emits `MetadataCleared`.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {number} item
     **/
    clearMetadata: GenericTxCall<
      (
        collection: number,
        item: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'ClearMetadata';
            params: { collection: number; item: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the metadata for a collection.
     *
     * Origin must be either `ForceOrigin` or `Signed` and the sender should be the Owner of
     * the `collection`.
     *
     * If the origin is `Signed`, then funds of signer are reserved according to the formula:
     * `MetadataDepositBase + DepositPerByte * data.len` taking into
     * account any already reserved funds.
     *
     * - `collection`: The identifier of the item whose metadata to update.
     * - `data`: The general information of this item. Limited in length by `StringLimit`.
     * - `is_frozen`: Whether the metadata should be frozen against further changes.
     *
     * Emits `CollectionMetadataSet`.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {BytesLike} data
     * @param {boolean} isFrozen
     **/
    setCollectionMetadata: GenericTxCall<
      (
        collection: number,
        data: BytesLike,
        isFrozen: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'SetCollectionMetadata';
            params: { collection: number; data: BytesLike; isFrozen: boolean };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Clear the metadata for a collection.
     *
     * Origin must be either `ForceOrigin` or `Signed` and the sender should be the Owner of
     * the `collection`.
     *
     * Any deposit is freed for the collection's owner.
     *
     * - `collection`: The identifier of the collection whose metadata to clear.
     *
     * Emits `CollectionMetadataCleared`.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     **/
    clearCollectionMetadata: GenericTxCall<
      (collection: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'ClearCollectionMetadata';
            params: { collection: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set (or reset) the acceptance of ownership for a particular account.
     *
     * Origin must be `Signed` and if `maybe_collection` is `Some`, then the signer must have a
     * provider reference.
     *
     * - `maybe_collection`: The identifier of the collection whose ownership the signer is
     * willing to accept, or if `None`, an indication that the signer is willing to accept no
     * ownership transferal.
     *
     * Emits `OwnershipAcceptanceChanged`.
     *
     * @param {number | undefined} maybeCollection
     **/
    setAcceptOwnership: GenericTxCall<
      (maybeCollection: number | undefined) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'SetAcceptOwnership';
            params: { maybeCollection: number | undefined };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the maximum amount of items a collection could have.
     *
     * Origin must be either `ForceOrigin` or `Signed` and the sender should be the Owner of
     * the `collection`.
     *
     * Note: This function can only succeed once per collection.
     *
     * - `collection`: The identifier of the collection to change.
     * - `max_supply`: The maximum amount of items a collection could have.
     *
     * Emits `CollectionMaxSupplySet` event when successful.
     *
     * @param {number} collection
     * @param {number} maxSupply
     **/
    setCollectionMaxSupply: GenericTxCall<
      (
        collection: number,
        maxSupply: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'SetCollectionMaxSupply';
            params: { collection: number; maxSupply: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set (or reset) the price for an item.
     *
     * Origin must be Signed and must be the owner of the asset `item`.
     *
     * - `collection`: The collection of the item.
     * - `item`: The item to set the price for.
     * - `price`: The price for the item. Pass `None`, to reset the price.
     * - `buyer`: Restricts the buy operation to a specific account.
     *
     * Emits `ItemPriceSet` on success if the price is not `None`.
     * Emits `ItemPriceRemoved` on success if the price is `None`.
     *
     * @param {number} collection
     * @param {number} item
     * @param {bigint | undefined} price
     * @param {MultiAddressLike | undefined} whitelistedBuyer
     **/
    setPrice: GenericTxCall<
      (
        collection: number,
        item: number,
        price: bigint | undefined,
        whitelistedBuyer: MultiAddressLike | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'SetPrice';
            params: {
              collection: number;
              item: number;
              price: bigint | undefined;
              whitelistedBuyer: MultiAddressLike | undefined;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Allows to buy an item if it's up for sale.
     *
     * Origin must be Signed and must not be the owner of the `item`.
     *
     * - `collection`: The collection of the item.
     * - `item`: The item the sender wants to buy.
     * - `bid_price`: The price the sender is willing to pay.
     *
     * Emits `ItemBought` on success.
     *
     * @param {number} collection
     * @param {number} item
     * @param {bigint} bidPrice
     **/
    buyItem: GenericTxCall<
      (
        collection: number,
        item: number,
        bidPrice: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'BuyItem';
            params: { collection: number; item: number; bidPrice: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Nfts`'s transaction calls
   **/
  nfts: {
    /**
     * Issue a new collection of non-fungible items from a public origin.
     *
     * This new collection has no items initially and its owner is the origin.
     *
     * The origin must be Signed and the sender must have sufficient funds free.
     *
     * `CollectionDeposit` funds of sender are reserved.
     *
     * Parameters:
     * - `admin`: The admin of this collection. The admin is the initial address of each
     * member of the collection's admin team.
     *
     * Emits `Created` event when successful.
     *
     * Weight: `O(1)`
     *
     * @param {MultiAddressLike} admin
     * @param {PalletNftsCollectionConfig} config
     **/
    create: GenericTxCall<
      (
        admin: MultiAddressLike,
        config: PalletNftsCollectionConfig,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'Create';
            params: { admin: MultiAddressLike; config: PalletNftsCollectionConfig };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Issue a new collection of non-fungible items from a privileged origin.
     *
     * This new collection has no items initially.
     *
     * The origin must conform to `ForceOrigin`.
     *
     * Unlike `create`, no funds are reserved.
     *
     * - `owner`: The owner of this collection of items. The owner has full superuser
     * permissions over this item, but may later change and configure the permissions using
     * `transfer_ownership` and `set_team`.
     *
     * Emits `ForceCreated` event when successful.
     *
     * Weight: `O(1)`
     *
     * @param {MultiAddressLike} owner
     * @param {PalletNftsCollectionConfig} config
     **/
    forceCreate: GenericTxCall<
      (
        owner: MultiAddressLike,
        config: PalletNftsCollectionConfig,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'ForceCreate';
            params: { owner: MultiAddressLike; config: PalletNftsCollectionConfig };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Destroy a collection of fungible items.
     *
     * The origin must conform to `ForceOrigin` or must be `Signed` and the sender must be the
     * owner of the `collection`.
     *
     * NOTE: The collection must have 0 items to be destroyed.
     *
     * - `collection`: The identifier of the collection to be destroyed.
     * - `witness`: Information on the items minted in the collection. This must be
     * correct.
     *
     * Emits `Destroyed` event when successful.
     *
     * Weight: `O(m + c + a)` where:
     * - `m = witness.item_metadatas`
     * - `c = witness.item_configs`
     * - `a = witness.attributes`
     *
     * @param {number} collection
     * @param {PalletNftsDestroyWitness} witness
     **/
    destroy: GenericTxCall<
      (
        collection: number,
        witness: PalletNftsDestroyWitness,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'Destroy';
            params: { collection: number; witness: PalletNftsDestroyWitness };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Mint an item of a particular collection.
     *
     * The origin must be Signed and the sender must comply with the `mint_settings` rules.
     *
     * - `collection`: The collection of the item to be minted.
     * - `item`: An identifier of the new item.
     * - `mint_to`: Account into which the item will be minted.
     * - `witness_data`: When the mint type is `HolderOf(collection_id)`, then the owned
     * item_id from that collection needs to be provided within the witness data object. If
     * the mint price is set, then it should be additionally confirmed in the `witness_data`.
     *
     * Note: the deposit will be taken from the `origin` and not the `owner` of the `item`.
     *
     * Emits `Issued` event when successful.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {number} item
     * @param {MultiAddressLike} mintTo
     * @param {PalletNftsMintWitness | undefined} witnessData
     **/
    mint: GenericTxCall<
      (
        collection: number,
        item: number,
        mintTo: MultiAddressLike,
        witnessData: PalletNftsMintWitness | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'Mint';
            params: {
              collection: number;
              item: number;
              mintTo: MultiAddressLike;
              witnessData: PalletNftsMintWitness | undefined;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Mint an item of a particular collection from a privileged origin.
     *
     * The origin must conform to `ForceOrigin` or must be `Signed` and the sender must be the
     * Issuer of the `collection`.
     *
     * - `collection`: The collection of the item to be minted.
     * - `item`: An identifier of the new item.
     * - `mint_to`: Account into which the item will be minted.
     * - `item_config`: A config of the new item.
     *
     * Emits `Issued` event when successful.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {number} item
     * @param {MultiAddressLike} mintTo
     * @param {PalletNftsItemConfig} itemConfig
     **/
    forceMint: GenericTxCall<
      (
        collection: number,
        item: number,
        mintTo: MultiAddressLike,
        itemConfig: PalletNftsItemConfig,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'ForceMint';
            params: { collection: number; item: number; mintTo: MultiAddressLike; itemConfig: PalletNftsItemConfig };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Destroy a single item.
     *
     * The origin must conform to `ForceOrigin` or must be Signed and the signing account must
     * be the owner of the `item`.
     *
     * - `collection`: The collection of the item to be burned.
     * - `item`: The item to be burned.
     *
     * Emits `Burned`.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {number} item
     **/
    burn: GenericTxCall<
      (
        collection: number,
        item: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'Burn';
            params: { collection: number; item: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Move an item from the sender account to another.
     *
     * Origin must be Signed and the signing account must be either:
     * - the Owner of the `item`;
     * - the approved delegate for the `item` (in this case, the approval is reset).
     *
     * Arguments:
     * - `collection`: The collection of the item to be transferred.
     * - `item`: The item to be transferred.
     * - `dest`: The account to receive ownership of the item.
     *
     * Emits `Transferred`.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {number} item
     * @param {MultiAddressLike} dest
     **/
    transfer: GenericTxCall<
      (
        collection: number,
        item: number,
        dest: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'Transfer';
            params: { collection: number; item: number; dest: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Re-evaluate the deposits on some items.
     *
     * Origin must be Signed and the sender should be the Owner of the `collection`.
     *
     * - `collection`: The collection of the items to be reevaluated.
     * - `items`: The items of the collection whose deposits will be reevaluated.
     *
     * NOTE: This exists as a best-effort function. Any items which are unknown or
     * in the case that the owner account does not have reservable funds to pay for a
     * deposit increase are ignored. Generally the owner isn't going to call this on items
     * whose existing deposit is less than the refreshed deposit as it would only cost them,
     * so it's of little consequence.
     *
     * It will still return an error in the case that the collection is unknown or the signer
     * is not permitted to call it.
     *
     * Weight: `O(items.len())`
     *
     * @param {number} collection
     * @param {Array<number>} items
     **/
    redeposit: GenericTxCall<
      (
        collection: number,
        items: Array<number>,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'Redeposit';
            params: { collection: number; items: Array<number> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Disallow further unprivileged transfer of an item.
     *
     * Origin must be Signed and the sender should be the Freezer of the `collection`.
     *
     * - `collection`: The collection of the item to be changed.
     * - `item`: The item to become non-transferable.
     *
     * Emits `ItemTransferLocked`.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {number} item
     **/
    lockItemTransfer: GenericTxCall<
      (
        collection: number,
        item: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'LockItemTransfer';
            params: { collection: number; item: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Re-allow unprivileged transfer of an item.
     *
     * Origin must be Signed and the sender should be the Freezer of the `collection`.
     *
     * - `collection`: The collection of the item to be changed.
     * - `item`: The item to become transferable.
     *
     * Emits `ItemTransferUnlocked`.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {number} item
     **/
    unlockItemTransfer: GenericTxCall<
      (
        collection: number,
        item: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'UnlockItemTransfer';
            params: { collection: number; item: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Disallows specified settings for the whole collection.
     *
     * Origin must be Signed and the sender should be the Owner of the `collection`.
     *
     * - `collection`: The collection to be locked.
     * - `lock_settings`: The settings to be locked.
     *
     * Note: it's possible to only lock(set) the setting, but not to unset it.
     *
     * Emits `CollectionLocked`.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {PalletNftsBitFlags} lockSettings
     **/
    lockCollection: GenericTxCall<
      (
        collection: number,
        lockSettings: PalletNftsBitFlags,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'LockCollection';
            params: { collection: number; lockSettings: PalletNftsBitFlags };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Change the Owner of a collection.
     *
     * Origin must be Signed and the sender should be the Owner of the `collection`.
     *
     * - `collection`: The collection whose owner should be changed.
     * - `owner`: The new Owner of this collection. They must have called
     * `set_accept_ownership` with `collection` in order for this operation to succeed.
     *
     * Emits `OwnerChanged`.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {MultiAddressLike} newOwner
     **/
    transferOwnership: GenericTxCall<
      (
        collection: number,
        newOwner: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'TransferOwnership';
            params: { collection: number; newOwner: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Change the Issuer, Admin and Freezer of a collection.
     *
     * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
     * `collection`.
     *
     * Note: by setting the role to `None` only the `ForceOrigin` will be able to change it
     * after to `Some(account)`.
     *
     * - `collection`: The collection whose team should be changed.
     * - `issuer`: The new Issuer of this collection.
     * - `admin`: The new Admin of this collection.
     * - `freezer`: The new Freezer of this collection.
     *
     * Emits `TeamChanged`.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {MultiAddressLike | undefined} issuer
     * @param {MultiAddressLike | undefined} admin
     * @param {MultiAddressLike | undefined} freezer
     **/
    setTeam: GenericTxCall<
      (
        collection: number,
        issuer: MultiAddressLike | undefined,
        admin: MultiAddressLike | undefined,
        freezer: MultiAddressLike | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'SetTeam';
            params: {
              collection: number;
              issuer: MultiAddressLike | undefined;
              admin: MultiAddressLike | undefined;
              freezer: MultiAddressLike | undefined;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Change the Owner of a collection.
     *
     * Origin must be `ForceOrigin`.
     *
     * - `collection`: The identifier of the collection.
     * - `owner`: The new Owner of this collection.
     *
     * Emits `OwnerChanged`.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {MultiAddressLike} owner
     **/
    forceCollectionOwner: GenericTxCall<
      (
        collection: number,
        owner: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'ForceCollectionOwner';
            params: { collection: number; owner: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Change the config of a collection.
     *
     * Origin must be `ForceOrigin`.
     *
     * - `collection`: The identifier of the collection.
     * - `config`: The new config of this collection.
     *
     * Emits `CollectionConfigChanged`.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {PalletNftsCollectionConfig} config
     **/
    forceCollectionConfig: GenericTxCall<
      (
        collection: number,
        config: PalletNftsCollectionConfig,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'ForceCollectionConfig';
            params: { collection: number; config: PalletNftsCollectionConfig };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Approve an item to be transferred by a delegated third-party account.
     *
     * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
     * `item`.
     *
     * - `collection`: The collection of the item to be approved for delegated transfer.
     * - `item`: The item to be approved for delegated transfer.
     * - `delegate`: The account to delegate permission to transfer the item.
     * - `maybe_deadline`: Optional deadline for the approval. Specified by providing the
     * number of blocks after which the approval will expire
     *
     * Emits `TransferApproved` on success.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {number} item
     * @param {MultiAddressLike} delegate
     * @param {number | undefined} maybeDeadline
     **/
    approveTransfer: GenericTxCall<
      (
        collection: number,
        item: number,
        delegate: MultiAddressLike,
        maybeDeadline: number | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'ApproveTransfer';
            params: { collection: number; item: number; delegate: MultiAddressLike; maybeDeadline: number | undefined };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Cancel one of the transfer approvals for a specific item.
     *
     * Origin must be either:
     * - the `Force` origin;
     * - `Signed` with the signer being the Owner of the `item`;
     *
     * Arguments:
     * - `collection`: The collection of the item of whose approval will be cancelled.
     * - `item`: The item of the collection of whose approval will be cancelled.
     * - `delegate`: The account that is going to loose their approval.
     *
     * Emits `ApprovalCancelled` on success.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {number} item
     * @param {MultiAddressLike} delegate
     **/
    cancelApproval: GenericTxCall<
      (
        collection: number,
        item: number,
        delegate: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'CancelApproval';
            params: { collection: number; item: number; delegate: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Cancel all the approvals of a specific item.
     *
     * Origin must be either:
     * - the `Force` origin;
     * - `Signed` with the signer being the Owner of the `item`;
     *
     * Arguments:
     * - `collection`: The collection of the item of whose approvals will be cleared.
     * - `item`: The item of the collection of whose approvals will be cleared.
     *
     * Emits `AllApprovalsCancelled` on success.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {number} item
     **/
    clearAllTransferApprovals: GenericTxCall<
      (
        collection: number,
        item: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'ClearAllTransferApprovals';
            params: { collection: number; item: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Disallows changing the metadata or attributes of the item.
     *
     * Origin must be either `ForceOrigin` or Signed and the sender should be the Admin
     * of the `collection`.
     *
     * - `collection`: The collection if the `item`.
     * - `item`: An item to be locked.
     * - `lock_metadata`: Specifies whether the metadata should be locked.
     * - `lock_attributes`: Specifies whether the attributes in the `CollectionOwner` namespace
     * should be locked.
     *
     * Note: `lock_attributes` affects the attributes in the `CollectionOwner` namespace only.
     * When the metadata or attributes are locked, it won't be possible the unlock them.
     *
     * Emits `ItemPropertiesLocked`.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {number} item
     * @param {boolean} lockMetadata
     * @param {boolean} lockAttributes
     **/
    lockItemProperties: GenericTxCall<
      (
        collection: number,
        item: number,
        lockMetadata: boolean,
        lockAttributes: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'LockItemProperties';
            params: { collection: number; item: number; lockMetadata: boolean; lockAttributes: boolean };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set an attribute for a collection or item.
     *
     * Origin must be Signed and must conform to the namespace ruleset:
     * - `CollectionOwner` namespace could be modified by the `collection` Admin only;
     * - `ItemOwner` namespace could be modified by the `maybe_item` owner only. `maybe_item`
     * should be set in that case;
     * - `Account(AccountId)` namespace could be modified only when the `origin` was given a
     * permission to do so;
     *
     * The funds of `origin` are reserved according to the formula:
     * `AttributeDepositBase + DepositPerByte * (key.len + value.len)` taking into
     * account any already reserved funds.
     *
     * - `collection`: The identifier of the collection whose item's metadata to set.
     * - `maybe_item`: The identifier of the item whose metadata to set.
     * - `namespace`: Attribute's namespace.
     * - `key`: The key of the attribute.
     * - `value`: The value to which to set the attribute.
     *
     * Emits `AttributeSet`.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {number | undefined} maybeItem
     * @param {PalletNftsAttributeNamespace} namespace
     * @param {BytesLike} key
     * @param {BytesLike} value
     **/
    setAttribute: GenericTxCall<
      (
        collection: number,
        maybeItem: number | undefined,
        namespace: PalletNftsAttributeNamespace,
        key: BytesLike,
        value: BytesLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'SetAttribute';
            params: {
              collection: number;
              maybeItem: number | undefined;
              namespace: PalletNftsAttributeNamespace;
              key: BytesLike;
              value: BytesLike;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Force-set an attribute for a collection or item.
     *
     * Origin must be `ForceOrigin`.
     *
     * If the attribute already exists and it was set by another account, the deposit
     * will be returned to the previous owner.
     *
     * - `set_as`: An optional owner of the attribute.
     * - `collection`: The identifier of the collection whose item's metadata to set.
     * - `maybe_item`: The identifier of the item whose metadata to set.
     * - `namespace`: Attribute's namespace.
     * - `key`: The key of the attribute.
     * - `value`: The value to which to set the attribute.
     *
     * Emits `AttributeSet`.
     *
     * Weight: `O(1)`
     *
     * @param {AccountId32Like | undefined} setAs
     * @param {number} collection
     * @param {number | undefined} maybeItem
     * @param {PalletNftsAttributeNamespace} namespace
     * @param {BytesLike} key
     * @param {BytesLike} value
     **/
    forceSetAttribute: GenericTxCall<
      (
        setAs: AccountId32Like | undefined,
        collection: number,
        maybeItem: number | undefined,
        namespace: PalletNftsAttributeNamespace,
        key: BytesLike,
        value: BytesLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'ForceSetAttribute';
            params: {
              setAs: AccountId32Like | undefined;
              collection: number;
              maybeItem: number | undefined;
              namespace: PalletNftsAttributeNamespace;
              key: BytesLike;
              value: BytesLike;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Clear an attribute for a collection or item.
     *
     * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
     * attribute.
     *
     * Any deposit is freed for the collection's owner.
     *
     * - `collection`: The identifier of the collection whose item's metadata to clear.
     * - `maybe_item`: The identifier of the item whose metadata to clear.
     * - `namespace`: Attribute's namespace.
     * - `key`: The key of the attribute.
     *
     * Emits `AttributeCleared`.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {number | undefined} maybeItem
     * @param {PalletNftsAttributeNamespace} namespace
     * @param {BytesLike} key
     **/
    clearAttribute: GenericTxCall<
      (
        collection: number,
        maybeItem: number | undefined,
        namespace: PalletNftsAttributeNamespace,
        key: BytesLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'ClearAttribute';
            params: {
              collection: number;
              maybeItem: number | undefined;
              namespace: PalletNftsAttributeNamespace;
              key: BytesLike;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Approve item's attributes to be changed by a delegated third-party account.
     *
     * Origin must be Signed and must be an owner of the `item`.
     *
     * - `collection`: A collection of the item.
     * - `item`: The item that holds attributes.
     * - `delegate`: The account to delegate permission to change attributes of the item.
     *
     * Emits `ItemAttributesApprovalAdded` on success.
     *
     * @param {number} collection
     * @param {number} item
     * @param {MultiAddressLike} delegate
     **/
    approveItemAttributes: GenericTxCall<
      (
        collection: number,
        item: number,
        delegate: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'ApproveItemAttributes';
            params: { collection: number; item: number; delegate: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Cancel the previously provided approval to change item's attributes.
     * All the previously set attributes by the `delegate` will be removed.
     *
     * Origin must be Signed and must be an owner of the `item`.
     *
     * - `collection`: Collection that the item is contained within.
     * - `item`: The item that holds attributes.
     * - `delegate`: The previously approved account to remove.
     *
     * Emits `ItemAttributesApprovalRemoved` on success.
     *
     * @param {number} collection
     * @param {number} item
     * @param {MultiAddressLike} delegate
     * @param {PalletNftsCancelAttributesApprovalWitness} witness
     **/
    cancelItemAttributesApproval: GenericTxCall<
      (
        collection: number,
        item: number,
        delegate: MultiAddressLike,
        witness: PalletNftsCancelAttributesApprovalWitness,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'CancelItemAttributesApproval';
            params: {
              collection: number;
              item: number;
              delegate: MultiAddressLike;
              witness: PalletNftsCancelAttributesApprovalWitness;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the metadata for an item.
     *
     * Origin must be either `ForceOrigin` or Signed and the sender should be the Admin of the
     * `collection`.
     *
     * If the origin is Signed, then funds of signer are reserved according to the formula:
     * `MetadataDepositBase + DepositPerByte * data.len` taking into
     * account any already reserved funds.
     *
     * - `collection`: The identifier of the collection whose item's metadata to set.
     * - `item`: The identifier of the item whose metadata to set.
     * - `data`: The general information of this item. Limited in length by `StringLimit`.
     *
     * Emits `ItemMetadataSet`.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {number} item
     * @param {BytesLike} data
     **/
    setMetadata: GenericTxCall<
      (
        collection: number,
        item: number,
        data: BytesLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'SetMetadata';
            params: { collection: number; item: number; data: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Clear the metadata for an item.
     *
     * Origin must be either `ForceOrigin` or Signed and the sender should be the Admin of the
     * `collection`.
     *
     * Any deposit is freed for the collection's owner.
     *
     * - `collection`: The identifier of the collection whose item's metadata to clear.
     * - `item`: The identifier of the item whose metadata to clear.
     *
     * Emits `ItemMetadataCleared`.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {number} item
     **/
    clearMetadata: GenericTxCall<
      (
        collection: number,
        item: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'ClearMetadata';
            params: { collection: number; item: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the metadata for a collection.
     *
     * Origin must be either `ForceOrigin` or `Signed` and the sender should be the Admin of
     * the `collection`.
     *
     * If the origin is `Signed`, then funds of signer are reserved according to the formula:
     * `MetadataDepositBase + DepositPerByte * data.len` taking into
     * account any already reserved funds.
     *
     * - `collection`: The identifier of the item whose metadata to update.
     * - `data`: The general information of this item. Limited in length by `StringLimit`.
     *
     * Emits `CollectionMetadataSet`.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     * @param {BytesLike} data
     **/
    setCollectionMetadata: GenericTxCall<
      (
        collection: number,
        data: BytesLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'SetCollectionMetadata';
            params: { collection: number; data: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Clear the metadata for a collection.
     *
     * Origin must be either `ForceOrigin` or `Signed` and the sender should be the Admin of
     * the `collection`.
     *
     * Any deposit is freed for the collection's owner.
     *
     * - `collection`: The identifier of the collection whose metadata to clear.
     *
     * Emits `CollectionMetadataCleared`.
     *
     * Weight: `O(1)`
     *
     * @param {number} collection
     **/
    clearCollectionMetadata: GenericTxCall<
      (collection: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'ClearCollectionMetadata';
            params: { collection: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set (or reset) the acceptance of ownership for a particular account.
     *
     * Origin must be `Signed` and if `maybe_collection` is `Some`, then the signer must have a
     * provider reference.
     *
     * - `maybe_collection`: The identifier of the collection whose ownership the signer is
     * willing to accept, or if `None`, an indication that the signer is willing to accept no
     * ownership transferal.
     *
     * Emits `OwnershipAcceptanceChanged`.
     *
     * @param {number | undefined} maybeCollection
     **/
    setAcceptOwnership: GenericTxCall<
      (maybeCollection: number | undefined) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'SetAcceptOwnership';
            params: { maybeCollection: number | undefined };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the maximum number of items a collection could have.
     *
     * Origin must be either `ForceOrigin` or `Signed` and the sender should be the Owner of
     * the `collection`.
     *
     * - `collection`: The identifier of the collection to change.
     * - `max_supply`: The maximum number of items a collection could have.
     *
     * Emits `CollectionMaxSupplySet` event when successful.
     *
     * @param {number} collection
     * @param {number} maxSupply
     **/
    setCollectionMaxSupply: GenericTxCall<
      (
        collection: number,
        maxSupply: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'SetCollectionMaxSupply';
            params: { collection: number; maxSupply: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Update mint settings.
     *
     * Origin must be either `ForceOrigin` or `Signed` and the sender should be the Issuer
     * of the `collection`.
     *
     * - `collection`: The identifier of the collection to change.
     * - `mint_settings`: The new mint settings.
     *
     * Emits `CollectionMintSettingsUpdated` event when successful.
     *
     * @param {number} collection
     * @param {PalletNftsMintSettings} mintSettings
     **/
    updateMintSettings: GenericTxCall<
      (
        collection: number,
        mintSettings: PalletNftsMintSettings,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'UpdateMintSettings';
            params: { collection: number; mintSettings: PalletNftsMintSettings };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set (or reset) the price for an item.
     *
     * Origin must be Signed and must be the owner of the `item`.
     *
     * - `collection`: The collection of the item.
     * - `item`: The item to set the price for.
     * - `price`: The price for the item. Pass `None`, to reset the price.
     * - `buyer`: Restricts the buy operation to a specific account.
     *
     * Emits `ItemPriceSet` on success if the price is not `None`.
     * Emits `ItemPriceRemoved` on success if the price is `None`.
     *
     * @param {number} collection
     * @param {number} item
     * @param {bigint | undefined} price
     * @param {MultiAddressLike | undefined} whitelistedBuyer
     **/
    setPrice: GenericTxCall<
      (
        collection: number,
        item: number,
        price: bigint | undefined,
        whitelistedBuyer: MultiAddressLike | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'SetPrice';
            params: {
              collection: number;
              item: number;
              price: bigint | undefined;
              whitelistedBuyer: MultiAddressLike | undefined;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Allows to buy an item if it's up for sale.
     *
     * Origin must be Signed and must not be the owner of the `item`.
     *
     * - `collection`: The collection of the item.
     * - `item`: The item the sender wants to buy.
     * - `bid_price`: The price the sender is willing to pay.
     *
     * Emits `ItemBought` on success.
     *
     * @param {number} collection
     * @param {number} item
     * @param {bigint} bidPrice
     **/
    buyItem: GenericTxCall<
      (
        collection: number,
        item: number,
        bidPrice: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'BuyItem';
            params: { collection: number; item: number; bidPrice: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Allows to pay the tips.
     *
     * Origin must be Signed.
     *
     * - `tips`: Tips array.
     *
     * Emits `TipSent` on every tip transfer.
     *
     * @param {Array<PalletNftsItemTip>} tips
     **/
    payTips: GenericTxCall<
      (tips: Array<PalletNftsItemTip>) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'PayTips';
            params: { tips: Array<PalletNftsItemTip> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Register a new atomic swap, declaring an intention to send an `item` in exchange for
     * `desired_item` from origin to target on the current blockchain.
     * The target can execute the swap during the specified `duration` of blocks (if set).
     * Additionally, the price could be set for the desired `item`.
     *
     * Origin must be Signed and must be an owner of the `item`.
     *
     * - `collection`: The collection of the item.
     * - `item`: The item an owner wants to give.
     * - `desired_collection`: The collection of the desired item.
     * - `desired_item`: The desired item an owner wants to receive.
     * - `maybe_price`: The price an owner is willing to pay or receive for the desired `item`.
     * - `duration`: A deadline for the swap. Specified by providing the number of blocks
     * after which the swap will expire.
     *
     * Emits `SwapCreated` on success.
     *
     * @param {number} offeredCollection
     * @param {number} offeredItem
     * @param {number} desiredCollection
     * @param {number | undefined} maybeDesiredItem
     * @param {PalletNftsPriceWithDirection | undefined} maybePrice
     * @param {number} duration
     **/
    createSwap: GenericTxCall<
      (
        offeredCollection: number,
        offeredItem: number,
        desiredCollection: number,
        maybeDesiredItem: number | undefined,
        maybePrice: PalletNftsPriceWithDirection | undefined,
        duration: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'CreateSwap';
            params: {
              offeredCollection: number;
              offeredItem: number;
              desiredCollection: number;
              maybeDesiredItem: number | undefined;
              maybePrice: PalletNftsPriceWithDirection | undefined;
              duration: number;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Cancel an atomic swap.
     *
     * Origin must be Signed.
     * Origin must be an owner of the `item` if the deadline hasn't expired.
     *
     * - `collection`: The collection of the item.
     * - `item`: The item an owner wants to give.
     *
     * Emits `SwapCancelled` on success.
     *
     * @param {number} offeredCollection
     * @param {number} offeredItem
     **/
    cancelSwap: GenericTxCall<
      (
        offeredCollection: number,
        offeredItem: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'CancelSwap';
            params: { offeredCollection: number; offeredItem: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Claim an atomic swap.
     * This method executes a pending swap, that was created by a counterpart before.
     *
     * Origin must be Signed and must be an owner of the `item`.
     *
     * - `send_collection`: The collection of the item to be sent.
     * - `send_item`: The item to be sent.
     * - `receive_collection`: The collection of the item to be received.
     * - `receive_item`: The item to be received.
     * - `witness_price`: A price that was previously agreed on.
     *
     * Emits `SwapClaimed` on success.
     *
     * @param {number} sendCollection
     * @param {number} sendItem
     * @param {number} receiveCollection
     * @param {number} receiveItem
     * @param {PalletNftsPriceWithDirection | undefined} witnessPrice
     **/
    claimSwap: GenericTxCall<
      (
        sendCollection: number,
        sendItem: number,
        receiveCollection: number,
        receiveItem: number,
        witnessPrice: PalletNftsPriceWithDirection | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'ClaimSwap';
            params: {
              sendCollection: number;
              sendItem: number;
              receiveCollection: number;
              receiveItem: number;
              witnessPrice: PalletNftsPriceWithDirection | undefined;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Mint an item by providing the pre-signed approval.
     *
     * Origin must be Signed.
     *
     * - `mint_data`: The pre-signed approval that consists of the information about the item,
     * its metadata, attributes, who can mint it (`None` for anyone) and until what block
     * number.
     * - `signature`: The signature of the `data` object.
     * - `signer`: The `data` object's signer. Should be an Issuer of the collection.
     *
     * Emits `Issued` on success.
     * Emits `AttributeSet` if the attributes were provided.
     * Emits `ItemMetadataSet` if the metadata was not empty.
     *
     * @param {PalletNftsPreSignedMint} mintData
     * @param {SpRuntimeMultiSignature} signature
     * @param {AccountId32Like} signer
     **/
    mintPreSigned: GenericTxCall<
      (
        mintData: PalletNftsPreSignedMint,
        signature: SpRuntimeMultiSignature,
        signer: AccountId32Like,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'MintPreSigned';
            params: { mintData: PalletNftsPreSignedMint; signature: SpRuntimeMultiSignature; signer: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set attributes for an item by providing the pre-signed approval.
     *
     * Origin must be Signed and must be an owner of the `data.item`.
     *
     * - `data`: The pre-signed approval that consists of the information about the item,
     * attributes to update and until what block number.
     * - `signature`: The signature of the `data` object.
     * - `signer`: The `data` object's signer. Should be an Admin of the collection for the
     * `CollectionOwner` namespace.
     *
     * Emits `AttributeSet` for each provided attribute.
     * Emits `ItemAttributesApprovalAdded` if the approval wasn't set before.
     * Emits `PreSignedAttributesSet` on success.
     *
     * @param {PalletNftsPreSignedAttributes} data
     * @param {SpRuntimeMultiSignature} signature
     * @param {AccountId32Like} signer
     **/
    setAttributesPreSigned: GenericTxCall<
      (
        data: PalletNftsPreSignedAttributes,
        signature: SpRuntimeMultiSignature,
        signer: AccountId32Like,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Nfts';
          palletCall: {
            name: 'SetAttributesPreSigned';
            params: {
              data: PalletNftsPreSignedAttributes;
              signature: SpRuntimeMultiSignature;
              signer: AccountId32Like;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `ForeignAssets`'s transaction calls
   **/
  foreignAssets: {
    /**
     * Issue a new class of fungible assets from a public origin.
     *
     * This new asset class has no assets initially and its owner is the origin.
     *
     * The origin must conform to the configured `CreateOrigin` and have sufficient funds free.
     *
     * Funds of sender are reserved by `AssetDeposit`.
     *
     * Parameters:
     * - `id`: The identifier of the new asset. This must not be currently in use to identify
     * an existing asset. If [`NextAssetId`] is set, then this must be equal to it.
     * - `admin`: The admin of this class of assets. The admin is the initial address of each
     * member of the asset class's admin team.
     * - `min_balance`: The minimum balance of this new asset that any single account must
     * have. If an account's balance is reduced below this, then it collapses to zero.
     *
     * Emits `Created` event when successful.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV5Location} id
     * @param {MultiAddressLike} admin
     * @param {bigint} minBalance
     **/
    create: GenericTxCall<
      (
        id: StagingXcmV5Location,
        admin: MultiAddressLike,
        minBalance: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'Create';
            params: { id: StagingXcmV5Location; admin: MultiAddressLike; minBalance: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Issue a new class of fungible assets from a privileged origin.
     *
     * This new asset class has no assets initially.
     *
     * The origin must conform to `ForceOrigin`.
     *
     * Unlike `create`, no funds are reserved.
     *
     * - `id`: The identifier of the new asset. This must not be currently in use to identify
     * an existing asset. If [`NextAssetId`] is set, then this must be equal to it.
     * - `owner`: The owner of this class of assets. The owner has full superuser permissions
     * over this asset, but may later change and configure the permissions using
     * `transfer_ownership` and `set_team`.
     * - `min_balance`: The minimum balance of this new asset that any single account must
     * have. If an account's balance is reduced below this, then it collapses to zero.
     *
     * Emits `ForceCreated` event when successful.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV5Location} id
     * @param {MultiAddressLike} owner
     * @param {boolean} isSufficient
     * @param {bigint} minBalance
     **/
    forceCreate: GenericTxCall<
      (
        id: StagingXcmV5Location,
        owner: MultiAddressLike,
        isSufficient: boolean,
        minBalance: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'ForceCreate';
            params: { id: StagingXcmV5Location; owner: MultiAddressLike; isSufficient: boolean; minBalance: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Start the process of destroying a fungible asset class.
     *
     * `start_destroy` is the first in a series of extrinsics that should be called, to allow
     * destruction of an asset class.
     *
     * The origin must conform to `ForceOrigin` or must be `Signed` by the asset's `owner`.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * It will fail with either [`Error::ContainsHolds`] or [`Error::ContainsFreezes`] if
     * an account contains holds or freezes in place.
     *
     * @param {StagingXcmV5Location} id
     **/
    startDestroy: GenericTxCall<
      (id: StagingXcmV5Location) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'StartDestroy';
            params: { id: StagingXcmV5Location };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Destroy all accounts associated with a given asset.
     *
     * `destroy_accounts` should only be called after `start_destroy` has been called, and the
     * asset is in a `Destroying` state.
     *
     * Due to weight restrictions, this function may need to be called multiple times to fully
     * destroy all accounts. It will destroy `RemoveItemsLimit` accounts at a time.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * Each call emits the `Event::DestroyedAccounts` event.
     *
     * @param {StagingXcmV5Location} id
     **/
    destroyAccounts: GenericTxCall<
      (id: StagingXcmV5Location) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'DestroyAccounts';
            params: { id: StagingXcmV5Location };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Destroy all approvals associated with a given asset up to the max (T::RemoveItemsLimit).
     *
     * `destroy_approvals` should only be called after `start_destroy` has been called, and the
     * asset is in a `Destroying` state.
     *
     * Due to weight restrictions, this function may need to be called multiple times to fully
     * destroy all approvals. It will destroy `RemoveItemsLimit` approvals at a time.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * Each call emits the `Event::DestroyedApprovals` event.
     *
     * @param {StagingXcmV5Location} id
     **/
    destroyApprovals: GenericTxCall<
      (id: StagingXcmV5Location) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'DestroyApprovals';
            params: { id: StagingXcmV5Location };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Complete destroying asset and unreserve currency.
     *
     * `finish_destroy` should only be called after `start_destroy` has been called, and the
     * asset is in a `Destroying` state. All accounts or approvals should be destroyed before
     * hand.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * Each successful call emits the `Event::Destroyed` event.
     *
     * @param {StagingXcmV5Location} id
     **/
    finishDestroy: GenericTxCall<
      (id: StagingXcmV5Location) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'FinishDestroy';
            params: { id: StagingXcmV5Location };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Mint assets of a particular class.
     *
     * The origin must be Signed and the sender must be the Issuer of the asset `id`.
     *
     * - `id`: The identifier of the asset to have some amount minted.
     * - `beneficiary`: The account to be credited with the minted assets.
     * - `amount`: The amount of the asset to be minted.
     *
     * Emits `Issued` event when successful.
     *
     * Weight: `O(1)`
     * Modes: Pre-existing balance of `beneficiary`; Account pre-existence of `beneficiary`.
     *
     * @param {StagingXcmV5Location} id
     * @param {MultiAddressLike} beneficiary
     * @param {bigint} amount
     **/
    mint: GenericTxCall<
      (
        id: StagingXcmV5Location,
        beneficiary: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'Mint';
            params: { id: StagingXcmV5Location; beneficiary: MultiAddressLike; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Reduce the balance of `who` by as much as possible up to `amount` assets of `id`.
     *
     * Origin must be Signed and the sender should be the Manager of the asset `id`.
     *
     * Bails with `NoAccount` if the `who` is already dead.
     *
     * - `id`: The identifier of the asset to have some amount burned.
     * - `who`: The account to be debited from.
     * - `amount`: The maximum amount by which `who`'s balance should be reduced.
     *
     * Emits `Burned` with the actual amount burned. If this takes the balance to below the
     * minimum for the asset, then the amount burned is increased to take it to zero.
     *
     * Weight: `O(1)`
     * Modes: Post-existence of `who`; Pre & post Zombie-status of `who`.
     *
     * @param {StagingXcmV5Location} id
     * @param {MultiAddressLike} who
     * @param {bigint} amount
     **/
    burn: GenericTxCall<
      (
        id: StagingXcmV5Location,
        who: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'Burn';
            params: { id: StagingXcmV5Location; who: MultiAddressLike; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Move some assets from the sender account to another.
     *
     * Origin must be Signed.
     *
     * - `id`: The identifier of the asset to have some amount transferred.
     * - `target`: The account to be credited.
     * - `amount`: The amount by which the sender's balance of assets should be reduced and
     * `target`'s balance increased. The amount actually transferred may be slightly greater in
     * the case that the transfer would otherwise take the sender balance above zero but below
     * the minimum balance. Must be greater than zero.
     *
     * Emits `Transferred` with the actual amount transferred. If this takes the source balance
     * to below the minimum for the asset, then the amount transferred is increased to take it
     * to zero.
     *
     * Weight: `O(1)`
     * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
     * `target`.
     *
     * @param {StagingXcmV5Location} id
     * @param {MultiAddressLike} target
     * @param {bigint} amount
     **/
    transfer: GenericTxCall<
      (
        id: StagingXcmV5Location,
        target: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'Transfer';
            params: { id: StagingXcmV5Location; target: MultiAddressLike; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Move some assets from the sender account to another, keeping the sender account alive.
     *
     * Origin must be Signed.
     *
     * - `id`: The identifier of the asset to have some amount transferred.
     * - `target`: The account to be credited.
     * - `amount`: The amount by which the sender's balance of assets should be reduced and
     * `target`'s balance increased. The amount actually transferred may be slightly greater in
     * the case that the transfer would otherwise take the sender balance above zero but below
     * the minimum balance. Must be greater than zero.
     *
     * Emits `Transferred` with the actual amount transferred. If this takes the source balance
     * to below the minimum for the asset, then the amount transferred is increased to take it
     * to zero.
     *
     * Weight: `O(1)`
     * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
     * `target`.
     *
     * @param {StagingXcmV5Location} id
     * @param {MultiAddressLike} target
     * @param {bigint} amount
     **/
    transferKeepAlive: GenericTxCall<
      (
        id: StagingXcmV5Location,
        target: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'TransferKeepAlive';
            params: { id: StagingXcmV5Location; target: MultiAddressLike; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Move some assets from one account to another.
     *
     * Origin must be Signed and the sender should be the Admin of the asset `id`.
     *
     * - `id`: The identifier of the asset to have some amount transferred.
     * - `source`: The account to be debited.
     * - `dest`: The account to be credited.
     * - `amount`: The amount by which the `source`'s balance of assets should be reduced and
     * `dest`'s balance increased. The amount actually transferred may be slightly greater in
     * the case that the transfer would otherwise take the `source` balance above zero but
     * below the minimum balance. Must be greater than zero.
     *
     * Emits `Transferred` with the actual amount transferred. If this takes the source balance
     * to below the minimum for the asset, then the amount transferred is increased to take it
     * to zero.
     *
     * Weight: `O(1)`
     * Modes: Pre-existence of `dest`; Post-existence of `source`; Account pre-existence of
     * `dest`.
     *
     * @param {StagingXcmV5Location} id
     * @param {MultiAddressLike} source
     * @param {MultiAddressLike} dest
     * @param {bigint} amount
     **/
    forceTransfer: GenericTxCall<
      (
        id: StagingXcmV5Location,
        source: MultiAddressLike,
        dest: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'ForceTransfer';
            params: { id: StagingXcmV5Location; source: MultiAddressLike; dest: MultiAddressLike; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Disallow further unprivileged transfers of an asset `id` from an account `who`. `who`
     * must already exist as an entry in `Account`s of the asset. If you want to freeze an
     * account that does not have an entry, use `touch_other` first.
     *
     * Origin must be Signed and the sender should be the Freezer of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     * - `who`: The account to be frozen.
     *
     * Emits `Frozen`.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV5Location} id
     * @param {MultiAddressLike} who
     **/
    freeze: GenericTxCall<
      (
        id: StagingXcmV5Location,
        who: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'Freeze';
            params: { id: StagingXcmV5Location; who: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Allow unprivileged transfers to and from an account again.
     *
     * Origin must be Signed and the sender should be the Admin of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     * - `who`: The account to be unfrozen.
     *
     * Emits `Thawed`.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV5Location} id
     * @param {MultiAddressLike} who
     **/
    thaw: GenericTxCall<
      (
        id: StagingXcmV5Location,
        who: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'Thaw';
            params: { id: StagingXcmV5Location; who: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Disallow further unprivileged transfers for the asset class.
     *
     * Origin must be Signed and the sender should be the Freezer of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     *
     * Emits `Frozen`.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV5Location} id
     **/
    freezeAsset: GenericTxCall<
      (id: StagingXcmV5Location) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'FreezeAsset';
            params: { id: StagingXcmV5Location };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Allow unprivileged transfers for the asset again.
     *
     * Origin must be Signed and the sender should be the Admin of the asset `id`.
     *
     * - `id`: The identifier of the asset to be thawed.
     *
     * Emits `Thawed`.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV5Location} id
     **/
    thawAsset: GenericTxCall<
      (id: StagingXcmV5Location) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'ThawAsset';
            params: { id: StagingXcmV5Location };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Change the Owner of an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * - `id`: The identifier of the asset.
     * - `owner`: The new Owner of this asset.
     *
     * Emits `OwnerChanged`.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV5Location} id
     * @param {MultiAddressLike} owner
     **/
    transferOwnership: GenericTxCall<
      (
        id: StagingXcmV5Location,
        owner: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'TransferOwnership';
            params: { id: StagingXcmV5Location; owner: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Change the Issuer, Admin and Freezer of an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     * - `issuer`: The new Issuer of this asset.
     * - `admin`: The new Admin of this asset.
     * - `freezer`: The new Freezer of this asset.
     *
     * Emits `TeamChanged`.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV5Location} id
     * @param {MultiAddressLike} issuer
     * @param {MultiAddressLike} admin
     * @param {MultiAddressLike} freezer
     **/
    setTeam: GenericTxCall<
      (
        id: StagingXcmV5Location,
        issuer: MultiAddressLike,
        admin: MultiAddressLike,
        freezer: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'SetTeam';
            params: {
              id: StagingXcmV5Location;
              issuer: MultiAddressLike;
              admin: MultiAddressLike;
              freezer: MultiAddressLike;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the metadata for an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * Funds of sender are reserved according to the formula:
     * `MetadataDepositBase + MetadataDepositPerByte * (name.len + symbol.len)` taking into
     * account any already reserved funds.
     *
     * - `id`: The identifier of the asset to update.
     * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
     * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
     * - `decimals`: The number of decimals this asset uses to represent one unit.
     *
     * Emits `MetadataSet`.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV5Location} id
     * @param {BytesLike} name
     * @param {BytesLike} symbol
     * @param {number} decimals
     **/
    setMetadata: GenericTxCall<
      (
        id: StagingXcmV5Location,
        name: BytesLike,
        symbol: BytesLike,
        decimals: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'SetMetadata';
            params: { id: StagingXcmV5Location; name: BytesLike; symbol: BytesLike; decimals: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Clear the metadata for an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * Any deposit is freed for the asset owner.
     *
     * - `id`: The identifier of the asset to clear.
     *
     * Emits `MetadataCleared`.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV5Location} id
     **/
    clearMetadata: GenericTxCall<
      (id: StagingXcmV5Location) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'ClearMetadata';
            params: { id: StagingXcmV5Location };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Force the metadata for an asset to some value.
     *
     * Origin must be ForceOrigin.
     *
     * Any deposit is left alone.
     *
     * - `id`: The identifier of the asset to update.
     * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
     * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
     * - `decimals`: The number of decimals this asset uses to represent one unit.
     *
     * Emits `MetadataSet`.
     *
     * Weight: `O(N + S)` where N and S are the length of the name and symbol respectively.
     *
     * @param {StagingXcmV5Location} id
     * @param {BytesLike} name
     * @param {BytesLike} symbol
     * @param {number} decimals
     * @param {boolean} isFrozen
     **/
    forceSetMetadata: GenericTxCall<
      (
        id: StagingXcmV5Location,
        name: BytesLike,
        symbol: BytesLike,
        decimals: number,
        isFrozen: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'ForceSetMetadata';
            params: {
              id: StagingXcmV5Location;
              name: BytesLike;
              symbol: BytesLike;
              decimals: number;
              isFrozen: boolean;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Clear the metadata for an asset.
     *
     * Origin must be ForceOrigin.
     *
     * Any deposit is returned.
     *
     * - `id`: The identifier of the asset to clear.
     *
     * Emits `MetadataCleared`.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV5Location} id
     **/
    forceClearMetadata: GenericTxCall<
      (id: StagingXcmV5Location) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'ForceClearMetadata';
            params: { id: StagingXcmV5Location };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Alter the attributes of a given asset.
     *
     * Origin must be `ForceOrigin`.
     *
     * - `id`: The identifier of the asset.
     * - `owner`: The new Owner of this asset.
     * - `issuer`: The new Issuer of this asset.
     * - `admin`: The new Admin of this asset.
     * - `freezer`: The new Freezer of this asset.
     * - `min_balance`: The minimum balance of this new asset that any single account must
     * have. If an account's balance is reduced below this, then it collapses to zero.
     * - `is_sufficient`: Whether a non-zero balance of this asset is deposit of sufficient
     * value to account for the state bloat associated with its balance storage. If set to
     * `true`, then non-zero balances may be stored without a `consumer` reference (and thus
     * an ED in the Balances pallet or whatever else is used to control user-account state
     * growth).
     * - `is_frozen`: Whether this asset class is frozen except for permissioned/admin
     * instructions.
     *
     * Emits `AssetStatusChanged` with the identity of the asset.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV5Location} id
     * @param {MultiAddressLike} owner
     * @param {MultiAddressLike} issuer
     * @param {MultiAddressLike} admin
     * @param {MultiAddressLike} freezer
     * @param {bigint} minBalance
     * @param {boolean} isSufficient
     * @param {boolean} isFrozen
     **/
    forceAssetStatus: GenericTxCall<
      (
        id: StagingXcmV5Location,
        owner: MultiAddressLike,
        issuer: MultiAddressLike,
        admin: MultiAddressLike,
        freezer: MultiAddressLike,
        minBalance: bigint,
        isSufficient: boolean,
        isFrozen: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'ForceAssetStatus';
            params: {
              id: StagingXcmV5Location;
              owner: MultiAddressLike;
              issuer: MultiAddressLike;
              admin: MultiAddressLike;
              freezer: MultiAddressLike;
              minBalance: bigint;
              isSufficient: boolean;
              isFrozen: boolean;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Approve an amount of asset for transfer by a delegated third-party account.
     *
     * Origin must be Signed.
     *
     * Ensures that `ApprovalDeposit` worth of `Currency` is reserved from signing account
     * for the purpose of holding the approval. If some non-zero amount of assets is already
     * approved from signing account to `delegate`, then it is topped up or unreserved to
     * meet the right value.
     *
     * NOTE: The signing account does not need to own `amount` of assets at the point of
     * making this call.
     *
     * - `id`: The identifier of the asset.
     * - `delegate`: The account to delegate permission to transfer asset.
     * - `amount`: The amount of asset that may be transferred by `delegate`. If there is
     * already an approval in place, then this acts additively.
     *
     * Emits `ApprovedTransfer` on success.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV5Location} id
     * @param {MultiAddressLike} delegate
     * @param {bigint} amount
     **/
    approveTransfer: GenericTxCall<
      (
        id: StagingXcmV5Location,
        delegate: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'ApproveTransfer';
            params: { id: StagingXcmV5Location; delegate: MultiAddressLike; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Cancel all of some asset approved for delegated transfer by a third-party account.
     *
     * Origin must be Signed and there must be an approval in place between signer and
     * `delegate`.
     *
     * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
     *
     * - `id`: The identifier of the asset.
     * - `delegate`: The account delegated permission to transfer asset.
     *
     * Emits `ApprovalCancelled` on success.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV5Location} id
     * @param {MultiAddressLike} delegate
     **/
    cancelApproval: GenericTxCall<
      (
        id: StagingXcmV5Location,
        delegate: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'CancelApproval';
            params: { id: StagingXcmV5Location; delegate: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Cancel all of some asset approved for delegated transfer by a third-party account.
     *
     * Origin must be either ForceOrigin or Signed origin with the signer being the Admin
     * account of the asset `id`.
     *
     * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
     *
     * - `id`: The identifier of the asset.
     * - `delegate`: The account delegated permission to transfer asset.
     *
     * Emits `ApprovalCancelled` on success.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV5Location} id
     * @param {MultiAddressLike} owner
     * @param {MultiAddressLike} delegate
     **/
    forceCancelApproval: GenericTxCall<
      (
        id: StagingXcmV5Location,
        owner: MultiAddressLike,
        delegate: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'ForceCancelApproval';
            params: { id: StagingXcmV5Location; owner: MultiAddressLike; delegate: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Transfer some asset balance from a previously delegated account to some third-party
     * account.
     *
     * Origin must be Signed and there must be an approval in place by the `owner` to the
     * signer.
     *
     * If the entire amount approved for transfer is transferred, then any deposit previously
     * reserved by `approve_transfer` is unreserved.
     *
     * - `id`: The identifier of the asset.
     * - `owner`: The account which previously approved for a transfer of at least `amount` and
     * from which the asset balance will be withdrawn.
     * - `destination`: The account to which the asset balance of `amount` will be transferred.
     * - `amount`: The amount of assets to transfer.
     *
     * Emits `TransferredApproved` on success.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV5Location} id
     * @param {MultiAddressLike} owner
     * @param {MultiAddressLike} destination
     * @param {bigint} amount
     **/
    transferApproved: GenericTxCall<
      (
        id: StagingXcmV5Location,
        owner: MultiAddressLike,
        destination: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'TransferApproved';
            params: {
              id: StagingXcmV5Location;
              owner: MultiAddressLike;
              destination: MultiAddressLike;
              amount: bigint;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Create an asset account for non-provider assets.
     *
     * A deposit will be taken from the signer account.
     *
     * - `origin`: Must be Signed; the signer account must have sufficient funds for a deposit
     * to be taken.
     * - `id`: The identifier of the asset for the account to be created.
     *
     * Emits `Touched` event when successful.
     *
     * @param {StagingXcmV5Location} id
     **/
    touch: GenericTxCall<
      (id: StagingXcmV5Location) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'Touch';
            params: { id: StagingXcmV5Location };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Return the deposit (if any) of an asset account or a consumer reference (if any) of an
     * account.
     *
     * The origin must be Signed.
     *
     * - `id`: The identifier of the asset for which the caller would like the deposit
     * refunded.
     * - `allow_burn`: If `true` then assets may be destroyed in order to complete the refund.
     *
     * It will fail with either [`Error::ContainsHolds`] or [`Error::ContainsFreezes`] if
     * the asset account contains holds or freezes in place.
     *
     * Emits `Refunded` event when successful.
     *
     * @param {StagingXcmV5Location} id
     * @param {boolean} allowBurn
     **/
    refund: GenericTxCall<
      (
        id: StagingXcmV5Location,
        allowBurn: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'Refund';
            params: { id: StagingXcmV5Location; allowBurn: boolean };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Sets the minimum balance of an asset.
     *
     * Only works if there aren't any accounts that are holding the asset or if
     * the new value of `min_balance` is less than the old one.
     *
     * Origin must be Signed and the sender has to be the Owner of the
     * asset `id`.
     *
     * - `id`: The identifier of the asset.
     * - `min_balance`: The new value of `min_balance`.
     *
     * Emits `AssetMinBalanceChanged` event when successful.
     *
     * @param {StagingXcmV5Location} id
     * @param {bigint} minBalance
     **/
    setMinBalance: GenericTxCall<
      (
        id: StagingXcmV5Location,
        minBalance: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'SetMinBalance';
            params: { id: StagingXcmV5Location; minBalance: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Create an asset account for `who`.
     *
     * A deposit will be taken from the signer account.
     *
     * - `origin`: Must be Signed by `Freezer` or `Admin` of the asset `id`; the signer account
     * must have sufficient funds for a deposit to be taken.
     * - `id`: The identifier of the asset for the account to be created.
     * - `who`: The account to be created.
     *
     * Emits `Touched` event when successful.
     *
     * @param {StagingXcmV5Location} id
     * @param {MultiAddressLike} who
     **/
    touchOther: GenericTxCall<
      (
        id: StagingXcmV5Location,
        who: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'TouchOther';
            params: { id: StagingXcmV5Location; who: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Return the deposit (if any) of a target asset account. Useful if you are the depositor.
     *
     * The origin must be Signed and either the account owner, depositor, or asset `Admin`. In
     * order to burn a non-zero balance of the asset, the caller must be the account and should
     * use `refund`.
     *
     * - `id`: The identifier of the asset for the account holding a deposit.
     * - `who`: The account to refund.
     *
     * It will fail with either [`Error::ContainsHolds`] or [`Error::ContainsFreezes`] if
     * the asset account contains holds or freezes in place.
     *
     * Emits `Refunded` event when successful.
     *
     * @param {StagingXcmV5Location} id
     * @param {MultiAddressLike} who
     **/
    refundOther: GenericTxCall<
      (
        id: StagingXcmV5Location,
        who: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'RefundOther';
            params: { id: StagingXcmV5Location; who: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Disallow further unprivileged transfers of an asset `id` to and from an account `who`.
     *
     * Origin must be Signed and the sender should be the Freezer of the asset `id`.
     *
     * - `id`: The identifier of the account's asset.
     * - `who`: The account to be unblocked.
     *
     * Emits `Blocked`.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV5Location} id
     * @param {MultiAddressLike} who
     **/
    block: GenericTxCall<
      (
        id: StagingXcmV5Location,
        who: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'Block';
            params: { id: StagingXcmV5Location; who: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Transfer the entire transferable balance from the caller asset account.
     *
     * NOTE: This function only attempts to transfer _transferable_ balances. This means that
     * any held, frozen, or minimum balance (when `keep_alive` is `true`), will not be
     * transferred by this function. To ensure that this function results in a killed account,
     * you might need to prepare the account by removing any reference counters, storage
     * deposits, etc...
     *
     * The dispatch origin of this call must be Signed.
     *
     * - `id`: The identifier of the asset for the account holding a deposit.
     * - `dest`: The recipient of the transfer.
     * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
     * of the funds the asset account has, causing the sender asset account to be killed
     * (false), or transfer everything except at least the minimum balance, which will
     * guarantee to keep the sender asset account alive (true).
     *
     * @param {StagingXcmV5Location} id
     * @param {MultiAddressLike} dest
     * @param {boolean} keepAlive
     **/
    transferAll: GenericTxCall<
      (
        id: StagingXcmV5Location,
        dest: MultiAddressLike,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ForeignAssets';
          palletCall: {
            name: 'TransferAll';
            params: { id: StagingXcmV5Location; dest: MultiAddressLike; keepAlive: boolean };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `PoolAssets`'s transaction calls
   **/
  poolAssets: {
    /**
     * Issue a new class of fungible assets from a public origin.
     *
     * This new asset class has no assets initially and its owner is the origin.
     *
     * The origin must conform to the configured `CreateOrigin` and have sufficient funds free.
     *
     * Funds of sender are reserved by `AssetDeposit`.
     *
     * Parameters:
     * - `id`: The identifier of the new asset. This must not be currently in use to identify
     * an existing asset. If [`NextAssetId`] is set, then this must be equal to it.
     * - `admin`: The admin of this class of assets. The admin is the initial address of each
     * member of the asset class's admin team.
     * - `min_balance`: The minimum balance of this new asset that any single account must
     * have. If an account's balance is reduced below this, then it collapses to zero.
     *
     * Emits `Created` event when successful.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} admin
     * @param {bigint} minBalance
     **/
    create: GenericTxCall<
      (
        id: number,
        admin: MultiAddressLike,
        minBalance: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'Create';
            params: { id: number; admin: MultiAddressLike; minBalance: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Issue a new class of fungible assets from a privileged origin.
     *
     * This new asset class has no assets initially.
     *
     * The origin must conform to `ForceOrigin`.
     *
     * Unlike `create`, no funds are reserved.
     *
     * - `id`: The identifier of the new asset. This must not be currently in use to identify
     * an existing asset. If [`NextAssetId`] is set, then this must be equal to it.
     * - `owner`: The owner of this class of assets. The owner has full superuser permissions
     * over this asset, but may later change and configure the permissions using
     * `transfer_ownership` and `set_team`.
     * - `min_balance`: The minimum balance of this new asset that any single account must
     * have. If an account's balance is reduced below this, then it collapses to zero.
     *
     * Emits `ForceCreated` event when successful.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} owner
     * @param {boolean} isSufficient
     * @param {bigint} minBalance
     **/
    forceCreate: GenericTxCall<
      (
        id: number,
        owner: MultiAddressLike,
        isSufficient: boolean,
        minBalance: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'ForceCreate';
            params: { id: number; owner: MultiAddressLike; isSufficient: boolean; minBalance: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Start the process of destroying a fungible asset class.
     *
     * `start_destroy` is the first in a series of extrinsics that should be called, to allow
     * destruction of an asset class.
     *
     * The origin must conform to `ForceOrigin` or must be `Signed` by the asset's `owner`.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * It will fail with either [`Error::ContainsHolds`] or [`Error::ContainsFreezes`] if
     * an account contains holds or freezes in place.
     *
     * @param {number} id
     **/
    startDestroy: GenericTxCall<
      (id: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'StartDestroy';
            params: { id: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Destroy all accounts associated with a given asset.
     *
     * `destroy_accounts` should only be called after `start_destroy` has been called, and the
     * asset is in a `Destroying` state.
     *
     * Due to weight restrictions, this function may need to be called multiple times to fully
     * destroy all accounts. It will destroy `RemoveItemsLimit` accounts at a time.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * Each call emits the `Event::DestroyedAccounts` event.
     *
     * @param {number} id
     **/
    destroyAccounts: GenericTxCall<
      (id: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'DestroyAccounts';
            params: { id: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Destroy all approvals associated with a given asset up to the max (T::RemoveItemsLimit).
     *
     * `destroy_approvals` should only be called after `start_destroy` has been called, and the
     * asset is in a `Destroying` state.
     *
     * Due to weight restrictions, this function may need to be called multiple times to fully
     * destroy all approvals. It will destroy `RemoveItemsLimit` approvals at a time.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * Each call emits the `Event::DestroyedApprovals` event.
     *
     * @param {number} id
     **/
    destroyApprovals: GenericTxCall<
      (id: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'DestroyApprovals';
            params: { id: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Complete destroying asset and unreserve currency.
     *
     * `finish_destroy` should only be called after `start_destroy` has been called, and the
     * asset is in a `Destroying` state. All accounts or approvals should be destroyed before
     * hand.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * Each successful call emits the `Event::Destroyed` event.
     *
     * @param {number} id
     **/
    finishDestroy: GenericTxCall<
      (id: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'FinishDestroy';
            params: { id: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Mint assets of a particular class.
     *
     * The origin must be Signed and the sender must be the Issuer of the asset `id`.
     *
     * - `id`: The identifier of the asset to have some amount minted.
     * - `beneficiary`: The account to be credited with the minted assets.
     * - `amount`: The amount of the asset to be minted.
     *
     * Emits `Issued` event when successful.
     *
     * Weight: `O(1)`
     * Modes: Pre-existing balance of `beneficiary`; Account pre-existence of `beneficiary`.
     *
     * @param {number} id
     * @param {MultiAddressLike} beneficiary
     * @param {bigint} amount
     **/
    mint: GenericTxCall<
      (
        id: number,
        beneficiary: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'Mint';
            params: { id: number; beneficiary: MultiAddressLike; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Reduce the balance of `who` by as much as possible up to `amount` assets of `id`.
     *
     * Origin must be Signed and the sender should be the Manager of the asset `id`.
     *
     * Bails with `NoAccount` if the `who` is already dead.
     *
     * - `id`: The identifier of the asset to have some amount burned.
     * - `who`: The account to be debited from.
     * - `amount`: The maximum amount by which `who`'s balance should be reduced.
     *
     * Emits `Burned` with the actual amount burned. If this takes the balance to below the
     * minimum for the asset, then the amount burned is increased to take it to zero.
     *
     * Weight: `O(1)`
     * Modes: Post-existence of `who`; Pre & post Zombie-status of `who`.
     *
     * @param {number} id
     * @param {MultiAddressLike} who
     * @param {bigint} amount
     **/
    burn: GenericTxCall<
      (
        id: number,
        who: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'Burn';
            params: { id: number; who: MultiAddressLike; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Move some assets from the sender account to another.
     *
     * Origin must be Signed.
     *
     * - `id`: The identifier of the asset to have some amount transferred.
     * - `target`: The account to be credited.
     * - `amount`: The amount by which the sender's balance of assets should be reduced and
     * `target`'s balance increased. The amount actually transferred may be slightly greater in
     * the case that the transfer would otherwise take the sender balance above zero but below
     * the minimum balance. Must be greater than zero.
     *
     * Emits `Transferred` with the actual amount transferred. If this takes the source balance
     * to below the minimum for the asset, then the amount transferred is increased to take it
     * to zero.
     *
     * Weight: `O(1)`
     * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
     * `target`.
     *
     * @param {number} id
     * @param {MultiAddressLike} target
     * @param {bigint} amount
     **/
    transfer: GenericTxCall<
      (
        id: number,
        target: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'Transfer';
            params: { id: number; target: MultiAddressLike; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Move some assets from the sender account to another, keeping the sender account alive.
     *
     * Origin must be Signed.
     *
     * - `id`: The identifier of the asset to have some amount transferred.
     * - `target`: The account to be credited.
     * - `amount`: The amount by which the sender's balance of assets should be reduced and
     * `target`'s balance increased. The amount actually transferred may be slightly greater in
     * the case that the transfer would otherwise take the sender balance above zero but below
     * the minimum balance. Must be greater than zero.
     *
     * Emits `Transferred` with the actual amount transferred. If this takes the source balance
     * to below the minimum for the asset, then the amount transferred is increased to take it
     * to zero.
     *
     * Weight: `O(1)`
     * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
     * `target`.
     *
     * @param {number} id
     * @param {MultiAddressLike} target
     * @param {bigint} amount
     **/
    transferKeepAlive: GenericTxCall<
      (
        id: number,
        target: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'TransferKeepAlive';
            params: { id: number; target: MultiAddressLike; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Move some assets from one account to another.
     *
     * Origin must be Signed and the sender should be the Admin of the asset `id`.
     *
     * - `id`: The identifier of the asset to have some amount transferred.
     * - `source`: The account to be debited.
     * - `dest`: The account to be credited.
     * - `amount`: The amount by which the `source`'s balance of assets should be reduced and
     * `dest`'s balance increased. The amount actually transferred may be slightly greater in
     * the case that the transfer would otherwise take the `source` balance above zero but
     * below the minimum balance. Must be greater than zero.
     *
     * Emits `Transferred` with the actual amount transferred. If this takes the source balance
     * to below the minimum for the asset, then the amount transferred is increased to take it
     * to zero.
     *
     * Weight: `O(1)`
     * Modes: Pre-existence of `dest`; Post-existence of `source`; Account pre-existence of
     * `dest`.
     *
     * @param {number} id
     * @param {MultiAddressLike} source
     * @param {MultiAddressLike} dest
     * @param {bigint} amount
     **/
    forceTransfer: GenericTxCall<
      (
        id: number,
        source: MultiAddressLike,
        dest: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'ForceTransfer';
            params: { id: number; source: MultiAddressLike; dest: MultiAddressLike; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Disallow further unprivileged transfers of an asset `id` from an account `who`. `who`
     * must already exist as an entry in `Account`s of the asset. If you want to freeze an
     * account that does not have an entry, use `touch_other` first.
     *
     * Origin must be Signed and the sender should be the Freezer of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     * - `who`: The account to be frozen.
     *
     * Emits `Frozen`.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} who
     **/
    freeze: GenericTxCall<
      (
        id: number,
        who: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'Freeze';
            params: { id: number; who: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Allow unprivileged transfers to and from an account again.
     *
     * Origin must be Signed and the sender should be the Admin of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     * - `who`: The account to be unfrozen.
     *
     * Emits `Thawed`.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} who
     **/
    thaw: GenericTxCall<
      (
        id: number,
        who: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'Thaw';
            params: { id: number; who: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Disallow further unprivileged transfers for the asset class.
     *
     * Origin must be Signed and the sender should be the Freezer of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     *
     * Emits `Frozen`.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     **/
    freezeAsset: GenericTxCall<
      (id: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'FreezeAsset';
            params: { id: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Allow unprivileged transfers for the asset again.
     *
     * Origin must be Signed and the sender should be the Admin of the asset `id`.
     *
     * - `id`: The identifier of the asset to be thawed.
     *
     * Emits `Thawed`.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     **/
    thawAsset: GenericTxCall<
      (id: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'ThawAsset';
            params: { id: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Change the Owner of an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * - `id`: The identifier of the asset.
     * - `owner`: The new Owner of this asset.
     *
     * Emits `OwnerChanged`.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} owner
     **/
    transferOwnership: GenericTxCall<
      (
        id: number,
        owner: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'TransferOwnership';
            params: { id: number; owner: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Change the Issuer, Admin and Freezer of an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     * - `issuer`: The new Issuer of this asset.
     * - `admin`: The new Admin of this asset.
     * - `freezer`: The new Freezer of this asset.
     *
     * Emits `TeamChanged`.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} issuer
     * @param {MultiAddressLike} admin
     * @param {MultiAddressLike} freezer
     **/
    setTeam: GenericTxCall<
      (
        id: number,
        issuer: MultiAddressLike,
        admin: MultiAddressLike,
        freezer: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'SetTeam';
            params: { id: number; issuer: MultiAddressLike; admin: MultiAddressLike; freezer: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the metadata for an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * Funds of sender are reserved according to the formula:
     * `MetadataDepositBase + MetadataDepositPerByte * (name.len + symbol.len)` taking into
     * account any already reserved funds.
     *
     * - `id`: The identifier of the asset to update.
     * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
     * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
     * - `decimals`: The number of decimals this asset uses to represent one unit.
     *
     * Emits `MetadataSet`.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {BytesLike} name
     * @param {BytesLike} symbol
     * @param {number} decimals
     **/
    setMetadata: GenericTxCall<
      (
        id: number,
        name: BytesLike,
        symbol: BytesLike,
        decimals: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'SetMetadata';
            params: { id: number; name: BytesLike; symbol: BytesLike; decimals: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Clear the metadata for an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * Any deposit is freed for the asset owner.
     *
     * - `id`: The identifier of the asset to clear.
     *
     * Emits `MetadataCleared`.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     **/
    clearMetadata: GenericTxCall<
      (id: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'ClearMetadata';
            params: { id: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Force the metadata for an asset to some value.
     *
     * Origin must be ForceOrigin.
     *
     * Any deposit is left alone.
     *
     * - `id`: The identifier of the asset to update.
     * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
     * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
     * - `decimals`: The number of decimals this asset uses to represent one unit.
     *
     * Emits `MetadataSet`.
     *
     * Weight: `O(N + S)` where N and S are the length of the name and symbol respectively.
     *
     * @param {number} id
     * @param {BytesLike} name
     * @param {BytesLike} symbol
     * @param {number} decimals
     * @param {boolean} isFrozen
     **/
    forceSetMetadata: GenericTxCall<
      (
        id: number,
        name: BytesLike,
        symbol: BytesLike,
        decimals: number,
        isFrozen: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'ForceSetMetadata';
            params: { id: number; name: BytesLike; symbol: BytesLike; decimals: number; isFrozen: boolean };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Clear the metadata for an asset.
     *
     * Origin must be ForceOrigin.
     *
     * Any deposit is returned.
     *
     * - `id`: The identifier of the asset to clear.
     *
     * Emits `MetadataCleared`.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     **/
    forceClearMetadata: GenericTxCall<
      (id: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'ForceClearMetadata';
            params: { id: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Alter the attributes of a given asset.
     *
     * Origin must be `ForceOrigin`.
     *
     * - `id`: The identifier of the asset.
     * - `owner`: The new Owner of this asset.
     * - `issuer`: The new Issuer of this asset.
     * - `admin`: The new Admin of this asset.
     * - `freezer`: The new Freezer of this asset.
     * - `min_balance`: The minimum balance of this new asset that any single account must
     * have. If an account's balance is reduced below this, then it collapses to zero.
     * - `is_sufficient`: Whether a non-zero balance of this asset is deposit of sufficient
     * value to account for the state bloat associated with its balance storage. If set to
     * `true`, then non-zero balances may be stored without a `consumer` reference (and thus
     * an ED in the Balances pallet or whatever else is used to control user-account state
     * growth).
     * - `is_frozen`: Whether this asset class is frozen except for permissioned/admin
     * instructions.
     *
     * Emits `AssetStatusChanged` with the identity of the asset.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} owner
     * @param {MultiAddressLike} issuer
     * @param {MultiAddressLike} admin
     * @param {MultiAddressLike} freezer
     * @param {bigint} minBalance
     * @param {boolean} isSufficient
     * @param {boolean} isFrozen
     **/
    forceAssetStatus: GenericTxCall<
      (
        id: number,
        owner: MultiAddressLike,
        issuer: MultiAddressLike,
        admin: MultiAddressLike,
        freezer: MultiAddressLike,
        minBalance: bigint,
        isSufficient: boolean,
        isFrozen: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'ForceAssetStatus';
            params: {
              id: number;
              owner: MultiAddressLike;
              issuer: MultiAddressLike;
              admin: MultiAddressLike;
              freezer: MultiAddressLike;
              minBalance: bigint;
              isSufficient: boolean;
              isFrozen: boolean;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Approve an amount of asset for transfer by a delegated third-party account.
     *
     * Origin must be Signed.
     *
     * Ensures that `ApprovalDeposit` worth of `Currency` is reserved from signing account
     * for the purpose of holding the approval. If some non-zero amount of assets is already
     * approved from signing account to `delegate`, then it is topped up or unreserved to
     * meet the right value.
     *
     * NOTE: The signing account does not need to own `amount` of assets at the point of
     * making this call.
     *
     * - `id`: The identifier of the asset.
     * - `delegate`: The account to delegate permission to transfer asset.
     * - `amount`: The amount of asset that may be transferred by `delegate`. If there is
     * already an approval in place, then this acts additively.
     *
     * Emits `ApprovedTransfer` on success.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} delegate
     * @param {bigint} amount
     **/
    approveTransfer: GenericTxCall<
      (
        id: number,
        delegate: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'ApproveTransfer';
            params: { id: number; delegate: MultiAddressLike; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Cancel all of some asset approved for delegated transfer by a third-party account.
     *
     * Origin must be Signed and there must be an approval in place between signer and
     * `delegate`.
     *
     * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
     *
     * - `id`: The identifier of the asset.
     * - `delegate`: The account delegated permission to transfer asset.
     *
     * Emits `ApprovalCancelled` on success.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} delegate
     **/
    cancelApproval: GenericTxCall<
      (
        id: number,
        delegate: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'CancelApproval';
            params: { id: number; delegate: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Cancel all of some asset approved for delegated transfer by a third-party account.
     *
     * Origin must be either ForceOrigin or Signed origin with the signer being the Admin
     * account of the asset `id`.
     *
     * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
     *
     * - `id`: The identifier of the asset.
     * - `delegate`: The account delegated permission to transfer asset.
     *
     * Emits `ApprovalCancelled` on success.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} owner
     * @param {MultiAddressLike} delegate
     **/
    forceCancelApproval: GenericTxCall<
      (
        id: number,
        owner: MultiAddressLike,
        delegate: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'ForceCancelApproval';
            params: { id: number; owner: MultiAddressLike; delegate: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Transfer some asset balance from a previously delegated account to some third-party
     * account.
     *
     * Origin must be Signed and there must be an approval in place by the `owner` to the
     * signer.
     *
     * If the entire amount approved for transfer is transferred, then any deposit previously
     * reserved by `approve_transfer` is unreserved.
     *
     * - `id`: The identifier of the asset.
     * - `owner`: The account which previously approved for a transfer of at least `amount` and
     * from which the asset balance will be withdrawn.
     * - `destination`: The account to which the asset balance of `amount` will be transferred.
     * - `amount`: The amount of assets to transfer.
     *
     * Emits `TransferredApproved` on success.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} owner
     * @param {MultiAddressLike} destination
     * @param {bigint} amount
     **/
    transferApproved: GenericTxCall<
      (
        id: number,
        owner: MultiAddressLike,
        destination: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'TransferApproved';
            params: { id: number; owner: MultiAddressLike; destination: MultiAddressLike; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Create an asset account for non-provider assets.
     *
     * A deposit will be taken from the signer account.
     *
     * - `origin`: Must be Signed; the signer account must have sufficient funds for a deposit
     * to be taken.
     * - `id`: The identifier of the asset for the account to be created.
     *
     * Emits `Touched` event when successful.
     *
     * @param {number} id
     **/
    touch: GenericTxCall<
      (id: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'Touch';
            params: { id: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Return the deposit (if any) of an asset account or a consumer reference (if any) of an
     * account.
     *
     * The origin must be Signed.
     *
     * - `id`: The identifier of the asset for which the caller would like the deposit
     * refunded.
     * - `allow_burn`: If `true` then assets may be destroyed in order to complete the refund.
     *
     * It will fail with either [`Error::ContainsHolds`] or [`Error::ContainsFreezes`] if
     * the asset account contains holds or freezes in place.
     *
     * Emits `Refunded` event when successful.
     *
     * @param {number} id
     * @param {boolean} allowBurn
     **/
    refund: GenericTxCall<
      (
        id: number,
        allowBurn: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'Refund';
            params: { id: number; allowBurn: boolean };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Sets the minimum balance of an asset.
     *
     * Only works if there aren't any accounts that are holding the asset or if
     * the new value of `min_balance` is less than the old one.
     *
     * Origin must be Signed and the sender has to be the Owner of the
     * asset `id`.
     *
     * - `id`: The identifier of the asset.
     * - `min_balance`: The new value of `min_balance`.
     *
     * Emits `AssetMinBalanceChanged` event when successful.
     *
     * @param {number} id
     * @param {bigint} minBalance
     **/
    setMinBalance: GenericTxCall<
      (
        id: number,
        minBalance: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'SetMinBalance';
            params: { id: number; minBalance: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Create an asset account for `who`.
     *
     * A deposit will be taken from the signer account.
     *
     * - `origin`: Must be Signed by `Freezer` or `Admin` of the asset `id`; the signer account
     * must have sufficient funds for a deposit to be taken.
     * - `id`: The identifier of the asset for the account to be created.
     * - `who`: The account to be created.
     *
     * Emits `Touched` event when successful.
     *
     * @param {number} id
     * @param {MultiAddressLike} who
     **/
    touchOther: GenericTxCall<
      (
        id: number,
        who: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'TouchOther';
            params: { id: number; who: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Return the deposit (if any) of a target asset account. Useful if you are the depositor.
     *
     * The origin must be Signed and either the account owner, depositor, or asset `Admin`. In
     * order to burn a non-zero balance of the asset, the caller must be the account and should
     * use `refund`.
     *
     * - `id`: The identifier of the asset for the account holding a deposit.
     * - `who`: The account to refund.
     *
     * It will fail with either [`Error::ContainsHolds`] or [`Error::ContainsFreezes`] if
     * the asset account contains holds or freezes in place.
     *
     * Emits `Refunded` event when successful.
     *
     * @param {number} id
     * @param {MultiAddressLike} who
     **/
    refundOther: GenericTxCall<
      (
        id: number,
        who: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'RefundOther';
            params: { id: number; who: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Disallow further unprivileged transfers of an asset `id` to and from an account `who`.
     *
     * Origin must be Signed and the sender should be the Freezer of the asset `id`.
     *
     * - `id`: The identifier of the account's asset.
     * - `who`: The account to be unblocked.
     *
     * Emits `Blocked`.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} who
     **/
    block: GenericTxCall<
      (
        id: number,
        who: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'Block';
            params: { id: number; who: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Transfer the entire transferable balance from the caller asset account.
     *
     * NOTE: This function only attempts to transfer _transferable_ balances. This means that
     * any held, frozen, or minimum balance (when `keep_alive` is `true`), will not be
     * transferred by this function. To ensure that this function results in a killed account,
     * you might need to prepare the account by removing any reference counters, storage
     * deposits, etc...
     *
     * The dispatch origin of this call must be Signed.
     *
     * - `id`: The identifier of the asset for the account holding a deposit.
     * - `dest`: The recipient of the transfer.
     * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
     * of the funds the asset account has, causing the sender asset account to be killed
     * (false), or transfer everything except at least the minimum balance, which will
     * guarantee to keep the sender asset account alive (true).
     *
     * @param {number} id
     * @param {MultiAddressLike} dest
     * @param {boolean} keepAlive
     **/
    transferAll: GenericTxCall<
      (
        id: number,
        dest: MultiAddressLike,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PoolAssets';
          palletCall: {
            name: 'TransferAll';
            params: { id: number; dest: MultiAddressLike; keepAlive: boolean };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `AssetConversion`'s transaction calls
   **/
  assetConversion: {
    /**
     * Creates an empty liquidity pool and an associated new `lp_token` asset
     * (the id of which is returned in the `Event::PoolCreated` event).
     *
     * Once a pool is created, someone may [`Pallet::add_liquidity`] to it.
     *
     * @param {StagingXcmV5Location} asset1
     * @param {StagingXcmV5Location} asset2
     **/
    createPool: GenericTxCall<
      (
        asset1: StagingXcmV5Location,
        asset2: StagingXcmV5Location,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'AssetConversion';
          palletCall: {
            name: 'CreatePool';
            params: { asset1: StagingXcmV5Location; asset2: StagingXcmV5Location };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Provide liquidity into the pool of `asset1` and `asset2`.
     * NOTE: an optimal amount of asset1 and asset2 will be calculated and
     * might be different than the provided `amount1_desired`/`amount2_desired`
     * thus you should provide the min amount you're happy to provide.
     * Params `amount1_min`/`amount2_min` represent that.
     * `mint_to` will be sent the liquidity tokens that represent this share of the pool.
     *
     * NOTE: when encountering an incorrect exchange rate and non-withdrawable pool liquidity,
     * batch an atomic call with [`Pallet::add_liquidity`] and
     * [`Pallet::swap_exact_tokens_for_tokens`] or [`Pallet::swap_tokens_for_exact_tokens`]
     * calls to render the liquidity withdrawable and rectify the exchange rate.
     *
     * Once liquidity is added, someone may successfully call
     * [`Pallet::swap_exact_tokens_for_tokens`].
     *
     * @param {StagingXcmV5Location} asset1
     * @param {StagingXcmV5Location} asset2
     * @param {bigint} amount1Desired
     * @param {bigint} amount2Desired
     * @param {bigint} amount1Min
     * @param {bigint} amount2Min
     * @param {AccountId32Like} mintTo
     **/
    addLiquidity: GenericTxCall<
      (
        asset1: StagingXcmV5Location,
        asset2: StagingXcmV5Location,
        amount1Desired: bigint,
        amount2Desired: bigint,
        amount1Min: bigint,
        amount2Min: bigint,
        mintTo: AccountId32Like,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'AssetConversion';
          palletCall: {
            name: 'AddLiquidity';
            params: {
              asset1: StagingXcmV5Location;
              asset2: StagingXcmV5Location;
              amount1Desired: bigint;
              amount2Desired: bigint;
              amount1Min: bigint;
              amount2Min: bigint;
              mintTo: AccountId32Like;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Allows you to remove liquidity by providing the `lp_token_burn` tokens that will be
     * burned in the process. With the usage of `amount1_min_receive`/`amount2_min_receive`
     * it's possible to control the min amount of returned tokens you're happy with.
     *
     * @param {StagingXcmV5Location} asset1
     * @param {StagingXcmV5Location} asset2
     * @param {bigint} lpTokenBurn
     * @param {bigint} amount1MinReceive
     * @param {bigint} amount2MinReceive
     * @param {AccountId32Like} withdrawTo
     **/
    removeLiquidity: GenericTxCall<
      (
        asset1: StagingXcmV5Location,
        asset2: StagingXcmV5Location,
        lpTokenBurn: bigint,
        amount1MinReceive: bigint,
        amount2MinReceive: bigint,
        withdrawTo: AccountId32Like,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'AssetConversion';
          palletCall: {
            name: 'RemoveLiquidity';
            params: {
              asset1: StagingXcmV5Location;
              asset2: StagingXcmV5Location;
              lpTokenBurn: bigint;
              amount1MinReceive: bigint;
              amount2MinReceive: bigint;
              withdrawTo: AccountId32Like;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Swap the exact amount of `asset1` into `asset2`.
     * `amount_out_min` param allows you to specify the min amount of the `asset2`
     * you're happy to receive.
     *
     * [`AssetConversionApi::quote_price_exact_tokens_for_tokens`] runtime call can be called
     * for a quote.
     *
     * @param {Array<StagingXcmV5Location>} path
     * @param {bigint} amountIn
     * @param {bigint} amountOutMin
     * @param {AccountId32Like} sendTo
     * @param {boolean} keepAlive
     **/
    swapExactTokensForTokens: GenericTxCall<
      (
        path: Array<StagingXcmV5Location>,
        amountIn: bigint,
        amountOutMin: bigint,
        sendTo: AccountId32Like,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'AssetConversion';
          palletCall: {
            name: 'SwapExactTokensForTokens';
            params: {
              path: Array<StagingXcmV5Location>;
              amountIn: bigint;
              amountOutMin: bigint;
              sendTo: AccountId32Like;
              keepAlive: boolean;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Swap any amount of `asset1` to get the exact amount of `asset2`.
     * `amount_in_max` param allows to specify the max amount of the `asset1`
     * you're happy to provide.
     *
     * [`AssetConversionApi::quote_price_tokens_for_exact_tokens`] runtime call can be called
     * for a quote.
     *
     * @param {Array<StagingXcmV5Location>} path
     * @param {bigint} amountOut
     * @param {bigint} amountInMax
     * @param {AccountId32Like} sendTo
     * @param {boolean} keepAlive
     **/
    swapTokensForExactTokens: GenericTxCall<
      (
        path: Array<StagingXcmV5Location>,
        amountOut: bigint,
        amountInMax: bigint,
        sendTo: AccountId32Like,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'AssetConversion';
          palletCall: {
            name: 'SwapTokensForExactTokens';
            params: {
              path: Array<StagingXcmV5Location>;
              amountOut: bigint;
              amountInMax: bigint;
              sendTo: AccountId32Like;
              keepAlive: boolean;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Touch an existing pool to fulfill prerequisites before providing liquidity, such as
     * ensuring that the pool's accounts are in place. It is typically useful when a pool
     * creator removes the pool's accounts and does not provide a liquidity. This action may
     * involve holding assets from the caller as a deposit for creating the pool's accounts.
     *
     * The origin must be Signed.
     *
     * - `asset1`: The asset ID of an existing pool with a pair (asset1, asset2).
     * - `asset2`: The asset ID of an existing pool with a pair (asset1, asset2).
     *
     * Emits `Touched` event when successful.
     *
     * @param {StagingXcmV5Location} asset1
     * @param {StagingXcmV5Location} asset2
     **/
    touch: GenericTxCall<
      (
        asset1: StagingXcmV5Location,
        asset2: StagingXcmV5Location,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'AssetConversion';
          palletCall: {
            name: 'Touch';
            params: { asset1: StagingXcmV5Location; asset2: StagingXcmV5Location };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Treasury`'s transaction calls
   **/
  treasury: {
    /**
     * Propose and approve a spend of treasury funds.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::SpendOrigin`] with the `Success` value being at least `amount`.
     *
     * ### Details
     * NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
     * beneficiary.
     *
     * ### Parameters
     * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
     * - `beneficiary`: The destination account for the transfer.
     *
     * ## Events
     *
     * Emits [`Event::SpendApproved`] if successful.
     *
     * @param {bigint} amount
     * @param {MultiAddressLike} beneficiary
     **/
    spendLocal: GenericTxCall<
      (
        amount: bigint,
        beneficiary: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Treasury';
          palletCall: {
            name: 'SpendLocal';
            params: { amount: bigint; beneficiary: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Force a previously approved proposal to be removed from the approval queue.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::RejectOrigin`].
     *
     * ## Details
     *
     * The original deposit will no longer be returned.
     *
     * ### Parameters
     * - `proposal_id`: The index of a proposal
     *
     * ### Complexity
     * - O(A) where `A` is the number of approvals
     *
     * ### Errors
     * - [`Error::ProposalNotApproved`]: The `proposal_id` supplied was not found in the
     * approval queue, i.e., the proposal has not been approved. This could also mean the
     * proposal does not exist altogether, thus there is no way it would have been approved
     * in the first place.
     *
     * @param {number} proposalId
     **/
    removeApproval: GenericTxCall<
      (proposalId: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Treasury';
          palletCall: {
            name: 'RemoveApproval';
            params: { proposalId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Propose and approve a spend of treasury funds.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::SpendOrigin`] with the `Success` value being at least
     * `amount` of `asset_kind` in the native asset. The amount of `asset_kind` is converted
     * for assertion using the [`Config::BalanceConverter`].
     *
     * ## Details
     *
     * Create an approved spend for transferring a specific `amount` of `asset_kind` to a
     * designated beneficiary. The spend must be claimed using the `payout` dispatchable within
     * the [`Config::PayoutPeriod`].
     *
     * ### Parameters
     * - `asset_kind`: An indicator of the specific asset class to be spent.
     * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
     * - `beneficiary`: The beneficiary of the spend.
     * - `valid_from`: The block number from which the spend can be claimed. It can refer to
     * the past if the resulting spend has not yet expired according to the
     * [`Config::PayoutPeriod`]. If `None`, the spend can be claimed immediately after
     * approval.
     *
     * ## Events
     *
     * Emits [`Event::AssetSpendApproved`] if successful.
     *
     * @param {PolkadotRuntimeCommonImplsVersionedLocatableAsset} assetKind
     * @param {bigint} amount
     * @param {ParachainsCommonPayVersionedLocatableAccount} beneficiary
     * @param {number | undefined} validFrom
     **/
    spend: GenericTxCall<
      (
        assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset,
        amount: bigint,
        beneficiary: ParachainsCommonPayVersionedLocatableAccount,
        validFrom: number | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Treasury';
          palletCall: {
            name: 'Spend';
            params: {
              assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset;
              amount: bigint;
              beneficiary: ParachainsCommonPayVersionedLocatableAccount;
              validFrom: number | undefined;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Claim a spend.
     *
     * ## Dispatch Origin
     *
     * Must be signed
     *
     * ## Details
     *
     * Spends must be claimed within some temporal bounds. A spend may be claimed within one
     * [`Config::PayoutPeriod`] from the `valid_from` block.
     * In case of a payout failure, the spend status must be updated with the `check_status`
     * dispatchable before retrying with the current function.
     *
     * ### Parameters
     * - `index`: The spend index.
     *
     * ## Events
     *
     * Emits [`Event::Paid`] if successful.
     *
     * @param {number} index
     *
     * @deprecated The `spend_local` call will be removed by May 2025. Migrate to the new flow and use the `spend` call.
     **/
    payout: GenericTxCall<
      (index: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Treasury';
          palletCall: {
            name: 'Payout';
            params: { index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Check the status of the spend and remove it from the storage if processed.
     *
     * ## Dispatch Origin
     *
     * Must be signed.
     *
     * ## Details
     *
     * The status check is a prerequisite for retrying a failed payout.
     * If a spend has either succeeded or expired, it is removed from the storage by this
     * function. In such instances, transaction fees are refunded.
     *
     * ### Parameters
     * - `index`: The spend index.
     *
     * ## Events
     *
     * Emits [`Event::PaymentFailed`] if the spend payout has failed.
     * Emits [`Event::SpendProcessed`] if the spend payout has succeed.
     *
     * @param {number} index
     *
     * @deprecated The `remove_approval` call will be removed by May 2025. It associated with the deprecated `spend_local` call.
     **/
    checkStatus: GenericTxCall<
      (index: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Treasury';
          palletCall: {
            name: 'CheckStatus';
            params: { index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Void previously approved spend.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::RejectOrigin`].
     *
     * ## Details
     *
     * A spend void is only possible if the payout has not been attempted yet.
     *
     * ### Parameters
     * - `index`: The spend index.
     *
     * ## Events
     *
     * Emits [`Event::AssetSpendVoided`] if successful.
     *
     * @param {number} index
     **/
    voidSpend: GenericTxCall<
      (index: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Treasury';
          palletCall: {
            name: 'VoidSpend';
            params: { index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `ConvictionVoting`'s transaction calls
   **/
  convictionVoting: {
    /**
     * Vote in a poll. If `vote.is_aye()`, the vote is to enact the proposal;
     * otherwise it is a vote to keep the status quo.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `poll_index`: The index of the poll to vote for.
     * - `vote`: The vote configuration.
     *
     * Weight: `O(R)` where R is the number of polls the voter has voted on.
     *
     * @param {number} pollIndex
     * @param {PalletConvictionVotingVoteAccountVote} vote
     **/
    vote: GenericTxCall<
      (
        pollIndex: number,
        vote: PalletConvictionVotingVoteAccountVote,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ConvictionVoting';
          palletCall: {
            name: 'Vote';
            params: { pollIndex: number; vote: PalletConvictionVotingVoteAccountVote };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Delegate the voting power (with some given conviction) of the sending account for a
     * particular class of polls.
     *
     * The balance delegated is locked for as long as it's delegated, and thereafter for the
     * time appropriate for the conviction's lock period.
     *
     * The dispatch origin of this call must be _Signed_, and the signing account must either:
     * - be delegating already; or
     * - have no voting activity (if there is, then it will need to be removed through
     * `remove_vote`).
     *
     * - `to`: The account whose voting the `target` account's voting power will follow.
     * - `class`: The class of polls to delegate. To delegate multiple classes, multiple calls
     * to this function are required.
     * - `conviction`: The conviction that will be attached to the delegated votes. When the
     * account is undelegated, the funds will be locked for the corresponding period.
     * - `balance`: The amount of the account's balance to be used in delegating. This must not
     * be more than the account's current balance.
     *
     * Emits `Delegated`.
     *
     * Weight: `O(R)` where R is the number of polls the voter delegating to has
     * voted on. Weight is initially charged as if maximum votes, but is refunded later.
     *
     * @param {number} class_
     * @param {MultiAddressLike} to
     * @param {PalletConvictionVotingConviction} conviction
     * @param {bigint} balance
     **/
    delegate: GenericTxCall<
      (
        class_: number,
        to: MultiAddressLike,
        conviction: PalletConvictionVotingConviction,
        balance: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ConvictionVoting';
          palletCall: {
            name: 'Delegate';
            params: {
              class: number;
              to: MultiAddressLike;
              conviction: PalletConvictionVotingConviction;
              balance: bigint;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Undelegate the voting power of the sending account for a particular class of polls.
     *
     * Tokens may be unlocked following once an amount of time consistent with the lock period
     * of the conviction with which the delegation was issued has passed.
     *
     * The dispatch origin of this call must be _Signed_ and the signing account must be
     * currently delegating.
     *
     * - `class`: The class of polls to remove the delegation from.
     *
     * Emits `Undelegated`.
     *
     * Weight: `O(R)` where R is the number of polls the voter delegating to has
     * voted on. Weight is initially charged as if maximum votes, but is refunded later.
     *
     * @param {number} class_
     **/
    undelegate: GenericTxCall<
      (class_: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'ConvictionVoting';
          palletCall: {
            name: 'Undelegate';
            params: { class: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove the lock caused by prior voting/delegating which has expired within a particular
     * class.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `class`: The class of polls to unlock.
     * - `target`: The account to remove the lock on.
     *
     * Weight: `O(R)` with R number of vote of target.
     *
     * @param {number} class_
     * @param {MultiAddressLike} target
     **/
    unlock: GenericTxCall<
      (
        class_: number,
        target: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ConvictionVoting';
          palletCall: {
            name: 'Unlock';
            params: { class: number; target: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove a vote for a poll.
     *
     * If:
     * - the poll was cancelled, or
     * - the poll is ongoing, or
     * - the poll has ended such that
     * - the vote of the account was in opposition to the result; or
     * - there was no conviction to the account's vote; or
     * - the account made a split vote
     * ...then the vote is removed cleanly and a following call to `unlock` may result in more
     * funds being available.
     *
     * If, however, the poll has ended and:
     * - it finished corresponding to the vote of the account, and
     * - the account made a standard vote with conviction, and
     * - the lock period of the conviction is not over
     * ...then the lock will be aggregated into the overall account's lock, which may involve
     * *overlocking* (where the two locks are combined into a single lock that is the maximum
     * of both the amount locked and the time is it locked for).
     *
     * The dispatch origin of this call must be _Signed_, and the signer must have a vote
     * registered for poll `index`.
     *
     * - `index`: The index of poll of the vote to be removed.
     * - `class`: Optional parameter, if given it indicates the class of the poll. For polls
     * which have finished or are cancelled, this must be `Some`.
     *
     * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
     * Weight is calculated for the maximum number of vote.
     *
     * @param {number | undefined} class_
     * @param {number} index
     **/
    removeVote: GenericTxCall<
      (
        class_: number | undefined,
        index: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ConvictionVoting';
          palletCall: {
            name: 'RemoveVote';
            params: { class: number | undefined; index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove a vote for a poll.
     *
     * If the `target` is equal to the signer, then this function is exactly equivalent to
     * `remove_vote`. If not equal to the signer, then the vote must have expired,
     * either because the poll was cancelled, because the voter lost the poll or
     * because the conviction period is over.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `target`: The account of the vote to be removed; this account must have voted for poll
     * `index`.
     * - `index`: The index of poll of the vote to be removed.
     * - `class`: The class of the poll.
     *
     * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
     * Weight is calculated for the maximum number of vote.
     *
     * @param {MultiAddressLike} target
     * @param {number} class_
     * @param {number} index
     **/
    removeOtherVote: GenericTxCall<
      (
        target: MultiAddressLike,
        class_: number,
        index: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ConvictionVoting';
          palletCall: {
            name: 'RemoveOtherVote';
            params: { target: MultiAddressLike; class: number; index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Referenda`'s transaction calls
   **/
  referenda: {
    /**
     * Propose a referendum on a privileged action.
     *
     * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
     * available.
     * - `proposal_origin`: The origin from which the proposal should be executed.
     * - `proposal`: The proposal.
     * - `enactment_moment`: The moment that the proposal should be enacted.
     *
     * Emits `Submitted`.
     *
     * @param {AssetHubPolkadotRuntimeOriginCaller} proposalOrigin
     * @param {FrameSupportPreimagesBounded} proposal
     * @param {FrameSupportScheduleDispatchTime} enactmentMoment
     **/
    submit: GenericTxCall<
      (
        proposalOrigin: AssetHubPolkadotRuntimeOriginCaller,
        proposal: FrameSupportPreimagesBounded,
        enactmentMoment: FrameSupportScheduleDispatchTime,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'Submit';
            params: {
              proposalOrigin: AssetHubPolkadotRuntimeOriginCaller;
              proposal: FrameSupportPreimagesBounded;
              enactmentMoment: FrameSupportScheduleDispatchTime;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Post the Decision Deposit for a referendum.
     *
     * - `origin`: must be `Signed` and the account must have funds available for the
     * referendum's track's Decision Deposit.
     * - `index`: The index of the submitted referendum whose Decision Deposit is yet to be
     * posted.
     *
     * Emits `DecisionDepositPlaced`.
     *
     * @param {number} index
     **/
    placeDecisionDeposit: GenericTxCall<
      (index: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'PlaceDecisionDeposit';
            params: { index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Refund the Decision Deposit for a closed referendum back to the depositor.
     *
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Decision Deposit has not yet been
     * refunded.
     *
     * Emits `DecisionDepositRefunded`.
     *
     * @param {number} index
     **/
    refundDecisionDeposit: GenericTxCall<
      (index: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'RefundDecisionDeposit';
            params: { index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Cancel an ongoing referendum.
     *
     * - `origin`: must be the `CancelOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     *
     * Emits `Cancelled`.
     *
     * @param {number} index
     **/
    cancel: GenericTxCall<
      (index: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'Cancel';
            params: { index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Cancel an ongoing referendum and slash the deposits.
     *
     * - `origin`: must be the `KillOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     *
     * Emits `Killed` and `DepositSlashed`.
     *
     * @param {number} index
     **/
    kill: GenericTxCall<
      (index: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'Kill';
            params: { index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Advance a referendum onto its next logical state. Only used internally.
     *
     * - `origin`: must be `Root`.
     * - `index`: the referendum to be advanced.
     *
     * @param {number} index
     **/
    nudgeReferendum: GenericTxCall<
      (index: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'NudgeReferendum';
            params: { index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Advance a track onto its next logical state. Only used internally.
     *
     * - `origin`: must be `Root`.
     * - `track`: the track to be advanced.
     *
     * Action item for when there is now one fewer referendum in the deciding phase and the
     * `DecidingCount` is not yet updated. This means that we should either:
     * - begin deciding another referendum (and leave `DecidingCount` alone); or
     * - decrement `DecidingCount`.
     *
     * @param {number} track
     **/
    oneFewerDeciding: GenericTxCall<
      (track: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'OneFewerDeciding';
            params: { track: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Refund the Submission Deposit for a closed referendum back to the depositor.
     *
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Submission Deposit has not yet been
     * refunded.
     *
     * Emits `SubmissionDepositRefunded`.
     *
     * @param {number} index
     **/
    refundSubmissionDeposit: GenericTxCall<
      (index: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'RefundSubmissionDeposit';
            params: { index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set or clear metadata of a referendum.
     *
     * Parameters:
     * - `origin`: Must be `Signed` by a creator of a referendum or by anyone to clear a
     * metadata of a finished referendum.
     * - `index`: The index of a referendum to set or clear metadata for.
     * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
     *
     * @param {number} index
     * @param {H256 | undefined} maybeHash
     **/
    setMetadata: GenericTxCall<
      (
        index: number,
        maybeHash: H256 | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'SetMetadata';
            params: { index: number; maybeHash: H256 | undefined };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Whitelist`'s transaction calls
   **/
  whitelist: {
    /**
     *
     * @param {H256} callHash
     **/
    whitelistCall: GenericTxCall<
      (callHash: H256) => ChainSubmittableExtrinsic<
        {
          pallet: 'Whitelist';
          palletCall: {
            name: 'WhitelistCall';
            params: { callHash: H256 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {H256} callHash
     **/
    removeWhitelistedCall: GenericTxCall<
      (callHash: H256) => ChainSubmittableExtrinsic<
        {
          pallet: 'Whitelist';
          palletCall: {
            name: 'RemoveWhitelistedCall';
            params: { callHash: H256 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {H256} callHash
     * @param {number} callEncodedLen
     * @param {SpWeightsWeightV2Weight} callWeightWitness
     **/
    dispatchWhitelistedCall: GenericTxCall<
      (
        callHash: H256,
        callEncodedLen: number,
        callWeightWitness: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Whitelist';
          palletCall: {
            name: 'DispatchWhitelistedCall';
            params: { callHash: H256; callEncodedLen: number; callWeightWitness: SpWeightsWeightV2Weight };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {AssetHubPolkadotRuntimeRuntimeCallLike} call
     **/
    dispatchWhitelistedCallWithPreimage: GenericTxCall<
      (call: AssetHubPolkadotRuntimeRuntimeCallLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'Whitelist';
          palletCall: {
            name: 'DispatchWhitelistedCallWithPreimage';
            params: { call: AssetHubPolkadotRuntimeRuntimeCallLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Bounties`'s transaction calls
   **/
  bounties: {
    /**
     * Propose a new bounty.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
     * `DataDepositPerByte` for each byte in `reason`. It will be unreserved upon approval,
     * or slashed when rejected.
     *
     * - `curator`: The curator account whom will manage this bounty.
     * - `fee`: The curator fee.
     * - `value`: The total payment amount of this bounty, curator fee included.
     * - `description`: The description of this bounty.
     *
     * @param {bigint} value
     * @param {BytesLike} description
     **/
    proposeBounty: GenericTxCall<
      (
        value: bigint,
        description: BytesLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Bounties';
          palletCall: {
            name: 'ProposeBounty';
            params: { value: bigint; description: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Approve a bounty proposal. At a later time, the bounty will be funded and become active
     * and the original deposit will be returned.
     *
     * May only be called from `T::SpendOrigin`.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {number} bountyId
     **/
    approveBounty: GenericTxCall<
      (bountyId: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Bounties';
          palletCall: {
            name: 'ApproveBounty';
            params: { bountyId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Propose a curator to a funded bounty.
     *
     * May only be called from `T::SpendOrigin`.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {number} bountyId
     * @param {MultiAddressLike} curator
     * @param {bigint} fee
     **/
    proposeCurator: GenericTxCall<
      (
        bountyId: number,
        curator: MultiAddressLike,
        fee: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Bounties';
          palletCall: {
            name: 'ProposeCurator';
            params: { bountyId: number; curator: MultiAddressLike; fee: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Unassign curator from a bounty.
     *
     * This function can only be called by the `RejectOrigin` a signed origin.
     *
     * If this function is called by the `RejectOrigin`, we assume that the curator is
     * malicious or inactive. As a result, we will slash the curator when possible.
     *
     * If the origin is the curator, we take this as a sign they are unable to do their job and
     * they willingly give up. We could slash them, but for now we allow them to recover their
     * deposit and exit without issue. (We may want to change this if it is abused.)
     *
     * Finally, the origin can be anyone if and only if the curator is "inactive". This allows
     * anyone in the community to call out that a curator is not doing their due diligence, and
     * we should pick a new curator. In this case the curator should also be slashed.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {number} bountyId
     **/
    unassignCurator: GenericTxCall<
      (bountyId: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Bounties';
          palletCall: {
            name: 'UnassignCurator';
            params: { bountyId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Accept the curator role for a bounty.
     * A deposit will be reserved from curator and refund upon successful payout.
     *
     * May only be called from the curator.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {number} bountyId
     **/
    acceptCurator: GenericTxCall<
      (bountyId: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Bounties';
          palletCall: {
            name: 'AcceptCurator';
            params: { bountyId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Award bounty to a beneficiary account. The beneficiary will be able to claim the funds
     * after a delay.
     *
     * The dispatch origin for this call must be the curator of this bounty.
     *
     * - `bounty_id`: Bounty ID to award.
     * - `beneficiary`: The beneficiary account whom will receive the payout.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {number} bountyId
     * @param {MultiAddressLike} beneficiary
     **/
    awardBounty: GenericTxCall<
      (
        bountyId: number,
        beneficiary: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Bounties';
          palletCall: {
            name: 'AwardBounty';
            params: { bountyId: number; beneficiary: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Claim the payout from an awarded bounty after payout delay.
     *
     * The dispatch origin for this call must be the beneficiary of this bounty.
     *
     * - `bounty_id`: Bounty ID to claim.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {number} bountyId
     **/
    claimBounty: GenericTxCall<
      (bountyId: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Bounties';
          palletCall: {
            name: 'ClaimBounty';
            params: { bountyId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Cancel a proposed or active bounty. All the funds will be sent to treasury and
     * the curator deposit will be unreserved if possible.
     *
     * Only `T::RejectOrigin` is able to cancel a bounty.
     *
     * - `bounty_id`: Bounty ID to cancel.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {number} bountyId
     **/
    closeBounty: GenericTxCall<
      (bountyId: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Bounties';
          palletCall: {
            name: 'CloseBounty';
            params: { bountyId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Extend the expiry time of an active bounty.
     *
     * The dispatch origin for this call must be the curator of this bounty.
     *
     * - `bounty_id`: Bounty ID to extend.
     * - `remark`: additional information.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {number} bountyId
     * @param {BytesLike} remark
     **/
    extendBountyExpiry: GenericTxCall<
      (
        bountyId: number,
        remark: BytesLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Bounties';
          palletCall: {
            name: 'ExtendBountyExpiry';
            params: { bountyId: number; remark: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Approve bountry and propose a curator simultaneously.
     * This call is a shortcut to calling `approve_bounty` and `propose_curator` separately.
     *
     * May only be called from `T::SpendOrigin`.
     *
     * - `bounty_id`: Bounty ID to approve.
     * - `curator`: The curator account whom will manage this bounty.
     * - `fee`: The curator fee.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {number} bountyId
     * @param {MultiAddressLike} curator
     * @param {bigint} fee
     **/
    approveBountyWithCurator: GenericTxCall<
      (
        bountyId: number,
        curator: MultiAddressLike,
        fee: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Bounties';
          palletCall: {
            name: 'ApproveBountyWithCurator';
            params: { bountyId: number; curator: MultiAddressLike; fee: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Poke the deposit reserved for creating a bounty proposal.
     *
     * This can be used by accounts to update their reserved amount.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `bounty_id`: The bounty id for which to adjust the deposit.
     *
     * If the deposit is updated, the difference will be reserved/unreserved from the
     * proposer's account.
     *
     * The transaction is made free if the deposit is updated and paid otherwise.
     *
     * Emits `DepositPoked` if the deposit is updated.
     *
     * @param {number} bountyId
     **/
    pokeDeposit: GenericTxCall<
      (bountyId: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Bounties';
          palletCall: {
            name: 'PokeDeposit';
            params: { bountyId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `ChildBounties`'s transaction calls
   **/
  childBounties: {
    /**
     * Add a new child-bounty.
     *
     * The dispatch origin for this call must be the curator of parent
     * bounty and the parent bounty must be in "active" state.
     *
     * Child-bounty gets added successfully & fund gets transferred from
     * parent bounty to child-bounty account, if parent bounty has enough
     * funds, else the call fails.
     *
     * Upper bound to maximum number of active child bounties that can be
     * added are managed via runtime trait config
     * [`Config::MaxActiveChildBountyCount`].
     *
     * If the call is success, the status of child-bounty is updated to
     * "Added".
     *
     * - `parent_bounty_id`: Index of parent bounty for which child-bounty is being added.
     * - `value`: Value for executing the proposal.
     * - `description`: Text description for the child-bounty.
     *
     * @param {number} parentBountyId
     * @param {bigint} value
     * @param {BytesLike} description
     **/
    addChildBounty: GenericTxCall<
      (
        parentBountyId: number,
        value: bigint,
        description: BytesLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ChildBounties';
          palletCall: {
            name: 'AddChildBounty';
            params: { parentBountyId: number; value: bigint; description: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Propose curator for funded child-bounty.
     *
     * The dispatch origin for this call must be curator of parent bounty.
     *
     * Parent bounty must be in active state, for this child-bounty call to
     * work.
     *
     * Child-bounty must be in "Added" state, for processing the call. And
     * state of child-bounty is moved to "CuratorProposed" on successful
     * call completion.
     *
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     * - `curator`: Address of child-bounty curator.
     * - `fee`: payment fee to child-bounty curator for execution.
     *
     * @param {number} parentBountyId
     * @param {number} childBountyId
     * @param {MultiAddressLike} curator
     * @param {bigint} fee
     **/
    proposeCurator: GenericTxCall<
      (
        parentBountyId: number,
        childBountyId: number,
        curator: MultiAddressLike,
        fee: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ChildBounties';
          palletCall: {
            name: 'ProposeCurator';
            params: { parentBountyId: number; childBountyId: number; curator: MultiAddressLike; fee: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Accept the curator role for the child-bounty.
     *
     * The dispatch origin for this call must be the curator of this
     * child-bounty.
     *
     * A deposit will be reserved from the curator and refund upon
     * successful payout or cancellation.
     *
     * Fee for curator is deducted from curator fee of parent bounty.
     *
     * Parent bounty must be in active state, for this child-bounty call to
     * work.
     *
     * Child-bounty must be in "CuratorProposed" state, for processing the
     * call. And state of child-bounty is moved to "Active" on successful
     * call completion.
     *
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     *
     * @param {number} parentBountyId
     * @param {number} childBountyId
     **/
    acceptCurator: GenericTxCall<
      (
        parentBountyId: number,
        childBountyId: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ChildBounties';
          palletCall: {
            name: 'AcceptCurator';
            params: { parentBountyId: number; childBountyId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Unassign curator from a child-bounty.
     *
     * The dispatch origin for this call can be either `RejectOrigin`, or
     * the curator of the parent bounty, or any signed origin.
     *
     * For the origin other than T::RejectOrigin and the child-bounty
     * curator, parent bounty must be in active state, for this call to
     * work. We allow child-bounty curator and T::RejectOrigin to execute
     * this call irrespective of the parent bounty state.
     *
     * If this function is called by the `RejectOrigin` or the
     * parent bounty curator, we assume that the child-bounty curator is
     * malicious or inactive. As a result, child-bounty curator deposit is
     * slashed.
     *
     * If the origin is the child-bounty curator, we take this as a sign
     * that they are unable to do their job, and are willingly giving up.
     * We could slash the deposit, but for now we allow them to unreserve
     * their deposit and exit without issue. (We may want to change this if
     * it is abused.)
     *
     * Finally, the origin can be anyone iff the child-bounty curator is
     * "inactive". Expiry update due of parent bounty is used to estimate
     * inactive state of child-bounty curator.
     *
     * This allows anyone in the community to call out that a child-bounty
     * curator is not doing their due diligence, and we should pick a new
     * one. In this case the child-bounty curator deposit is slashed.
     *
     * State of child-bounty is moved to Added state on successful call
     * completion.
     *
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     *
     * @param {number} parentBountyId
     * @param {number} childBountyId
     **/
    unassignCurator: GenericTxCall<
      (
        parentBountyId: number,
        childBountyId: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ChildBounties';
          palletCall: {
            name: 'UnassignCurator';
            params: { parentBountyId: number; childBountyId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Award child-bounty to a beneficiary.
     *
     * The beneficiary will be able to claim the funds after a delay.
     *
     * The dispatch origin for this call must be the parent curator or
     * curator of this child-bounty.
     *
     * Parent bounty must be in active state, for this child-bounty call to
     * work.
     *
     * Child-bounty must be in active state, for processing the call. And
     * state of child-bounty is moved to "PendingPayout" on successful call
     * completion.
     *
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     * - `beneficiary`: Beneficiary account.
     *
     * @param {number} parentBountyId
     * @param {number} childBountyId
     * @param {MultiAddressLike} beneficiary
     **/
    awardChildBounty: GenericTxCall<
      (
        parentBountyId: number,
        childBountyId: number,
        beneficiary: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ChildBounties';
          palletCall: {
            name: 'AwardChildBounty';
            params: { parentBountyId: number; childBountyId: number; beneficiary: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Claim the payout from an awarded child-bounty after payout delay.
     *
     * The dispatch origin for this call may be any signed origin.
     *
     * Call works independent of parent bounty state, No need for parent
     * bounty to be in active state.
     *
     * The Beneficiary is paid out with agreed bounty value. Curator fee is
     * paid & curator deposit is unreserved.
     *
     * Child-bounty must be in "PendingPayout" state, for processing the
     * call. And instance of child-bounty is removed from the state on
     * successful call completion.
     *
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     *
     * @param {number} parentBountyId
     * @param {number} childBountyId
     **/
    claimChildBounty: GenericTxCall<
      (
        parentBountyId: number,
        childBountyId: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ChildBounties';
          palletCall: {
            name: 'ClaimChildBounty';
            params: { parentBountyId: number; childBountyId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Cancel a proposed or active child-bounty. Child-bounty account funds
     * are transferred to parent bounty account. The child-bounty curator
     * deposit may be unreserved if possible.
     *
     * The dispatch origin for this call must be either parent curator or
     * `T::RejectOrigin`.
     *
     * If the state of child-bounty is `Active`, curator deposit is
     * unreserved.
     *
     * If the state of child-bounty is `PendingPayout`, call fails &
     * returns `PendingPayout` error.
     *
     * For the origin other than T::RejectOrigin, parent bounty must be in
     * active state, for this child-bounty call to work. For origin
     * T::RejectOrigin execution is forced.
     *
     * Instance of child-bounty is removed from the state on successful
     * call completion.
     *
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     *
     * @param {number} parentBountyId
     * @param {number} childBountyId
     **/
    closeChildBounty: GenericTxCall<
      (
        parentBountyId: number,
        childBountyId: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ChildBounties';
          palletCall: {
            name: 'CloseChildBounty';
            params: { parentBountyId: number; childBountyId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `AssetRate`'s transaction calls
   **/
  assetRate: {
    /**
     * Initialize a conversion rate to native balance for the given asset.
     *
     * ## Complexity
     * - O(1)
     *
     * @param {PolkadotRuntimeCommonImplsVersionedLocatableAsset} assetKind
     * @param {FixedU128} rate
     **/
    create: GenericTxCall<
      (
        assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset,
        rate: FixedU128,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'AssetRate';
          palletCall: {
            name: 'Create';
            params: { assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset; rate: FixedU128 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Update the conversion rate to native balance for the given asset.
     *
     * ## Complexity
     * - O(1)
     *
     * @param {PolkadotRuntimeCommonImplsVersionedLocatableAsset} assetKind
     * @param {FixedU128} rate
     **/
    update: GenericTxCall<
      (
        assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset,
        rate: FixedU128,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'AssetRate';
          palletCall: {
            name: 'Update';
            params: { assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset; rate: FixedU128 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove an existing conversion rate to native balance for the given asset.
     *
     * ## Complexity
     * - O(1)
     *
     * @param {PolkadotRuntimeCommonImplsVersionedLocatableAsset} assetKind
     **/
    remove: GenericTxCall<
      (assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset) => ChainSubmittableExtrinsic<
        {
          pallet: 'AssetRate';
          palletCall: {
            name: 'Remove';
            params: { assetKind: PolkadotRuntimeCommonImplsVersionedLocatableAsset };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `StateTrieMigration`'s transaction calls
   **/
  stateTrieMigration: {
    /**
     * Control the automatic migration.
     *
     * The dispatch origin of this call must be [`Config::ControlOrigin`].
     *
     * @param {PalletStateTrieMigrationMigrationLimits | undefined} maybeConfig
     **/
    controlAutoMigration: GenericTxCall<
      (maybeConfig: PalletStateTrieMigrationMigrationLimits | undefined) => ChainSubmittableExtrinsic<
        {
          pallet: 'StateTrieMigration';
          palletCall: {
            name: 'ControlAutoMigration';
            params: { maybeConfig: PalletStateTrieMigrationMigrationLimits | undefined };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Continue the migration for the given `limits`.
     *
     * The dispatch origin of this call can be any signed account.
     *
     * This transaction has NO MONETARY INCENTIVES. calling it will not reward anyone. Albeit,
     * Upon successful execution, the transaction fee is returned.
     *
     * The (potentially over-estimated) of the byte length of all the data read must be
     * provided for up-front fee-payment and weighing. In essence, the caller is guaranteeing
     * that executing the current `MigrationTask` with the given `limits` will not exceed
     * `real_size_upper` bytes of read data.
     *
     * The `witness_task` is merely a helper to prevent the caller from being slashed or
     * generally trigger a migration that they do not intend. This parameter is just a message
     * from caller, saying that they believed `witness_task` was the last state of the
     * migration, and they only wish for their transaction to do anything, if this assumption
     * holds. In case `witness_task` does not match, the transaction fails.
     *
     * Based on the documentation of [`MigrationTask::migrate_until_exhaustion`], the
     * recommended way of doing this is to pass a `limit` that only bounds `count`, as the
     * `size` limit can always be overwritten.
     *
     * @param {PalletStateTrieMigrationMigrationLimits} limits
     * @param {number} realSizeUpper
     * @param {PalletStateTrieMigrationMigrationTask} witnessTask
     **/
    continueMigrate: GenericTxCall<
      (
        limits: PalletStateTrieMigrationMigrationLimits,
        realSizeUpper: number,
        witnessTask: PalletStateTrieMigrationMigrationTask,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'StateTrieMigration';
          palletCall: {
            name: 'ContinueMigrate';
            params: {
              limits: PalletStateTrieMigrationMigrationLimits;
              realSizeUpper: number;
              witnessTask: PalletStateTrieMigrationMigrationTask;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Migrate the list of top keys by iterating each of them one by one.
     *
     * This does not affect the global migration process tracker ([`MigrationProcess`]), and
     * should only be used in case any keys are leftover due to a bug.
     *
     * @param {Array<BytesLike>} keys
     * @param {number} witnessSize
     **/
    migrateCustomTop: GenericTxCall<
      (
        keys: Array<BytesLike>,
        witnessSize: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'StateTrieMigration';
          palletCall: {
            name: 'MigrateCustomTop';
            params: { keys: Array<BytesLike>; witnessSize: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Migrate the list of child keys by iterating each of them one by one.
     *
     * All of the given child keys must be present under one `child_root`.
     *
     * This does not affect the global migration process tracker ([`MigrationProcess`]), and
     * should only be used in case any keys are leftover due to a bug.
     *
     * @param {BytesLike} root
     * @param {Array<BytesLike>} childKeys
     * @param {number} totalSize
     **/
    migrateCustomChild: GenericTxCall<
      (
        root: BytesLike,
        childKeys: Array<BytesLike>,
        totalSize: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'StateTrieMigration';
          palletCall: {
            name: 'MigrateCustomChild';
            params: { root: BytesLike; childKeys: Array<BytesLike>; totalSize: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the maximum limit of the signed migration.
     *
     * @param {PalletStateTrieMigrationMigrationLimits} limits
     **/
    setSignedMaxLimits: GenericTxCall<
      (limits: PalletStateTrieMigrationMigrationLimits) => ChainSubmittableExtrinsic<
        {
          pallet: 'StateTrieMigration';
          palletCall: {
            name: 'SetSignedMaxLimits';
            params: { limits: PalletStateTrieMigrationMigrationLimits };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Forcefully set the progress the running migration.
     *
     * This is only useful in one case: the next key to migrate is too big to be migrated with
     * a signed account, in a parachain context, and we simply want to skip it. A reasonable
     * example of this would be `:code:`, which is both very expensive to migrate, and commonly
     * used, so probably it is already migrated.
     *
     * In case you mess things up, you can also, in principle, use this to reset the migration
     * process.
     *
     * @param {PalletStateTrieMigrationProgress} progressTop
     * @param {PalletStateTrieMigrationProgress} progressChild
     **/
    forceSetProgress: GenericTxCall<
      (
        progressTop: PalletStateTrieMigrationProgress,
        progressChild: PalletStateTrieMigrationProgress,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'StateTrieMigration';
          palletCall: {
            name: 'ForceSetProgress';
            params: { progressTop: PalletStateTrieMigrationProgress; progressChild: PalletStateTrieMigrationProgress };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `NominationPools`'s transaction calls
   **/
  nominationPools: {
    /**
     * Stake funds with a pool. The amount to bond is delegated (or transferred based on
     * [`adapter::StakeStrategyType`]) from the member to the pool account and immediately
     * increases the pool's bond.
     *
     * The method of transferring the amount to the pool account is determined by
     * [`adapter::StakeStrategyType`]. If the pool is configured to use
     * [`adapter::StakeStrategyType::Delegate`], the funds remain in the account of
     * the `origin`, while the pool gains the right to use these funds for staking.
     *
     * # Note
     *
     * * An account can only be a member of a single pool.
     * * An account cannot join the same pool multiple times.
     * * This call will *not* dust the member account, so the member must have at least
     * `existential deposit + amount` in their account.
     * * Only a pool with [`PoolState::Open`] can be joined
     *
     * @param {bigint} amount
     * @param {number} poolId
     **/
    join: GenericTxCall<
      (
        amount: bigint,
        poolId: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'Join';
            params: { amount: bigint; poolId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Bond `extra` more funds from `origin` into the pool to which they already belong.
     *
     * Additional funds can come from either the free balance of the account, of from the
     * accumulated rewards, see [`BondExtra`].
     *
     * Bonding extra funds implies an automatic payout of all pending rewards as well.
     * See `bond_extra_other` to bond pending rewards of `other` members.
     *
     * @param {PalletNominationPoolsBondExtra} extra
     **/
    bondExtra: GenericTxCall<
      (extra: PalletNominationPoolsBondExtra) => ChainSubmittableExtrinsic<
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'BondExtra';
            params: { extra: PalletNominationPoolsBondExtra };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * A bonded member can use this to claim their payout based on the rewards that the pool
     * has accumulated since their last claimed payout (OR since joining if this is their first
     * time claiming rewards). The payout will be transferred to the member's account.
     *
     * The member will earn rewards pro rata based on the members stake vs the sum of the
     * members in the pools stake. Rewards do not "expire".
     *
     * See `claim_payout_other` to claim rewards on behalf of some `other` pool member.
     *
     **/
    claimPayout: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'ClaimPayout';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Unbond up to `unbonding_points` of the `member_account`'s funds from the pool. It
     * implicitly collects the rewards one last time, since not doing so would mean some
     * rewards would be forfeited.
     *
     * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
     * account).
     *
     * # Conditions for a permissionless dispatch.
     *
     * * The pool is blocked and the caller is either the root or bouncer. This is refereed to
     * as a kick.
     * * The pool is destroying and the member is not the depositor.
     * * The pool is destroying, the member is the depositor and no other members are in the
     * pool.
     *
     * ## Conditions for permissioned dispatch (i.e. the caller is also the
     * `member_account`):
     *
     * * The caller is not the depositor.
     * * The caller is the depositor, the pool is destroying and no other members are in the
     * pool.
     *
     * # Note
     *
     * If there are too many unlocking chunks to unbond with the pool account,
     * [`Call::pool_withdraw_unbonded`] can be called to try and minimize unlocking chunks.
     * The [`StakingInterface::unbond`] will implicitly call [`Call::pool_withdraw_unbonded`]
     * to try to free chunks if necessary (ie. if unbound was called and no unlocking chunks
     * are available). However, it may not be possible to release the current unlocking chunks,
     * in which case, the result of this call will likely be the `NoMoreChunks` error from the
     * staking system.
     *
     * @param {MultiAddressLike} memberAccount
     * @param {bigint} unbondingPoints
     **/
    unbond: GenericTxCall<
      (
        memberAccount: MultiAddressLike,
        unbondingPoints: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'Unbond';
            params: { memberAccount: MultiAddressLike; unbondingPoints: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Call `withdraw_unbonded` for the pools account. This call can be made by any account.
     *
     * This is useful if there are too many unlocking chunks to call `unbond`, and some
     * can be cleared by withdrawing. In the case there are too many unlocking chunks, the user
     * would probably see an error like `NoMoreChunks` emitted from the staking system when
     * they attempt to unbond.
     *
     * @param {number} poolId
     * @param {number} numSlashingSpans
     **/
    poolWithdrawUnbonded: GenericTxCall<
      (
        poolId: number,
        numSlashingSpans: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'PoolWithdrawUnbonded';
            params: { poolId: number; numSlashingSpans: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Withdraw unbonded funds from `member_account`. If no bonded funds can be unbonded, an
     * error is returned.
     *
     * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
     * account).
     *
     * # Conditions for a permissionless dispatch
     *
     * * The pool is in destroy mode and the target is not the depositor.
     * * The target is the depositor and they are the only member in the sub pools.
     * * The pool is blocked and the caller is either the root or bouncer.
     *
     * # Conditions for permissioned dispatch
     *
     * * The caller is the target and they are not the depositor.
     *
     * # Note
     *
     * - If the target is the depositor, the pool will be destroyed.
     * - If the pool has any pending slash, we also try to slash the member before letting them
     * withdraw. This calculation adds some weight overhead and is only defensive. In reality,
     * pool slashes must have been already applied via permissionless [`Call::apply_slash`].
     *
     * @param {MultiAddressLike} memberAccount
     * @param {number} numSlashingSpans
     **/
    withdrawUnbonded: GenericTxCall<
      (
        memberAccount: MultiAddressLike,
        numSlashingSpans: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'WithdrawUnbonded';
            params: { memberAccount: MultiAddressLike; numSlashingSpans: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Create a new delegation pool.
     *
     * # Arguments
     *
     * * `amount` - The amount of funds to delegate to the pool. This also acts of a sort of
     * deposit since the pools creator cannot fully unbond funds until the pool is being
     * destroyed.
     * * `index` - A disambiguation index for creating the account. Likely only useful when
     * creating multiple pools in the same extrinsic.
     * * `root` - The account to set as [`PoolRoles::root`].
     * * `nominator` - The account to set as the [`PoolRoles::nominator`].
     * * `bouncer` - The account to set as the [`PoolRoles::bouncer`].
     *
     * # Note
     *
     * In addition to `amount`, the caller will transfer the existential deposit; so the caller
     * needs at have at least `amount + existential_deposit` transferable.
     *
     * @param {bigint} amount
     * @param {MultiAddressLike} root
     * @param {MultiAddressLike} nominator
     * @param {MultiAddressLike} bouncer
     **/
    create: GenericTxCall<
      (
        amount: bigint,
        root: MultiAddressLike,
        nominator: MultiAddressLike,
        bouncer: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'Create';
            params: { amount: bigint; root: MultiAddressLike; nominator: MultiAddressLike; bouncer: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Create a new delegation pool with a previously used pool id
     *
     * # Arguments
     *
     * same as `create` with the inclusion of
     * * `pool_id` - `A valid PoolId.
     *
     * @param {bigint} amount
     * @param {MultiAddressLike} root
     * @param {MultiAddressLike} nominator
     * @param {MultiAddressLike} bouncer
     * @param {number} poolId
     **/
    createWithPoolId: GenericTxCall<
      (
        amount: bigint,
        root: MultiAddressLike,
        nominator: MultiAddressLike,
        bouncer: MultiAddressLike,
        poolId: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'CreateWithPoolId';
            params: {
              amount: bigint;
              root: MultiAddressLike;
              nominator: MultiAddressLike;
              bouncer: MultiAddressLike;
              poolId: number;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Nominate on behalf of the pool.
     *
     * The dispatch origin of this call must be signed by the pool nominator or the pool
     * root role.
     *
     * This directly forwards the call to an implementation of `StakingInterface` (e.g.,
     * `pallet-staking`) through [`Config::StakeAdapter`], on behalf of the bonded pool.
     *
     * # Note
     *
     * In addition to a `root` or `nominator` role of `origin`, the pool's depositor needs to
     * have at least `depositor_min_bond` in the pool to start nominating.
     *
     * @param {number} poolId
     * @param {Array<AccountId32Like>} validators
     **/
    nominate: GenericTxCall<
      (
        poolId: number,
        validators: Array<AccountId32Like>,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'Nominate';
            params: { poolId: number; validators: Array<AccountId32Like> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set a new state for the pool.
     *
     * If a pool is already in the `Destroying` state, then under no condition can its state
     * change again.
     *
     * The dispatch origin of this call must be either:
     *
     * 1. signed by the bouncer, or the root role of the pool,
     * 2. if the pool conditions to be open are NOT met (as described by `ok_to_be_open`), and
     * then the state of the pool can be permissionlessly changed to `Destroying`.
     *
     * @param {number} poolId
     * @param {PalletNominationPoolsPoolState} state
     **/
    setState: GenericTxCall<
      (
        poolId: number,
        state: PalletNominationPoolsPoolState,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'SetState';
            params: { poolId: number; state: PalletNominationPoolsPoolState };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set a new metadata for the pool.
     *
     * The dispatch origin of this call must be signed by the bouncer, or the root role of the
     * pool.
     *
     * @param {number} poolId
     * @param {BytesLike} metadata
     **/
    setMetadata: GenericTxCall<
      (
        poolId: number,
        metadata: BytesLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'SetMetadata';
            params: { poolId: number; metadata: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Update configurations for the nomination pools. The origin for this call must be
     * [`Config::AdminOrigin`].
     *
     * # Arguments
     *
     * * `min_join_bond` - Set [`MinJoinBond`].
     * * `min_create_bond` - Set [`MinCreateBond`].
     * * `max_pools` - Set [`MaxPools`].
     * * `max_members` - Set [`MaxPoolMembers`].
     * * `max_members_per_pool` - Set [`MaxPoolMembersPerPool`].
     * * `global_max_commission` - Set [`GlobalMaxCommission`].
     *
     * @param {PalletNominationPoolsConfigOp} minJoinBond
     * @param {PalletNominationPoolsConfigOp} minCreateBond
     * @param {PalletNominationPoolsConfigOpU32} maxPools
     * @param {PalletNominationPoolsConfigOpU32} maxMembers
     * @param {PalletNominationPoolsConfigOpU32} maxMembersPerPool
     * @param {PalletNominationPoolsConfigOpPerbill} globalMaxCommission
     **/
    setConfigs: GenericTxCall<
      (
        minJoinBond: PalletNominationPoolsConfigOp,
        minCreateBond: PalletNominationPoolsConfigOp,
        maxPools: PalletNominationPoolsConfigOpU32,
        maxMembers: PalletNominationPoolsConfigOpU32,
        maxMembersPerPool: PalletNominationPoolsConfigOpU32,
        globalMaxCommission: PalletNominationPoolsConfigOpPerbill,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'SetConfigs';
            params: {
              minJoinBond: PalletNominationPoolsConfigOp;
              minCreateBond: PalletNominationPoolsConfigOp;
              maxPools: PalletNominationPoolsConfigOpU32;
              maxMembers: PalletNominationPoolsConfigOpU32;
              maxMembersPerPool: PalletNominationPoolsConfigOpU32;
              globalMaxCommission: PalletNominationPoolsConfigOpPerbill;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Update the roles of the pool.
     *
     * The root is the only entity that can change any of the roles, including itself,
     * excluding the depositor, who can never change.
     *
     * It emits an event, notifying UIs of the role change. This event is quite relevant to
     * most pool members and they should be informed of changes to pool roles.
     *
     * @param {number} poolId
     * @param {PalletNominationPoolsConfigOp004} newRoot
     * @param {PalletNominationPoolsConfigOp004} newNominator
     * @param {PalletNominationPoolsConfigOp004} newBouncer
     **/
    updateRoles: GenericTxCall<
      (
        poolId: number,
        newRoot: PalletNominationPoolsConfigOp004,
        newNominator: PalletNominationPoolsConfigOp004,
        newBouncer: PalletNominationPoolsConfigOp004,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'UpdateRoles';
            params: {
              poolId: number;
              newRoot: PalletNominationPoolsConfigOp004;
              newNominator: PalletNominationPoolsConfigOp004;
              newBouncer: PalletNominationPoolsConfigOp004;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Chill on behalf of the pool.
     *
     * The dispatch origin of this call can be signed by the pool nominator or the pool
     * root role, same as [`Pallet::nominate`].
     *
     * This directly forwards the call to an implementation of `StakingInterface` (e.g.,
     * `pallet-staking`) through [`Config::StakeAdapter`], on behalf of the bonded pool.
     *
     * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
     * account).
     *
     * # Conditions for a permissionless dispatch:
     * * When pool depositor has less than `MinNominatorBond` staked, otherwise pool members
     * are unable to unbond.
     *
     * # Conditions for permissioned dispatch:
     * * The caller is the pool's nominator or root.
     *
     * @param {number} poolId
     **/
    chill: GenericTxCall<
      (poolId: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'Chill';
            params: { poolId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * `origin` bonds funds from `extra` for some pool member `member` into their respective
     * pools.
     *
     * `origin` can bond extra funds from free balance or pending rewards when `origin ==
     * other`.
     *
     * In the case of `origin != other`, `origin` can only bond extra pending rewards of
     * `other` members assuming set_claim_permission for the given member is
     * `PermissionlessCompound` or `PermissionlessAll`.
     *
     * @param {MultiAddressLike} member
     * @param {PalletNominationPoolsBondExtra} extra
     **/
    bondExtraOther: GenericTxCall<
      (
        member: MultiAddressLike,
        extra: PalletNominationPoolsBondExtra,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'BondExtraOther';
            params: { member: MultiAddressLike; extra: PalletNominationPoolsBondExtra };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Allows a pool member to set a claim permission to allow or disallow permissionless
     * bonding and withdrawing.
     *
     * # Arguments
     *
     * * `origin` - Member of a pool.
     * * `permission` - The permission to be applied.
     *
     * @param {PalletNominationPoolsClaimPermission} permission
     **/
    setClaimPermission: GenericTxCall<
      (permission: PalletNominationPoolsClaimPermission) => ChainSubmittableExtrinsic<
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'SetClaimPermission';
            params: { permission: PalletNominationPoolsClaimPermission };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * `origin` can claim payouts on some pool member `other`'s behalf.
     *
     * Pool member `other` must have a `PermissionlessWithdraw` or `PermissionlessAll` claim
     * permission for this call to be successful.
     *
     * @param {AccountId32Like} other
     **/
    claimPayoutOther: GenericTxCall<
      (other: AccountId32Like) => ChainSubmittableExtrinsic<
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'ClaimPayoutOther';
            params: { other: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the commission of a pool.
     * Both a commission percentage and a commission payee must be provided in the `current`
     * tuple. Where a `current` of `None` is provided, any current commission will be removed.
     *
     * - If a `None` is supplied to `new_commission`, existing commission will be removed.
     *
     * @param {number} poolId
     * @param {[Perbill, AccountId32Like] | undefined} newCommission
     **/
    setCommission: GenericTxCall<
      (
        poolId: number,
        newCommission: [Perbill, AccountId32Like] | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'SetCommission';
            params: { poolId: number; newCommission: [Perbill, AccountId32Like] | undefined };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the maximum commission of a pool.
     *
     * - Initial max can be set to any `Perbill`, and only smaller values thereafter.
     * - Current commission will be lowered in the event it is higher than a new max
     * commission.
     *
     * @param {number} poolId
     * @param {Perbill} maxCommission
     **/
    setCommissionMax: GenericTxCall<
      (
        poolId: number,
        maxCommission: Perbill,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'SetCommissionMax';
            params: { poolId: number; maxCommission: Perbill };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the commission change rate for a pool.
     *
     * Initial change rate is not bounded, whereas subsequent updates can only be more
     * restrictive than the current.
     *
     * @param {number} poolId
     * @param {PalletNominationPoolsCommissionChangeRate} changeRate
     **/
    setCommissionChangeRate: GenericTxCall<
      (
        poolId: number,
        changeRate: PalletNominationPoolsCommissionChangeRate,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'SetCommissionChangeRate';
            params: { poolId: number; changeRate: PalletNominationPoolsCommissionChangeRate };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Claim pending commission.
     *
     * The `root` role of the pool is _always_ allowed to claim the pool's commission.
     *
     * If the pool has set `CommissionClaimPermission::Permissionless`, then any account can
     * trigger the process of claiming the pool's commission.
     *
     * If the pool has set its `CommissionClaimPermission` to `Account(acc)`, then only
     * accounts
     * * `acc`, and
     * * the pool's root account
     *
     * may call this extrinsic on behalf of the pool.
     *
     * Pending commissions are paid out and added to the total claimed commission.
     * The total pending commission is reset to zero.
     *
     * @param {number} poolId
     **/
    claimCommission: GenericTxCall<
      (poolId: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'ClaimCommission';
            params: { poolId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Top up the deficit or withdraw the excess ED from the pool.
     *
     * When a pool is created, the pool depositor transfers ED to the reward account of the
     * pool. ED is subject to change and over time, the deposit in the reward account may be
     * insufficient to cover the ED deficit of the pool or vice-versa where there is excess
     * deposit to the pool. This call allows anyone to adjust the ED deposit of the
     * pool by either topping up the deficit or claiming the excess.
     *
     * @param {number} poolId
     **/
    adjustPoolDeposit: GenericTxCall<
      (poolId: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'AdjustPoolDeposit';
            params: { poolId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set or remove a pool's commission claim permission.
     *
     * Determines who can claim the pool's pending commission. Only the `Root` role of the pool
     * is able to configure commission claim permissions.
     *
     * @param {number} poolId
     * @param {PalletNominationPoolsCommissionClaimPermission | undefined} permission
     **/
    setCommissionClaimPermission: GenericTxCall<
      (
        poolId: number,
        permission: PalletNominationPoolsCommissionClaimPermission | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'SetCommissionClaimPermission';
            params: { poolId: number; permission: PalletNominationPoolsCommissionClaimPermission | undefined };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Apply a pending slash on a member.
     *
     * Fails unless [`crate::pallet::Config::StakeAdapter`] is of strategy type:
     * [`adapter::StakeStrategyType::Delegate`].
     *
     * The pending slash amount of the member must be equal or more than `ExistentialDeposit`.
     * This call can be dispatched permissionlessly (i.e. by any account). If the execution
     * is successful, fee is refunded and caller may be rewarded with a part of the slash
     * based on the [`crate::pallet::Config::StakeAdapter`] configuration.
     *
     * @param {MultiAddressLike} memberAccount
     **/
    applySlash: GenericTxCall<
      (memberAccount: MultiAddressLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'ApplySlash';
            params: { memberAccount: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Migrates delegated funds from the pool account to the `member_account`.
     *
     * Fails unless [`crate::pallet::Config::StakeAdapter`] is of strategy type:
     * [`adapter::StakeStrategyType::Delegate`].
     *
     * This is a permission-less call and refunds any fee if claim is successful.
     *
     * If the pool has migrated to delegation based staking, the staked tokens of pool members
     * can be moved and held in their own account. See [`adapter::DelegateStake`]
     *
     * @param {MultiAddressLike} memberAccount
     **/
    migrateDelegation: GenericTxCall<
      (memberAccount: MultiAddressLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'MigrateDelegation';
            params: { memberAccount: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Migrate pool from [`adapter::StakeStrategyType::Transfer`] to
     * [`adapter::StakeStrategyType::Delegate`].
     *
     * Fails unless [`crate::pallet::Config::StakeAdapter`] is of strategy type:
     * [`adapter::StakeStrategyType::Delegate`].
     *
     * This call can be dispatched permissionlessly, and refunds any fee if successful.
     *
     * If the pool has already migrated to delegation based staking, this call will fail.
     *
     * @param {number} poolId
     **/
    migratePoolToDelegateStake: GenericTxCall<
      (poolId: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'MigratePoolToDelegateStake';
            params: { poolId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `VoterList`'s transaction calls
   **/
  voterList: {
    /**
     * Declare that some `dislocated` account has, through rewards or penalties, sufficiently
     * changed its score that it should properly fall into a different bag than its current
     * one.
     *
     * Anyone can call this function about any potentially dislocated account.
     *
     * Will always update the stored score of `dislocated` to the correct score, based on
     * `ScoreProvider`.
     *
     * If `dislocated` does not exists, it returns an error.
     *
     * @param {MultiAddressLike} dislocated
     **/
    rebag: GenericTxCall<
      (dislocated: MultiAddressLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'VoterList';
          palletCall: {
            name: 'Rebag';
            params: { dislocated: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Move the caller's Id directly in front of `lighter`.
     *
     * The dispatch origin for this call must be _Signed_ and can only be called by the Id of
     * the account going in front of `lighter`. Fee is payed by the origin under all
     * circumstances.
     *
     * Only works if:
     *
     * - both nodes are within the same bag,
     * - and `origin` has a greater `Score` than `lighter`.
     *
     * @param {MultiAddressLike} lighter
     **/
    putInFrontOf: GenericTxCall<
      (lighter: MultiAddressLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'VoterList';
          palletCall: {
            name: 'PutInFrontOf';
            params: { lighter: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Same as [`Pallet::put_in_front_of`], but it can be called by anyone.
     *
     * Fee is paid by the origin under all circumstances.
     *
     * @param {MultiAddressLike} heavier
     * @param {MultiAddressLike} lighter
     **/
    putInFrontOfOther: GenericTxCall<
      (
        heavier: MultiAddressLike,
        lighter: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'VoterList';
          palletCall: {
            name: 'PutInFrontOfOther';
            params: { heavier: MultiAddressLike; lighter: MultiAddressLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `StakingRcClient`'s transaction calls
   **/
  stakingRcClient: {
    /**
     * Called to indicate the start of a new session on the relay chain.
     *
     * @param {PalletStakingAsyncRcClientSessionReport} report
     **/
    relaySessionReport: GenericTxCall<
      (report: PalletStakingAsyncRcClientSessionReport) => ChainSubmittableExtrinsic<
        {
          pallet: 'StakingRcClient';
          palletCall: {
            name: 'RelaySessionReport';
            params: { report: PalletStakingAsyncRcClientSessionReport };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {Array<[number, PalletStakingAsyncRcClientOffence]>} offences
     **/
    relayNewOffencePaged: GenericTxCall<
      (offences: Array<[number, PalletStakingAsyncRcClientOffence]>) => ChainSubmittableExtrinsic<
        {
          pallet: 'StakingRcClient';
          palletCall: {
            name: 'RelayNewOffencePaged';
            params: { offences: Array<[number, PalletStakingAsyncRcClientOffence]> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `MultiBlockElection`'s transaction calls
   **/
  multiBlockElection: {
    /**
     * Manage this pallet.
     *
     * The origin of this call must be [`Config::AdminOrigin`].
     *
     * See [`AdminOperation`] for various operations that are possible.
     *
     * @param {PalletElectionProviderMultiBlockAdminOperation} op
     **/
    manage: GenericTxCall<
      (op: PalletElectionProviderMultiBlockAdminOperation) => ChainSubmittableExtrinsic<
        {
          pallet: 'MultiBlockElection';
          palletCall: {
            name: 'Manage';
            params: { op: PalletElectionProviderMultiBlockAdminOperation };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `MultiBlockElectionVerifier`'s transaction calls
   **/
  multiBlockElectionVerifier: {
    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `MultiBlockElectionUnsigned`'s transaction calls
   **/
  multiBlockElectionUnsigned: {
    /**
     * Submit an unsigned solution.
     *
     * This works very much like an inherent, as only the validators are permitted to submit
     * anything. By default validators will compute this call in their `offchain_worker` hook
     * and try and submit it back.
     *
     * This is different from signed page submission mainly in that the solution page is
     * verified on the fly.
     *
     * The `paged_solution` may contain at most [`Config::MinerPages`] pages. They are
     * interpreted as msp -> lsp, as per [`crate::Pallet::msp_range_for`].
     *
     * For example, if `Pages = 4`, and `MinerPages = 2`, our full snapshot range would be [0,
     * 1, 2, 3], with 3 being msp. But, in this case, then the `paged_raw_solution.pages` is
     * expected to correspond to `[snapshot(2), snapshot(3)]`.
     *
     * @param {PalletElectionProviderMultiBlockPagedRawSolution} pagedSolution
     **/
    submitUnsigned: GenericTxCall<
      (pagedSolution: PalletElectionProviderMultiBlockPagedRawSolution) => ChainSubmittableExtrinsic<
        {
          pallet: 'MultiBlockElectionUnsigned';
          palletCall: {
            name: 'SubmitUnsigned';
            params: { pagedSolution: PalletElectionProviderMultiBlockPagedRawSolution };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `MultiBlockElectionSigned`'s transaction calls
   **/
  multiBlockElectionSigned: {
    /**
     * Register oneself for an upcoming signed election.
     *
     * @param {SpNposElectionsElectionScore} claimedScore
     **/
    register: GenericTxCall<
      (claimedScore: SpNposElectionsElectionScore) => ChainSubmittableExtrinsic<
        {
          pallet: 'MultiBlockElectionSigned';
          palletCall: {
            name: 'Register';
            params: { claimedScore: SpNposElectionsElectionScore };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Submit a single page of a solution.
     *
     * Must always come after [`Pallet::register`].
     *
     * `maybe_solution` can be set to `None` to erase the page.
     *
     * Collects deposits from the signed origin based on [`Config::DepositBase`] and
     * [`Config::DepositPerPage`].
     *
     * @param {number} page
     * @param {AssetHubPolkadotRuntimeStakingNposCompactSolution16 | undefined} maybeSolution
     **/
    submitPage: GenericTxCall<
      (
        page: number,
        maybeSolution: AssetHubPolkadotRuntimeStakingNposCompactSolution16 | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'MultiBlockElectionSigned';
          palletCall: {
            name: 'SubmitPage';
            params: { page: number; maybeSolution: AssetHubPolkadotRuntimeStakingNposCompactSolution16 | undefined };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Retract a submission.
     *
     * A portion of the deposit may be returned, based on the [`Config::BailoutGraceRatio`].
     *
     * This will fully remove the solution from storage.
     *
     **/
    bail: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'MultiBlockElectionSigned';
          palletCall: {
            name: 'Bail';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Clear the data of a submitter form an old round.
     *
     * The dispatch origin of this call must be signed, and the original submitter.
     *
     * This can only be called for submissions that end up being discarded, as in they are not
     * processed and they end up lingering in the queue.
     *
     * @param {number} round
     * @param {number} witnessPages
     **/
    clearOldRoundData: GenericTxCall<
      (
        round: number,
        witnessPages: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'MultiBlockElectionSigned';
          palletCall: {
            name: 'ClearOldRoundData';
            params: { round: number; witnessPages: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the invulnerable list.
     *
     * Dispatch origin must the the same as [`crate::Config::AdminOrigin`].
     *
     * @param {Array<AccountId32Like>} inv
     **/
    setInvulnerables: GenericTxCall<
      (inv: Array<AccountId32Like>) => ChainSubmittableExtrinsic<
        {
          pallet: 'MultiBlockElectionSigned';
          palletCall: {
            name: 'SetInvulnerables';
            params: { inv: Array<AccountId32Like> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Staking`'s transaction calls
   **/
  staking: {
    /**
     * Take the origin account as a stash and lock up `value` of its balance. `controller` will
     * be the account that controls it.
     *
     * `value` must be more than the `minimum_balance` specified by `T::Currency`.
     *
     * The dispatch origin for this call must be _Signed_ by the stash account.
     *
     * Emits `Bonded`.
     *
     * NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned
     * unless the `origin` falls below _existential deposit_ (or equal to 0) and gets removed
     * as dust.
     *
     * @param {bigint} value
     * @param {PalletStakingAsyncRewardDestination} payee
     **/
    bond: GenericTxCall<
      (
        value: bigint,
        payee: PalletStakingAsyncRewardDestination,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'Bond';
            params: { value: bigint; payee: PalletStakingAsyncRewardDestination };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Add some extra amount that have appeared in the stash `free_balance` into the balance up
     * for staking.
     *
     * The dispatch origin for this call must be _Signed_ by the stash, not the controller.
     *
     * Use this if there are additional funds in your stash account that you wish to bond.
     * Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose
     * any limitation on the amount that can be added.
     *
     * Emits `Bonded`.
     *
     * @param {bigint} maxAdditional
     **/
    bondExtra: GenericTxCall<
      (maxAdditional: bigint) => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'BondExtra';
            params: { maxAdditional: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Schedule a portion of the stash to be unlocked ready for transfer out after the bond
     * period ends. If this leaves an amount actively bonded less than
     * [`asset::existential_deposit`], then it is increased to the full amount.
     *
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     *
     * Once the unlock period is done, you can call `withdraw_unbonded` to actually move
     * the funds out of management ready for transfer.
     *
     * No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)
     * can co-exists at the same time. If there are no unlocking chunks slots available
     * [`Call::withdraw_unbonded`] is called to remove some of the chunks (if possible).
     *
     * If a user encounters the `InsufficientBond` error when calling this extrinsic,
     * they should call `chill` first in order to free up their bonded funds.
     *
     * Emits `Unbonded`.
     *
     * See also [`Call::withdraw_unbonded`].
     *
     * @param {bigint} value
     **/
    unbond: GenericTxCall<
      (value: bigint) => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'Unbond';
            params: { value: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove any stake that has been fully unbonded and is ready for withdrawal.
     *
     * Stake is considered fully unbonded once [`Config::BondingDuration`] has elapsed since
     * the unbonding was initiated. In rare casessuch as when offences for the unbonded era
     * have been reported but not yet processedwithdrawal is restricted to eras for which
     * all offences have been processed.
     *
     * The unlocked stake will be returned as free balance in the stash account.
     *
     * The dispatch origin for this call must be _Signed_ by the controller.
     *
     * Emits `Withdrawn`.
     *
     * See also [`Call::unbond`].
     *
     * ## Parameters
     *
     * - `num_slashing_spans`: **Deprecated**. Retained only for backward compatibility; this
     * parameter has no effect.
     *
     * @param {number} numSlashingSpans
     **/
    withdrawUnbonded: GenericTxCall<
      (numSlashingSpans: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'WithdrawUnbonded';
            params: { numSlashingSpans: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Declare the desire to validate for the origin controller.
     *
     * Effects will be felt at the beginning of the next era.
     *
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     *
     * @param {PalletStakingAsyncValidatorPrefs} prefs
     **/
    validate: GenericTxCall<
      (prefs: PalletStakingAsyncValidatorPrefs) => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'Validate';
            params: { prefs: PalletStakingAsyncValidatorPrefs };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Declare the desire to nominate `targets` for the origin controller.
     *
     * Effects will be felt at the beginning of the next era.
     *
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     *
     * @param {Array<MultiAddressLike>} targets
     **/
    nominate: GenericTxCall<
      (targets: Array<MultiAddressLike>) => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'Nominate';
            params: { targets: Array<MultiAddressLike> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Declare no desire to either validate or nominate.
     *
     * Effects will be felt at the beginning of the next era.
     *
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     *
     * ## Complexity
     * - Independent of the arguments. Insignificant complexity.
     * - Contains one read.
     * - Writes are limited to the `origin` account key.
     *
     **/
    chill: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'Chill';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * (Re-)set the payment target for a controller.
     *
     * Effects will be felt instantly (as soon as this function is completed successfully).
     *
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     *
     * @param {PalletStakingAsyncRewardDestination} payee
     **/
    setPayee: GenericTxCall<
      (payee: PalletStakingAsyncRewardDestination) => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'SetPayee';
            params: { payee: PalletStakingAsyncRewardDestination };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * (Re-)sets the controller of a stash to the stash itself. This function previously
     * accepted a `controller` argument to set the controller to an account other than the
     * stash itself. This functionality has now been removed, now only setting the controller
     * to the stash, if it is not already.
     *
     * Effects will be felt instantly (as soon as this function is completed successfully).
     *
     * The dispatch origin for this call must be _Signed_ by the stash, not the controller.
     *
     **/
    setController: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'SetController';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Sets the ideal number of validators.
     *
     * The dispatch origin must be Root.
     *
     * @param {number} new_
     **/
    setValidatorCount: GenericTxCall<
      (new_: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'SetValidatorCount';
            params: { new: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Increments the ideal number of validators up to maximum of
     * `T::MaxValidatorSet`.
     *
     * The dispatch origin must be Root.
     *
     * @param {number} additional
     **/
    increaseValidatorCount: GenericTxCall<
      (additional: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'IncreaseValidatorCount';
            params: { additional: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Scale up the ideal number of validators by a factor up to maximum of
     * `T::MaxValidatorSet`.
     *
     * The dispatch origin must be Root.
     *
     * @param {Percent} factor
     **/
    scaleValidatorCount: GenericTxCall<
      (factor: Percent) => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'ScaleValidatorCount';
            params: { factor: Percent };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Force there to be no new eras indefinitely.
     *
     * The dispatch origin must be Root.
     *
     * # Warning
     *
     * The election process starts multiple blocks before the end of the era.
     * Thus the election process may be ongoing when this is called. In this case the
     * election will continue until the next era is triggered.
     *
     **/
    forceNoEras: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'ForceNoEras';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Force there to be a new era at the end of the next session. After this, it will be
     * reset to normal (non-forced) behaviour.
     *
     * The dispatch origin must be Root.
     *
     * # Warning
     *
     * The election process starts multiple blocks before the end of the era.
     * If this is called just before a new era is triggered, the election process may not
     * have enough blocks to get a result.
     *
     **/
    forceNewEra: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'ForceNewEra';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the validators who cannot be slashed (if any).
     *
     * The dispatch origin must be Root.
     *
     * @param {Array<AccountId32Like>} invulnerables
     **/
    setInvulnerables: GenericTxCall<
      (invulnerables: Array<AccountId32Like>) => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'SetInvulnerables';
            params: { invulnerables: Array<AccountId32Like> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Force a current staker to become completely unstaked, immediately.
     *
     * The dispatch origin must be Root.
     * ## Parameters
     *
     * - `stash`: The stash account to be unstaked.
     * - `num_slashing_spans`: **Deprecated**. This parameter is retained for backward
     * compatibility. It no longer has any effect.
     *
     * @param {AccountId32Like} stash
     * @param {number} numSlashingSpans
     **/
    forceUnstake: GenericTxCall<
      (
        stash: AccountId32Like,
        numSlashingSpans: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'ForceUnstake';
            params: { stash: AccountId32Like; numSlashingSpans: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Force there to be a new era at the end of sessions indefinitely.
     *
     * The dispatch origin must be Root.
     *
     * # Warning
     *
     * The election process starts multiple blocks before the end of the era.
     * If this is called just before a new era is triggered, the election process may not
     * have enough blocks to get a result.
     *
     **/
    forceNewEraAlways: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'ForceNewEraAlways';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Cancels scheduled slashes for a given era before they are applied.
     *
     * This function allows `T::AdminOrigin` to cancel pending slashes for specified validators
     * in a given era. The cancelled slashes are stored and will be checked when applying
     * slashes.
     *
     * ## Parameters
     * - `era`: The staking era for which slashes should be cancelled. This is the era where
     * the slash would be applied, not the era in which the offence was committed.
     * - `validator_slashes`: A list of validator stash accounts and their slash fractions to
     * be cancelled.
     *
     * @param {number} era
     * @param {Array<[AccountId32Like, Perbill]>} validatorSlashes
     **/
    cancelDeferredSlash: GenericTxCall<
      (
        era: number,
        validatorSlashes: Array<[AccountId32Like, Perbill]>,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'CancelDeferredSlash';
            params: { era: number; validatorSlashes: Array<[AccountId32Like, Perbill]> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Pay out next page of the stakers behind a validator for the given era.
     *
     * - `validator_stash` is the stash account of the validator.
     * - `era` may be any era between `[current_era - history_depth; current_era]`.
     *
     * The origin of this call must be _Signed_. Any account can call this function, even if
     * it is not one of the stakers.
     *
     * The reward payout could be paged in case there are too many nominators backing the
     * `validator_stash`. This call will payout unpaid pages in an ascending order. To claim a
     * specific page, use `payout_stakers_by_page`.`
     *
     * If all pages are claimed, it returns an error `InvalidPage`.
     *
     * @param {AccountId32Like} validatorStash
     * @param {number} era
     **/
    payoutStakers: GenericTxCall<
      (
        validatorStash: AccountId32Like,
        era: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'PayoutStakers';
            params: { validatorStash: AccountId32Like; era: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Rebond a portion of the stash scheduled to be unlocked.
     *
     * The dispatch origin must be signed by the controller.
     *
     * @param {bigint} value
     **/
    rebond: GenericTxCall<
      (value: bigint) => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'Rebond';
            params: { value: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove all data structures concerning a staker/stash once it is at a state where it can
     * be considered `dust` in the staking system. The requirements are:
     *
     * 1. the `total_balance` of the stash is below `min_chilled_bond` or is zero.
     * 2. or, the `ledger.total` of the stash is below `min_chilled_bond` or is zero.
     *
     * The former can happen in cases like a slash; the latter when a fully unbonded account
     * is still receiving staking rewards in `RewardDestination::Staked`.
     *
     * It can be called by anyone, as long as `stash` meets the above requirements.
     *
     * Refunds the transaction fees upon successful execution.
     *
     * ## Parameters
     *
     * - `stash`: The stash account to be reaped.
     * - `num_slashing_spans`: **Deprecated**. This parameter is retained for backward
     * compatibility. It no longer has any effect.
     *
     * @param {AccountId32Like} stash
     * @param {number} numSlashingSpans
     **/
    reapStash: GenericTxCall<
      (
        stash: AccountId32Like,
        numSlashingSpans: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'ReapStash';
            params: { stash: AccountId32Like; numSlashingSpans: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove the given nominations from the calling validator.
     *
     * Effects will be felt at the beginning of the next era.
     *
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     *
     * - `who`: A list of nominator stash accounts who are nominating this validator which
     * should no longer be nominating this validator.
     *
     * Note: Making this call only makes sense if you first set the validator preferences to
     * block any further nominations.
     *
     * @param {Array<MultiAddressLike>} who
     **/
    kick: GenericTxCall<
      (who: Array<MultiAddressLike>) => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'Kick';
            params: { who: Array<MultiAddressLike> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Update the various staking configurations .
     *
     * * `min_nominator_bond`: The minimum active bond needed to be a nominator.
     * * `min_validator_bond`: The minimum active bond needed to be a validator.
     * * `max_nominator_count`: The max number of users who can be a nominator at once. When
     * set to `None`, no limit is enforced.
     * * `max_validator_count`: The max number of users who can be a validator at once. When
     * set to `None`, no limit is enforced.
     * * `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which
     * should be filled in order for the `chill_other` transaction to work.
     * * `min_commission`: The minimum amount of commission that each validators must maintain.
     * This is checked only upon calling `validate`. Existing validators are not affected.
     *
     * RuntimeOrigin must be Root to call this function.
     *
     * NOTE: Existing nominators and validators will not be affected by this update.
     * to kick people under the new limits, `chill_other` should be called.
     *
     * @param {PalletStakingAsyncPalletConfigOp} minNominatorBond
     * @param {PalletStakingAsyncPalletConfigOp} minValidatorBond
     * @param {PalletStakingAsyncPalletConfigOpU32} maxNominatorCount
     * @param {PalletStakingAsyncPalletConfigOpU32} maxValidatorCount
     * @param {PalletStakingAsyncPalletConfigOpPercent} chillThreshold
     * @param {PalletStakingAsyncPalletConfigOpPerbill} minCommission
     * @param {PalletStakingAsyncPalletConfigOpPercent} maxStakedRewards
     **/
    setStakingConfigs: GenericTxCall<
      (
        minNominatorBond: PalletStakingAsyncPalletConfigOp,
        minValidatorBond: PalletStakingAsyncPalletConfigOp,
        maxNominatorCount: PalletStakingAsyncPalletConfigOpU32,
        maxValidatorCount: PalletStakingAsyncPalletConfigOpU32,
        chillThreshold: PalletStakingAsyncPalletConfigOpPercent,
        minCommission: PalletStakingAsyncPalletConfigOpPerbill,
        maxStakedRewards: PalletStakingAsyncPalletConfigOpPercent,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'SetStakingConfigs';
            params: {
              minNominatorBond: PalletStakingAsyncPalletConfigOp;
              minValidatorBond: PalletStakingAsyncPalletConfigOp;
              maxNominatorCount: PalletStakingAsyncPalletConfigOpU32;
              maxValidatorCount: PalletStakingAsyncPalletConfigOpU32;
              chillThreshold: PalletStakingAsyncPalletConfigOpPercent;
              minCommission: PalletStakingAsyncPalletConfigOpPerbill;
              maxStakedRewards: PalletStakingAsyncPalletConfigOpPercent;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Declare a `controller` to stop participating as either a validator or nominator.
     *
     * Effects will be felt at the beginning of the next era.
     *
     * The dispatch origin for this call must be _Signed_, but can be called by anyone.
     *
     * If the caller is the same as the controller being targeted, then no further checks are
     * enforced, and this function behaves just like `chill`.
     *
     * If the caller is different than the controller being targeted, the following conditions
     * must be met:
     *
     * * `controller` must belong to a nominator who has become non-decodable,
     *
     * Or:
     *
     * * A `ChillThreshold` must be set and checked which defines how close to the max
     * nominators or validators we must reach before users can start chilling one-another.
     * * A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine
     * how close we are to the threshold.
     * * A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines
     * if this is a person that should be chilled because they have not met the threshold
     * bond required.
     *
     * This can be helpful if bond requirements are updated, and we need to remove old users
     * who do not satisfy these requirements.
     *
     * @param {AccountId32Like} stash
     **/
    chillOther: GenericTxCall<
      (stash: AccountId32Like) => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'ChillOther';
            params: { stash: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Force a validator to have at least the minimum commission. This will not affect a
     * validator who already has a commission greater than or equal to the minimum. Any account
     * can call this.
     *
     * @param {AccountId32Like} validatorStash
     **/
    forceApplyMinCommission: GenericTxCall<
      (validatorStash: AccountId32Like) => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'ForceApplyMinCommission';
            params: { validatorStash: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Sets the minimum amount of commission that each validators must maintain.
     *
     * This call has lower privilege requirements than `set_staking_config` and can be called
     * by the `T::AdminOrigin`. Root can always call this.
     *
     * @param {Perbill} new_
     **/
    setMinCommission: GenericTxCall<
      (new_: Perbill) => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'SetMinCommission';
            params: { new: Perbill };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Pay out a page of the stakers behind a validator for the given era and page.
     *
     * - `validator_stash` is the stash account of the validator.
     * - `era` may be any era between `[current_era - history_depth; current_era]`.
     * - `page` is the page index of nominators to pay out with value between 0 and
     * `num_nominators / T::MaxExposurePageSize`.
     *
     * The origin of this call must be _Signed_. Any account can call this function, even if
     * it is not one of the stakers.
     *
     * If a validator has more than [`Config::MaxExposurePageSize`] nominators backing
     * them, then the list of nominators is paged, with each page being capped at
     * [`Config::MaxExposurePageSize`.] If a validator has more than one page of nominators,
     * the call needs to be made for each page separately in order for all the nominators
     * backing a validator to receive the reward. The nominators are not sorted across pages
     * and so it should not be assumed the highest staker would be on the topmost page and vice
     * versa. If rewards are not claimed in [`Config::HistoryDepth`] eras, they are lost.
     *
     * @param {AccountId32Like} validatorStash
     * @param {number} era
     * @param {number} page
     **/
    payoutStakersByPage: GenericTxCall<
      (
        validatorStash: AccountId32Like,
        era: number,
        page: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'PayoutStakersByPage';
            params: { validatorStash: AccountId32Like; era: number; page: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Migrates an account's `RewardDestination::Controller` to
     * `RewardDestination::Account(controller)`.
     *
     * Effects will be felt instantly (as soon as this function is completed successfully).
     *
     * This will waive the transaction fee if the `payee` is successfully migrated.
     *
     * @param {AccountId32Like} controller
     **/
    updatePayee: GenericTxCall<
      (controller: AccountId32Like) => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'UpdatePayee';
            params: { controller: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Updates a batch of controller accounts to their corresponding stash account if they are
     * not the same. Ignores any controller accounts that do not exist, and does not operate if
     * the stash and controller are already the same.
     *
     * Effects will be felt instantly (as soon as this function is completed successfully).
     *
     * The dispatch origin must be `T::AdminOrigin`.
     *
     * @param {Array<AccountId32Like>} controllers
     **/
    deprecateControllerBatch: GenericTxCall<
      (controllers: Array<AccountId32Like>) => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'DeprecateControllerBatch';
            params: { controllers: Array<AccountId32Like> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Restores the state of a ledger which is in an inconsistent state.
     *
     * The requirements to restore a ledger are the following:
     * * The stash is bonded; or
     * * The stash is not bonded but it has a staking lock left behind; or
     * * If the stash has an associated ledger and its state is inconsistent; or
     * * If the ledger is not corrupted *but* its staking lock is out of sync.
     *
     * The `maybe_*` input parameters will overwrite the corresponding data and metadata of the
     * ledger associated with the stash. If the input parameters are not set, the ledger will
     * be reset values from on-chain state.
     *
     * @param {AccountId32Like} stash
     * @param {AccountId32Like | undefined} maybeController
     * @param {bigint | undefined} maybeTotal
     * @param {Array<PalletStakingAsyncLedgerUnlockChunk> | undefined} maybeUnlocking
     **/
    restoreLedger: GenericTxCall<
      (
        stash: AccountId32Like,
        maybeController: AccountId32Like | undefined,
        maybeTotal: bigint | undefined,
        maybeUnlocking: Array<PalletStakingAsyncLedgerUnlockChunk> | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'RestoreLedger';
            params: {
              stash: AccountId32Like;
              maybeController: AccountId32Like | undefined;
              maybeTotal: bigint | undefined;
              maybeUnlocking: Array<PalletStakingAsyncLedgerUnlockChunk> | undefined;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Migrates permissionlessly a stash from locks to holds.
     *
     * This removes the old lock on the stake and creates a hold on it atomically. If all
     * stake cannot be held, the best effort is made to hold as much as possible. The remaining
     * stake is removed from the ledger.
     *
     * The fee is waived if the migration is successful.
     *
     * @param {AccountId32Like} stash
     **/
    migrateCurrency: GenericTxCall<
      (stash: AccountId32Like) => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'MigrateCurrency';
            params: { stash: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Manually and permissionlessly applies a deferred slash for a given era.
     *
     * Normally, slashes are automatically applied shortly after the start of the `slash_era`.
     * The automatic application of slashes is handled by the pallet's internal logic, and it
     * tries to apply one slash page per block of the era.
     * If for some reason, one era is not enough for applying all slash pages, the remaining
     * slashes need to be manually (permissionlessly) applied.
     *
     * For a given era x, if at era x+1, slashes are still unapplied, all withdrawals get
     * blocked, and these need to be manually applied by calling this function.
     * This function exists as a **fallback mechanism** for this extreme situation, but we
     * never expect to encounter this in normal scenarios.
     *
     * The parameters for this call can be queried by looking at the `UnappliedSlashes` storage
     * for eras older than the active era.
     *
     * ## Parameters
     * - `slash_era`: The staking era in which the slash was originally scheduled.
     * - `slash_key`: A unique identifier for the slash, represented as a tuple:
     * - `stash`: The stash account of the validator being slashed.
     * - `slash_fraction`: The fraction of the stake that was slashed.
     * - `page_index`: The index of the exposure page being processed.
     *
     * ## Behavior
     * - The function is **permissionless**anyone can call it.
     * - The `slash_era` **must be the current era or a past era**.
     * If it is in the future, the
     * call fails with `EraNotStarted`.
     * - The fee is waived if the slash is successfully applied.
     *
     * ## Future Improvement
     * - Implement an **off-chain worker (OCW) task** to automatically apply slashes when there
     * is unused block space, improving efficiency.
     *
     * @param {number} slashEra
     * @param {[AccountId32Like, Perbill, number]} slashKey
     **/
    applySlash: GenericTxCall<
      (
        slashEra: number,
        slashKey: [AccountId32Like, Perbill, number],
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'ApplySlash';
            params: { slashEra: number; slashKey: [AccountId32Like, Perbill, number] };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Perform one step of era pruning to prevent PoV size exhaustion from unbounded deletions.
     *
     * This extrinsic enables permissionless lazy pruning of era data by performing
     * incremental deletion of storage items. Each call processes a limited number
     * of items based on available block weight to avoid exceeding block limits.
     *
     * Returns `Pays::No` when work is performed to incentivize regular maintenance.
     * Anyone can call this to help maintain the chain's storage health.
     *
     * The era must be eligible for pruning (older than HistoryDepth + 1).
     * Check `EraPruningState` storage to see if an era needs pruning before calling.
     *
     * @param {number} era
     **/
    pruneEraStep: GenericTxCall<
      (era: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'PruneEraStep';
            params: { era: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `AhOps`'s transaction calls
   **/
  ahOps: {
    /**
     * Unreserve the deposit that was taken for creating a crowdloan.
     *
     * This can be called by any signed origin. It unreserves the lease deposit on the account
     * that won the lease auction. It can be unreserved once all leases expired. Note that it
     * will be called automatically from `withdraw_crowdloan_contribution` for the matching
     * crowdloan account.
     *
     * Solo bidder accounts that won lease auctions can use this to unreserve their amount.
     *
     * @param {number} block
     * @param {AccountId32Like | undefined} depositor
     * @param {PolkadotParachainPrimitivesPrimitivesId} paraId
     **/
    unreserveLeaseDeposit: GenericTxCall<
      (
        block: number,
        depositor: AccountId32Like | undefined,
        paraId: PolkadotParachainPrimitivesPrimitivesId,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhOps';
          palletCall: {
            name: 'UnreserveLeaseDeposit';
            params: {
              block: number;
              depositor: AccountId32Like | undefined;
              paraId: PolkadotParachainPrimitivesPrimitivesId;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Withdraw the contribution of a finished crowdloan.
     *
     * A crowdloan contribution can be withdrawn if either:
     * - The crowdloan failed to in an auction and timed out
     * - Won an auction and all leases expired
     *
     * Can be called by any signed origin.
     *
     * @param {number} block
     * @param {AccountId32Like | undefined} depositor
     * @param {PolkadotParachainPrimitivesPrimitivesId} paraId
     **/
    withdrawCrowdloanContribution: GenericTxCall<
      (
        block: number,
        depositor: AccountId32Like | undefined,
        paraId: PolkadotParachainPrimitivesPrimitivesId,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhOps';
          palletCall: {
            name: 'WithdrawCrowdloanContribution';
            params: {
              block: number;
              depositor: AccountId32Like | undefined;
              paraId: PolkadotParachainPrimitivesPrimitivesId;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Unreserve the deposit that was taken for creating a crowdloan.
     *
     * This can be called once either:
     * - The crowdloan failed to win an auction and timed out
     * - Won an auction, all leases expired and all contributions are withdrawn
     *
     * Can be called by any signed origin. The condition that all contributions are withdrawn
     * is in place since the reserve acts as a storage deposit.
     *
     * @param {number} block
     * @param {AccountId32Like | undefined} depositor
     * @param {PolkadotParachainPrimitivesPrimitivesId} paraId
     **/
    unreserveCrowdloanReserve: GenericTxCall<
      (
        block: number,
        depositor: AccountId32Like | undefined,
        paraId: PolkadotParachainPrimitivesPrimitivesId,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhOps';
          palletCall: {
            name: 'UnreserveCrowdloanReserve';
            params: {
              block: number;
              depositor: AccountId32Like | undefined;
              paraId: PolkadotParachainPrimitivesPrimitivesId;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Transfer the balance from the pre-migration treasury account to the post-migration
     * treasury account.
     *
     * This call can only be called after the migration is completed.
     *
     * @param {StagingXcmV5Location} assetId
     **/
    transferToPostMigrationTreasury: GenericTxCall<
      (assetId: StagingXcmV5Location) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhOps';
          palletCall: {
            name: 'TransferToPostMigrationTreasury';
            params: { assetId: StagingXcmV5Location };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `AhMigrator`'s transaction calls
   **/
  ahMigrator: {
    /**
     * Receive accounts from the Relay Chain.
     *
     * The accounts sent with `pallet_rc_migrator::Pallet::migrate_accounts` function.
     *
     * @param {Array<PalletRcMigratorAccountsAccount>} accounts
     **/
    receiveAccounts: GenericTxCall<
      (accounts: Array<PalletRcMigratorAccountsAccount>) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhMigrator';
          palletCall: {
            name: 'ReceiveAccounts';
            params: { accounts: Array<PalletRcMigratorAccountsAccount> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Receive multisigs from the Relay Chain.
     *
     * This will be called from an XCM `Transact` inside a DMP from the relay chain. The
     * multisigs were prepared by
     * `pallet_rc_migrator::multisig::MultisigMigrator::migrate_many`.
     *
     * @param {Array<PalletRcMigratorMultisigRcMultisig>} accounts
     **/
    receiveMultisigs: GenericTxCall<
      (accounts: Array<PalletRcMigratorMultisigRcMultisig>) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhMigrator';
          palletCall: {
            name: 'ReceiveMultisigs';
            params: { accounts: Array<PalletRcMigratorMultisigRcMultisig> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Receive proxies from the Relay Chain.
     *
     * @param {Array<PalletRcMigratorProxyRcProxy>} proxies
     **/
    receiveProxyProxies: GenericTxCall<
      (proxies: Array<PalletRcMigratorProxyRcProxy>) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhMigrator';
          palletCall: {
            name: 'ReceiveProxyProxies';
            params: { proxies: Array<PalletRcMigratorProxyRcProxy> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Receive proxy announcements from the Relay Chain.
     *
     * @param {Array<PalletRcMigratorProxyRcProxyAnnouncement>} announcements
     **/
    receiveProxyAnnouncements: GenericTxCall<
      (announcements: Array<PalletRcMigratorProxyRcProxyAnnouncement>) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhMigrator';
          palletCall: {
            name: 'ReceiveProxyAnnouncements';
            params: { announcements: Array<PalletRcMigratorProxyRcProxyAnnouncement> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {Array<PalletRcMigratorPreimageChunksRcPreimageChunk>} chunks
     **/
    receivePreimageChunks: GenericTxCall<
      (chunks: Array<PalletRcMigratorPreimageChunksRcPreimageChunk>) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhMigrator';
          palletCall: {
            name: 'ReceivePreimageChunks';
            params: { chunks: Array<PalletRcMigratorPreimageChunksRcPreimageChunk> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {Array<PalletRcMigratorPreimageRequestStatusPortableRequestStatus>} requestStatus
     **/
    receivePreimageRequestStatus: GenericTxCall<
      (requestStatus: Array<PalletRcMigratorPreimageRequestStatusPortableRequestStatus>) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhMigrator';
          palletCall: {
            name: 'ReceivePreimageRequestStatus';
            params: { requestStatus: Array<PalletRcMigratorPreimageRequestStatusPortableRequestStatus> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {Array<PalletRcMigratorPreimageLegacyRequestStatusRcPreimageLegacyStatus>} legacyStatus
     **/
    receivePreimageLegacyStatus: GenericTxCall<
      (
        legacyStatus: Array<PalletRcMigratorPreimageLegacyRequestStatusRcPreimageLegacyStatus>,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhMigrator';
          palletCall: {
            name: 'ReceivePreimageLegacyStatus';
            params: { legacyStatus: Array<PalletRcMigratorPreimageLegacyRequestStatusRcPreimageLegacyStatus> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {Array<PalletRcMigratorStakingNomPoolsRcNomPoolsMessage>} messages
     **/
    receiveNomPoolsMessages: GenericTxCall<
      (messages: Array<PalletRcMigratorStakingNomPoolsRcNomPoolsMessage>) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhMigrator';
          palletCall: {
            name: 'ReceiveNomPoolsMessages';
            params: { messages: Array<PalletRcMigratorStakingNomPoolsRcNomPoolsMessage> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {Array<PalletRcMigratorVestingRcVestingSchedule>} schedules
     **/
    receiveVestingSchedules: GenericTxCall<
      (schedules: Array<PalletRcMigratorVestingRcVestingSchedule>) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhMigrator';
          palletCall: {
            name: 'ReceiveVestingSchedules';
            params: { schedules: Array<PalletRcMigratorVestingRcVestingSchedule> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Receive referendum counts, deciding counts, votes for the track queue.
     *
     * @param {Array<PalletRcMigratorReferendaReferendaMessage>} values
     **/
    receiveReferendaValues: GenericTxCall<
      (values: Array<PalletRcMigratorReferendaReferendaMessage>) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhMigrator';
          palletCall: {
            name: 'ReceiveReferendaValues';
            params: { values: Array<PalletRcMigratorReferendaReferendaMessage> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Receive referendums from the Relay Chain.
     *
     * @param {Array<[number, PalletReferendaReferendumInfo]>} referendums
     **/
    receiveReferendums: GenericTxCall<
      (referendums: Array<[number, PalletReferendaReferendumInfo]>) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhMigrator';
          palletCall: {
            name: 'ReceiveReferendums';
            params: { referendums: Array<[number, PalletReferendaReferendumInfo]> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {Array<PalletRcMigratorClaimsRcClaimsMessage>} messages
     **/
    receiveClaims: GenericTxCall<
      (messages: Array<PalletRcMigratorClaimsRcClaimsMessage>) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhMigrator';
          palletCall: {
            name: 'ReceiveClaims';
            params: { messages: Array<PalletRcMigratorClaimsRcClaimsMessage> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {Array<PalletRcMigratorStakingBagsListPortableBagsListMessage>} messages
     **/
    receiveBagsListMessages: GenericTxCall<
      (messages: Array<PalletRcMigratorStakingBagsListPortableBagsListMessage>) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhMigrator';
          palletCall: {
            name: 'ReceiveBagsListMessages';
            params: { messages: Array<PalletRcMigratorStakingBagsListPortableBagsListMessage> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {Array<PalletRcMigratorSchedulerRcSchedulerMessage>} messages
     **/
    receiveSchedulerMessages: GenericTxCall<
      (messages: Array<PalletRcMigratorSchedulerRcSchedulerMessage>) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhMigrator';
          palletCall: {
            name: 'ReceiveSchedulerMessages';
            params: { messages: Array<PalletRcMigratorSchedulerRcSchedulerMessage> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {Array<PalletRcMigratorIndicesRcIndicesIndex>} indices
     **/
    receiveIndices: GenericTxCall<
      (indices: Array<PalletRcMigratorIndicesRcIndicesIndex>) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhMigrator';
          palletCall: {
            name: 'ReceiveIndices';
            params: { indices: Array<PalletRcMigratorIndicesRcIndicesIndex> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {Array<PalletRcMigratorConvictionVotingRcConvictionVotingMessage>} messages
     **/
    receiveConvictionVotingMessages: GenericTxCall<
      (messages: Array<PalletRcMigratorConvictionVotingRcConvictionVotingMessage>) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhMigrator';
          palletCall: {
            name: 'ReceiveConvictionVotingMessages';
            params: { messages: Array<PalletRcMigratorConvictionVotingRcConvictionVotingMessage> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {Array<PalletRcMigratorBountiesRcBountiesMessage>} messages
     **/
    receiveBountiesMessages: GenericTxCall<
      (messages: Array<PalletRcMigratorBountiesRcBountiesMessage>) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhMigrator';
          palletCall: {
            name: 'ReceiveBountiesMessages';
            params: { messages: Array<PalletRcMigratorBountiesRcBountiesMessage> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {Array<[PolkadotRuntimeCommonImplsVersionedLocatableAsset, FixedU128]>} rates
     **/
    receiveAssetRates: GenericTxCall<
      (rates: Array<[PolkadotRuntimeCommonImplsVersionedLocatableAsset, FixedU128]>) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhMigrator';
          palletCall: {
            name: 'ReceiveAssetRates';
            params: { rates: Array<[PolkadotRuntimeCommonImplsVersionedLocatableAsset, FixedU128]> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {Array<PalletRcMigratorCrowdloanRcCrowdloanMessage>} messages
     **/
    receiveCrowdloanMessages: GenericTxCall<
      (messages: Array<PalletRcMigratorCrowdloanRcCrowdloanMessage>) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhMigrator';
          palletCall: {
            name: 'ReceiveCrowdloanMessages';
            params: { messages: Array<PalletRcMigratorCrowdloanRcCrowdloanMessage> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {Array<[number, H256]>} metadata
     **/
    receiveReferendaMetadata: GenericTxCall<
      (metadata: Array<[number, H256]>) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhMigrator';
          palletCall: {
            name: 'ReceiveReferendaMetadata';
            params: { metadata: Array<[number, H256]> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {Array<PalletRcMigratorTreasuryPortableTreasuryMessage>} messages
     **/
    receiveTreasuryMessages: GenericTxCall<
      (messages: Array<PalletRcMigratorTreasuryPortableTreasuryMessage>) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhMigrator';
          palletCall: {
            name: 'ReceiveTreasuryMessages';
            params: { messages: Array<PalletRcMigratorTreasuryPortableTreasuryMessage> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {Array<PalletRcMigratorSchedulerSchedulerAgendaMessage>} messages
     **/
    receiveSchedulerAgendaMessages: GenericTxCall<
      (messages: Array<PalletRcMigratorSchedulerSchedulerAgendaMessage>) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhMigrator';
          palletCall: {
            name: 'ReceiveSchedulerAgendaMessages';
            params: { messages: Array<PalletRcMigratorSchedulerSchedulerAgendaMessage> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {Array<PalletRcMigratorStakingDelegatedStakingPortableDelegatedStakingMessage>} messages
     **/
    receiveDelegatedStakingMessages: GenericTxCall<
      (
        messages: Array<PalletRcMigratorStakingDelegatedStakingPortableDelegatedStakingMessage>,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhMigrator';
          palletCall: {
            name: 'ReceiveDelegatedStakingMessages';
            params: { messages: Array<PalletRcMigratorStakingDelegatedStakingPortableDelegatedStakingMessage> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {Array<PalletRcMigratorChildBountiesPortableChildBountiesMessage>} messages
     **/
    receiveChildBountiesMessages: GenericTxCall<
      (messages: Array<PalletRcMigratorChildBountiesPortableChildBountiesMessage>) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhMigrator';
          palletCall: {
            name: 'ReceiveChildBountiesMessages';
            params: { messages: Array<PalletRcMigratorChildBountiesPortableChildBountiesMessage> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {Array<PalletRcMigratorStakingMessagePortableStakingMessage>} messages
     **/
    receiveStakingMessages: GenericTxCall<
      (messages: Array<PalletRcMigratorStakingMessagePortableStakingMessage>) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhMigrator';
          palletCall: {
            name: 'ReceiveStakingMessages';
            params: { messages: Array<PalletRcMigratorStakingMessagePortableStakingMessage> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the migration stage.
     *
     * This call is intended for emergency use only and is guarded by the
     * [`Config::AdminOrigin`].
     *
     * @param {PalletAhMigratorMigrationStage} stage
     **/
    forceSetStage: GenericTxCall<
      (stage: PalletAhMigratorMigrationStage) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhMigrator';
          palletCall: {
            name: 'ForceSetStage';
            params: { stage: PalletAhMigratorMigrationStage };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Start the data migration.
     *
     * This is typically called by the Relay Chain to start the migration on the Asset Hub and
     * receive a handshake message indicating the Asset Hub's readiness.
     *
     **/
    startMigration: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'AhMigrator';
          palletCall: {
            name: 'StartMigration';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the DMP queue priority configuration.
     *
     * Can only be called by the `AdminOrigin`.
     *
     * @param {PalletRcMigratorQueuePriority} new_
     **/
    setDmpQueuePriority: GenericTxCall<
      (new_: PalletRcMigratorQueuePriority) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhMigrator';
          palletCall: {
            name: 'SetDmpQueuePriority';
            params: { new: PalletRcMigratorQueuePriority };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the manager account id.
     *
     * The manager has the similar to [`Config::AdminOrigin`] privileges except that it
     * can not set the manager account id via `set_manager` call.
     *
     * @param {AccountId32Like | undefined} new_
     **/
    setManager: GenericTxCall<
      (new_: AccountId32Like | undefined) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhMigrator';
          palletCall: {
            name: 'SetManager';
            params: { new: AccountId32Like | undefined };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Finish the migration.
     *
     * This is typically called by the Relay Chain to signal the migration has finished.
     *
     * The `data` parameter might be `None` if we are running the migration for a second time
     * for some pallets and have already performed the checking account balance correction,
     * so we do not need to do it this time.
     *
     * @param {PalletRcMigratorMigrationFinishedData | undefined} data
     * @param {number} coolOffEndAt
     **/
    finishMigration: GenericTxCall<
      (
        data: PalletRcMigratorMigrationFinishedData | undefined,
        coolOffEndAt: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhMigrator';
          palletCall: {
            name: 'FinishMigration';
            params: { data: PalletRcMigratorMigrationFinishedData | undefined; coolOffEndAt: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * XCM send call identical to the [`pallet_xcm::Pallet::send`] call but with the
     * [Config::SendXcm] router which will be able to send messages to the Relay Chain during
     * the migration.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedXcm} message
     **/
    sendXcmMessage: GenericTxCall<
      (
        dest: XcmVersionedLocation,
        message: XcmVersionedXcm,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'AhMigrator';
          palletCall: {
            name: 'SendXcmMessage';
            params: { dest: XcmVersionedLocation; message: XcmVersionedXcm };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
}
