// Generated by dedot cli

import type { GenericRuntimeApis, GenericRuntimeApiMethod } from 'dedot/types';
import type {
  H256,
  RuntimeVersion,
  Header,
  DispatchError,
  Result,
  UncheckedExtrinsicLike,
  UncheckedExtrinsic,
  Bytes,
  BytesLike,
  AccountId32Like,
  AccountId32,
  U256,
  H160,
  FixedBytes,
} from 'dedot/codecs';
import type {
  SpConsensusSlotsSlotDuration,
  SpConsensusAuraEd25519AppEd25519Public,
  SpConsensusSlotsSlot,
  SpRuntimeBlock,
  SpRuntimeExtrinsicInclusionMode,
  SpCoreOpaqueMetadata,
  SpRuntimeTransactionValidityTransactionValidityError,
  SpInherentsInherentData,
  SpInherentsCheckInherentsResult,
  SpRuntimeTransactionValidityValidTransaction,
  SpRuntimeTransactionValidityTransactionSource,
  SpCoreCryptoKeyTypeId,
  FrameSupportViewFunctionsViewFunctionDispatchError,
  FrameSupportViewFunctionsViewFunctionId,
  PalletTransactionPaymentRuntimeDispatchInfo,
  PalletTransactionPaymentFeeDetails,
  SpWeightsWeightV2Weight,
  AssetHubPolkadotRuntimeRuntimeCallLike,
  XcmVersionedAssetId,
  XcmRuntimeApisFeesError,
  XcmVersionedXcm,
  XcmVersionedAssets,
  XcmVersionedLocation,
  XcmRuntimeApisDryRunCallDryRunEffects,
  XcmRuntimeApisDryRunError,
  AssetHubPolkadotRuntimeOriginCaller,
  XcmRuntimeApisDryRunXcmDryRunEffects,
  XcmRuntimeApisConversionsError,
  XcmRuntimeApisTrustedQueryError,
  XcmVersionedAsset,
  XcmRuntimeApisAuthorizedAliasesOriginAliaser,
  XcmRuntimeApisAuthorizedAliasesError,
  AssetsCommonRuntimeApiFungiblesAccessError,
  CumulusPrimitivesCoreCollationInfo,
  StagingXcmV5Location,
  PolkadotParachainPrimitivesPrimitivesId,
  SystemParachainsCommonApisInflationInfo,
  PalletReviveEvmApiRpcTypesGenBlock,
  PalletReviveEvmBlockHashReceiptGasInfo,
  PalletRevivePrimitivesContractResult,
  PalletRevivePrimitivesContractResultInstantiateReturnValue,
  PalletRevivePrimitivesCode,
  PalletRevivePrimitivesEthTransactInfo,
  PalletRevivePrimitivesEthTransactError,
  PalletReviveEvmApiRpcTypesGenGenericTransaction,
  PalletReviveEvmApiRpcTypesDryRunConfig,
  PalletRevivePrimitivesCodeUploadReturnValue,
  PalletRevivePrimitivesContractAccessError,
  PalletReviveEvmApiDebugRpcTypesTrace,
  PalletReviveEvmApiDebugRpcTypesTracerType,
  PalletRevivePrimitivesBalanceConversionError,
} from './types.js';

export interface RuntimeApis extends GenericRuntimeApis {
  /**
   * @runtimeapi: AuraApi - 0xdd718d5cc53262d4
   **/
  auraApi: {
    /**
     * Returns the slot duration for Aura.
     *
     * Currently, only the value provided by this type at genesis will be used.
     *
     * @callname: AuraApi_slot_duration
     **/
    slotDuration: GenericRuntimeApiMethod<() => Promise<SpConsensusSlotsSlotDuration>>;

    /**
     * Return the current set of authorities.
     *
     * @callname: AuraApi_authorities
     **/
    authorities: GenericRuntimeApiMethod<() => Promise<Array<SpConsensusAuraEd25519AppEd25519Public>>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: RelayParentOffsetApi - 0x04e70521a0d3d2f8
   **/
  relayParentOffsetApi: {
    /**
     * Fetch the slot offset that is expected from the relay chain.
     *
     * @callname: RelayParentOffsetApi_relay_parent_offset
     **/
    relayParentOffset: GenericRuntimeApiMethod<() => Promise<number>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: AuraUnincludedSegmentApi - 0xd7bdd8a272ca0d65
   **/
  auraUnincludedSegmentApi: {
    /**
     * Whether it is legal to extend the chain, assuming the given block is the most
     * recently included one as-of the relay parent that will be built against, and
     * the given relay chain slot.
     *
     * This should be consistent with the logic the runtime uses when validating blocks to
     * avoid issues.
     *
     * When the unincluded segment is empty, i.e. `included_hash == at`, where at is the block
     * whose state we are querying against, this must always return `true` as long as the slot
     * is more recent than the included block itself.
     *
     * @callname: AuraUnincludedSegmentApi_can_build_upon
     * @param {H256} included_hash
     * @param {SpConsensusSlotsSlot} slot
     **/
    canBuildUpon: GenericRuntimeApiMethod<(includedHash: H256, slot: SpConsensusSlotsSlot) => Promise<boolean>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: Core - 0xdf6acb689907609b
   **/
  core: {
    /**
     * Returns the version of the runtime.
     *
     * @callname: Core_version
     **/
    version: GenericRuntimeApiMethod<() => Promise<RuntimeVersion>>;

    /**
     * Execute the given block.
     *
     * @callname: Core_execute_block
     * @param {SpRuntimeBlock} block
     **/
    executeBlock: GenericRuntimeApiMethod<(block: SpRuntimeBlock) => Promise<[]>>;

    /**
     * Initialize a block with the given header and return the runtime executive mode.
     *
     * @callname: Core_initialize_block
     * @param {Header} header
     **/
    initializeBlock: GenericRuntimeApiMethod<(header: Header) => Promise<SpRuntimeExtrinsicInclusionMode>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: Metadata - 0x37e397fc7c91f5e4
   **/
  metadata: {
    /**
     * Returns the metadata of a runtime.
     *
     * @callname: Metadata_metadata
     **/
    metadata: GenericRuntimeApiMethod<() => Promise<SpCoreOpaqueMetadata>>;

    /**
     * Returns the metadata at a given version.
     *
     * If the given `version` isn't supported, this will return `None`.
     * Use [`Self::metadata_versions`] to find out about supported metadata version of the runtime.
     *
     * @callname: Metadata_metadata_at_version
     * @param {number} version
     **/
    metadataAtVersion: GenericRuntimeApiMethod<(version: number) => Promise<SpCoreOpaqueMetadata | undefined>>;

    /**
     * Returns the supported metadata versions.
     *
     * This can be used to call `metadata_at_version`.
     *
     * @callname: Metadata_metadata_versions
     **/
    metadataVersions: GenericRuntimeApiMethod<() => Promise<Array<number>>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: BlockBuilder - 0x40fe3ad401f8959a
   **/
  blockBuilder: {
    /**
     * Apply the given extrinsic.
     *
     * Returns an inclusion outcome which specifies if this extrinsic is included in
     * this block or not.
     *
     * @callname: BlockBuilder_apply_extrinsic
     * @param {UncheckedExtrinsicLike} extrinsic
     **/
    applyExtrinsic: GenericRuntimeApiMethod<
      (
        extrinsic: UncheckedExtrinsicLike,
      ) => Promise<Result<Result<[], DispatchError>, SpRuntimeTransactionValidityTransactionValidityError>>
    >;

    /**
     * Finish the current block.
     *
     * @callname: BlockBuilder_finalize_block
     **/
    finalizeBlock: GenericRuntimeApiMethod<() => Promise<Header>>;

    /**
     * Generate inherent extrinsics. The inherent data will vary from chain to chain.
     *
     * @callname: BlockBuilder_inherent_extrinsics
     * @param {SpInherentsInherentData} inherent
     **/
    inherentExtrinsics: GenericRuntimeApiMethod<
      (inherent: SpInherentsInherentData) => Promise<Array<UncheckedExtrinsic>>
    >;

    /**
     * Check that the inherents are valid. The inherent data will vary from chain to chain.
     *
     * @callname: BlockBuilder_check_inherents
     * @param {SpRuntimeBlock} block
     * @param {SpInherentsInherentData} data
     **/
    checkInherents: GenericRuntimeApiMethod<
      (block: SpRuntimeBlock, data: SpInherentsInherentData) => Promise<SpInherentsCheckInherentsResult>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: TaggedTransactionQueue - 0xd2bc9897eed08f15
   **/
  taggedTransactionQueue: {
    /**
     * Validate the transaction.
     *
     * This method is invoked by the transaction pool to learn details about given transaction.
     * The implementation should make sure to verify the correctness of the transaction
     * against current state. The given `block_hash` corresponds to the hash of the block
     * that is used as current state.
     *
     * Note that this call may be performed by the pool multiple times and transactions
     * might be verified in any possible order.
     *
     * @callname: TaggedTransactionQueue_validate_transaction
     * @param {SpRuntimeTransactionValidityTransactionSource} source
     * @param {UncheckedExtrinsicLike} tx
     * @param {H256} block_hash
     **/
    validateTransaction: GenericRuntimeApiMethod<
      (
        source: SpRuntimeTransactionValidityTransactionSource,
        tx: UncheckedExtrinsicLike,
        blockHash: H256,
      ) => Promise<
        Result<SpRuntimeTransactionValidityValidTransaction, SpRuntimeTransactionValidityTransactionValidityError>
      >
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: OffchainWorkerApi - 0xf78b278be53f454c
   **/
  offchainWorkerApi: {
    /**
     * Starts the off-chain task for given block header.
     *
     * @callname: OffchainWorkerApi_offchain_worker
     * @param {Header} header
     **/
    offchainWorker: GenericRuntimeApiMethod<(header: Header) => Promise<[]>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: SessionKeys - 0xab3c0572291feb8b
   **/
  sessionKeys: {
    /**
     * Generate a set of session keys with optionally using the given seed.
     * The keys should be stored within the keystore exposed via runtime
     * externalities.
     *
     * The seed needs to be a valid `utf8` string.
     *
     * Returns the concatenated SCALE encoded public keys.
     *
     * @callname: SessionKeys_generate_session_keys
     * @param {BytesLike | undefined} seed
     **/
    generateSessionKeys: GenericRuntimeApiMethod<(seed?: BytesLike | undefined) => Promise<Bytes>>;

    /**
     * Decode the given public session keys.
     *
     * Returns the list of public raw public keys + key type.
     *
     * @callname: SessionKeys_decode_session_keys
     * @param {BytesLike} encoded
     **/
    decodeSessionKeys: GenericRuntimeApiMethod<
      (encoded: BytesLike) => Promise<Array<[Bytes, SpCoreCryptoKeyTypeId]> | undefined>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: RuntimeViewFunction - 0xccd9de6396c899ca
   **/
  runtimeViewFunction: {
    /**
     * Execute a view function query.
     *
     * @callname: RuntimeViewFunction_execute_view_function
     * @param {FrameSupportViewFunctionsViewFunctionId} query_id
     * @param {BytesLike} input
     **/
    executeViewFunction: GenericRuntimeApiMethod<
      (
        queryId: FrameSupportViewFunctionsViewFunctionId,
        input: BytesLike,
      ) => Promise<Result<Bytes, FrameSupportViewFunctionsViewFunctionDispatchError>>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: AccountNonceApi - 0xbc9d89904f5b923f
   **/
  accountNonceApi: {
    /**
     * Get current account nonce of given `AccountId`.
     *
     * @callname: AccountNonceApi_account_nonce
     * @param {AccountId32Like} account
     **/
    accountNonce: GenericRuntimeApiMethod<(account: AccountId32Like) => Promise<number>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: TransactionPaymentApi - 0x37c8bb1350a9a2a8
   **/
  transactionPaymentApi: {
    /**
     *
     * @callname: TransactionPaymentApi_query_info
     * @param {UncheckedExtrinsicLike} uxt
     * @param {number} len
     **/
    queryInfo: GenericRuntimeApiMethod<
      (uxt: UncheckedExtrinsicLike, len: number) => Promise<PalletTransactionPaymentRuntimeDispatchInfo>
    >;

    /**
     *
     * @callname: TransactionPaymentApi_query_fee_details
     * @param {UncheckedExtrinsicLike} uxt
     * @param {number} len
     **/
    queryFeeDetails: GenericRuntimeApiMethod<
      (uxt: UncheckedExtrinsicLike, len: number) => Promise<PalletTransactionPaymentFeeDetails>
    >;

    /**
     *
     * @callname: TransactionPaymentApi_query_weight_to_fee
     * @param {SpWeightsWeightV2Weight} weight
     **/
    queryWeightToFee: GenericRuntimeApiMethod<(weight: SpWeightsWeightV2Weight) => Promise<bigint>>;

    /**
     *
     * @callname: TransactionPaymentApi_query_length_to_fee
     * @param {number} length
     **/
    queryLengthToFee: GenericRuntimeApiMethod<(length: number) => Promise<bigint>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: TransactionPaymentCallApi - 0xf3ff14d5ab527059
   **/
  transactionPaymentCallApi: {
    /**
     * Query information of a dispatch class, weight, and fee of a given encoded `Call`.
     *
     * @callname: TransactionPaymentCallApi_query_call_info
     * @param {AssetHubPolkadotRuntimeRuntimeCallLike} call
     * @param {number} len
     **/
    queryCallInfo: GenericRuntimeApiMethod<
      (
        call: AssetHubPolkadotRuntimeRuntimeCallLike,
        len: number,
      ) => Promise<PalletTransactionPaymentRuntimeDispatchInfo>
    >;

    /**
     * Query fee details of a given encoded `Call`.
     *
     * @callname: TransactionPaymentCallApi_query_call_fee_details
     * @param {AssetHubPolkadotRuntimeRuntimeCallLike} call
     * @param {number} len
     **/
    queryCallFeeDetails: GenericRuntimeApiMethod<
      (call: AssetHubPolkadotRuntimeRuntimeCallLike, len: number) => Promise<PalletTransactionPaymentFeeDetails>
    >;

    /**
     * Query the output of the current `WeightToFee` given some input.
     *
     * @callname: TransactionPaymentCallApi_query_weight_to_fee
     * @param {SpWeightsWeightV2Weight} weight
     **/
    queryWeightToFee: GenericRuntimeApiMethod<(weight: SpWeightsWeightV2Weight) => Promise<bigint>>;

    /**
     * Query the output of the current `LengthToFee` given some input.
     *
     * @callname: TransactionPaymentCallApi_query_length_to_fee
     * @param {number} length
     **/
    queryLengthToFee: GenericRuntimeApiMethod<(length: number) => Promise<bigint>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: XcmPaymentApi - 0x6ff52ee858e6c5bd
   **/
  xcmPaymentApi: {
    /**
     * Returns a list of acceptable payment assets.
     *
     * # Arguments
     *
     * * `xcm_version`: Version.
     *
     * @callname: XcmPaymentApi_query_acceptable_payment_assets
     * @param {number} xcm_version
     **/
    queryAcceptablePaymentAssets: GenericRuntimeApiMethod<
      (xcmVersion: number) => Promise<Result<Array<XcmVersionedAssetId>, XcmRuntimeApisFeesError>>
    >;

    /**
     * Returns a weight needed to execute a XCM.
     *
     * # Arguments
     *
     * * `message`: `VersionedXcm`.
     *
     * @callname: XcmPaymentApi_query_xcm_weight
     * @param {XcmVersionedXcm} message
     **/
    queryXcmWeight: GenericRuntimeApiMethod<
      (message: XcmVersionedXcm) => Promise<Result<SpWeightsWeightV2Weight, XcmRuntimeApisFeesError>>
    >;

    /**
     * Converts a weight into a fee for the specified `AssetId`.
     *
     * # Arguments
     *
     * * `weight`: convertible `Weight`.
     * * `asset`: `VersionedAssetId`.
     *
     * @callname: XcmPaymentApi_query_weight_to_asset_fee
     * @param {SpWeightsWeightV2Weight} weight
     * @param {XcmVersionedAssetId} asset
     **/
    queryWeightToAssetFee: GenericRuntimeApiMethod<
      (weight: SpWeightsWeightV2Weight, asset: XcmVersionedAssetId) => Promise<Result<bigint, XcmRuntimeApisFeesError>>
    >;

    /**
     * Get delivery fees for sending a specific `message` to a `destination`.
     * These always come in a specific asset, defined by the chain.
     *
     * # Arguments
     * * `message`: The message that'll be sent, necessary because most delivery fees are based on the
     * size of the message.
     * * `destination`: The destination to send the message to. Different destinations may use
     * different senders that charge different fees.
     *
     * @callname: XcmPaymentApi_query_delivery_fees
     * @param {XcmVersionedLocation} destination
     * @param {XcmVersionedXcm} message
     **/
    queryDeliveryFees: GenericRuntimeApiMethod<
      (
        destination: XcmVersionedLocation,
        message: XcmVersionedXcm,
      ) => Promise<Result<XcmVersionedAssets, XcmRuntimeApisFeesError>>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: DryRunApi - 0x91b1c8b16328eb92
   **/
  dryRunApi: {
    /**
     * Dry run call V2.
     *
     * @callname: DryRunApi_dry_run_call
     * @param {AssetHubPolkadotRuntimeOriginCaller} origin
     * @param {AssetHubPolkadotRuntimeRuntimeCallLike} call
     * @param {number} result_xcms_version
     **/
    dryRunCall: GenericRuntimeApiMethod<
      (
        origin: AssetHubPolkadotRuntimeOriginCaller,
        call: AssetHubPolkadotRuntimeRuntimeCallLike,
        resultXcmsVersion: number,
      ) => Promise<Result<XcmRuntimeApisDryRunCallDryRunEffects, XcmRuntimeApisDryRunError>>
    >;

    /**
     * Dry run XCM program
     *
     * @callname: DryRunApi_dry_run_xcm
     * @param {XcmVersionedLocation} origin_location
     * @param {XcmVersionedXcm} xcm
     **/
    dryRunXcm: GenericRuntimeApiMethod<
      (
        originLocation: XcmVersionedLocation,
        xcm: XcmVersionedXcm,
      ) => Promise<Result<XcmRuntimeApisDryRunXcmDryRunEffects, XcmRuntimeApisDryRunError>>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: LocationToAccountApi - 0x9ffb505aa738d69c
   **/
  locationToAccountApi: {
    /**
     * Converts `Location` to `AccountId`.
     *
     * @callname: LocationToAccountApi_convert_location
     * @param {XcmVersionedLocation} location
     **/
    convertLocation: GenericRuntimeApiMethod<
      (location: XcmVersionedLocation) => Promise<Result<AccountId32, XcmRuntimeApisConversionsError>>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: TrustedQueryApi - 0x2609be83ac4468dc
   **/
  trustedQueryApi: {
    /**
     * Returns if the location is a trusted reserve for the asset.
     *
     * # Arguments
     * * `asset`: `VersionedAsset`.
     * * `location`: `VersionedLocation`.
     *
     * @callname: TrustedQueryApi_is_trusted_reserve
     * @param {XcmVersionedAsset} asset
     * @param {XcmVersionedLocation} location
     **/
    isTrustedReserve: GenericRuntimeApiMethod<
      (
        asset: XcmVersionedAsset,
        location: XcmVersionedLocation,
      ) => Promise<Result<boolean, XcmRuntimeApisTrustedQueryError>>
    >;

    /**
     * Returns if the asset can be teleported to the location.
     *
     * # Arguments
     * * `asset`: `VersionedAsset`.
     * * `location`: `VersionedLocation`.
     *
     * @callname: TrustedQueryApi_is_trusted_teleporter
     * @param {XcmVersionedAsset} asset
     * @param {XcmVersionedLocation} location
     **/
    isTrustedTeleporter: GenericRuntimeApiMethod<
      (
        asset: XcmVersionedAsset,
        location: XcmVersionedLocation,
      ) => Promise<Result<boolean, XcmRuntimeApisTrustedQueryError>>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: AuthorizedAliasersApi - 0x12c8e3d4d7e06de0
   **/
  authorizedAliasersApi: {
    /**
     * Returns locations allowed to alias into and act as `target`.
     *
     * @callname: AuthorizedAliasersApi_authorized_aliasers
     * @param {XcmVersionedLocation} target
     **/
    authorizedAliasers: GenericRuntimeApiMethod<
      (
        target: XcmVersionedLocation,
      ) => Promise<Result<Array<XcmRuntimeApisAuthorizedAliasesOriginAliaser>, XcmRuntimeApisAuthorizedAliasesError>>
    >;

    /**
     * Returns whether `origin` is allowed to alias into and act as `target`.
     *
     * @callname: AuthorizedAliasersApi_is_authorized_alias
     * @param {XcmVersionedLocation} origin
     * @param {XcmVersionedLocation} target
     **/
    isAuthorizedAlias: GenericRuntimeApiMethod<
      (
        origin: XcmVersionedLocation,
        target: XcmVersionedLocation,
      ) => Promise<Result<boolean, XcmRuntimeApisAuthorizedAliasesError>>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: FungiblesApi - 0xde92b8a0426b9bf6
   **/
  fungiblesApi: {
    /**
     * Returns the list of all [`Asset`] that an `AccountId` has.
     *
     * @callname: FungiblesApi_query_account_balances
     * @param {AccountId32Like} account
     **/
    queryAccountBalances: GenericRuntimeApiMethod<
      (account: AccountId32Like) => Promise<Result<XcmVersionedAssets, AssetsCommonRuntimeApiFungiblesAccessError>>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: CollectCollationInfo - 0xea93e3f16f3d6962
   **/
  collectCollationInfo: {
    /**
     * Collect information about a collation.
     *
     * The given `header` is the header of the built block for that
     * we are collecting the collation info for.
     *
     * @callname: CollectCollationInfo_collect_collation_info
     * @param {Header} header
     **/
    collectCollationInfo: GenericRuntimeApiMethod<(header: Header) => Promise<CumulusPrimitivesCoreCollationInfo>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: GenesisBuilder - 0xfbc577b9d747efd6
   **/
  genesisBuilder: {
    /**
     * Build `RuntimeGenesisConfig` from a JSON blob not using any defaults and store it in the
     * storage.
     *
     * In the case of a FRAME-based runtime, this function deserializes the full
     * `RuntimeGenesisConfig` from the given JSON blob and puts it into the storage. If the
     * provided JSON blob is incorrect or incomplete or the deserialization fails, an error
     * is returned.
     *
     * Please note that provided JSON blob must contain all `RuntimeGenesisConfig` fields, no
     * defaults will be used.
     *
     * @callname: GenesisBuilder_build_state
     * @param {BytesLike} json
     **/
    buildState: GenericRuntimeApiMethod<(json: BytesLike) => Promise<Result<[], string>>>;

    /**
     * Returns a JSON blob representation of the built-in `RuntimeGenesisConfig` identified by
     * `id`.
     *
     * If `id` is `None` the function should return JSON blob representation of the default
     * `RuntimeGenesisConfig` struct of the runtime. Implementation must provide default
     * `RuntimeGenesisConfig`.
     *
     * Otherwise function returns a JSON representation of the built-in, named
     * `RuntimeGenesisConfig` preset identified by `id`, or `None` if such preset does not
     * exist. Returned `Vec<u8>` contains bytes of JSON blob (patch) which comprises a list of
     * (potentially nested) key-value pairs that are intended for customizing the default
     * runtime genesis config. The patch shall be merged (rfc7386) with the JSON representation
     * of the default `RuntimeGenesisConfig` to create a comprehensive genesis config that can
     * be used in `build_state` method.
     *
     * @callname: GenesisBuilder_get_preset
     * @param {string | undefined} id
     **/
    getPreset: GenericRuntimeApiMethod<(id?: string | undefined) => Promise<Bytes | undefined>>;

    /**
     * Returns a list of identifiers for available builtin `RuntimeGenesisConfig` presets.
     *
     * The presets from the list can be queried with [`GenesisBuilder::get_preset`] method. If
     * no named presets are provided by the runtime the list is empty.
     *
     * @callname: GenesisBuilder_preset_names
     **/
    presetNames: GenericRuntimeApiMethod<() => Promise<Array<string>>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: AssetConversionApi - 0x8a8047a53a8277ec
   **/
  assetConversionApi: {
    /**
     * Provides a quote for [`Pallet::swap_tokens_for_exact_tokens`].
     *
     * Note that the price may have changed by the time the transaction is executed.
     * (Use `amount_in_max` to control slippage.)
     *
     * @callname: AssetConversionApi_quote_price_tokens_for_exact_tokens
     * @param {StagingXcmV5Location} asset1
     * @param {StagingXcmV5Location} asset2
     * @param {bigint} amount
     * @param {boolean} include_fee
     **/
    quotePriceTokensForExactTokens: GenericRuntimeApiMethod<
      (
        asset1: StagingXcmV5Location,
        asset2: StagingXcmV5Location,
        amount: bigint,
        includeFee: boolean,
      ) => Promise<bigint | undefined>
    >;

    /**
     * Provides a quote for [`Pallet::swap_exact_tokens_for_tokens`].
     *
     * Note that the price may have changed by the time the transaction is executed.
     * (Use `amount_out_min` to control slippage.)
     *
     * @callname: AssetConversionApi_quote_price_exact_tokens_for_tokens
     * @param {StagingXcmV5Location} asset1
     * @param {StagingXcmV5Location} asset2
     * @param {bigint} amount
     * @param {boolean} include_fee
     **/
    quotePriceExactTokensForTokens: GenericRuntimeApiMethod<
      (
        asset1: StagingXcmV5Location,
        asset2: StagingXcmV5Location,
        amount: bigint,
        includeFee: boolean,
      ) => Promise<bigint | undefined>
    >;

    /**
     * Returns the size of the liquidity pool for the given asset pair.
     *
     * @callname: AssetConversionApi_get_reserves
     * @param {StagingXcmV5Location} asset1
     * @param {StagingXcmV5Location} asset2
     **/
    getReserves: GenericRuntimeApiMethod<
      (asset1: StagingXcmV5Location, asset2: StagingXcmV5Location) => Promise<[bigint, bigint] | undefined>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: GetParachainInfo - 0xa2ddb6a58477bf63
   **/
  getParachainInfo: {
    /**
     * Retrieve the parachain id used for runtime.
     *
     * @callname: GetParachainInfo_parachain_id
     **/
    parachainId: GenericRuntimeApiMethod<() => Promise<PolkadotParachainPrimitivesPrimitivesId>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: NominationPoolsApi - 0x17a6bc0d0062aeb3
   **/
  nominationPoolsApi: {
    /**
     * Returns the pending rewards for the member that the AccountId was given for.
     *
     * @callname: NominationPoolsApi_pending_rewards
     * @param {AccountId32Like} who
     **/
    pendingRewards: GenericRuntimeApiMethod<(who: AccountId32Like) => Promise<bigint>>;

    /**
     * Returns the equivalent balance of `points` for a given pool.
     *
     * @callname: NominationPoolsApi_points_to_balance
     * @param {number} pool_id
     * @param {bigint} points
     **/
    pointsToBalance: GenericRuntimeApiMethod<(poolId: number, points: bigint) => Promise<bigint>>;

    /**
     * Returns the equivalent points of `new_funds` for a given pool.
     *
     * @callname: NominationPoolsApi_balance_to_points
     * @param {number} pool_id
     * @param {bigint} new_funds
     **/
    balanceToPoints: GenericRuntimeApiMethod<(poolId: number, newFunds: bigint) => Promise<bigint>>;

    /**
     * Returns the pending slash for a given pool.
     *
     * @callname: NominationPoolsApi_pool_pending_slash
     * @param {number} pool_id
     **/
    poolPendingSlash: GenericRuntimeApiMethod<(poolId: number) => Promise<bigint>>;

    /**
     * Returns the pending slash for a given pool member.
     *
     * If pending slash of the member exceeds `ExistentialDeposit`, it can be reported on
     * chain.
     *
     * @callname: NominationPoolsApi_member_pending_slash
     * @param {AccountId32Like} member
     **/
    memberPendingSlash: GenericRuntimeApiMethod<(member: AccountId32Like) => Promise<bigint>>;

    /**
     * Returns true if the pool with `pool_id` needs migration.
     *
     * This can happen when the `pallet-nomination-pools` has switched to using strategy
     * [`DelegateStake`](pallet_nomination_pools::adapter::DelegateStake) but the pool
     * still has funds that were staked using the older strategy
     * [TransferStake](pallet_nomination_pools::adapter::TransferStake). Use
     * [`migrate_pool_to_delegate_stake`](pallet_nomination_pools::Call::migrate_pool_to_delegate_stake)
     * to migrate the pool.
     *
     * @callname: NominationPoolsApi_pool_needs_delegate_migration
     * @param {number} pool_id
     **/
    poolNeedsDelegateMigration: GenericRuntimeApiMethod<(poolId: number) => Promise<boolean>>;

    /**
     * Returns true if the delegated funds of the pool `member` needs migration.
     *
     * Once a pool has successfully migrated to the strategy
     * [`DelegateStake`](pallet_nomination_pools::adapter::DelegateStake), the funds of the
     * member can be migrated from pool account to the member's account. Use
     * [`migrate_delegation`](pallet_nomination_pools::Call::migrate_delegation)
     * to migrate the funds of the pool member.
     *
     * @callname: NominationPoolsApi_member_needs_delegate_migration
     * @param {AccountId32Like} member
     **/
    memberNeedsDelegateMigration: GenericRuntimeApiMethod<(member: AccountId32Like) => Promise<boolean>>;

    /**
     * Returns the total contribution of a pool member including any balance that is unbonding.
     *
     * @callname: NominationPoolsApi_member_total_balance
     * @param {AccountId32Like} who
     **/
    memberTotalBalance: GenericRuntimeApiMethod<(who: AccountId32Like) => Promise<bigint>>;

    /**
     * Total balance contributed to the pool.
     *
     * @callname: NominationPoolsApi_pool_balance
     * @param {number} pool_id
     **/
    poolBalance: GenericRuntimeApiMethod<(poolId: number) => Promise<bigint>>;

    /**
     * Returns the bonded account and reward account associated with the pool_id.
     *
     * @callname: NominationPoolsApi_pool_accounts
     * @param {number} pool_id
     **/
    poolAccounts: GenericRuntimeApiMethod<(poolId: number) => Promise<[AccountId32, AccountId32]>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: StakingApi - 0x18ef58a3b67ba770
   **/
  stakingApi: {
    /**
     * Returns the nominations quota for a nominator with a given balance.
     *
     * @callname: StakingApi_nominations_quota
     * @param {bigint} balance
     **/
    nominationsQuota: GenericRuntimeApiMethod<(balance: bigint) => Promise<number>>;

    /**
     * Returns the page count of exposures for a validator `account` in a given era.
     *
     * @callname: StakingApi_eras_stakers_page_count
     * @param {number} era
     * @param {AccountId32Like} account
     **/
    erasStakersPageCount: GenericRuntimeApiMethod<(era: number, account: AccountId32Like) => Promise<number>>;

    /**
     * Returns true if validator `account` has pages to be claimed for the given era.
     *
     * @callname: StakingApi_pending_rewards
     * @param {number} era
     * @param {AccountId32Like} account
     **/
    pendingRewards: GenericRuntimeApiMethod<(era: number, account: AccountId32Like) => Promise<boolean>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: Inflation - 0xc51ff1fa3f5d0cca
   **/
  inflation: {
    /**
     * Return the current estimates of the issuance amount.
     *
     * This is marked as experimental in light of RFC#89. Nonetheless, its usage is highly
     * recommended over trying to read-storage, or re-create the onchain logic.
     *
     * @callname: Inflation_experimental_issuance_prediction_info
     **/
    experimentalIssuancePredictionInfo: GenericRuntimeApiMethod<() => Promise<SystemParachainsCommonApisInflationInfo>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
  /**
   * @runtimeapi: ReviveApi - 0x8c403e5c4a9fd442
   **/
  reviveApi: {
    /**
     * Returns the current ETH block.
     *
     * This is one block behind the substrate block.
     *
     * @callname: ReviveApi_eth_block
     **/
    ethBlock: GenericRuntimeApiMethod<() => Promise<PalletReviveEvmApiRpcTypesGenBlock>>;

    /**
     * Returns the ETH block hash for the given block number.
     *
     * @callname: ReviveApi_eth_block_hash
     * @param {U256} number
     **/
    ethBlockHash: GenericRuntimeApiMethod<(number: U256) => Promise<H256 | undefined>>;

    /**
     * The details needed to reconstruct the receipt information offchain.
     *
     * # Note
     *
     * Each entry corresponds to the appropriate Ethereum transaction in the current block.
     *
     * @callname: ReviveApi_eth_receipt_data
     **/
    ethReceiptData: GenericRuntimeApiMethod<() => Promise<Array<PalletReviveEvmBlockHashReceiptGasInfo>>>;

    /**
     * Returns the block gas limit.
     *
     * @callname: ReviveApi_block_gas_limit
     **/
    blockGasLimit: GenericRuntimeApiMethod<() => Promise<U256>>;

    /**
     * Returns the free balance of the given `[H160]` address, using EVM decimals.
     *
     * @callname: ReviveApi_balance
     * @param {H160} address
     **/
    balance: GenericRuntimeApiMethod<(address: H160) => Promise<U256>>;

    /**
     * Returns the gas price.
     *
     * @callname: ReviveApi_gas_price
     **/
    gasPrice: GenericRuntimeApiMethod<() => Promise<U256>>;

    /**
     * Returns the nonce of the given `[H160]` address.
     *
     * @callname: ReviveApi_nonce
     * @param {H160} address
     **/
    nonce: GenericRuntimeApiMethod<(address: H160) => Promise<number>>;

    /**
     * Perform a call from a specified account to a given contract.
     *
     * See [`crate::Pallet::bare_call`].
     *
     * @callname: ReviveApi_call
     * @param {AccountId32Like} origin
     * @param {H160} dest
     * @param {bigint} value
     * @param {SpWeightsWeightV2Weight | undefined} gas_limit
     * @param {bigint | undefined} storage_deposit_limit
     * @param {BytesLike} input_data
     **/
    call: GenericRuntimeApiMethod<
      (
        origin: AccountId32Like,
        dest: H160,
        value: bigint,
        gasLimit: SpWeightsWeightV2Weight | undefined,
        storageDepositLimit: bigint | undefined,
        inputData: BytesLike,
      ) => Promise<PalletRevivePrimitivesContractResult>
    >;

    /**
     * Instantiate a new contract.
     *
     * See `[crate::Pallet::bare_instantiate]`.
     *
     * @callname: ReviveApi_instantiate
     * @param {AccountId32Like} origin
     * @param {bigint} value
     * @param {SpWeightsWeightV2Weight | undefined} gas_limit
     * @param {bigint | undefined} storage_deposit_limit
     * @param {PalletRevivePrimitivesCode} code
     * @param {BytesLike} data
     * @param {FixedBytes<32> | undefined} salt
     **/
    instantiate: GenericRuntimeApiMethod<
      (
        origin: AccountId32Like,
        value: bigint,
        gasLimit: SpWeightsWeightV2Weight | undefined,
        storageDepositLimit: bigint | undefined,
        code: PalletRevivePrimitivesCode,
        data: BytesLike,
        salt?: FixedBytes<32> | undefined,
      ) => Promise<PalletRevivePrimitivesContractResultInstantiateReturnValue>
    >;

    /**
     * Perform an Ethereum call.
     *
     * Deprecated use `v2` version instead.
     * See [`crate::Pallet::dry_run_eth_transact`]
     *
     * @callname: ReviveApi_eth_transact
     * @param {PalletReviveEvmApiRpcTypesGenGenericTransaction} tx
     **/
    ethTransact: GenericRuntimeApiMethod<
      (
        tx: PalletReviveEvmApiRpcTypesGenGenericTransaction,
      ) => Promise<Result<PalletRevivePrimitivesEthTransactInfo, PalletRevivePrimitivesEthTransactError>>
    >;

    /**
     * Perform an Ethereum call.
     *
     * See [`crate::Pallet::dry_run_eth_transact`]
     *
     * @callname: ReviveApi_eth_transact_with_config
     * @param {PalletReviveEvmApiRpcTypesGenGenericTransaction} tx
     * @param {PalletReviveEvmApiRpcTypesDryRunConfig} config
     **/
    ethTransactWithConfig: GenericRuntimeApiMethod<
      (
        tx: PalletReviveEvmApiRpcTypesGenGenericTransaction,
        config: PalletReviveEvmApiRpcTypesDryRunConfig,
      ) => Promise<Result<PalletRevivePrimitivesEthTransactInfo, PalletRevivePrimitivesEthTransactError>>
    >;

    /**
     * Upload new code without instantiating a contract from it.
     *
     * See [`crate::Pallet::bare_upload_code`].
     *
     * @callname: ReviveApi_upload_code
     * @param {AccountId32Like} origin
     * @param {BytesLike} code
     * @param {bigint | undefined} storage_deposit_limit
     **/
    uploadCode: GenericRuntimeApiMethod<
      (
        origin: AccountId32Like,
        code: BytesLike,
        storageDepositLimit?: bigint | undefined,
      ) => Promise<Result<PalletRevivePrimitivesCodeUploadReturnValue, DispatchError>>
    >;

    /**
     * Query a given storage key in a given contract.
     *
     * Returns `Ok(Some(Vec<u8>))` if the storage value exists under the given key in the
     * specified account and `Ok(None)` if it doesn't. If the account specified by the address
     * doesn't exist, or doesn't have a contract then `Err` is returned.
     *
     * @callname: ReviveApi_get_storage
     * @param {H160} address
     * @param {FixedBytes<32>} key
     **/
    getStorage: GenericRuntimeApiMethod<
      (
        address: H160,
        key: FixedBytes<32>,
      ) => Promise<Result<Bytes | undefined, PalletRevivePrimitivesContractAccessError>>
    >;

    /**
     * Query a given variable-sized storage key in a given contract.
     *
     * Returns `Ok(Some(Vec<u8>))` if the storage value exists under the given key in the
     * specified account and `Ok(None)` if it doesn't. If the account specified by the address
     * doesn't exist, or doesn't have a contract then `Err` is returned.
     *
     * @callname: ReviveApi_get_storage_var_key
     * @param {H160} address
     * @param {BytesLike} key
     **/
    getStorageVarKey: GenericRuntimeApiMethod<
      (address: H160, key: BytesLike) => Promise<Result<Bytes | undefined, PalletRevivePrimitivesContractAccessError>>
    >;

    /**
     * Traces the execution of an entire block and returns call traces.
     *
     * This is intended to be called through `state_call` to replay the block from the
     * parent block.
     *
     * See eth-rpc `debug_traceBlockByNumber` for usage.
     *
     * @callname: ReviveApi_trace_block
     * @param {SpRuntimeBlock} block
     * @param {PalletReviveEvmApiDebugRpcTypesTracerType} config
     **/
    traceBlock: GenericRuntimeApiMethod<
      (
        block: SpRuntimeBlock,
        config: PalletReviveEvmApiDebugRpcTypesTracerType,
      ) => Promise<Array<[number, PalletReviveEvmApiDebugRpcTypesTrace]>>
    >;

    /**
     * Traces the execution of a specific transaction within a block.
     *
     * This is intended to be called through `state_call` to replay the block from the
     * parent hash up to the transaction.
     *
     * See eth-rpc `debug_traceTransaction` for usage.
     *
     * @callname: ReviveApi_trace_tx
     * @param {SpRuntimeBlock} block
     * @param {number} tx_index
     * @param {PalletReviveEvmApiDebugRpcTypesTracerType} config
     **/
    traceTx: GenericRuntimeApiMethod<
      (
        block: SpRuntimeBlock,
        txIndex: number,
        config: PalletReviveEvmApiDebugRpcTypesTracerType,
      ) => Promise<PalletReviveEvmApiDebugRpcTypesTrace | undefined>
    >;

    /**
     * Dry run and return the trace of the given call.
     *
     * See eth-rpc `debug_traceCall` for usage.
     *
     * @callname: ReviveApi_trace_call
     * @param {PalletReviveEvmApiRpcTypesGenGenericTransaction} tx
     * @param {PalletReviveEvmApiDebugRpcTypesTracerType} config
     **/
    traceCall: GenericRuntimeApiMethod<
      (
        tx: PalletReviveEvmApiRpcTypesGenGenericTransaction,
        config: PalletReviveEvmApiDebugRpcTypesTracerType,
      ) => Promise<Result<PalletReviveEvmApiDebugRpcTypesTrace, PalletRevivePrimitivesEthTransactError>>
    >;

    /**
     * The address of the validator that produced the current block.
     *
     * @callname: ReviveApi_block_author
     **/
    blockAuthor: GenericRuntimeApiMethod<() => Promise<H160>>;

    /**
     * Get the H160 address associated to this account id
     *
     * @callname: ReviveApi_address
     * @param {AccountId32Like} account_id
     **/
    address: GenericRuntimeApiMethod<(accountId: AccountId32Like) => Promise<H160>>;

    /**
     * Get the account id associated to this H160 address.
     *
     * @callname: ReviveApi_account_id
     * @param {H160} address
     **/
    accountId: GenericRuntimeApiMethod<(address: H160) => Promise<AccountId32>>;

    /**
     * The address used to call the runtime's pallets dispatchables
     *
     * @callname: ReviveApi_runtime_pallets_address
     **/
    runtimePalletsAddress: GenericRuntimeApiMethod<() => Promise<H160>>;

    /**
     * The code at the specified address taking pre-compiles into account.
     *
     * @callname: ReviveApi_code
     * @param {H160} address
     **/
    code: GenericRuntimeApiMethod<(address: H160) => Promise<Bytes>>;

    /**
     * Construct the new balance and dust components of this EVM balance.
     *
     * @callname: ReviveApi_new_balance_with_dust
     * @param {U256} balance
     **/
    newBalanceWithDust: GenericRuntimeApiMethod<
      (balance: U256) => Promise<Result<[bigint, number], PalletRevivePrimitivesBalanceConversionError>>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod;
  };
}
