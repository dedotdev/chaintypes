// Generated by dedot cli

import type { GenericChainStorage, GenericStorageQuery, Callback } from 'dedot/types';
import type {
  AccountId32,
  AccountId32Like,
  H256,
  Bytes,
  Digest,
  Phase,
  FixedU128,
  Data,
  BytesLike,
  FixedBytes,
  Permill,
  H160,
  U256,
} from 'dedot/codecs';
import type {
  FrameSystemAccountInfo,
  FrameSupportDispatchPerDispatchClass,
  FrameSystemEventRecord,
  FrameSystemLastRuntimeUpgradeInfo,
  FrameSystemCodeUpgradeAuthorization,
  SpWeightsWeightV2Weight,
  PalletBalancesAccountData,
  PalletBalancesBalanceLock,
  PalletBalancesReserveData,
  FrameSupportTokensMiscIdAmount,
  FrameSupportTokensMiscIdAmount002,
  PalletTransactionPaymentReleases,
  PalletTreasuryProposal,
  PalletTreasurySpendStatus,
  PalletPreimageOldRequestStatus,
  PalletPreimageRequestStatus,
  PalletIdentityRegistration,
  PalletIdentityRegistrarInfo,
  PalletIdentityAuthorityProperties,
  PalletIdentityUsernameInformation,
  PalletIdentityProvider,
  FrameSupportPreimagesBounded,
  PalletDemocracyReferendumInfo,
  PalletDemocracyVoteVoting,
  PalletDemocracyVoteThreshold,
  PalletDemocracyMetadataOwner,
  HydradxRuntimeRuntimeCall,
  PalletCollectiveVotes,
  PalletProxyProxyDefinition,
  PalletProxyAnnouncement,
  PalletMultisigMultisig,
  PalletUniquesCollectionDetails,
  PalletUniquesItemDetails,
  PalletUniquesCollectionMetadata,
  PalletUniquesItemMetadata,
  PalletStateTrieMigrationMigrationTask,
  PalletStateTrieMigrationMigrationLimits,
  PalletConvictionVotingVoteVoting,
  PalletReferendaReferendumInfo,
  EvmCoreErrorExitReason,
  PalletAssetRegistryAssetDetails,
  HydradxRuntimeXcmAssetLocation,
  PalletClaimsEthereumAddress,
  PalletGenesisHistoryChain,
  PalletOmnipoolAssetState,
  PalletOmnipoolTradability,
  PalletOmnipoolPosition,
  PalletLiquidityMiningGlobalFarmData,
  PalletLiquidityMiningYieldFarmData,
  PalletLiquidityMiningDepositData,
  PalletOtcOrder,
  PalletCircuitBreakerTradeVolumeLimit,
  PalletCircuitBreakerLiquidityLimit,
  PalletCircuitBreakerLockdownStatus,
  HydradxTraitsRouterTrade,
  HydradxTraitsRouterAssetPair,
  PalletDynamicFeesFeeEntry,
  PalletDynamicFeesAssetFeeConfig,
  PalletStakingStakingData,
  PalletStakingPosition,
  PalletStakingVoting,
  PalletStakingVote,
  PalletStableswapPoolInfo,
  PalletStableswapPoolPegInfo,
  PalletStableswapTradability,
  PalletStableswapPoolSnapshot,
  PalletLbpPool,
  PalletReferralsLevel,
  PalletReferralsFeeDistribution,
  PalletHsmCollateralInfo,
  PalletDispenserDispenserConfigData,
  OrmlTokensBalanceLock,
  OrmlTokensAccountData,
  OrmlTokensReserveData,
  OrmlVestingVestingSchedule,
  PalletEvmCodeMetadata,
  EthereumTransactionTransactionV3,
  FpRpcTransactionStatus,
  EthereumReceiptReceiptV4,
  EthereumBlock,
  PalletLiquidityMiningDepositData002,
  PalletDcaSchedule,
  PalletSchedulerScheduled,
  PalletSchedulerRetryConfig,
  CumulusPalletParachainSystemUnincludedSegmentAncestor,
  CumulusPalletParachainSystemUnincludedSegmentSegmentTracker,
  PolkadotPrimitivesV8PersistedValidationData,
  PolkadotPrimitivesV8UpgradeRestriction,
  PolkadotPrimitivesV8UpgradeGoAhead,
  SpTrieStorageProof,
  CumulusPalletParachainSystemRelayStateSnapshotMessagingStateSnapshot,
  PolkadotPrimitivesV8AbridgedHostConfiguration,
  CumulusPrimitivesParachainInherentMessageQueueChain,
  PolkadotParachainPrimitivesPrimitivesId,
  PolkadotCorePrimitivesOutboundHrmpMessage,
  PalletXcmQueryStatus,
  XcmVersionedLocation,
  PalletXcmVersionMigrationStage,
  PalletXcmRemoteLockedFungibleRecord,
  XcmVersionedAssetId,
  StagingXcmV5Xcm,
  PalletXcmAuthorizedAliasesEntry,
  CumulusPalletXcmpQueueOutboundChannelDetails,
  CumulusPalletXcmpQueueQueueConfigData,
  PalletMessageQueueBookState,
  CumulusPrimitivesCoreAggregateMessageOrigin,
  PalletMessageQueuePage,
  PalletMigrationsMigrationCursor,
  StagingXcmV5Location,
  PalletCollatorSelectionCandidateInfo,
  HydradxRuntimeOpaqueSessionKeys,
  SpStakingOffenceOffenceSeverity,
  SpCoreCryptoKeyTypeId,
  SpConsensusAuraSr25519AppSr25519Public,
  SpConsensusSlotsSlot,
  PalletEmaOracleOracleEntry,
  HydradxTraitsOracleOraclePeriod,
  PalletBroadcastExecutionType,
} from './types.js';

export interface ChainStorage extends GenericChainStorage {
  /**
   * Pallet `System`'s storage queries
   **/
  system: {
    /**
     * The full account information for a particular account ID.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<FrameSystemAccountInfo> =} callback
     **/
    account: GenericStorageQuery<(arg: AccountId32Like) => FrameSystemAccountInfo, AccountId32>;

    /**
     * Total extrinsics count for the current block.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    extrinsicCount: GenericStorageQuery<() => number | undefined>;

    /**
     * Whether all inherents have been applied.
     *
     * @param {Callback<boolean> =} callback
     **/
    inherentsApplied: GenericStorageQuery<() => boolean>;

    /**
     * The current weight for the block.
     *
     * @param {Callback<FrameSupportDispatchPerDispatchClass> =} callback
     **/
    blockWeight: GenericStorageQuery<() => FrameSupportDispatchPerDispatchClass>;

    /**
     * Total length (in bytes) for all extrinsics put together, for the current block.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    allExtrinsicsLen: GenericStorageQuery<() => number | undefined>;

    /**
     * Map of block numbers to block hashes.
     *
     * @param {number} arg
     * @param {Callback<H256> =} callback
     **/
    blockHash: GenericStorageQuery<(arg: number) => H256, number>;

    /**
     * Extrinsics data for the current block (maps an extrinsic's index to its data).
     *
     * @param {number} arg
     * @param {Callback<Bytes> =} callback
     **/
    extrinsicData: GenericStorageQuery<(arg: number) => Bytes, number>;

    /**
     * The current block number being processed. Set by `execute_block`.
     *
     * @param {Callback<number> =} callback
     **/
    number: GenericStorageQuery<() => number>;

    /**
     * Hash of the previous block.
     *
     * @param {Callback<H256> =} callback
     **/
    parentHash: GenericStorageQuery<() => H256>;

    /**
     * Digest of the current block, also part of the block header.
     *
     * @param {Callback<Digest> =} callback
     **/
    digest: GenericStorageQuery<() => Digest>;

    /**
     * Events deposited for the current block.
     *
     * NOTE: The item is unbound and should therefore never be read on chain.
     * It could otherwise inflate the PoV size of a block.
     *
     * Events have a large in-memory size. Box the events to not go out-of-memory
     * just in case someone still reads them from within the runtime.
     *
     * @param {Callback<Array<FrameSystemEventRecord>> =} callback
     **/
    events: GenericStorageQuery<() => Array<FrameSystemEventRecord>>;

    /**
     * The number of events in the `Events<T>` list.
     *
     * @param {Callback<number> =} callback
     **/
    eventCount: GenericStorageQuery<() => number>;

    /**
     * Mapping between a topic (represented by T::Hash) and a vector of indexes
     * of events in the `<Events<T>>` list.
     *
     * All topic vectors have deterministic storage locations depending on the topic. This
     * allows light-clients to leverage the changes trie storage tracking mechanism and
     * in case of changes fetch the list of events of interest.
     *
     * The value has the type `(BlockNumberFor<T>, EventIndex)` because if we used only just
     * the `EventIndex` then in case if the topic has the same contents on the next block
     * no notification will be triggered thus the event might be lost.
     *
     * @param {H256} arg
     * @param {Callback<Array<[number, number]>> =} callback
     **/
    eventTopics: GenericStorageQuery<(arg: H256) => Array<[number, number]>, H256>;

    /**
     * Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened.
     *
     * @param {Callback<FrameSystemLastRuntimeUpgradeInfo | undefined> =} callback
     **/
    lastRuntimeUpgrade: GenericStorageQuery<() => FrameSystemLastRuntimeUpgradeInfo | undefined>;

    /**
     * True if we have upgraded so that `type RefCount` is `u32`. False (default) if not.
     *
     * @param {Callback<boolean> =} callback
     **/
    upgradedToU32RefCount: GenericStorageQuery<() => boolean>;

    /**
     * True if we have upgraded so that AccountInfo contains three types of `RefCount`. False
     * (default) if not.
     *
     * @param {Callback<boolean> =} callback
     **/
    upgradedToTripleRefCount: GenericStorageQuery<() => boolean>;

    /**
     * The execution phase of the block.
     *
     * @param {Callback<Phase | undefined> =} callback
     **/
    executionPhase: GenericStorageQuery<() => Phase | undefined>;

    /**
     * `Some` if a code upgrade has been authorized.
     *
     * @param {Callback<FrameSystemCodeUpgradeAuthorization | undefined> =} callback
     **/
    authorizedUpgrade: GenericStorageQuery<() => FrameSystemCodeUpgradeAuthorization | undefined>;

    /**
     * The weight reclaimed for the extrinsic.
     *
     * This information is available until the end of the extrinsic execution.
     * More precisely this information is removed in `note_applied_extrinsic`.
     *
     * Logic doing some post dispatch weight reduction must update this storage to avoid duplicate
     * reduction.
     *
     * @param {Callback<SpWeightsWeightV2Weight> =} callback
     **/
    extrinsicWeightReclaimed: GenericStorageQuery<() => SpWeightsWeightV2Weight>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Timestamp`'s storage queries
   **/
  timestamp: {
    /**
     * The current time for the current block.
     *
     * @param {Callback<bigint> =} callback
     **/
    now: GenericStorageQuery<() => bigint>;

    /**
     * Whether the timestamp has been updated in this block.
     *
     * This value is updated to `true` upon successful submission of a timestamp by a node.
     * It is then checked at the end of each block execution in the `on_finalize` hook.
     *
     * @param {Callback<boolean> =} callback
     **/
    didUpdate: GenericStorageQuery<() => boolean>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Balances`'s storage queries
   **/
  balances: {
    /**
     * The total units issued in the system.
     *
     * @param {Callback<bigint> =} callback
     **/
    totalIssuance: GenericStorageQuery<() => bigint>;

    /**
     * The total units of outstanding deactivated balance in the system.
     *
     * @param {Callback<bigint> =} callback
     **/
    inactiveIssuance: GenericStorageQuery<() => bigint>;

    /**
     * The Balances pallet example of storing the balance of an account.
     *
     * # Example
     *
     * ```nocompile
     * impl pallet_balances::Config for Runtime {
     * type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>
     * }
     * ```
     *
     * You can also store the balance of an account in the `System` pallet.
     *
     * # Example
     *
     * ```nocompile
     * impl pallet_balances::Config for Runtime {
     * type AccountStore = System
     * }
     * ```
     *
     * But this comes with tradeoffs, storing account balances in the system pallet stores
     * `frame_system` data alongside the account data contrary to storing account balances in the
     * `Balances` pallet, which uses a `StorageMap` to store balances data only.
     * NOTE: This is only used in the case that this pallet is used to store balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletBalancesAccountData> =} callback
     **/
    account: GenericStorageQuery<(arg: AccountId32Like) => PalletBalancesAccountData, AccountId32>;

    /**
     * Any liquidity locks on some account balances.
     * NOTE: Should only be accessed when setting, changing and freeing a lock.
     *
     * Use of locks is deprecated in favour of freezes. See `https://github.com/paritytech/substrate/pull/12951/`
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletBalancesBalanceLock>> =} callback
     **/
    locks: GenericStorageQuery<(arg: AccountId32Like) => Array<PalletBalancesBalanceLock>, AccountId32>;

    /**
     * Named reserves on some account balances.
     *
     * Use of reserves is deprecated in favour of holds. See `https://github.com/paritytech/substrate/pull/12951/`
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletBalancesReserveData>> =} callback
     **/
    reserves: GenericStorageQuery<(arg: AccountId32Like) => Array<PalletBalancesReserveData>, AccountId32>;

    /**
     * Holds on account balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<FrameSupportTokensMiscIdAmount>> =} callback
     **/
    holds: GenericStorageQuery<(arg: AccountId32Like) => Array<FrameSupportTokensMiscIdAmount>, AccountId32>;

    /**
     * Freeze locks on account balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<FrameSupportTokensMiscIdAmount002>> =} callback
     **/
    freezes: GenericStorageQuery<(arg: AccountId32Like) => Array<FrameSupportTokensMiscIdAmount002>, AccountId32>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `TransactionPayment`'s storage queries
   **/
  transactionPayment: {
    /**
     *
     * @param {Callback<FixedU128> =} callback
     **/
    nextFeeMultiplier: GenericStorageQuery<() => FixedU128>;

    /**
     *
     * @param {Callback<PalletTransactionPaymentReleases> =} callback
     **/
    storageVersion: GenericStorageQuery<() => PalletTransactionPaymentReleases>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `MultiTransactionPayment`'s storage queries
   **/
  multiTransactionPayment: {
    /**
     * Account currency map
     *
     * @param {AccountId32Like} arg
     * @param {Callback<number | undefined> =} callback
     **/
    accountCurrencyMap: GenericStorageQuery<(arg: AccountId32Like) => number | undefined, AccountId32>;

    /**
     * Curated list of currencies which fees can be paid mapped to corresponding fallback price
     *
     * @param {number} arg
     * @param {Callback<FixedU128 | undefined> =} callback
     **/
    acceptedCurrencies: GenericStorageQuery<(arg: number) => FixedU128 | undefined, number>;

    /**
     * Asset prices from the spot price provider or the fallback price if the price is not available. Updated at the beginning of every block.
     *
     * @param {number} arg
     * @param {Callback<FixedU128 | undefined> =} callback
     **/
    acceptedCurrencyPrice: GenericStorageQuery<(arg: number) => FixedU128 | undefined, number>;

    /**
     *
     * @param {AccountId32Like} arg
     * @param {Callback<number | undefined> =} callback
     **/
    transactionCurrencyOverride: GenericStorageQuery<(arg: AccountId32Like) => number | undefined, AccountId32>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Treasury`'s storage queries
   **/
  treasury: {
    /**
     * DEPRECATED: associated with `spend_local` call and will be removed in May 2025.
     * Refer to <https://github.com/paritytech/polkadot-sdk/pull/5961> for migration to `spend`.
     *
     * Number of proposals that have been made.
     *
     * @param {Callback<number> =} callback
     **/
    proposalCount: GenericStorageQuery<() => number>;

    /**
     * DEPRECATED: associated with `spend_local` call and will be removed in May 2025.
     * Refer to <https://github.com/paritytech/polkadot-sdk/pull/5961> for migration to `spend`.
     *
     * Proposals that have been made.
     *
     * @param {number} arg
     * @param {Callback<PalletTreasuryProposal | undefined> =} callback
     **/
    proposals: GenericStorageQuery<(arg: number) => PalletTreasuryProposal | undefined, number>;

    /**
     * The amount which has been reported as inactive to Currency.
     *
     * @param {Callback<bigint> =} callback
     **/
    deactivated: GenericStorageQuery<() => bigint>;

    /**
     * DEPRECATED: associated with `spend_local` call and will be removed in May 2025.
     * Refer to <https://github.com/paritytech/polkadot-sdk/pull/5961> for migration to `spend`.
     *
     * Proposal indices that have been approved but not yet awarded.
     *
     * @param {Callback<Array<number>> =} callback
     **/
    approvals: GenericStorageQuery<() => Array<number>>;

    /**
     * The count of spends that have been made.
     *
     * @param {Callback<number> =} callback
     **/
    spendCount: GenericStorageQuery<() => number>;

    /**
     * Spends that have been approved and being processed.
     *
     * @param {number} arg
     * @param {Callback<PalletTreasurySpendStatus | undefined> =} callback
     **/
    spends: GenericStorageQuery<(arg: number) => PalletTreasurySpendStatus | undefined, number>;

    /**
     * The blocknumber for the last triggered spend period.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    lastSpendPeriod: GenericStorageQuery<() => number | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Preimage`'s storage queries
   **/
  preimage: {
    /**
     * The request status of a given hash.
     *
     * @param {H256} arg
     * @param {Callback<PalletPreimageOldRequestStatus | undefined> =} callback
     **/
    statusFor: GenericStorageQuery<(arg: H256) => PalletPreimageOldRequestStatus | undefined, H256>;

    /**
     * The request status of a given hash.
     *
     * @param {H256} arg
     * @param {Callback<PalletPreimageRequestStatus | undefined> =} callback
     **/
    requestStatusFor: GenericStorageQuery<(arg: H256) => PalletPreimageRequestStatus | undefined, H256>;

    /**
     *
     * @param {[H256, number]} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    preimageFor: GenericStorageQuery<(arg: [H256, number]) => Bytes | undefined, [H256, number]>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Identity`'s storage queries
   **/
  identity: {
    /**
     * Information that is pertinent to identify the entity behind an account. First item is the
     * registration, second is the account's primary username.
     *
     * TWOX-NOTE: OK ― `AccountId` is a secure hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletIdentityRegistration | undefined> =} callback
     **/
    identityOf: GenericStorageQuery<(arg: AccountId32Like) => PalletIdentityRegistration | undefined, AccountId32>;

    /**
     * Identifies the primary username of an account.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    usernameOf: GenericStorageQuery<(arg: AccountId32Like) => Bytes | undefined, AccountId32>;

    /**
     * The super-identity of an alternative "sub" identity together with its name, within that
     * context. If the account is not some other account's sub-identity, then just `None`.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[AccountId32, Data] | undefined> =} callback
     **/
    superOf: GenericStorageQuery<(arg: AccountId32Like) => [AccountId32, Data] | undefined, AccountId32>;

    /**
     * Alternative "sub" identities of this account.
     *
     * The first item is the deposit, the second is a vector of the accounts.
     *
     * TWOX-NOTE: OK ― `AccountId` is a secure hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[bigint, Array<AccountId32>]> =} callback
     **/
    subsOf: GenericStorageQuery<(arg: AccountId32Like) => [bigint, Array<AccountId32>], AccountId32>;

    /**
     * The set of registrars. Not expected to get very big as can only be added through a
     * special origin (likely a council motion).
     *
     * The index into this can be cast to `RegistrarIndex` to get a valid value.
     *
     * @param {Callback<Array<PalletIdentityRegistrarInfo | undefined>> =} callback
     **/
    registrars: GenericStorageQuery<() => Array<PalletIdentityRegistrarInfo | undefined>>;

    /**
     * A map of the accounts who are authorized to grant usernames.
     *
     * @param {BytesLike} arg
     * @param {Callback<PalletIdentityAuthorityProperties | undefined> =} callback
     **/
    authorityOf: GenericStorageQuery<(arg: BytesLike) => PalletIdentityAuthorityProperties | undefined, Bytes>;

    /**
     * Reverse lookup from `username` to the `AccountId` that has registered it and the provider of
     * the username. The `owner` value should be a key in the `UsernameOf` map, but it may not if
     * the user has cleared their username or it has been removed.
     *
     * Multiple usernames may map to the same `AccountId`, but `UsernameOf` will only map to one
     * primary username.
     *
     * @param {BytesLike} arg
     * @param {Callback<PalletIdentityUsernameInformation | undefined> =} callback
     **/
    usernameInfoOf: GenericStorageQuery<(arg: BytesLike) => PalletIdentityUsernameInformation | undefined, Bytes>;

    /**
     * Usernames that an authority has granted, but that the account controller has not confirmed
     * that they want it. Used primarily in cases where the `AccountId` cannot provide a signature
     * because they are a pure proxy, multisig, etc. In order to confirm it, they should call
     * [accept_username](`Call::accept_username`).
     *
     * First tuple item is the account and second is the acceptance deadline.
     *
     * @param {BytesLike} arg
     * @param {Callback<[AccountId32, number, PalletIdentityProvider] | undefined> =} callback
     **/
    pendingUsernames: GenericStorageQuery<
      (arg: BytesLike) => [AccountId32, number, PalletIdentityProvider] | undefined,
      Bytes
    >;

    /**
     * Usernames for which the authority that granted them has started the removal process by
     * unbinding them. Each unbinding username maps to its grace period expiry, which is the first
     * block in which the username could be deleted through a
     * [remove_username](`Call::remove_username`) call.
     *
     * @param {BytesLike} arg
     * @param {Callback<number | undefined> =} callback
     **/
    unbindingUsernames: GenericStorageQuery<(arg: BytesLike) => number | undefined, Bytes>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Democracy`'s storage queries
   **/
  democracy: {
    /**
     * The number of (public) proposals that have been made so far.
     *
     * @param {Callback<number> =} callback
     **/
    publicPropCount: GenericStorageQuery<() => number>;

    /**
     * The public proposals. Unsorted. The second item is the proposal.
     *
     * @param {Callback<Array<[number, FrameSupportPreimagesBounded, AccountId32]>> =} callback
     **/
    publicProps: GenericStorageQuery<() => Array<[number, FrameSupportPreimagesBounded, AccountId32]>>;

    /**
     * Those who have locked a deposit.
     *
     * TWOX-NOTE: Safe, as increasing integer keys are safe.
     *
     * @param {number} arg
     * @param {Callback<[Array<AccountId32>, bigint] | undefined> =} callback
     **/
    depositOf: GenericStorageQuery<(arg: number) => [Array<AccountId32>, bigint] | undefined, number>;

    /**
     * The next free referendum index, aka the number of referenda started so far.
     *
     * @param {Callback<number> =} callback
     **/
    referendumCount: GenericStorageQuery<() => number>;

    /**
     * The lowest referendum index representing an unbaked referendum. Equal to
     * `ReferendumCount` if there isn't a unbaked referendum.
     *
     * @param {Callback<number> =} callback
     **/
    lowestUnbaked: GenericStorageQuery<() => number>;

    /**
     * Information concerning any given referendum.
     *
     * TWOX-NOTE: SAFE as indexes are not under an attacker’s control.
     *
     * @param {number} arg
     * @param {Callback<PalletDemocracyReferendumInfo | undefined> =} callback
     **/
    referendumInfoOf: GenericStorageQuery<(arg: number) => PalletDemocracyReferendumInfo | undefined, number>;

    /**
     * All votes for a particular voter. We store the balance for the number of votes that we
     * have recorded. The second item is the total amount of delegations, that will be added.
     *
     * TWOX-NOTE: SAFE as `AccountId`s are crypto hashes anyway.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletDemocracyVoteVoting> =} callback
     **/
    votingOf: GenericStorageQuery<(arg: AccountId32Like) => PalletDemocracyVoteVoting, AccountId32>;

    /**
     * True if the last referendum tabled was submitted externally. False if it was a public
     * proposal.
     *
     * @param {Callback<boolean> =} callback
     **/
    lastTabledWasExternal: GenericStorageQuery<() => boolean>;

    /**
     * The referendum to be tabled whenever it would be valid to table an external proposal.
     * This happens when a referendum needs to be tabled and one of two conditions are met:
     * - `LastTabledWasExternal` is `false`; or
     * - `PublicProps` is empty.
     *
     * @param {Callback<[FrameSupportPreimagesBounded, PalletDemocracyVoteThreshold] | undefined> =} callback
     **/
    nextExternal: GenericStorageQuery<() => [FrameSupportPreimagesBounded, PalletDemocracyVoteThreshold] | undefined>;

    /**
     * A record of who vetoed what. Maps proposal hash to a possible existent block number
     * (until when it may not be resubmitted) and who vetoed it.
     *
     * @param {H256} arg
     * @param {Callback<[number, Array<AccountId32>] | undefined> =} callback
     **/
    blacklist: GenericStorageQuery<(arg: H256) => [number, Array<AccountId32>] | undefined, H256>;

    /**
     * Record of all proposals that have been subject to emergency cancellation.
     *
     * @param {H256} arg
     * @param {Callback<boolean> =} callback
     **/
    cancellations: GenericStorageQuery<(arg: H256) => boolean, H256>;

    /**
     * General information concerning any proposal or referendum.
     * The `Hash` refers to the preimage of the `Preimages` provider which can be a JSON
     * dump or IPFS hash of a JSON file.
     *
     * Consider a garbage collection for a metadata of finished referendums to `unrequest` (remove)
     * large preimages.
     *
     * @param {PalletDemocracyMetadataOwner} arg
     * @param {Callback<H256 | undefined> =} callback
     **/
    metadataOf: GenericStorageQuery<
      (arg: PalletDemocracyMetadataOwner) => H256 | undefined,
      PalletDemocracyMetadataOwner
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `TechnicalCommittee`'s storage queries
   **/
  technicalCommittee: {
    /**
     * The hashes of the active proposals.
     *
     * @param {Callback<Array<H256>> =} callback
     **/
    proposals: GenericStorageQuery<() => Array<H256>>;

    /**
     * Actual proposal for a given hash, if it's current.
     *
     * @param {H256} arg
     * @param {Callback<HydradxRuntimeRuntimeCall | undefined> =} callback
     **/
    proposalOf: GenericStorageQuery<(arg: H256) => HydradxRuntimeRuntimeCall | undefined, H256>;

    /**
     * Consideration cost created for publishing and storing a proposal.
     *
     * Determined by [Config::Consideration] and may be not present for certain proposals (e.g. if
     * the proposal count at the time of creation was below threshold N).
     *
     * @param {H256} arg
     * @param {Callback<[AccountId32, []] | undefined> =} callback
     **/
    costOf: GenericStorageQuery<(arg: H256) => [AccountId32, []] | undefined, H256>;

    /**
     * Votes on a given proposal, if it is ongoing.
     *
     * @param {H256} arg
     * @param {Callback<PalletCollectiveVotes | undefined> =} callback
     **/
    voting: GenericStorageQuery<(arg: H256) => PalletCollectiveVotes | undefined, H256>;

    /**
     * Proposals so far.
     *
     * @param {Callback<number> =} callback
     **/
    proposalCount: GenericStorageQuery<() => number>;

    /**
     * The current members of the collective. This is stored sorted (just by value).
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    members: GenericStorageQuery<() => Array<AccountId32>>;

    /**
     * The prime member that helps determine the default vote behavior in case of abstentions.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    prime: GenericStorageQuery<() => AccountId32 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Proxy`'s storage queries
   **/
  proxy: {
    /**
     * The set of account proxies. Maps the account which has delegated to the accounts
     * which are being delegated to, together with the amount held on deposit.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[Array<PalletProxyProxyDefinition>, bigint]> =} callback
     **/
    proxies: GenericStorageQuery<(arg: AccountId32Like) => [Array<PalletProxyProxyDefinition>, bigint], AccountId32>;

    /**
     * The announcements made by the proxy (key).
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[Array<PalletProxyAnnouncement>, bigint]> =} callback
     **/
    announcements: GenericStorageQuery<(arg: AccountId32Like) => [Array<PalletProxyAnnouncement>, bigint], AccountId32>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Multisig`'s storage queries
   **/
  multisig: {
    /**
     * The set of open multisig operations.
     *
     * @param {[AccountId32Like, FixedBytes<32>]} arg
     * @param {Callback<PalletMultisigMultisig | undefined> =} callback
     **/
    multisigs: GenericStorageQuery<
      (arg: [AccountId32Like, FixedBytes<32>]) => PalletMultisigMultisig | undefined,
      [AccountId32, FixedBytes<32>]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Uniques`'s storage queries
   **/
  uniques: {
    /**
     * Details of a collection.
     *
     * @param {bigint} arg
     * @param {Callback<PalletUniquesCollectionDetails | undefined> =} callback
     **/
    class: GenericStorageQuery<(arg: bigint) => PalletUniquesCollectionDetails | undefined, bigint>;

    /**
     * The collection, if any, of which an account is willing to take ownership.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    ownershipAcceptance: GenericStorageQuery<(arg: AccountId32Like) => bigint | undefined, AccountId32>;

    /**
     * The items held by any given account; set out this way so that items owned by a single
     * account can be enumerated.
     *
     * @param {[AccountId32Like, bigint, bigint]} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    account: GenericStorageQuery<
      (arg: [AccountId32Like, bigint, bigint]) => [] | undefined,
      [AccountId32, bigint, bigint]
    >;

    /**
     * The collections owned by any given account; set out this way so that collections owned by
     * a single account can be enumerated.
     *
     * @param {[AccountId32Like, bigint]} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    classAccount: GenericStorageQuery<(arg: [AccountId32Like, bigint]) => [] | undefined, [AccountId32, bigint]>;

    /**
     * The items in existence and their ownership details.
     *
     * @param {[bigint, bigint]} arg
     * @param {Callback<PalletUniquesItemDetails | undefined> =} callback
     **/
    asset: GenericStorageQuery<(arg: [bigint, bigint]) => PalletUniquesItemDetails | undefined, [bigint, bigint]>;

    /**
     * Metadata of a collection.
     *
     * @param {bigint} arg
     * @param {Callback<PalletUniquesCollectionMetadata | undefined> =} callback
     **/
    classMetadataOf: GenericStorageQuery<(arg: bigint) => PalletUniquesCollectionMetadata | undefined, bigint>;

    /**
     * Metadata of an item.
     *
     * @param {[bigint, bigint]} arg
     * @param {Callback<PalletUniquesItemMetadata | undefined> =} callback
     **/
    instanceMetadataOf: GenericStorageQuery<
      (arg: [bigint, bigint]) => PalletUniquesItemMetadata | undefined,
      [bigint, bigint]
    >;

    /**
     * Attributes of a collection.
     *
     * @param {[bigint, bigint | undefined, BytesLike]} arg
     * @param {Callback<[Bytes, bigint] | undefined> =} callback
     **/
    attribute: GenericStorageQuery<
      (arg: [bigint, bigint | undefined, BytesLike]) => [Bytes, bigint] | undefined,
      [bigint, bigint | undefined, Bytes]
    >;

    /**
     * Price of an asset instance.
     *
     * @param {[bigint, bigint]} arg
     * @param {Callback<[bigint, AccountId32 | undefined] | undefined> =} callback
     **/
    itemPriceOf: GenericStorageQuery<
      (arg: [bigint, bigint]) => [bigint, AccountId32 | undefined] | undefined,
      [bigint, bigint]
    >;

    /**
     * Keeps track of the number of items a collection might have.
     *
     * @param {bigint} arg
     * @param {Callback<number | undefined> =} callback
     **/
    collectionMaxSupply: GenericStorageQuery<(arg: bigint) => number | undefined, bigint>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `StateTrieMigration`'s storage queries
   **/
  stateTrieMigration: {
    /**
     * Migration progress.
     *
     * This stores the snapshot of the last migrated keys. It can be set into motion and move
     * forward by any of the means provided by this pallet.
     *
     * @param {Callback<PalletStateTrieMigrationMigrationTask> =} callback
     **/
    migrationProcess: GenericStorageQuery<() => PalletStateTrieMigrationMigrationTask>;

    /**
     * The limits that are imposed on automatic migrations.
     *
     * If set to None, then no automatic migration happens.
     *
     * @param {Callback<PalletStateTrieMigrationMigrationLimits | undefined> =} callback
     **/
    autoLimits: GenericStorageQuery<() => PalletStateTrieMigrationMigrationLimits | undefined>;

    /**
     * The maximum limits that the signed migration could use.
     *
     * If not set, no signed submission is allowed.
     *
     * @param {Callback<PalletStateTrieMigrationMigrationLimits | undefined> =} callback
     **/
    signedMigrationMaxLimits: GenericStorageQuery<() => PalletStateTrieMigrationMigrationLimits | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `ConvictionVoting`'s storage queries
   **/
  convictionVoting: {
    /**
     * All voting for a particular voter in a particular voting class. We store the balance for the
     * number of votes that we have recorded.
     *
     * @param {[AccountId32Like, number]} arg
     * @param {Callback<PalletConvictionVotingVoteVoting> =} callback
     **/
    votingFor: GenericStorageQuery<
      (arg: [AccountId32Like, number]) => PalletConvictionVotingVoteVoting,
      [AccountId32, number]
    >;

    /**
     * The voting classes which have a non-zero lock requirement and the lock amounts which they
     * require. The actual amount locked on behalf of this pallet should always be the maximum of
     * this list.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<[number, bigint]>> =} callback
     **/
    classLocksFor: GenericStorageQuery<(arg: AccountId32Like) => Array<[number, bigint]>, AccountId32>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Referenda`'s storage queries
   **/
  referenda: {
    /**
     * The next free referendum index, aka the number of referenda started so far.
     *
     * @param {Callback<number> =} callback
     **/
    referendumCount: GenericStorageQuery<() => number>;

    /**
     * Information concerning any given referendum.
     *
     * @param {number} arg
     * @param {Callback<PalletReferendaReferendumInfo | undefined> =} callback
     **/
    referendumInfoFor: GenericStorageQuery<(arg: number) => PalletReferendaReferendumInfo | undefined, number>;

    /**
     * The sorted list of referenda ready to be decided but not yet being decided, ordered by
     * conviction-weighted approvals.
     *
     * This should be empty if `DecidingCount` is less than `TrackInfo::max_deciding`.
     *
     * @param {number} arg
     * @param {Callback<Array<[number, bigint]>> =} callback
     **/
    trackQueue: GenericStorageQuery<(arg: number) => Array<[number, bigint]>, number>;

    /**
     * The number of referenda being decided currently.
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    decidingCount: GenericStorageQuery<(arg: number) => number, number>;

    /**
     * The metadata is a general information concerning the referendum.
     * The `Hash` refers to the preimage of the `Preimages` provider which can be a JSON
     * dump or IPFS hash of a JSON file.
     *
     * Consider a garbage collection for a metadata of finished referendums to `unrequest` (remove)
     * large preimages.
     *
     * @param {number} arg
     * @param {Callback<H256 | undefined> =} callback
     **/
    metadataOf: GenericStorageQuery<(arg: number) => H256 | undefined, number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Whitelist`'s storage queries
   **/
  whitelist: {
    /**
     *
     * @param {H256} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    whitelistedCall: GenericStorageQuery<(arg: H256) => [] | undefined, H256>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Dispatcher`'s storage queries
   **/
  dispatcher: {
    /**
     *
     * @param {Callback<AccountId32> =} callback
     **/
    aaveManagerAccount: GenericStorageQuery<() => AccountId32>;

    /**
     *
     * @param {Callback<bigint> =} callback
     **/
    extraGas: GenericStorageQuery<() => bigint>;

    /**
     *
     * @param {Callback<EvmCoreErrorExitReason | undefined> =} callback
     **/
    lastEvmCallExitReason: GenericStorageQuery<() => EvmCoreErrorExitReason | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `AssetRegistry`'s storage queries
   **/
  assetRegistry: {
    /**
     * Details of an asset.
     *
     * @param {number} arg
     * @param {Callback<PalletAssetRegistryAssetDetails | undefined> =} callback
     **/
    assets: GenericStorageQuery<(arg: number) => PalletAssetRegistryAssetDetails | undefined, number>;

    /**
     * Next available asset id. This is sequential id assigned for each new registered asset.
     *
     * @param {Callback<number> =} callback
     **/
    nextAssetId: GenericStorageQuery<() => number>;

    /**
     * Mapping between asset name and asset id.
     *
     * @param {BytesLike} arg
     * @param {Callback<number | undefined> =} callback
     **/
    assetIds: GenericStorageQuery<(arg: BytesLike) => number | undefined, Bytes>;

    /**
     * Native location of an asset.
     *
     * @param {number} arg
     * @param {Callback<HydradxRuntimeXcmAssetLocation | undefined> =} callback
     **/
    assetLocations: GenericStorageQuery<(arg: number) => HydradxRuntimeXcmAssetLocation | undefined, number>;

    /**
     * Non-native assets which transfer is banned.
     *
     * @param {number} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    bannedAssets: GenericStorageQuery<(arg: number) => [] | undefined, number>;

    /**
     * Local asset for native location.
     *
     * @param {HydradxRuntimeXcmAssetLocation} arg
     * @param {Callback<number | undefined> =} callback
     **/
    locationAssets: GenericStorageQuery<
      (arg: HydradxRuntimeXcmAssetLocation) => number | undefined,
      HydradxRuntimeXcmAssetLocation
    >;

    /**
     * Number of accounts that paid existential deposits for insufficient assets.
     * This storage is used by `SufficiencyCheck`.
     *
     * @param {Callback<bigint> =} callback
     **/
    existentialDepositCounter: GenericStorageQuery<() => bigint>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Claims`'s storage queries
   **/
  claims: {
    /**
     * Asset id storage for each shared token
     *
     * @param {PalletClaimsEthereumAddress} arg
     * @param {Callback<bigint> =} callback
     **/
    claims: GenericStorageQuery<(arg: PalletClaimsEthereumAddress) => bigint, PalletClaimsEthereumAddress>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `GenesisHistory`'s storage queries
   **/
  genesisHistory: {
    /**
     *
     * @param {Callback<PalletGenesisHistoryChain> =} callback
     **/
    previousChain: GenericStorageQuery<() => PalletGenesisHistoryChain>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `CollatorRewards`'s storage queries
   **/
  collatorRewards: {
    /**
     * Stores the collators per session (index).
     *
     * @param {number} arg
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    collators: GenericStorageQuery<(arg: number) => Array<AccountId32>, number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Omnipool`'s storage queries
   **/
  omnipool: {
    /**
     * State of an asset in the omnipool
     *
     * @param {number} arg
     * @param {Callback<PalletOmnipoolAssetState | undefined> =} callback
     **/
    assets: GenericStorageQuery<(arg: number) => PalletOmnipoolAssetState | undefined, number>;

    /**
     * Tradable state of hub asset.
     *
     * @param {Callback<PalletOmnipoolTradability> =} callback
     **/
    hubAssetTradability: GenericStorageQuery<() => PalletOmnipoolTradability>;

    /**
     * LP positions. Maps NFT instance id to corresponding position
     *
     * @param {bigint} arg
     * @param {Callback<PalletOmnipoolPosition | undefined> =} callback
     **/
    positions: GenericStorageQuery<(arg: bigint) => PalletOmnipoolPosition | undefined, bigint>;

    /**
     * Position ids sequencer
     *
     * @param {Callback<bigint> =} callback
     **/
    nextPositionId: GenericStorageQuery<() => bigint>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `TransactionPause`'s storage queries
   **/
  transactionPause: {
    /**
     * The paused transaction map
     *
     * map (PalletNameBytes, FunctionNameBytes) => Option<()>
     *
     * @param {[BytesLike, BytesLike]} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    pausedTransactions: GenericStorageQuery<(arg: [BytesLike, BytesLike]) => [] | undefined, [Bytes, Bytes]>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Duster`'s storage queries
   **/
  duster: {
    /**
     * Accounts excluded from dusting.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    accountWhitelist: GenericStorageQuery<(arg: AccountId32Like) => [] | undefined, AccountId32>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `OmnipoolWarehouseLM`'s storage queries
   **/
  omnipoolWarehouseLM: {
    /**
     * Id sequencer for `GlobalFarm` and `YieldFarm`.
     *
     * @param {Callback<number> =} callback
     **/
    farmSequencer: GenericStorageQuery<() => number>;

    /**
     *
     * @param {Callback<bigint> =} callback
     **/
    depositSequencer: GenericStorageQuery<() => bigint>;

    /**
     *
     * @param {number} arg
     * @param {Callback<PalletLiquidityMiningGlobalFarmData | undefined> =} callback
     **/
    globalFarm: GenericStorageQuery<(arg: number) => PalletLiquidityMiningGlobalFarmData | undefined, number>;

    /**
     * Yield farm details.
     *
     * @param {[number, number, number]} arg
     * @param {Callback<PalletLiquidityMiningYieldFarmData | undefined> =} callback
     **/
    yieldFarm: GenericStorageQuery<
      (arg: [number, number, number]) => PalletLiquidityMiningYieldFarmData | undefined,
      [number, number, number]
    >;

    /**
     * Deposit details.
     *
     * @param {bigint} arg
     * @param {Callback<PalletLiquidityMiningDepositData | undefined> =} callback
     **/
    deposit: GenericStorageQuery<(arg: bigint) => PalletLiquidityMiningDepositData | undefined, bigint>;

    /**
     * Active(farms able to receive LP shares deposits) yield farms.
     *
     * @param {[number, number]} arg
     * @param {Callback<number | undefined> =} callback
     **/
    activeYieldFarm: GenericStorageQuery<(arg: [number, number]) => number | undefined, [number, number]>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `OmnipoolLiquidityMining`'s storage queries
   **/
  omnipoolLiquidityMining: {
    /**
     * Map of omnipool position's ids to LM's deposit ids.
     *
     * @param {bigint} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    omniPositionId: GenericStorageQuery<(arg: bigint) => bigint | undefined, bigint>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `OTC`'s storage queries
   **/
  otc: {
    /**
     * ID sequencer for Orders
     *
     * @param {Callback<number> =} callback
     **/
    nextOrderId: GenericStorageQuery<() => number>;

    /**
     *
     * @param {number} arg
     * @param {Callback<PalletOtcOrder | undefined> =} callback
     **/
    orders: GenericStorageQuery<(arg: number) => PalletOtcOrder | undefined, number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `CircuitBreaker`'s storage queries
   **/
  circuitBreaker: {
    /**
     * Trade volume limits of assets set by set_trade_volume_limit.
     * If not set, returns the default limit.
     *
     * @param {number} arg
     * @param {Callback<[number, number]> =} callback
     **/
    tradeVolumeLimitPerAsset: GenericStorageQuery<(arg: number) => [number, number], number>;

    /**
     * Trade volumes per asset
     *
     * @param {number} arg
     * @param {Callback<PalletCircuitBreakerTradeVolumeLimit | undefined> =} callback
     **/
    allowedTradeVolumeLimitPerAsset: GenericStorageQuery<
      (arg: number) => PalletCircuitBreakerTradeVolumeLimit | undefined,
      number
    >;

    /**
     * Liquidity limits of assets for adding liquidity.
     * If not set, returns the default limit.
     *
     * @param {number} arg
     * @param {Callback<[number, number] | undefined> =} callback
     **/
    liquidityAddLimitPerAsset: GenericStorageQuery<(arg: number) => [number, number] | undefined, number>;

    /**
     * Add liquidity volumes per asset
     *
     * @param {number} arg
     * @param {Callback<PalletCircuitBreakerLiquidityLimit | undefined> =} callback
     **/
    allowedAddLiquidityAmountPerAsset: GenericStorageQuery<
      (arg: number) => PalletCircuitBreakerLiquidityLimit | undefined,
      number
    >;

    /**
     *
     * @param {number} arg
     * @param {Callback<PalletCircuitBreakerLockdownStatus | undefined> =} callback
     **/
    assetLockdownState: GenericStorageQuery<(arg: number) => PalletCircuitBreakerLockdownStatus | undefined, number>;

    /**
     * Liquidity limits of assets for removing liquidity.
     * If not set, returns the default limit.
     *
     * @param {number} arg
     * @param {Callback<[number, number] | undefined> =} callback
     **/
    liquidityRemoveLimitPerAsset: GenericStorageQuery<(arg: number) => [number, number] | undefined, number>;

    /**
     * Remove liquidity volumes per asset
     *
     * @param {number} arg
     * @param {Callback<PalletCircuitBreakerLiquidityLimit | undefined> =} callback
     **/
    allowedRemoveLiquidityAmountPerAsset: GenericStorageQuery<
      (arg: number) => PalletCircuitBreakerLiquidityLimit | undefined,
      number
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Router`'s storage queries
   **/
  router: {
    /**
     * Storing routes for asset pairs
     *
     * @param {HydradxTraitsRouterAssetPair} arg
     * @param {Callback<Array<HydradxTraitsRouterTrade> | undefined> =} callback
     **/
    routes: GenericStorageQuery<
      (arg: HydradxTraitsRouterAssetPair) => Array<HydradxTraitsRouterTrade> | undefined,
      HydradxTraitsRouterAssetPair
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `DynamicFees`'s storage queries
   **/
  dynamicFees: {
    /**
     * Stores last calculated fee of an asset and block number in which it was changed..
     * Stored as (Asset fee, Protocol fee, Block number)
     *
     * @param {number} arg
     * @param {Callback<PalletDynamicFeesFeeEntry | undefined> =} callback
     **/
    assetFee: GenericStorageQuery<(arg: number) => PalletDynamicFeesFeeEntry | undefined, number>;

    /**
     * Stores per-asset fee configuration (Fixed or Dynamic)
     *
     * @param {number} arg
     * @param {Callback<PalletDynamicFeesAssetFeeConfig | undefined> =} callback
     **/
    assetFeeConfiguration: GenericStorageQuery<(arg: number) => PalletDynamicFeesAssetFeeConfig | undefined, number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Staking`'s storage queries
   **/
  staking: {
    /**
     * Global staking state.
     *
     * @param {Callback<PalletStakingStakingData> =} callback
     **/
    staking: GenericStorageQuery<() => PalletStakingStakingData>;

    /**
     * User's position state.
     *
     * @param {bigint} arg
     * @param {Callback<PalletStakingPosition | undefined> =} callback
     **/
    positions: GenericStorageQuery<(arg: bigint) => PalletStakingPosition | undefined, bigint>;

    /**
     * Position ids sequencer.
     *
     * @param {Callback<bigint> =} callback
     **/
    nextPositionId: GenericStorageQuery<() => bigint>;

    /**
     * List of position votes.
     *
     * @param {bigint} arg
     * @param {Callback<PalletStakingVoting> =} callback
     **/
    votes: GenericStorageQuery<(arg: bigint) => PalletStakingVoting, bigint>;

    /**
     * List of processed vote. Used to determine if the vote should be locked in case of voting not in favor.
     *
     * @param {[AccountId32Like, number]} arg
     * @param {Callback<PalletStakingVote | undefined> =} callback
     **/
    votesRewarded: GenericStorageQuery<
      (arg: [AccountId32Like, number]) => PalletStakingVote | undefined,
      [AccountId32, number]
    >;

    /**
     * Legacy storage! - Used to handle democracy votes until democracy pallet is fully removed.
     *
     * @param {bigint} arg
     * @param {Callback<PalletStakingVoting> =} callback
     **/
    positionVotes: GenericStorageQuery<(arg: bigint) => PalletStakingVoting, bigint>;

    /**
     * Legacy storage! - Used to handle democracy processed votes until democracy pallet is fully removed.
     *
     * @param {[AccountId32Like, number]} arg
     * @param {Callback<PalletStakingVote | undefined> =} callback
     **/
    processedVotes: GenericStorageQuery<
      (arg: [AccountId32Like, number]) => PalletStakingVote | undefined,
      [AccountId32, number]
    >;

    /**
     * Block number when we switched to 6 sec. blocks.
     *
     * @param {Callback<number> =} callback
     **/
    sixSecBlocksSince: GenericStorageQuery<() => number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Stableswap`'s storage queries
   **/
  stableswap: {
    /**
     * Existing pools
     *
     * @param {number} arg
     * @param {Callback<PalletStableswapPoolInfo | undefined> =} callback
     **/
    pools: GenericStorageQuery<(arg: number) => PalletStableswapPoolInfo | undefined, number>;

    /**
     * Pool peg info.
     *
     * @param {number} arg
     * @param {Callback<PalletStableswapPoolPegInfo | undefined> =} callback
     **/
    poolPegs: GenericStorageQuery<(arg: number) => PalletStableswapPoolPegInfo | undefined, number>;

    /**
     * Tradability state of pool assets.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletStableswapTradability> =} callback
     **/
    assetTradability: GenericStorageQuery<(arg: [number, number]) => PalletStableswapTradability, [number, number]>;

    /**
     * Temporary pool state storage. Used to save a state of pool in a single block.
     *
     * @param {number} arg
     * @param {Callback<PalletStableswapPoolSnapshot | undefined> =} callback
     **/
    poolSnapshots: GenericStorageQuery<(arg: number) => PalletStableswapPoolSnapshot | undefined, number>;

    /**
     * Temporary pool's trade fee for current block.
     *
     * @param {number} arg
     * @param {Callback<Permill | undefined> =} callback
     **/
    blockFee: GenericStorageQuery<(arg: number) => Permill | undefined, number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Bonds`'s storage queries
   **/
  bonds: {
    /**
     * Registered bond ids.
     * Maps (underlying asset ID, maturity) -> bond ID
     *
     * @param {[number, bigint]} arg
     * @param {Callback<number | undefined> =} callback
     **/
    bondIds: GenericStorageQuery<(arg: [number, bigint]) => number | undefined, [number, bigint]>;

    /**
     * Registered bonds.
     * Maps bond ID -> (underlying asset ID, maturity)
     *
     * @param {number} arg
     * @param {Callback<[number, bigint] | undefined> =} callback
     **/
    bonds: GenericStorageQuery<(arg: number) => [number, bigint] | undefined, number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `LBP`'s storage queries
   **/
  lbp: {
    /**
     * Details of a pool.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletLbpPool | undefined> =} callback
     **/
    poolData: GenericStorageQuery<(arg: AccountId32Like) => PalletLbpPool | undefined, AccountId32>;

    /**
     * Storage used for tracking existing fee collectors
     * Not more than one fee collector per asset possible
     *
     * @param {[AccountId32Like, number]} arg
     * @param {Callback<boolean> =} callback
     **/
    feeCollectorWithAsset: GenericStorageQuery<(arg: [AccountId32Like, number]) => boolean, [AccountId32, number]>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `XYK`'s storage queries
   **/
  xyk: {
    /**
     * Asset id storage for shared pool tokens
     *
     * @param {AccountId32Like} arg
     * @param {Callback<number> =} callback
     **/
    shareToken: GenericStorageQuery<(arg: AccountId32Like) => number, AccountId32>;

    /**
     * Total liquidity in a pool.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<bigint> =} callback
     **/
    totalLiquidity: GenericStorageQuery<(arg: AccountId32Like) => bigint, AccountId32>;

    /**
     * Asset pair in a pool.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[number, number] | undefined> =} callback
     **/
    poolAssets: GenericStorageQuery<(arg: AccountId32Like) => [number, number] | undefined, AccountId32>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Referrals`'s storage queries
   **/
  referrals: {
    /**
     * Referral codes
     * Maps a referral code to an account.
     *
     * @param {BytesLike} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    referralCodes: GenericStorageQuery<(arg: BytesLike) => AccountId32 | undefined, Bytes>;

    /**
     * Referral accounts
     * Maps an account to a referral code.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    referralAccounts: GenericStorageQuery<(arg: AccountId32Like) => Bytes | undefined, AccountId32>;

    /**
     * Linked accounts.
     * Maps an account to a referral account.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    linkedAccounts: GenericStorageQuery<(arg: AccountId32Like) => AccountId32 | undefined, AccountId32>;

    /**
     * Shares of a referral account
     *
     * @param {AccountId32Like} arg
     * @param {Callback<bigint> =} callback
     **/
    referrerShares: GenericStorageQuery<(arg: AccountId32Like) => bigint, AccountId32>;

    /**
     * Shares of a trader account
     *
     * @param {AccountId32Like} arg
     * @param {Callback<bigint> =} callback
     **/
    traderShares: GenericStorageQuery<(arg: AccountId32Like) => bigint, AccountId32>;

    /**
     * Total share issuance.
     *
     * @param {Callback<bigint> =} callback
     **/
    totalShares: GenericStorageQuery<() => bigint>;

    /**
     * Referer level and total accumulated rewards over time.
     * Maps referrer account to (Level, Balance). Level indicates current rewards and Balance is used to unlock next level.
     * Dev note: we use OptionQuery here because this helps to easily determine that an account if referrer account.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[PalletReferralsLevel, bigint] | undefined> =} callback
     **/
    referrer: GenericStorageQuery<(arg: AccountId32Like) => [PalletReferralsLevel, bigint] | undefined, AccountId32>;

    /**
     * Asset fee distribution rewards information.
     * Maps (asset_id, level) to asset reward percentages.
     *
     * @param {[number, PalletReferralsLevel]} arg
     * @param {Callback<PalletReferralsFeeDistribution | undefined> =} callback
     **/
    assetRewards: GenericStorageQuery<
      (arg: [number, PalletReferralsLevel]) => PalletReferralsFeeDistribution | undefined,
      [number, PalletReferralsLevel]
    >;

    /**
     * Information about assets that are currently in the rewards pot.
     * Used to easily determine list of assets that need to be converted.
     *
     * @param {number} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    pendingConversions: GenericStorageQuery<(arg: number) => [] | undefined, number>;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForPendingConversions: GenericStorageQuery<() => number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Liquidation`'s storage queries
   **/
  liquidation: {
    /**
     * Borrowing market contract address
     *
     * @param {Callback<H160> =} callback
     **/
    borrowingContract: GenericStorageQuery<() => H160>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `HSM`'s storage queries
   **/
  hsm: {
    /**
     * List of approved assets that Hollar can be purchased with
     *
     * This storage maps asset IDs to their collateral configuration information.
     * Only assets in this map can be used to mint or redeem Hollar through HSM.
     * Each collateral has specific parameters controlling its usage in the HSM mechanism.
     *
     * @param {number} arg
     * @param {Callback<PalletHsmCollateralInfo | undefined> =} callback
     **/
    collaterals: GenericStorageQuery<(arg: number) => PalletHsmCollateralInfo | undefined, number>;

    /**
     * Amount of Hollar bought with an asset in a single block
     *
     * This storage tracks how much Hollar has been bought back by HSM for each collateral
     * asset within the current block. This is used to enforce rate limiting on Hollar redemptions.
     * Values are reset to zero at the end of each block in on_finalize.
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    hollarAmountReceived: GenericStorageQuery<(arg: number) => bigint, number>;

    /**
     * Address of the flash loan receiver.
     *
     * @param {Callback<H160 | undefined> =} callback
     **/
    flashMinter: GenericStorageQuery<() => H160 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Parameters`'s storage queries
   **/
  parameters: {
    /**
     *
     * @param {Callback<boolean> =} callback
     **/
    isTestnet: GenericStorageQuery<() => boolean>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Signet`'s storage queries
   **/
  signet: {
    /**
     * The admin account that controls this pallet
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    admin: GenericStorageQuery<() => AccountId32 | undefined>;

    /**
     * The amount required as deposit for signature requests
     *
     * @param {Callback<bigint> =} callback
     **/
    signatureDeposit: GenericStorageQuery<() => bigint>;

    /**
     * The CAIP-2 chain identifier
     *
     * @param {Callback<Bytes> =} callback
     **/
    chainId: GenericStorageQuery<() => Bytes>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `EthDispenser`'s storage queries
   **/
  ethDispenser: {
    /**
     * Global configuration for the dispenser.
     *
     * Currently only tracks whether the pallet is paused. If `None`, defaults
     * to unpaused.
     *
     * @param {Callback<PalletDispenserDispenserConfigData | undefined> =} callback
     **/
    dispenserConfig: GenericStorageQuery<() => PalletDispenserDispenserConfigData | undefined>;

    /**
     * Tracked ETH balance (in wei) currently available in the external faucet.
     *
     * This value is updated manually via governance and is used as a guardrail
     * to prevent issuing requests that would over-spend the faucet.
     *
     * @param {Callback<bigint> =} callback
     **/
    faucetBalanceWei: GenericStorageQuery<() => bigint>;

    /**
     * Request IDs that have already been used.
     *
     * This prevents accidental or malicious re-submission of the same request.
     *
     * @param {FixedBytes<32>} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    usedRequestIds: GenericStorageQuery<(arg: FixedBytes<32>) => [] | undefined, FixedBytes<32>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Tokens`'s storage queries
   **/
  tokens: {
    /**
     * The total issuance of a token type.
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    totalIssuance: GenericStorageQuery<(arg: number) => bigint, number>;

    /**
     * Any liquidity locks of a token type under an account.
     * NOTE: Should only be accessed when setting, changing and freeing a lock.
     *
     * @param {[AccountId32Like, number]} arg
     * @param {Callback<Array<OrmlTokensBalanceLock>> =} callback
     **/
    locks: GenericStorageQuery<(arg: [AccountId32Like, number]) => Array<OrmlTokensBalanceLock>, [AccountId32, number]>;

    /**
     * The balance of a token type under an account.
     *
     * NOTE: If the total is ever zero, decrease account ref account.
     *
     * NOTE: This is only used in the case that this module is used to store
     * balances.
     *
     * @param {[AccountId32Like, number]} arg
     * @param {Callback<OrmlTokensAccountData> =} callback
     **/
    accounts: GenericStorageQuery<(arg: [AccountId32Like, number]) => OrmlTokensAccountData, [AccountId32, number]>;

    /**
     * Named reserves on some account balances.
     *
     * @param {[AccountId32Like, number]} arg
     * @param {Callback<Array<OrmlTokensReserveData>> =} callback
     **/
    reserves: GenericStorageQuery<
      (arg: [AccountId32Like, number]) => Array<OrmlTokensReserveData>,
      [AccountId32, number]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Vesting`'s storage queries
   **/
  vesting: {
    /**
     * Vesting schedules of an account.
     *
     * VestingSchedules: map AccountId => Vec<VestingSchedule>
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<OrmlVestingVestingSchedule>> =} callback
     **/
    vestingSchedules: GenericStorageQuery<(arg: AccountId32Like) => Array<OrmlVestingVestingSchedule>, AccountId32>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `EVM`'s storage queries
   **/
  evm: {
    /**
     *
     * @param {H160} arg
     * @param {Callback<Bytes> =} callback
     **/
    accountCodes: GenericStorageQuery<(arg: H160) => Bytes, H160>;

    /**
     *
     * @param {H160} arg
     * @param {Callback<PalletEvmCodeMetadata | undefined> =} callback
     **/
    accountCodesMetadata: GenericStorageQuery<(arg: H160) => PalletEvmCodeMetadata | undefined, H160>;

    /**
     *
     * @param {[H160, H256]} arg
     * @param {Callback<H256> =} callback
     **/
    accountStorages: GenericStorageQuery<(arg: [H160, H256]) => H256, [H160, H256]>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `EVMChainId`'s storage queries
   **/
  evmChainId: {
    /**
     * The EVM chain ID.
     *
     * @param {Callback<bigint> =} callback
     **/
    chainId: GenericStorageQuery<() => bigint>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Ethereum`'s storage queries
   **/
  ethereum: {
    /**
     * Mapping from transaction index to transaction in the current building block.
     *
     * @param {number} arg
     * @param {Callback<[EthereumTransactionTransactionV3, FpRpcTransactionStatus, EthereumReceiptReceiptV4] | undefined> =} callback
     **/
    pending: GenericStorageQuery<
      (arg: number) => [EthereumTransactionTransactionV3, FpRpcTransactionStatus, EthereumReceiptReceiptV4] | undefined,
      number
    >;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForPending: GenericStorageQuery<() => number>;

    /**
     * The current Ethereum block.
     *
     * @param {Callback<EthereumBlock | undefined> =} callback
     **/
    currentBlock: GenericStorageQuery<() => EthereumBlock | undefined>;

    /**
     * The current Ethereum receipts.
     *
     * @param {Callback<Array<EthereumReceiptReceiptV4> | undefined> =} callback
     **/
    currentReceipts: GenericStorageQuery<() => Array<EthereumReceiptReceiptV4> | undefined>;

    /**
     * The current transaction statuses.
     *
     * @param {Callback<Array<FpRpcTransactionStatus> | undefined> =} callback
     **/
    currentTransactionStatuses: GenericStorageQuery<() => Array<FpRpcTransactionStatus> | undefined>;

    /**
     *
     * @param {U256} arg
     * @param {Callback<H256> =} callback
     **/
    blockHash: GenericStorageQuery<(arg: U256) => H256, U256>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `EVMAccounts`'s storage queries
   **/
  evmAccounts: {
    /**
     * Maps an EVM address to the last 12 bytes of a substrate account.
     *
     * @param {H160} arg
     * @param {Callback<FixedBytes<12> | undefined> =} callback
     **/
    accountExtension: GenericStorageQuery<(arg: H160) => FixedBytes<12> | undefined, H160>;

    /**
     * Whitelisted addresses that are allowed to deploy smart contracts.
     *
     * @param {H160} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    contractDeployer: GenericStorageQuery<(arg: H160) => [] | undefined, H160>;

    /**
     * Whitelisted contracts that are allowed to manage balances and tokens.
     *
     * @param {H160} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    approvedContract: GenericStorageQuery<(arg: H160) => [] | undefined, H160>;

    /**
     * Tracks accounts that have been marked as EVM accounts.
     * An account is marked as EVM account right before we charge the evm fee
     * This is used to avoid resetting frame system nonce of accounts.
     * When we mark account as EVM account, we increase its sufficients counter by one.
     * We never decrease this sufficients, so side effect is that account can never be reaped
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    markedEvmAccounts: GenericStorageQuery<(arg: AccountId32Like) => [] | undefined, AccountId32>;

    /**
     * ERC20-style allowances storage for the MultiCurrency precompile:
     * (asset_id, owner, spender) -> allowance
     *
     * @param {[number, H160, H160]} arg
     * @param {Callback<bigint> =} callback
     **/
    allowances: GenericStorageQuery<(arg: [number, H160, H160]) => bigint, [number, H160, H160]>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `DynamicEvmFee`'s storage queries
   **/
  dynamicEvmFee: {
    /**
     * Base fee per gas
     *
     * @param {Callback<U256> =} callback
     **/
    baseFeePerGas: GenericStorageQuery<() => U256>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `XYKWarehouseLM`'s storage queries
   **/
  xykWarehouseLM: {
    /**
     * Id sequencer for `GlobalFarm` and `YieldFarm`.
     *
     * @param {Callback<number> =} callback
     **/
    farmSequencer: GenericStorageQuery<() => number>;

    /**
     *
     * @param {Callback<bigint> =} callback
     **/
    depositSequencer: GenericStorageQuery<() => bigint>;

    /**
     *
     * @param {number} arg
     * @param {Callback<PalletLiquidityMiningGlobalFarmData | undefined> =} callback
     **/
    globalFarm: GenericStorageQuery<(arg: number) => PalletLiquidityMiningGlobalFarmData | undefined, number>;

    /**
     * Yield farm details.
     *
     * @param {[AccountId32Like, number, number]} arg
     * @param {Callback<PalletLiquidityMiningYieldFarmData | undefined> =} callback
     **/
    yieldFarm: GenericStorageQuery<
      (arg: [AccountId32Like, number, number]) => PalletLiquidityMiningYieldFarmData | undefined,
      [AccountId32, number, number]
    >;

    /**
     * Deposit details.
     *
     * @param {bigint} arg
     * @param {Callback<PalletLiquidityMiningDepositData002 | undefined> =} callback
     **/
    deposit: GenericStorageQuery<(arg: bigint) => PalletLiquidityMiningDepositData002 | undefined, bigint>;

    /**
     * Active(farms able to receive LP shares deposits) yield farms.
     *
     * @param {[AccountId32Like, number]} arg
     * @param {Callback<number | undefined> =} callback
     **/
    activeYieldFarm: GenericStorageQuery<(arg: [AccountId32Like, number]) => number | undefined, [AccountId32, number]>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `DCA`'s storage queries
   **/
  dca: {
    /**
     * Id sequencer for schedules
     *
     * @param {Callback<number> =} callback
     **/
    scheduleIdSequencer: GenericStorageQuery<() => number>;

    /**
     * Storing schedule details
     *
     * @param {number} arg
     * @param {Callback<PalletDcaSchedule | undefined> =} callback
     **/
    schedules: GenericStorageQuery<(arg: number) => PalletDcaSchedule | undefined, number>;

    /**
     * Storing schedule ownership
     *
     * @param {[AccountId32Like, number]} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    scheduleOwnership: GenericStorageQuery<(arg: [AccountId32Like, number]) => [] | undefined, [AccountId32, number]>;

    /**
     * Keep tracking the remaining amounts to spend for DCA schedules
     *
     * @param {number} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    remainingAmounts: GenericStorageQuery<(arg: number) => bigint | undefined, number>;

    /**
     * Keep tracking the retry on error flag for DCA schedules
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    retriesOnError: GenericStorageQuery<(arg: number) => number, number>;

    /**
     * Keep tracking the blocknumber when the schedule is planned to be executed
     *
     * @param {number} arg
     * @param {Callback<number | undefined> =} callback
     **/
    scheduleExecutionBlock: GenericStorageQuery<(arg: number) => number | undefined, number>;

    /**
     * Keep tracking of the schedule ids to be executed in the block
     *
     * @param {number} arg
     * @param {Callback<Array<number>> =} callback
     **/
    scheduleIdsPerBlock: GenericStorageQuery<(arg: number) => Array<number>, number>;

    /**
     * Stores the current extra gas value for each schedule.
     * Initialized to 0, increments on EvmOutOfGas, persists after successful execution.
     * Cleaned up when schedule terminates or completes.
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    scheduleExtraGas: GenericStorageQuery<(arg: number) => bigint, number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Scheduler`'s storage queries
   **/
  scheduler: {
    /**
     * Block number at which the agenda began incomplete execution.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    incompleteSince: GenericStorageQuery<() => number | undefined>;

    /**
     * Items to be executed, indexed by the block number that they should be executed on.
     *
     * @param {number} arg
     * @param {Callback<Array<PalletSchedulerScheduled | undefined>> =} callback
     **/
    agenda: GenericStorageQuery<(arg: number) => Array<PalletSchedulerScheduled | undefined>, number>;

    /**
     * Retry configurations for items to be executed, indexed by task address.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletSchedulerRetryConfig | undefined> =} callback
     **/
    retries: GenericStorageQuery<(arg: [number, number]) => PalletSchedulerRetryConfig | undefined, [number, number]>;

    /**
     * Lookup from a name to the block number and index of the task.
     *
     * For v3 -> v4 the previously unbounded identities are Blake2-256 hashed to form the v4
     * identities.
     *
     * @param {FixedBytes<32>} arg
     * @param {Callback<[number, number] | undefined> =} callback
     **/
    lookup: GenericStorageQuery<(arg: FixedBytes<32>) => [number, number] | undefined, FixedBytes<32>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `ParachainSystem`'s storage queries
   **/
  parachainSystem: {
    /**
     * Latest included block descendants the runtime accepted. In other words, these are
     * ancestors of the currently executing block which have not been included in the observed
     * relay-chain state.
     *
     * The segment length is limited by the capacity returned from the [`ConsensusHook`] configured
     * in the pallet.
     *
     * @param {Callback<Array<CumulusPalletParachainSystemUnincludedSegmentAncestor>> =} callback
     **/
    unincludedSegment: GenericStorageQuery<() => Array<CumulusPalletParachainSystemUnincludedSegmentAncestor>>;

    /**
     * Storage field that keeps track of bandwidth used by the unincluded segment along with the
     * latest HRMP watermark. Used for limiting the acceptance of new blocks with
     * respect to relay chain constraints.
     *
     * @param {Callback<CumulusPalletParachainSystemUnincludedSegmentSegmentTracker | undefined> =} callback
     **/
    aggregatedUnincludedSegment: GenericStorageQuery<
      () => CumulusPalletParachainSystemUnincludedSegmentSegmentTracker | undefined
    >;

    /**
     * In case of a scheduled upgrade, this storage field contains the validation code to be
     * applied.
     *
     * As soon as the relay chain gives us the go-ahead signal, we will overwrite the
     * [`:code`][sp_core::storage::well_known_keys::CODE] which will result the next block process
     * with the new validation code. This concludes the upgrade process.
     *
     * @param {Callback<Bytes> =} callback
     **/
    pendingValidationCode: GenericStorageQuery<() => Bytes>;

    /**
     * Validation code that is set by the parachain and is to be communicated to collator and
     * consequently the relay-chain.
     *
     * This will be cleared in `on_initialize` of each new block if no other pallet already set
     * the value.
     *
     * @param {Callback<Bytes | undefined> =} callback
     **/
    newValidationCode: GenericStorageQuery<() => Bytes | undefined>;

    /**
     * The [`PersistedValidationData`] set for this block.
     * This value is expected to be set only once per block and it's never stored
     * in the trie.
     *
     * @param {Callback<PolkadotPrimitivesV8PersistedValidationData | undefined> =} callback
     **/
    validationData: GenericStorageQuery<() => PolkadotPrimitivesV8PersistedValidationData | undefined>;

    /**
     * Were the validation data set to notify the relay chain?
     *
     * @param {Callback<boolean> =} callback
     **/
    didSetValidationCode: GenericStorageQuery<() => boolean>;

    /**
     * The relay chain block number associated with the last parachain block.
     *
     * This is updated in `on_finalize`.
     *
     * @param {Callback<number> =} callback
     **/
    lastRelayChainBlockNumber: GenericStorageQuery<() => number>;

    /**
     * An option which indicates if the relay-chain restricts signalling a validation code upgrade.
     * In other words, if this is `Some` and [`NewValidationCode`] is `Some` then the produced
     * candidate will be invalid.
     *
     * This storage item is a mirror of the corresponding value for the current parachain from the
     * relay-chain. This value is ephemeral which means it doesn't hit the storage. This value is
     * set after the inherent.
     *
     * @param {Callback<PolkadotPrimitivesV8UpgradeRestriction | undefined> =} callback
     **/
    upgradeRestrictionSignal: GenericStorageQuery<() => PolkadotPrimitivesV8UpgradeRestriction | undefined>;

    /**
     * Optional upgrade go-ahead signal from the relay-chain.
     *
     * This storage item is a mirror of the corresponding value for the current parachain from the
     * relay-chain. This value is ephemeral which means it doesn't hit the storage. This value is
     * set after the inherent.
     *
     * @param {Callback<PolkadotPrimitivesV8UpgradeGoAhead | undefined> =} callback
     **/
    upgradeGoAhead: GenericStorageQuery<() => PolkadotPrimitivesV8UpgradeGoAhead | undefined>;

    /**
     * The state proof for the last relay parent block.
     *
     * This field is meant to be updated each block with the validation data inherent. Therefore,
     * before processing of the inherent, e.g. in `on_initialize` this data may be stale.
     *
     * This data is also absent from the genesis.
     *
     * @param {Callback<SpTrieStorageProof | undefined> =} callback
     **/
    relayStateProof: GenericStorageQuery<() => SpTrieStorageProof | undefined>;

    /**
     * The snapshot of some state related to messaging relevant to the current parachain as per
     * the relay parent.
     *
     * This field is meant to be updated each block with the validation data inherent. Therefore,
     * before processing of the inherent, e.g. in `on_initialize` this data may be stale.
     *
     * This data is also absent from the genesis.
     *
     * @param {Callback<CumulusPalletParachainSystemRelayStateSnapshotMessagingStateSnapshot | undefined> =} callback
     **/
    relevantMessagingState: GenericStorageQuery<
      () => CumulusPalletParachainSystemRelayStateSnapshotMessagingStateSnapshot | undefined
    >;

    /**
     * The parachain host configuration that was obtained from the relay parent.
     *
     * This field is meant to be updated each block with the validation data inherent. Therefore,
     * before processing of the inherent, e.g. in `on_initialize` this data may be stale.
     *
     * This data is also absent from the genesis.
     *
     * @param {Callback<PolkadotPrimitivesV8AbridgedHostConfiguration | undefined> =} callback
     **/
    hostConfiguration: GenericStorageQuery<() => PolkadotPrimitivesV8AbridgedHostConfiguration | undefined>;

    /**
     * The last downward message queue chain head we have observed.
     *
     * This value is loaded before and saved after processing inbound downward messages carried
     * by the system inherent.
     *
     * @param {Callback<CumulusPrimitivesParachainInherentMessageQueueChain> =} callback
     **/
    lastDmqMqcHead: GenericStorageQuery<() => CumulusPrimitivesParachainInherentMessageQueueChain>;

    /**
     * The message queue chain heads we have observed per each channel incoming channel.
     *
     * This value is loaded before and saved after processing inbound downward messages carried
     * by the system inherent.
     *
     * @param {Callback<Array<[PolkadotParachainPrimitivesPrimitivesId, CumulusPrimitivesParachainInherentMessageQueueChain]>> =} callback
     **/
    lastHrmpMqcHeads: GenericStorageQuery<
      () => Array<[PolkadotParachainPrimitivesPrimitivesId, CumulusPrimitivesParachainInherentMessageQueueChain]>
    >;

    /**
     * Number of downward messages processed in a block.
     *
     * This will be cleared in `on_initialize` of each new block.
     *
     * @param {Callback<number> =} callback
     **/
    processedDownwardMessages: GenericStorageQuery<() => number>;

    /**
     * HRMP watermark that was set in a block.
     *
     * This will be cleared in `on_initialize` of each new block.
     *
     * @param {Callback<number> =} callback
     **/
    hrmpWatermark: GenericStorageQuery<() => number>;

    /**
     * HRMP messages that were sent in a block.
     *
     * This will be cleared in `on_initialize` of each new block.
     *
     * @param {Callback<Array<PolkadotCorePrimitivesOutboundHrmpMessage>> =} callback
     **/
    hrmpOutboundMessages: GenericStorageQuery<() => Array<PolkadotCorePrimitivesOutboundHrmpMessage>>;

    /**
     * Upward messages that were sent in a block.
     *
     * This will be cleared in `on_initialize` of each new block.
     *
     * @param {Callback<Array<Bytes>> =} callback
     **/
    upwardMessages: GenericStorageQuery<() => Array<Bytes>>;

    /**
     * Upward messages that are still pending and not yet send to the relay chain.
     *
     * @param {Callback<Array<Bytes>> =} callback
     **/
    pendingUpwardMessages: GenericStorageQuery<() => Array<Bytes>>;

    /**
     * The factor to multiply the base delivery fee by for UMP.
     *
     * @param {Callback<FixedU128> =} callback
     **/
    upwardDeliveryFeeFactor: GenericStorageQuery<() => FixedU128>;

    /**
     * The number of HRMP messages we observed in `on_initialize` and thus used that number for
     * announcing the weight of `on_initialize` and `on_finalize`.
     *
     * @param {Callback<number> =} callback
     **/
    announcedHrmpMessagesPerCandidate: GenericStorageQuery<() => number>;

    /**
     * The weight we reserve at the beginning of the block for processing XCMP messages. This
     * overrides the amount set in the Config trait.
     *
     * @param {Callback<SpWeightsWeightV2Weight | undefined> =} callback
     **/
    reservedXcmpWeightOverride: GenericStorageQuery<() => SpWeightsWeightV2Weight | undefined>;

    /**
     * The weight we reserve at the beginning of the block for processing DMP messages. This
     * overrides the amount set in the Config trait.
     *
     * @param {Callback<SpWeightsWeightV2Weight | undefined> =} callback
     **/
    reservedDmpWeightOverride: GenericStorageQuery<() => SpWeightsWeightV2Weight | undefined>;

    /**
     * A custom head data that should be returned as result of `validate_block`.
     *
     * See `Pallet::set_custom_validation_head_data` for more information.
     *
     * @param {Callback<Bytes | undefined> =} callback
     **/
    customValidationHeadData: GenericStorageQuery<() => Bytes | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `ParachainInfo`'s storage queries
   **/
  parachainInfo: {
    /**
     *
     * @param {Callback<PolkadotParachainPrimitivesPrimitivesId> =} callback
     **/
    parachainId: GenericStorageQuery<() => PolkadotParachainPrimitivesPrimitivesId>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `PolkadotXcm`'s storage queries
   **/
  polkadotXcm: {
    /**
     * The latest available query index.
     *
     * @param {Callback<bigint> =} callback
     **/
    queryCounter: GenericStorageQuery<() => bigint>;

    /**
     * The ongoing queries.
     *
     * @param {bigint} arg
     * @param {Callback<PalletXcmQueryStatus | undefined> =} callback
     **/
    queries: GenericStorageQuery<(arg: bigint) => PalletXcmQueryStatus | undefined, bigint>;

    /**
     * The existing asset traps.
     *
     * Key is the blake2 256 hash of (origin, versioned `Assets`) pair. Value is the number of
     * times this pair has been trapped (usually just 1 if it exists at all).
     *
     * @param {H256} arg
     * @param {Callback<number> =} callback
     **/
    assetTraps: GenericStorageQuery<(arg: H256) => number, H256>;

    /**
     * Default version to encode XCM when latest version of destination is unknown. If `None`,
     * then the destinations whose XCM version is unknown are considered unreachable.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    safeXcmVersion: GenericStorageQuery<() => number | undefined>;

    /**
     * The Latest versions that we know various locations support.
     *
     * @param {[number, XcmVersionedLocation]} arg
     * @param {Callback<number | undefined> =} callback
     **/
    supportedVersion: GenericStorageQuery<
      (arg: [number, XcmVersionedLocation]) => number | undefined,
      [number, XcmVersionedLocation]
    >;

    /**
     * All locations that we have requested version notifications from.
     *
     * @param {[number, XcmVersionedLocation]} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    versionNotifiers: GenericStorageQuery<
      (arg: [number, XcmVersionedLocation]) => bigint | undefined,
      [number, XcmVersionedLocation]
    >;

    /**
     * The target locations that are subscribed to our version changes, as well as the most recent
     * of our versions we informed them of.
     *
     * @param {[number, XcmVersionedLocation]} arg
     * @param {Callback<[bigint, SpWeightsWeightV2Weight, number] | undefined> =} callback
     **/
    versionNotifyTargets: GenericStorageQuery<
      (arg: [number, XcmVersionedLocation]) => [bigint, SpWeightsWeightV2Weight, number] | undefined,
      [number, XcmVersionedLocation]
    >;

    /**
     * Destinations whose latest XCM version we would like to know. Duplicates not allowed, and
     * the `u32` counter is the number of times that a send to the destination has been attempted,
     * which is used as a prioritization.
     *
     * @param {Callback<Array<[XcmVersionedLocation, number]>> =} callback
     **/
    versionDiscoveryQueue: GenericStorageQuery<() => Array<[XcmVersionedLocation, number]>>;

    /**
     * The current migration's stage, if any.
     *
     * @param {Callback<PalletXcmVersionMigrationStage | undefined> =} callback
     **/
    currentMigration: GenericStorageQuery<() => PalletXcmVersionMigrationStage | undefined>;

    /**
     * Fungible assets which we know are locked on a remote chain.
     *
     * @param {[number, AccountId32Like, XcmVersionedAssetId]} arg
     * @param {Callback<PalletXcmRemoteLockedFungibleRecord | undefined> =} callback
     **/
    remoteLockedFungibles: GenericStorageQuery<
      (arg: [number, AccountId32Like, XcmVersionedAssetId]) => PalletXcmRemoteLockedFungibleRecord | undefined,
      [number, AccountId32, XcmVersionedAssetId]
    >;

    /**
     * Fungible assets which we know are locked on this chain.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<[bigint, XcmVersionedLocation]> | undefined> =} callback
     **/
    lockedFungibles: GenericStorageQuery<
      (arg: AccountId32Like) => Array<[bigint, XcmVersionedLocation]> | undefined,
      AccountId32
    >;

    /**
     * Global suspension state of the XCM executor.
     *
     * @param {Callback<boolean> =} callback
     **/
    xcmExecutionSuspended: GenericStorageQuery<() => boolean>;

    /**
     * Whether or not incoming XCMs (both executed locally and received) should be recorded.
     * Only one XCM program will be recorded at a time.
     * This is meant to be used in runtime APIs, and it's advised it stays false
     * for all other use cases, so as to not degrade regular performance.
     *
     * Only relevant if this pallet is being used as the [`xcm_executor::traits::RecordXcm`]
     * implementation in the XCM executor configuration.
     *
     * @param {Callback<boolean> =} callback
     **/
    shouldRecordXcm: GenericStorageQuery<() => boolean>;

    /**
     * If [`ShouldRecordXcm`] is set to true, then the last XCM program executed locally
     * will be stored here.
     * Runtime APIs can fetch the XCM that was executed by accessing this value.
     *
     * Only relevant if this pallet is being used as the [`xcm_executor::traits::RecordXcm`]
     * implementation in the XCM executor configuration.
     *
     * @param {Callback<StagingXcmV5Xcm | undefined> =} callback
     **/
    recordedXcm: GenericStorageQuery<() => StagingXcmV5Xcm | undefined>;

    /**
     * Map of authorized aliasers of local origins. Each local location can authorize a list of
     * other locations to alias into it. Each aliaser is only valid until its inner `expiry`
     * block number.
     *
     * @param {XcmVersionedLocation} arg
     * @param {Callback<PalletXcmAuthorizedAliasesEntry | undefined> =} callback
     **/
    authorizedAliases: GenericStorageQuery<
      (arg: XcmVersionedLocation) => PalletXcmAuthorizedAliasesEntry | undefined,
      XcmVersionedLocation
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `XcmpQueue`'s storage queries
   **/
  xcmpQueue: {
    /**
     * The suspended inbound XCMP channels. All others are not suspended.
     *
     * This is a `StorageValue` instead of a `StorageMap` since we expect multiple reads per block
     * to different keys with a one byte payload. The access to `BoundedBTreeSet` will be cached
     * within the block and therefore only included once in the proof size.
     *
     * NOTE: The PoV benchmarking cannot know this and will over-estimate, but the actual proof
     * will be smaller.
     *
     * @param {Callback<Array<PolkadotParachainPrimitivesPrimitivesId>> =} callback
     **/
    inboundXcmpSuspended: GenericStorageQuery<() => Array<PolkadotParachainPrimitivesPrimitivesId>>;

    /**
     * The non-empty XCMP channels in order of becoming non-empty, and the index of the first
     * and last outbound message. If the two indices are equal, then it indicates an empty
     * queue and there must be a non-`Ok` `OutboundStatus`. We assume queues grow no greater
     * than 65535 items. Queue indices for normal messages begin at one; zero is reserved in
     * case of the need to send a high-priority signal message this block.
     * The bool is true if there is a signal message waiting to be sent.
     *
     * @param {Callback<Array<CumulusPalletXcmpQueueOutboundChannelDetails>> =} callback
     **/
    outboundXcmpStatus: GenericStorageQuery<() => Array<CumulusPalletXcmpQueueOutboundChannelDetails>>;

    /**
     * The messages outbound in a given XCMP channel.
     *
     * @param {[PolkadotParachainPrimitivesPrimitivesId, number]} arg
     * @param {Callback<Bytes> =} callback
     **/
    outboundXcmpMessages: GenericStorageQuery<
      (arg: [PolkadotParachainPrimitivesPrimitivesId, number]) => Bytes,
      [PolkadotParachainPrimitivesPrimitivesId, number]
    >;

    /**
     * Any signal messages waiting to be sent.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<Bytes> =} callback
     **/
    signalMessages: GenericStorageQuery<
      (arg: PolkadotParachainPrimitivesPrimitivesId) => Bytes,
      PolkadotParachainPrimitivesPrimitivesId
    >;

    /**
     * The configuration which controls the dynamics of the outbound queue.
     *
     * @param {Callback<CumulusPalletXcmpQueueQueueConfigData> =} callback
     **/
    queueConfig: GenericStorageQuery<() => CumulusPalletXcmpQueueQueueConfigData>;

    /**
     * Whether or not the XCMP queue is suspended from executing incoming XCMs or not.
     *
     * @param {Callback<boolean> =} callback
     **/
    queueSuspended: GenericStorageQuery<() => boolean>;

    /**
     * The factor to multiply the base delivery fee by.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<FixedU128> =} callback
     **/
    deliveryFeeFactor: GenericStorageQuery<
      (arg: PolkadotParachainPrimitivesPrimitivesId) => FixedU128,
      PolkadotParachainPrimitivesPrimitivesId
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `MessageQueue`'s storage queries
   **/
  messageQueue: {
    /**
     * The index of the first and last (non-empty) pages.
     *
     * @param {CumulusPrimitivesCoreAggregateMessageOrigin} arg
     * @param {Callback<PalletMessageQueueBookState> =} callback
     **/
    bookStateFor: GenericStorageQuery<
      (arg: CumulusPrimitivesCoreAggregateMessageOrigin) => PalletMessageQueueBookState,
      CumulusPrimitivesCoreAggregateMessageOrigin
    >;

    /**
     * The origin at which we should begin servicing.
     *
     * @param {Callback<CumulusPrimitivesCoreAggregateMessageOrigin | undefined> =} callback
     **/
    serviceHead: GenericStorageQuery<() => CumulusPrimitivesCoreAggregateMessageOrigin | undefined>;

    /**
     * The map of page indices to pages.
     *
     * @param {[CumulusPrimitivesCoreAggregateMessageOrigin, number]} arg
     * @param {Callback<PalletMessageQueuePage | undefined> =} callback
     **/
    pages: GenericStorageQuery<
      (arg: [CumulusPrimitivesCoreAggregateMessageOrigin, number]) => PalletMessageQueuePage | undefined,
      [CumulusPrimitivesCoreAggregateMessageOrigin, number]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `MultiBlockMigrations`'s storage queries
   **/
  multiBlockMigrations: {
    /**
     * The currently active migration to run and its cursor.
     *
     * `None` indicates that no migration is running.
     *
     * @param {Callback<PalletMigrationsMigrationCursor | undefined> =} callback
     **/
    cursor: GenericStorageQuery<() => PalletMigrationsMigrationCursor | undefined>;

    /**
     * Set of all successfully executed migrations.
     *
     * This is used as blacklist, to not re-execute migrations that have not been removed from the
     * codebase yet. Governance can regularly clear this out via `clear_historic`.
     *
     * @param {BytesLike} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    historic: GenericStorageQuery<(arg: BytesLike) => [] | undefined, Bytes>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `UnknownTokens`'s storage queries
   **/
  unknownTokens: {
    /**
     * Concrete fungible balances under a given location and a concrete
     * fungible id.
     *
     * double_map: who, asset_id => u128
     *
     * @param {[StagingXcmV5Location, StagingXcmV5Location]} arg
     * @param {Callback<bigint> =} callback
     **/
    concreteFungibleBalances: GenericStorageQuery<
      (arg: [StagingXcmV5Location, StagingXcmV5Location]) => bigint,
      [StagingXcmV5Location, StagingXcmV5Location]
    >;

    /**
     * Abstract fungible balances under a given location and a abstract
     * fungible id.
     *
     * double_map: who, asset_id => u128
     *
     * @param {[StagingXcmV5Location, BytesLike]} arg
     * @param {Callback<bigint> =} callback
     **/
    abstractFungibleBalances: GenericStorageQuery<
      (arg: [StagingXcmV5Location, BytesLike]) => bigint,
      [StagingXcmV5Location, Bytes]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Authorship`'s storage queries
   **/
  authorship: {
    /**
     * Author of current block.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    author: GenericStorageQuery<() => AccountId32 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `CollatorSelection`'s storage queries
   **/
  collatorSelection: {
    /**
     * The invulnerable, permissioned collators. This list must be sorted.
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    invulnerables: GenericStorageQuery<() => Array<AccountId32>>;

    /**
     * The (community, limited) collation candidates. `Candidates` and `Invulnerables` should be
     * mutually exclusive.
     *
     * This list is sorted in ascending order by deposit and when the deposits are equal, the least
     * recently updated is considered greater.
     *
     * @param {Callback<Array<PalletCollatorSelectionCandidateInfo>> =} callback
     **/
    candidateList: GenericStorageQuery<() => Array<PalletCollatorSelectionCandidateInfo>>;

    /**
     * Last block authored by collator.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<number> =} callback
     **/
    lastAuthoredBlock: GenericStorageQuery<(arg: AccountId32Like) => number, AccountId32>;

    /**
     * Desired number of candidates.
     *
     * This should ideally always be less than [`Config::MaxCandidates`] for weights to be correct.
     *
     * @param {Callback<number> =} callback
     **/
    desiredCandidates: GenericStorageQuery<() => number>;

    /**
     * Fixed amount to deposit to become a collator.
     *
     * When a collator calls `leave_intent` they immediately receive the deposit back.
     *
     * @param {Callback<bigint> =} callback
     **/
    candidacyBond: GenericStorageQuery<() => bigint>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Session`'s storage queries
   **/
  session: {
    /**
     * The current set of validators.
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    validators: GenericStorageQuery<() => Array<AccountId32>>;

    /**
     * Current index of the session.
     *
     * @param {Callback<number> =} callback
     **/
    currentIndex: GenericStorageQuery<() => number>;

    /**
     * True if the underlying economic identities or weighting behind the validators
     * has changed in the queued validator set.
     *
     * @param {Callback<boolean> =} callback
     **/
    queuedChanged: GenericStorageQuery<() => boolean>;

    /**
     * The queued keys for the next session. When the next session begins, these keys
     * will be used to determine the validator's session keys.
     *
     * @param {Callback<Array<[AccountId32, HydradxRuntimeOpaqueSessionKeys]>> =} callback
     **/
    queuedKeys: GenericStorageQuery<() => Array<[AccountId32, HydradxRuntimeOpaqueSessionKeys]>>;

    /**
     * Indices of disabled validators.
     *
     * The vec is always kept sorted so that we can find whether a given validator is
     * disabled using binary search. It gets cleared when `on_session_ending` returns
     * a new set of identities.
     *
     * @param {Callback<Array<[number, SpStakingOffenceOffenceSeverity]>> =} callback
     **/
    disabledValidators: GenericStorageQuery<() => Array<[number, SpStakingOffenceOffenceSeverity]>>;

    /**
     * The next session keys for a validator.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<HydradxRuntimeOpaqueSessionKeys | undefined> =} callback
     **/
    nextKeys: GenericStorageQuery<(arg: AccountId32Like) => HydradxRuntimeOpaqueSessionKeys | undefined, AccountId32>;

    /**
     * The owner of a key. The key is the `KeyTypeId` + the encoded key.
     *
     * @param {[SpCoreCryptoKeyTypeId, BytesLike]} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    keyOwner: GenericStorageQuery<
      (arg: [SpCoreCryptoKeyTypeId, BytesLike]) => AccountId32 | undefined,
      [SpCoreCryptoKeyTypeId, Bytes]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Aura`'s storage queries
   **/
  aura: {
    /**
     * The current authority set.
     *
     * @param {Callback<Array<SpConsensusAuraSr25519AppSr25519Public>> =} callback
     **/
    authorities: GenericStorageQuery<() => Array<SpConsensusAuraSr25519AppSr25519Public>>;

    /**
     * The current slot of this block.
     *
     * This will be set in `on_initialize`.
     *
     * @param {Callback<SpConsensusSlotsSlot> =} callback
     **/
    currentSlot: GenericStorageQuery<() => SpConsensusSlotsSlot>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `AuraExt`'s storage queries
   **/
  auraExt: {
    /**
     * Serves as cache for the authorities.
     *
     * The authorities in AuRa are overwritten in `on_initialize` when we switch to a new session,
     * but we require the old authorities to verify the seal when validating a PoV. This will
     * always be updated to the latest AuRa authorities in `on_finalize`.
     *
     * @param {Callback<Array<SpConsensusAuraSr25519AppSr25519Public>> =} callback
     **/
    authorities: GenericStorageQuery<() => Array<SpConsensusAuraSr25519AppSr25519Public>>;

    /**
     * Current relay chain slot paired with a number of authored blocks.
     *
     * This is updated in [`FixedVelocityConsensusHook::on_state_proof`] with the current relay
     * chain slot as provided by the relay chain state proof.
     *
     * @param {Callback<[SpConsensusSlotsSlot, number] | undefined> =} callback
     **/
    relaySlotInfo: GenericStorageQuery<() => [SpConsensusSlotsSlot, number] | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `EmaOracle`'s storage queries
   **/
  emaOracle: {
    /**
     * Accumulator for oracle data in current block that will be recorded at the end of the block.
     *
     * @param {Callback<Array<[[FixedBytes<8>, [number, number]], PalletEmaOracleOracleEntry]>> =} callback
     **/
    accumulator: GenericStorageQuery<() => Array<[[FixedBytes<8>, [number, number]], PalletEmaOracleOracleEntry]>>;

    /**
     * Oracle storage keyed by data source, involved asset ids and the period length of the oracle.
     *
     * Stores the data entry as well as the block number when the oracle was first initialized.
     *
     * @param {[FixedBytes<8>, [number, number], HydradxTraitsOracleOraclePeriod]} arg
     * @param {Callback<[PalletEmaOracleOracleEntry, number] | undefined> =} callback
     **/
    oracles: GenericStorageQuery<
      (
        arg: [FixedBytes<8>, [number, number], HydradxTraitsOracleOraclePeriod],
      ) => [PalletEmaOracleOracleEntry, number] | undefined,
      [FixedBytes<8>, [number, number], HydradxTraitsOracleOraclePeriod]
    >;

    /**
     * Assets that are whitelisted and tracked by the pallet.
     *
     * @param {Callback<Array<[FixedBytes<8>, [number, number]]>> =} callback
     **/
    whitelistedAssets: GenericStorageQuery<() => Array<[FixedBytes<8>, [number, number]]>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
  /**
   * Pallet `Broadcast`'s storage queries
   **/
  broadcast: {
    /**
     * Next available incremental ID
     *
     * @param {Callback<number> =} callback
     **/
    incrementalId: GenericStorageQuery<() => number>;

    /**
     * Execution context to figure out where the trade is originated from
     *
     * @param {Callback<Array<PalletBroadcastExecutionType>> =} callback
     **/
    executionContext: GenericStorageQuery<() => Array<PalletBroadcastExecutionType>>;

    /**
     * If filled, we overwrite the original swapper. Mainly used in router to not to use temporary trade account
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    swapper: GenericStorageQuery<() => AccountId32 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery;
  };
}
