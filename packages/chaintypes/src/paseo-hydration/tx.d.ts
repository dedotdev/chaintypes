// Generated by dedot cli

import type {
  GenericChainTx,
  GenericTxCall,
  GenericChainKnownTypes,
  ISubmittableExtrinsic,
  ISubmittableResult,
  IRuntimeTxCall,
} from 'dedot/types';
import type {
  AccountId32Like,
  Extrinsic,
  BytesLike,
  H256,
  FixedU128,
  H160,
  U256,
  Data,
  FixedBytes,
  Permill,
  Perquintill,
  Perbill,
} from 'dedot/codecs';
import type {
  HydradxRuntimeRuntimeCallLike,
  SpRuntimeMultiSignature,
  FrameSystemEventRecord,
  PalletBalancesAdjustmentDirection,
  HydradxRuntimeOriginCaller,
  SpWeightsWeightV2Weight,
  PalletIdentityLegacyIdentityInfo,
  PalletIdentityJudgement,
  FrameSupportPreimagesBounded,
  PalletDemocracyVoteAccountVote,
  PalletDemocracyConviction,
  PalletDemocracyMetadataOwner,
  HydradxRuntimeSystemProxyType,
  PalletMultisigTimepoint,
  PalletUniquesDestroyWitness,
  PalletStateTrieMigrationMigrationLimits,
  PalletStateTrieMigrationMigrationTask,
  PalletStateTrieMigrationProgress,
  PalletConvictionVotingVoteAccountVote,
  PalletConvictionVotingConviction,
  FrameSupportScheduleDispatchTime,
  PalletAssetRegistryAssetType,
  HydradxRuntimeXcmAssetLocation,
  PalletClaimsEcdsaSignature,
  PalletOmnipoolTradability,
  PalletLiquidityMiningLoyaltyCurve,
  HydradxTraitsStableswapAssetAmount,
  HydradxTraitsRouterTrade,
  HydradxTraitsRouterAssetPair,
  PalletDynamicFeesAssetFeeConfig,
  PalletStableswapTradability,
  PalletStableswapPegSource,
  PalletLbpWeightCurveType,
  PalletReferralsLevel,
  PalletReferralsFeeDistribution,
  PalletHsmArbitrage,
  PalletSignetSignature,
  PalletSignetErrorResponse,
  PalletDispenserEvmTransactionParams,
  OrmlVestingVestingSchedule,
  EthereumTransactionEip7702AuthorizationListItem,
  EthereumTransactionTransactionV3,
  PalletXykAssetPair,
  PalletDcaSchedule,
  CumulusPrimitivesParachainInherentParachainInherentData,
  XcmVersionedLocation,
  XcmVersionedXcm,
  XcmVersionedAssets,
  StagingXcmV5Location,
  XcmV3WeightLimit,
  StagingXcmExecutorAssetTransferTransferType,
  XcmVersionedAssetId,
  CumulusPrimitivesCoreAggregateMessageOrigin,
  PalletMigrationsMigrationCursor,
  PalletMigrationsHistoricCleanupSelector,
  XcmVersionedAsset,
  HydradxRuntimeOpaqueSessionKeys,
} from './types.js';

export type ChainSubmittableExtrinsic<
  T extends IRuntimeTxCall = HydradxRuntimeRuntimeCallLike,
  ChainKnownTypes extends GenericChainKnownTypes = GenericChainKnownTypes,
> = Extrinsic<AccountId32Like, T, SpRuntimeMultiSignature, ChainKnownTypes['Extra']> &
  ISubmittableExtrinsic<ISubmittableResult<FrameSystemEventRecord>, ChainKnownTypes['AssetId']>;

export type TxCall<ChainKnownTypes extends GenericChainKnownTypes = GenericChainKnownTypes> = (
  ...args: any[]
) => ChainSubmittableExtrinsic<HydradxRuntimeRuntimeCallLike, ChainKnownTypes>;

export interface ChainTx<
  ChainKnownTypes extends GenericChainKnownTypes = GenericChainKnownTypes,
> extends GenericChainTx<TxCall<ChainKnownTypes>> {
  /**
   * Pallet `System`'s transaction calls
   **/
  system: {
    /**
     * Make some on-chain remark.
     *
     * Can be executed by every `origin`.
     *
     * @param {BytesLike} remark
     **/
    remark: GenericTxCall<
      (remark: BytesLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'System';
          palletCall: {
            name: 'Remark';
            params: { remark: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the number of pages in the WebAssembly environment's heap.
     *
     * @param {bigint} pages
     **/
    setHeapPages: GenericTxCall<
      (pages: bigint) => ChainSubmittableExtrinsic<
        {
          pallet: 'System';
          palletCall: {
            name: 'SetHeapPages';
            params: { pages: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the new runtime code.
     *
     * @param {BytesLike} code
     **/
    setCode: GenericTxCall<
      (code: BytesLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'System';
          palletCall: {
            name: 'SetCode';
            params: { code: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the new runtime code without doing any checks of the given `code`.
     *
     * Note that runtime upgrades will not run if this is called with a not-increasing spec
     * version!
     *
     * @param {BytesLike} code
     **/
    setCodeWithoutChecks: GenericTxCall<
      (code: BytesLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'System';
          palletCall: {
            name: 'SetCodeWithoutChecks';
            params: { code: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set some items of storage.
     *
     * @param {Array<[BytesLike, BytesLike]>} items
     **/
    setStorage: GenericTxCall<
      (items: Array<[BytesLike, BytesLike]>) => ChainSubmittableExtrinsic<
        {
          pallet: 'System';
          palletCall: {
            name: 'SetStorage';
            params: { items: Array<[BytesLike, BytesLike]> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Kill some items from storage.
     *
     * @param {Array<BytesLike>} keys
     **/
    killStorage: GenericTxCall<
      (keys: Array<BytesLike>) => ChainSubmittableExtrinsic<
        {
          pallet: 'System';
          palletCall: {
            name: 'KillStorage';
            params: { keys: Array<BytesLike> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Kill all storage items with a key that starts with the given prefix.
     *
     * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
     * the prefix we are removing to accurately calculate the weight of this function.
     *
     * @param {BytesLike} prefix
     * @param {number} subkeys
     **/
    killPrefix: GenericTxCall<
      (
        prefix: BytesLike,
        subkeys: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'System';
          palletCall: {
            name: 'KillPrefix';
            params: { prefix: BytesLike; subkeys: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Make some on-chain remark and emit event.
     *
     * @param {BytesLike} remark
     **/
    remarkWithEvent: GenericTxCall<
      (remark: BytesLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'System';
          palletCall: {
            name: 'RemarkWithEvent';
            params: { remark: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
     * later.
     *
     * This call requires Root origin.
     *
     * @param {H256} codeHash
     **/
    authorizeUpgrade: GenericTxCall<
      (codeHash: H256) => ChainSubmittableExtrinsic<
        {
          pallet: 'System';
          palletCall: {
            name: 'AuthorizeUpgrade';
            params: { codeHash: H256 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
     * later.
     *
     * WARNING: This authorizes an upgrade that will take place without any safety checks, for
     * example that the spec name remains the same and that the version number increases. Not
     * recommended for normal use. Use `authorize_upgrade` instead.
     *
     * This call requires Root origin.
     *
     * @param {H256} codeHash
     **/
    authorizeUpgradeWithoutChecks: GenericTxCall<
      (codeHash: H256) => ChainSubmittableExtrinsic<
        {
          pallet: 'System';
          palletCall: {
            name: 'AuthorizeUpgradeWithoutChecks';
            params: { codeHash: H256 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Provide the preimage (runtime binary) `code` for an upgrade that has been authorized.
     *
     * If the authorization required a version check, this call will ensure the spec name
     * remains unchanged and that the spec version has increased.
     *
     * Depending on the runtime's `OnSetCode` configuration, this function may directly apply
     * the new `code` in the same block or attempt to schedule the upgrade.
     *
     * All origins are allowed.
     *
     * @param {BytesLike} code
     **/
    applyAuthorizedUpgrade: GenericTxCall<
      (code: BytesLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'System';
          palletCall: {
            name: 'ApplyAuthorizedUpgrade';
            params: { code: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Timestamp`'s transaction calls
   **/
  timestamp: {
    /**
     * Set the current time.
     *
     * This call should be invoked exactly once per block. It will panic at the finalization
     * phase, if this call hasn't been invoked by that time.
     *
     * The timestamp should be greater than the previous one by the amount specified by
     * [`Config::MinimumPeriod`].
     *
     * The dispatch origin for this call must be _None_.
     *
     * This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware
     * that changing the complexity of this call could result exhausting the resources in a
     * block to execute any other calls.
     *
     * ## Complexity
     * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
     * - 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in
     * `on_finalize`)
     * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
     *
     * @param {bigint} now
     **/
    set: GenericTxCall<
      (now: bigint) => ChainSubmittableExtrinsic<
        {
          pallet: 'Timestamp';
          palletCall: {
            name: 'Set';
            params: { now: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Balances`'s transaction calls
   **/
  balances: {
    /**
     * Transfer some liquid free balance to another account.
     *
     * `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
     * If the sender's account is below the existential deposit as a result
     * of the transfer, the account will be reaped.
     *
     * The dispatch origin for this call must be `Signed` by the transactor.
     *
     * @param {AccountId32Like} dest
     * @param {bigint} value
     **/
    transferAllowDeath: GenericTxCall<
      (
        dest: AccountId32Like,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Balances';
          palletCall: {
            name: 'TransferAllowDeath';
            params: { dest: AccountId32Like; value: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Exactly as `transfer_allow_death`, except the origin must be root and the source account
     * may be specified.
     *
     * @param {AccountId32Like} source
     * @param {AccountId32Like} dest
     * @param {bigint} value
     **/
    forceTransfer: GenericTxCall<
      (
        source: AccountId32Like,
        dest: AccountId32Like,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Balances';
          palletCall: {
            name: 'ForceTransfer';
            params: { source: AccountId32Like; dest: AccountId32Like; value: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
     * kill the origin account.
     *
     * 99% of the time you want [`transfer_allow_death`] instead.
     *
     * [`transfer_allow_death`]: struct.Pallet.html#method.transfer
     *
     * @param {AccountId32Like} dest
     * @param {bigint} value
     **/
    transferKeepAlive: GenericTxCall<
      (
        dest: AccountId32Like,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Balances';
          palletCall: {
            name: 'TransferKeepAlive';
            params: { dest: AccountId32Like; value: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Transfer the entire transferable balance from the caller account.
     *
     * NOTE: This function only attempts to transfer _transferable_ balances. This means that
     * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
     * transferred by this function. To ensure that this function results in a killed account,
     * you might need to prepare the account by removing any reference counters, storage
     * deposits, etc...
     *
     * The dispatch origin of this call must be Signed.
     *
     * - `dest`: The recipient of the transfer.
     * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
     * of the funds the account has, causing the sender account to be killed (false), or
     * transfer everything except at least the existential deposit, which will guarantee to
     * keep the sender account alive (true).
     *
     * @param {AccountId32Like} dest
     * @param {boolean} keepAlive
     **/
    transferAll: GenericTxCall<
      (
        dest: AccountId32Like,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Balances';
          palletCall: {
            name: 'TransferAll';
            params: { dest: AccountId32Like; keepAlive: boolean };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Unreserve some balance from a user by force.
     *
     * Can only be called by ROOT.
     *
     * @param {AccountId32Like} who
     * @param {bigint} amount
     **/
    forceUnreserve: GenericTxCall<
      (
        who: AccountId32Like,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Balances';
          palletCall: {
            name: 'ForceUnreserve';
            params: { who: AccountId32Like; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Upgrade a specified account.
     *
     * - `origin`: Must be `Signed`.
     * - `who`: The account to be upgraded.
     *
     * This will waive the transaction fee if at least all but 10% of the accounts needed to
     * be upgraded. (We let some not have to be upgraded just in order to allow for the
     * possibility of churn).
     *
     * @param {Array<AccountId32Like>} who
     **/
    upgradeAccounts: GenericTxCall<
      (who: Array<AccountId32Like>) => ChainSubmittableExtrinsic<
        {
          pallet: 'Balances';
          palletCall: {
            name: 'UpgradeAccounts';
            params: { who: Array<AccountId32Like> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the regular balance of a given account.
     *
     * The dispatch origin for this call is `root`.
     *
     * @param {AccountId32Like} who
     * @param {bigint} newFree
     **/
    forceSetBalance: GenericTxCall<
      (
        who: AccountId32Like,
        newFree: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Balances';
          palletCall: {
            name: 'ForceSetBalance';
            params: { who: AccountId32Like; newFree: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Adjust the total issuance in a saturating way.
     *
     * Can only be called by root and always needs a positive `delta`.
     *
     * # Example
     *
     * @param {PalletBalancesAdjustmentDirection} direction
     * @param {bigint} delta
     **/
    forceAdjustTotalIssuance: GenericTxCall<
      (
        direction: PalletBalancesAdjustmentDirection,
        delta: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Balances';
          palletCall: {
            name: 'ForceAdjustTotalIssuance';
            params: { direction: PalletBalancesAdjustmentDirection; delta: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Burn the specified liquid free balance from the origin account.
     *
     * If the origin's account ends up below the existential deposit as a result
     * of the burn and `keep_alive` is false, the account will be reaped.
     *
     * Unlike sending funds to a _burn_ address, which merely makes the funds inaccessible,
     * this `burn` operation will reduce total issuance by the amount _burned_.
     *
     * @param {bigint} value
     * @param {boolean} keepAlive
     **/
    burn: GenericTxCall<
      (
        value: bigint,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Balances';
          palletCall: {
            name: 'Burn';
            params: { value: bigint; keepAlive: boolean };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `MultiTransactionPayment`'s transaction calls
   **/
  multiTransactionPayment: {
    /**
     * Set selected currency for given account.
     *
     * This allows to set a currency for an account in which all transaction fees will be paid.
     * Account balance cannot be zero.
     *
     * In case of sufficient asset, the chosen currency must be in the list of accepted currencies
     * In case of insufficient asset, the chosen currency must have a XYK pool with DOT
     *
     * When currency is set, fixed fee is withdrawn from the account to pay for the currency change
     *
     * EVM accounts are now allowed to change thier payment currency.
     *
     * Emits `CurrencySet` event when successful.
     *
     * @param {number} currency
     **/
    setCurrency: GenericTxCall<
      (currency: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'MultiTransactionPayment';
          palletCall: {
            name: 'SetCurrency';
            params: { currency: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Add a currency to the list of accepted currencies.
     *
     * Only member can perform this action.
     *
     * Currency must not be already accepted. Core asset id cannot be explicitly added.
     *
     * Emits `CurrencyAdded` event when successful.
     *
     * @param {number} currency
     * @param {FixedU128} price
     **/
    addCurrency: GenericTxCall<
      (
        currency: number,
        price: FixedU128,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'MultiTransactionPayment';
          palletCall: {
            name: 'AddCurrency';
            params: { currency: number; price: FixedU128 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove currency from the list of supported currencies
     * Only selected members can perform this action
     *
     * Core asset cannot be removed.
     *
     * Emits `CurrencyRemoved` when successful.
     *
     * @param {number} currency
     **/
    removeCurrency: GenericTxCall<
      (currency: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'MultiTransactionPayment';
          palletCall: {
            name: 'RemoveCurrency';
            params: { currency: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Reset currency of the specified account to HDX.
     * If the account is EVM account, the payment currency is reset to WETH.
     * Only selected members can perform this action.
     *
     * Emits `CurrencySet` when successful.
     *
     * @param {AccountId32Like} accountId
     **/
    resetPaymentCurrency: GenericTxCall<
      (accountId: AccountId32Like) => ChainSubmittableExtrinsic<
        {
          pallet: 'MultiTransactionPayment';
          palletCall: {
            name: 'ResetPaymentCurrency';
            params: { accountId: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Dispatch EVM permit.
     * The main purpose of this function is to allow EVM accounts to pay for the transaction fee in non-native currency
     * by allowing them to self-dispatch pre-signed permit.
     * The EVM fee is paid in the currency set for the account.
     *
     * @param {H160} from
     * @param {H160} to
     * @param {U256} value
     * @param {BytesLike} data
     * @param {bigint} gasLimit
     * @param {U256} deadline
     * @param {number} v
     * @param {H256} r
     * @param {H256} s
     **/
    dispatchPermit: GenericTxCall<
      (
        from: H160,
        to: H160,
        value: U256,
        data: BytesLike,
        gasLimit: bigint,
        deadline: U256,
        v: number,
        r: H256,
        s: H256,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'MultiTransactionPayment';
          palletCall: {
            name: 'DispatchPermit';
            params: {
              from: H160;
              to: H160;
              value: U256;
              data: BytesLike;
              gasLimit: bigint;
              deadline: U256;
              v: number;
              r: H256;
              s: H256;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Treasury`'s transaction calls
   **/
  treasury: {
    /**
     * Propose and approve a spend of treasury funds.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::SpendOrigin`] with the `Success` value being at least `amount`.
     *
     * ### Details
     * NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
     * beneficiary.
     *
     * ### Parameters
     * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
     * - `beneficiary`: The destination account for the transfer.
     *
     * ## Events
     *
     * Emits [`Event::SpendApproved`] if successful.
     *
     * @param {bigint} amount
     * @param {AccountId32Like} beneficiary
     **/
    spendLocal: GenericTxCall<
      (
        amount: bigint,
        beneficiary: AccountId32Like,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Treasury';
          palletCall: {
            name: 'SpendLocal';
            params: { amount: bigint; beneficiary: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Force a previously approved proposal to be removed from the approval queue.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::RejectOrigin`].
     *
     * ## Details
     *
     * The original deposit will no longer be returned.
     *
     * ### Parameters
     * - `proposal_id`: The index of a proposal
     *
     * ### Complexity
     * - O(A) where `A` is the number of approvals
     *
     * ### Errors
     * - [`Error::ProposalNotApproved`]: The `proposal_id` supplied was not found in the
     * approval queue, i.e., the proposal has not been approved. This could also mean the
     * proposal does not exist altogether, thus there is no way it would have been approved
     * in the first place.
     *
     * @param {number} proposalId
     **/
    removeApproval: GenericTxCall<
      (proposalId: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Treasury';
          palletCall: {
            name: 'RemoveApproval';
            params: { proposalId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Propose and approve a spend of treasury funds.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::SpendOrigin`] with the `Success` value being at least
     * `amount` of `asset_kind` in the native asset. The amount of `asset_kind` is converted
     * for assertion using the [`Config::BalanceConverter`].
     *
     * ## Details
     *
     * Create an approved spend for transferring a specific `amount` of `asset_kind` to a
     * designated beneficiary. The spend must be claimed using the `payout` dispatchable within
     * the [`Config::PayoutPeriod`].
     *
     * ### Parameters
     * - `asset_kind`: An indicator of the specific asset class to be spent.
     * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
     * - `beneficiary`: The beneficiary of the spend.
     * - `valid_from`: The block number from which the spend can be claimed. It can refer to
     * the past if the resulting spend has not yet expired according to the
     * [`Config::PayoutPeriod`]. If `None`, the spend can be claimed immediately after
     * approval.
     *
     * ## Events
     *
     * Emits [`Event::AssetSpendApproved`] if successful.
     *
     * @param {[]} assetKind
     * @param {bigint} amount
     * @param {AccountId32Like} beneficiary
     * @param {number | undefined} validFrom
     **/
    spend: GenericTxCall<
      (
        assetKind: [],
        amount: bigint,
        beneficiary: AccountId32Like,
        validFrom: number | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Treasury';
          palletCall: {
            name: 'Spend';
            params: { assetKind: []; amount: bigint; beneficiary: AccountId32Like; validFrom: number | undefined };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Claim a spend.
     *
     * ## Dispatch Origin
     *
     * Must be signed
     *
     * ## Details
     *
     * Spends must be claimed within some temporal bounds. A spend may be claimed within one
     * [`Config::PayoutPeriod`] from the `valid_from` block.
     * In case of a payout failure, the spend status must be updated with the `check_status`
     * dispatchable before retrying with the current function.
     *
     * ### Parameters
     * - `index`: The spend index.
     *
     * ## Events
     *
     * Emits [`Event::Paid`] if successful.
     *
     * @param {number} index
     **/
    payout: GenericTxCall<
      (index: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Treasury';
          palletCall: {
            name: 'Payout';
            params: { index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Check the status of the spend and remove it from the storage if processed.
     *
     * ## Dispatch Origin
     *
     * Must be signed.
     *
     * ## Details
     *
     * The status check is a prerequisite for retrying a failed payout.
     * If a spend has either succeeded or expired, it is removed from the storage by this
     * function. In such instances, transaction fees are refunded.
     *
     * ### Parameters
     * - `index`: The spend index.
     *
     * ## Events
     *
     * Emits [`Event::PaymentFailed`] if the spend payout has failed.
     * Emits [`Event::SpendProcessed`] if the spend payout has succeed.
     *
     * @param {number} index
     **/
    checkStatus: GenericTxCall<
      (index: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Treasury';
          palletCall: {
            name: 'CheckStatus';
            params: { index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Void previously approved spend.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::RejectOrigin`].
     *
     * ## Details
     *
     * A spend void is only possible if the payout has not been attempted yet.
     *
     * ### Parameters
     * - `index`: The spend index.
     *
     * ## Events
     *
     * Emits [`Event::AssetSpendVoided`] if successful.
     *
     * @param {number} index
     **/
    voidSpend: GenericTxCall<
      (index: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Treasury';
          palletCall: {
            name: 'VoidSpend';
            params: { index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Utility`'s transaction calls
   **/
  utility: {
    /**
     * Send a batch of dispatch calls.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     *
     * @param {Array<HydradxRuntimeRuntimeCallLike>} calls
     **/
    batch: GenericTxCall<
      (calls: Array<HydradxRuntimeRuntimeCallLike>) => ChainSubmittableExtrinsic<
        {
          pallet: 'Utility';
          palletCall: {
            name: 'Batch';
            params: { calls: Array<HydradxRuntimeRuntimeCallLike> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Send a call through an indexed pseudonym of the sender.
     *
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     *
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     *
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * @param {number} index
     * @param {HydradxRuntimeRuntimeCallLike} call
     **/
    asDerivative: GenericTxCall<
      (
        index: number,
        call: HydradxRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Utility';
          palletCall: {
            name: 'AsDerivative';
            params: { index: number; call: HydradxRuntimeRuntimeCallLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * @param {Array<HydradxRuntimeRuntimeCallLike>} calls
     **/
    batchAll: GenericTxCall<
      (calls: Array<HydradxRuntimeRuntimeCallLike>) => ChainSubmittableExtrinsic<
        {
          pallet: 'Utility';
          palletCall: {
            name: 'BatchAll';
            params: { calls: Array<HydradxRuntimeRuntimeCallLike> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Dispatches a function call with a provided origin.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {HydradxRuntimeOriginCaller} asOrigin
     * @param {HydradxRuntimeRuntimeCallLike} call
     **/
    dispatchAs: GenericTxCall<
      (
        asOrigin: HydradxRuntimeOriginCaller,
        call: HydradxRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Utility';
          palletCall: {
            name: 'DispatchAs';
            params: { asOrigin: HydradxRuntimeOriginCaller; call: HydradxRuntimeRuntimeCallLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * @param {Array<HydradxRuntimeRuntimeCallLike>} calls
     **/
    forceBatch: GenericTxCall<
      (calls: Array<HydradxRuntimeRuntimeCallLike>) => ChainSubmittableExtrinsic<
        {
          pallet: 'Utility';
          palletCall: {
            name: 'ForceBatch';
            params: { calls: Array<HydradxRuntimeRuntimeCallLike> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Dispatch a function call with a specified weight.
     *
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * @param {HydradxRuntimeRuntimeCallLike} call
     * @param {SpWeightsWeightV2Weight} weight
     **/
    withWeight: GenericTxCall<
      (
        call: HydradxRuntimeRuntimeCallLike,
        weight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Utility';
          palletCall: {
            name: 'WithWeight';
            params: { call: HydradxRuntimeRuntimeCallLike; weight: SpWeightsWeightV2Weight };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Dispatch a fallback call in the event the main call fails to execute.
     * May be called from any origin except `None`.
     *
     * This function first attempts to dispatch the `main` call.
     * If the `main` call fails, the `fallback` is attemted.
     * if the fallback is successfully dispatched, the weights of both calls
     * are accumulated and an event containing the main call error is deposited.
     *
     * In the event of a fallback failure the whole call fails
     * with the weights returned.
     *
     * - `main`: The main call to be dispatched. This is the primary action to execute.
     * - `fallback`: The fallback call to be dispatched in case the `main` call fails.
     *
     * ## Dispatch Logic
     * - If the origin is `root`, both the main and fallback calls are executed without
     * applying any origin filters.
     * - If the origin is not `root`, the origin filter is applied to both the `main` and
     * `fallback` calls.
     *
     * ## Use Case
     * - Some use cases might involve submitting a `batch` type call in either main, fallback
     * or both.
     *
     * @param {HydradxRuntimeRuntimeCallLike} main
     * @param {HydradxRuntimeRuntimeCallLike} fallback
     **/
    ifElse: GenericTxCall<
      (
        main: HydradxRuntimeRuntimeCallLike,
        fallback: HydradxRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Utility';
          palletCall: {
            name: 'IfElse';
            params: { main: HydradxRuntimeRuntimeCallLike; fallback: HydradxRuntimeRuntimeCallLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Dispatches a function call with a provided origin.
     *
     * Almost the same as [`Pallet::dispatch_as`] but forwards any error of the inner call.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * @param {HydradxRuntimeOriginCaller} asOrigin
     * @param {HydradxRuntimeRuntimeCallLike} call
     **/
    dispatchAsFallible: GenericTxCall<
      (
        asOrigin: HydradxRuntimeOriginCaller,
        call: HydradxRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Utility';
          palletCall: {
            name: 'DispatchAsFallible';
            params: { asOrigin: HydradxRuntimeOriginCaller; call: HydradxRuntimeRuntimeCallLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Preimage`'s transaction calls
   **/
  preimage: {
    /**
     * Register a preimage on-chain.
     *
     * If the preimage was previously requested, no fees or deposits are taken for providing
     * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
     *
     * @param {BytesLike} bytes
     **/
    notePreimage: GenericTxCall<
      (bytes: BytesLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'NotePreimage';
            params: { bytes: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Clear an unrequested preimage from the runtime storage.
     *
     * If `len` is provided, then it will be a much cheaper operation.
     *
     * - `hash`: The hash of the preimage to be removed from the store.
     * - `len`: The length of the preimage of `hash`.
     *
     * @param {H256} hash
     **/
    unnotePreimage: GenericTxCall<
      (hash: H256) => ChainSubmittableExtrinsic<
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'UnnotePreimage';
            params: { hash: H256 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Request a preimage be uploaded to the chain without paying any fees or deposits.
     *
     * If the preimage requests has already been provided on-chain, we unreserve any deposit
     * a user may have paid, and take the control of the preimage out of their hands.
     *
     * @param {H256} hash
     **/
    requestPreimage: GenericTxCall<
      (hash: H256) => ChainSubmittableExtrinsic<
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'RequestPreimage';
            params: { hash: H256 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Clear a previously made request for a preimage.
     *
     * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
     *
     * @param {H256} hash
     **/
    unrequestPreimage: GenericTxCall<
      (hash: H256) => ChainSubmittableExtrinsic<
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'UnrequestPreimage';
            params: { hash: H256 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Ensure that the bulk of pre-images is upgraded.
     *
     * The caller pays no fee if at least 90% of pre-images were successfully updated.
     *
     * @param {Array<H256>} hashes
     **/
    ensureUpdated: GenericTxCall<
      (hashes: Array<H256>) => ChainSubmittableExtrinsic<
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'EnsureUpdated';
            params: { hashes: Array<H256> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Identity`'s transaction calls
   **/
  identity: {
    /**
     * Add a registrar to the system.
     *
     * The dispatch origin for this call must be `T::RegistrarOrigin`.
     *
     * - `account`: the account of the registrar.
     *
     * Emits `RegistrarAdded` if successful.
     *
     * @param {AccountId32Like} account
     **/
    addRegistrar: GenericTxCall<
      (account: AccountId32Like) => ChainSubmittableExtrinsic<
        {
          pallet: 'Identity';
          palletCall: {
            name: 'AddRegistrar';
            params: { account: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set an account's identity information and reserve the appropriate deposit.
     *
     * If the account already has identity information, the deposit is taken as part payment
     * for the new deposit.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `info`: The identity information.
     *
     * Emits `IdentitySet` if successful.
     *
     * @param {PalletIdentityLegacyIdentityInfo} info
     **/
    setIdentity: GenericTxCall<
      (info: PalletIdentityLegacyIdentityInfo) => ChainSubmittableExtrinsic<
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetIdentity';
            params: { info: PalletIdentityLegacyIdentityInfo };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the sub-accounts of the sender.
     *
     * Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
     * and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * identity.
     *
     * - `subs`: The identity's (new) sub-accounts.
     *
     * @param {Array<[AccountId32Like, Data]>} subs
     **/
    setSubs: GenericTxCall<
      (subs: Array<[AccountId32Like, Data]>) => ChainSubmittableExtrinsic<
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetSubs';
            params: { subs: Array<[AccountId32Like, Data]> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Clear an account's identity info and all sub-accounts and return all deposits.
     *
     * Payment: All reserved balances on the account are returned.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * identity.
     *
     * Emits `IdentityCleared` if successful.
     *
     **/
    clearIdentity: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'Identity';
          palletCall: {
            name: 'ClearIdentity';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Request a judgement from a registrar.
     *
     * Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
     * given.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a
     * registered identity.
     *
     * - `reg_index`: The index of the registrar whose judgement is requested.
     * - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
     *
     * ```nocompile
     * Registrars::<T>::get().get(reg_index).unwrap().fee
     * ```
     *
     * Emits `JudgementRequested` if successful.
     *
     * @param {number} regIndex
     * @param {bigint} maxFee
     **/
    requestJudgement: GenericTxCall<
      (
        regIndex: number,
        maxFee: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RequestJudgement';
            params: { regIndex: number; maxFee: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Cancel a previous request.
     *
     * Payment: A previously reserved deposit is returned on success.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a
     * registered identity.
     *
     * - `reg_index`: The index of the registrar whose judgement is no longer requested.
     *
     * Emits `JudgementUnrequested` if successful.
     *
     * @param {number} regIndex
     **/
    cancelRequest: GenericTxCall<
      (regIndex: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Identity';
          palletCall: {
            name: 'CancelRequest';
            params: { regIndex: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the fee required for a judgement to be requested from a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `fee`: the new fee.
     *
     * @param {number} index
     * @param {bigint} fee
     **/
    setFee: GenericTxCall<
      (
        index: number,
        fee: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetFee';
            params: { index: number; fee: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Change the account associated with a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `new`: the new account ID.
     *
     * @param {number} index
     * @param {AccountId32Like} new_
     **/
    setAccountId: GenericTxCall<
      (
        index: number,
        new_: AccountId32Like,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetAccountId';
            params: { index: number; new: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the field information for a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `fields`: the fields that the registrar concerns themselves with.
     *
     * @param {number} index
     * @param {bigint} fields
     **/
    setFields: GenericTxCall<
      (
        index: number,
        fields: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetFields';
            params: { index: number; fields: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Provide a judgement for an account's identity.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `reg_index`.
     *
     * - `reg_index`: the index of the registrar whose judgement is being made.
     * - `target`: the account whose identity the judgement is upon. This must be an account
     * with a registered identity.
     * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
     * - `identity`: The hash of the [`IdentityInformationProvider`] for that the judgement is
     * provided.
     *
     * Note: Judgements do not apply to a username.
     *
     * Emits `JudgementGiven` if successful.
     *
     * @param {number} regIndex
     * @param {AccountId32Like} target
     * @param {PalletIdentityJudgement} judgement
     * @param {H256} identity
     **/
    provideJudgement: GenericTxCall<
      (
        regIndex: number,
        target: AccountId32Like,
        judgement: PalletIdentityJudgement,
        identity: H256,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Identity';
          palletCall: {
            name: 'ProvideJudgement';
            params: { regIndex: number; target: AccountId32Like; judgement: PalletIdentityJudgement; identity: H256 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove an account's identity and sub-account information and slash the deposits.
     *
     * Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
     * `Slash`. Verification request deposits are not returned; they should be cancelled
     * manually using `cancel_request`.
     *
     * The dispatch origin for this call must match `T::ForceOrigin`.
     *
     * - `target`: the account whose identity the judgement is upon. This must be an account
     * with a registered identity.
     *
     * Emits `IdentityKilled` if successful.
     *
     * @param {AccountId32Like} target
     **/
    killIdentity: GenericTxCall<
      (target: AccountId32Like) => ChainSubmittableExtrinsic<
        {
          pallet: 'Identity';
          palletCall: {
            name: 'KillIdentity';
            params: { target: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Add the given account to the sender's subs.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     *
     * @param {AccountId32Like} sub
     * @param {Data} data
     **/
    addSub: GenericTxCall<
      (
        sub: AccountId32Like,
        data: Data,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Identity';
          palletCall: {
            name: 'AddSub';
            params: { sub: AccountId32Like; data: Data };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Alter the associated name of the given sub-account.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     *
     * @param {AccountId32Like} sub
     * @param {Data} data
     **/
    renameSub: GenericTxCall<
      (
        sub: AccountId32Like,
        data: Data,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RenameSub';
            params: { sub: AccountId32Like; data: Data };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove the given account from the sender's subs.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     *
     * @param {AccountId32Like} sub
     **/
    removeSub: GenericTxCall<
      (sub: AccountId32Like) => ChainSubmittableExtrinsic<
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RemoveSub';
            params: { sub: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove the sender as a sub-account.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender (*not* the original depositor).
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * super-identity.
     *
     * NOTE: This should not normally be used, but is provided in the case that the non-
     * controller of an account is maliciously registered as a sub-account.
     *
     **/
    quitSub: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'Identity';
          palletCall: {
            name: 'QuitSub';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Add an `AccountId` with permission to grant usernames with a given `suffix` appended.
     *
     * The authority can grant up to `allocation` usernames. To top up the allocation or
     * change the account used to grant usernames, this call can be used with the updated
     * parameters to overwrite the existing configuration.
     *
     * @param {AccountId32Like} authority
     * @param {BytesLike} suffix
     * @param {number} allocation
     **/
    addUsernameAuthority: GenericTxCall<
      (
        authority: AccountId32Like,
        suffix: BytesLike,
        allocation: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Identity';
          palletCall: {
            name: 'AddUsernameAuthority';
            params: { authority: AccountId32Like; suffix: BytesLike; allocation: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove `authority` from the username authorities.
     *
     * @param {BytesLike} suffix
     * @param {AccountId32Like} authority
     **/
    removeUsernameAuthority: GenericTxCall<
      (
        suffix: BytesLike,
        authority: AccountId32Like,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RemoveUsernameAuthority';
            params: { suffix: BytesLike; authority: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the username for `who`. Must be called by a username authority.
     *
     * If `use_allocation` is set, the authority must have a username allocation available to
     * spend. Otherwise, the authority will need to put up a deposit for registering the
     * username.
     *
     * Users can either pre-sign their usernames or
     * accept them later.
     *
     * Usernames must:
     * - Only contain lowercase ASCII characters or digits.
     * - When combined with the suffix of the issuing authority be _less than_ the
     * `MaxUsernameLength`.
     *
     * @param {AccountId32Like} who
     * @param {BytesLike} username
     * @param {SpRuntimeMultiSignature | undefined} signature
     * @param {boolean} useAllocation
     **/
    setUsernameFor: GenericTxCall<
      (
        who: AccountId32Like,
        username: BytesLike,
        signature: SpRuntimeMultiSignature | undefined,
        useAllocation: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetUsernameFor';
            params: {
              who: AccountId32Like;
              username: BytesLike;
              signature: SpRuntimeMultiSignature | undefined;
              useAllocation: boolean;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Accept a given username that an `authority` granted. The call must include the full
     * username, as in `username.suffix`.
     *
     * @param {BytesLike} username
     **/
    acceptUsername: GenericTxCall<
      (username: BytesLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'Identity';
          palletCall: {
            name: 'AcceptUsername';
            params: { username: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove an expired username approval. The username was approved by an authority but never
     * accepted by the user and must now be beyond its expiration. The call must include the
     * full username, as in `username.suffix`.
     *
     * @param {BytesLike} username
     **/
    removeExpiredApproval: GenericTxCall<
      (username: BytesLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RemoveExpiredApproval';
            params: { username: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set a given username as the primary. The username should include the suffix.
     *
     * @param {BytesLike} username
     **/
    setPrimaryUsername: GenericTxCall<
      (username: BytesLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetPrimaryUsername';
            params: { username: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Start the process of removing a username by placing it in the unbinding usernames map.
     * Once the grace period has passed, the username can be deleted by calling
     * [remove_username](crate::Call::remove_username).
     *
     * @param {BytesLike} username
     **/
    unbindUsername: GenericTxCall<
      (username: BytesLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'Identity';
          palletCall: {
            name: 'UnbindUsername';
            params: { username: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Permanently delete a username which has been unbinding for longer than the grace period.
     * Caller is refunded the fee if the username expired and the removal was successful.
     *
     * @param {BytesLike} username
     **/
    removeUsername: GenericTxCall<
      (username: BytesLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RemoveUsername';
            params: { username: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Call with [ForceOrigin](crate::Config::ForceOrigin) privileges which deletes a username
     * and slashes any deposit associated with it.
     *
     * @param {BytesLike} username
     **/
    killUsername: GenericTxCall<
      (username: BytesLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'Identity';
          palletCall: {
            name: 'KillUsername';
            params: { username: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Democracy`'s transaction calls
   **/
  democracy: {
    /**
     * Propose a sensitive action to be taken.
     *
     * The dispatch origin of this call must be _Signed_ and the sender must
     * have funds to cover the deposit.
     *
     * - `proposal_hash`: The hash of the proposal preimage.
     * - `value`: The amount of deposit (must be at least `MinimumDeposit`).
     *
     * Emits `Proposed`.
     *
     * @param {FrameSupportPreimagesBounded} proposal
     * @param {bigint} value
     **/
    propose: GenericTxCall<
      (
        proposal: FrameSupportPreimagesBounded,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Democracy';
          palletCall: {
            name: 'Propose';
            params: { proposal: FrameSupportPreimagesBounded; value: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Signals agreement with a particular proposal.
     *
     * The dispatch origin of this call must be _Signed_ and the sender
     * must have funds to cover the deposit, equal to the original deposit.
     *
     * - `proposal`: The index of the proposal to second.
     *
     * @param {number} proposal
     **/
    second: GenericTxCall<
      (proposal: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Democracy';
          palletCall: {
            name: 'Second';
            params: { proposal: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;
     * otherwise it is a vote to keep the status quo.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `ref_index`: The index of the referendum to vote for.
     * - `vote`: The vote configuration.
     *
     * @param {number} refIndex
     * @param {PalletDemocracyVoteAccountVote} vote
     **/
    vote: GenericTxCall<
      (
        refIndex: number,
        vote: PalletDemocracyVoteAccountVote,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Democracy';
          palletCall: {
            name: 'Vote';
            params: { refIndex: number; vote: PalletDemocracyVoteAccountVote };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Schedule an emergency cancellation of a referendum. Cannot happen twice to the same
     * referendum.
     *
     * The dispatch origin of this call must be `CancellationOrigin`.
     *
     * -`ref_index`: The index of the referendum to cancel.
     *
     * Weight: `O(1)`.
     *
     * @param {number} refIndex
     **/
    emergencyCancel: GenericTxCall<
      (refIndex: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Democracy';
          palletCall: {
            name: 'EmergencyCancel';
            params: { refIndex: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Schedule a referendum to be tabled once it is legal to schedule an external
     * referendum.
     *
     * The dispatch origin of this call must be `ExternalOrigin`.
     *
     * - `proposal_hash`: The preimage hash of the proposal.
     *
     * @param {FrameSupportPreimagesBounded} proposal
     **/
    externalPropose: GenericTxCall<
      (proposal: FrameSupportPreimagesBounded) => ChainSubmittableExtrinsic<
        {
          pallet: 'Democracy';
          palletCall: {
            name: 'ExternalPropose';
            params: { proposal: FrameSupportPreimagesBounded };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Schedule a majority-carries referendum to be tabled next once it is legal to schedule
     * an external referendum.
     *
     * The dispatch of this call must be `ExternalMajorityOrigin`.
     *
     * - `proposal_hash`: The preimage hash of the proposal.
     *
     * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
     * pre-scheduled `external_propose` call.
     *
     * Weight: `O(1)`
     *
     * @param {FrameSupportPreimagesBounded} proposal
     **/
    externalProposeMajority: GenericTxCall<
      (proposal: FrameSupportPreimagesBounded) => ChainSubmittableExtrinsic<
        {
          pallet: 'Democracy';
          palletCall: {
            name: 'ExternalProposeMajority';
            params: { proposal: FrameSupportPreimagesBounded };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Schedule a negative-turnout-bias referendum to be tabled next once it is legal to
     * schedule an external referendum.
     *
     * The dispatch of this call must be `ExternalDefaultOrigin`.
     *
     * - `proposal_hash`: The preimage hash of the proposal.
     *
     * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
     * pre-scheduled `external_propose` call.
     *
     * Weight: `O(1)`
     *
     * @param {FrameSupportPreimagesBounded} proposal
     **/
    externalProposeDefault: GenericTxCall<
      (proposal: FrameSupportPreimagesBounded) => ChainSubmittableExtrinsic<
        {
          pallet: 'Democracy';
          palletCall: {
            name: 'ExternalProposeDefault';
            params: { proposal: FrameSupportPreimagesBounded };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Schedule the currently externally-proposed majority-carries referendum to be tabled
     * immediately. If there is no externally-proposed referendum currently, or if there is one
     * but it is not a majority-carries referendum then it fails.
     *
     * The dispatch of this call must be `FastTrackOrigin`.
     *
     * - `proposal_hash`: The hash of the current external proposal.
     * - `voting_period`: The period that is allowed for voting on this proposal. Increased to
     * Must be always greater than zero.
     * For `FastTrackOrigin` must be equal or greater than `FastTrackVotingPeriod`.
     * - `delay`: The number of block after voting has ended in approval and this should be
     * enacted. This doesn't have a minimum amount.
     *
     * Emits `Started`.
     *
     * Weight: `O(1)`
     *
     * @param {H256} proposalHash
     * @param {number} votingPeriod
     * @param {number} delay
     **/
    fastTrack: GenericTxCall<
      (
        proposalHash: H256,
        votingPeriod: number,
        delay: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Democracy';
          palletCall: {
            name: 'FastTrack';
            params: { proposalHash: H256; votingPeriod: number; delay: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Veto and blacklist the external proposal hash.
     *
     * The dispatch origin of this call must be `VetoOrigin`.
     *
     * - `proposal_hash`: The preimage hash of the proposal to veto and blacklist.
     *
     * Emits `Vetoed`.
     *
     * Weight: `O(V + log(V))` where V is number of `existing vetoers`
     *
     * @param {H256} proposalHash
     **/
    vetoExternal: GenericTxCall<
      (proposalHash: H256) => ChainSubmittableExtrinsic<
        {
          pallet: 'Democracy';
          palletCall: {
            name: 'VetoExternal';
            params: { proposalHash: H256 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove a referendum.
     *
     * The dispatch origin of this call must be _Root_.
     *
     * - `ref_index`: The index of the referendum to cancel.
     *
     * # Weight: `O(1)`.
     *
     * @param {number} refIndex
     **/
    cancelReferendum: GenericTxCall<
      (refIndex: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Democracy';
          palletCall: {
            name: 'CancelReferendum';
            params: { refIndex: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Delegate the voting power (with some given conviction) of the sending account.
     *
     * The balance delegated is locked for as long as it's delegated, and thereafter for the
     * time appropriate for the conviction's lock period.
     *
     * The dispatch origin of this call must be _Signed_, and the signing account must either:
     * - be delegating already; or
     * - have no voting activity (if there is, then it will need to be removed/consolidated
     * through `reap_vote` or `unvote`).
     *
     * - `to`: The account whose voting the `target` account's voting power will follow.
     * - `conviction`: The conviction that will be attached to the delegated votes. When the
     * account is undelegated, the funds will be locked for the corresponding period.
     * - `balance`: The amount of the account's balance to be used in delegating. This must not
     * be more than the account's current balance.
     *
     * Emits `Delegated`.
     *
     * Weight: `O(R)` where R is the number of referendums the voter delegating to has
     * voted on. Weight is charged as if maximum votes.
     *
     * @param {AccountId32Like} to
     * @param {PalletDemocracyConviction} conviction
     * @param {bigint} balance
     **/
    delegate: GenericTxCall<
      (
        to: AccountId32Like,
        conviction: PalletDemocracyConviction,
        balance: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Democracy';
          palletCall: {
            name: 'Delegate';
            params: { to: AccountId32Like; conviction: PalletDemocracyConviction; balance: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Undelegate the voting power of the sending account.
     *
     * Tokens may be unlocked following once an amount of time consistent with the lock period
     * of the conviction with which the delegation was issued.
     *
     * The dispatch origin of this call must be _Signed_ and the signing account must be
     * currently delegating.
     *
     * Emits `Undelegated`.
     *
     * Weight: `O(R)` where R is the number of referendums the voter delegating to has
     * voted on. Weight is charged as if maximum votes.
     *
     **/
    undelegate: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'Democracy';
          palletCall: {
            name: 'Undelegate';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Clears all public proposals.
     *
     * The dispatch origin of this call must be _Root_.
     *
     * Weight: `O(1)`.
     *
     **/
    clearPublicProposals: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'Democracy';
          palletCall: {
            name: 'ClearPublicProposals';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Unlock tokens that have an expired lock.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `target`: The account to remove the lock on.
     *
     * Weight: `O(R)` with R number of vote of target.
     *
     * @param {AccountId32Like} target
     **/
    unlock: GenericTxCall<
      (target: AccountId32Like) => ChainSubmittableExtrinsic<
        {
          pallet: 'Democracy';
          palletCall: {
            name: 'Unlock';
            params: { target: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove a vote for a referendum.
     *
     * If:
     * - the referendum was cancelled, or
     * - the referendum is ongoing, or
     * - the referendum has ended such that
     * - the vote of the account was in opposition to the result; or
     * - there was no conviction to the account's vote; or
     * - the account made a split vote
     * ...then the vote is removed cleanly and a following call to `unlock` may result in more
     * funds being available.
     *
     * If, however, the referendum has ended and:
     * - it finished corresponding to the vote of the account, and
     * - the account made a standard vote with conviction, and
     * - the lock period of the conviction is not over
     * ...then the lock will be aggregated into the overall account's lock, which may involve
     * *overlocking* (where the two locks are combined into a single lock that is the maximum
     * of both the amount locked and the time is it locked for).
     *
     * The dispatch origin of this call must be _Signed_, and the signer must have a vote
     * registered for referendum `index`.
     *
     * - `index`: The index of referendum of the vote to be removed.
     *
     * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
     * Weight is calculated for the maximum number of vote.
     *
     * @param {number} index
     **/
    removeVote: GenericTxCall<
      (index: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Democracy';
          palletCall: {
            name: 'RemoveVote';
            params: { index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove a vote for a referendum.
     *
     * If the `target` is equal to the signer, then this function is exactly equivalent to
     * `remove_vote`. If not equal to the signer, then the vote must have expired,
     * either because the referendum was cancelled, because the voter lost the referendum or
     * because the conviction period is over.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `target`: The account of the vote to be removed; this account must have voted for
     * referendum `index`.
     * - `index`: The index of referendum of the vote to be removed.
     *
     * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
     * Weight is calculated for the maximum number of vote.
     *
     * @param {AccountId32Like} target
     * @param {number} index
     **/
    removeOtherVote: GenericTxCall<
      (
        target: AccountId32Like,
        index: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Democracy';
          palletCall: {
            name: 'RemoveOtherVote';
            params: { target: AccountId32Like; index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Permanently place a proposal into the blacklist. This prevents it from ever being
     * proposed again.
     *
     * If called on a queued public or external proposal, then this will result in it being
     * removed. If the `ref_index` supplied is an active referendum with the proposal hash,
     * then it will be cancelled.
     *
     * The dispatch origin of this call must be `BlacklistOrigin`.
     *
     * - `proposal_hash`: The proposal hash to blacklist permanently.
     * - `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be
     * cancelled.
     *
     * Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a
     * reasonable value).
     *
     * @param {H256} proposalHash
     * @param {number | undefined} maybeRefIndex
     **/
    blacklist: GenericTxCall<
      (
        proposalHash: H256,
        maybeRefIndex: number | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Democracy';
          palletCall: {
            name: 'Blacklist';
            params: { proposalHash: H256; maybeRefIndex: number | undefined };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove a proposal.
     *
     * The dispatch origin of this call must be `CancelProposalOrigin`.
     *
     * - `prop_index`: The index of the proposal to cancel.
     *
     * Weight: `O(p)` where `p = PublicProps::<T>::decode_len()`
     *
     * @param {number} propIndex
     **/
    cancelProposal: GenericTxCall<
      (propIndex: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Democracy';
          palletCall: {
            name: 'CancelProposal';
            params: { propIndex: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set or clear a metadata of a proposal or a referendum.
     *
     * Parameters:
     * - `origin`: Must correspond to the `MetadataOwner`.
     * - `ExternalOrigin` for an external proposal with the `SuperMajorityApprove`
     * threshold.
     * - `ExternalDefaultOrigin` for an external proposal with the `SuperMajorityAgainst`
     * threshold.
     * - `ExternalMajorityOrigin` for an external proposal with the `SimpleMajority`
     * threshold.
     * - `Signed` by a creator for a public proposal.
     * - `Signed` to clear a metadata for a finished referendum.
     * - `Root` to set a metadata for an ongoing referendum.
     * - `owner`: an identifier of a metadata owner.
     * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
     *
     * @param {PalletDemocracyMetadataOwner} owner
     * @param {H256 | undefined} maybeHash
     **/
    setMetadata: GenericTxCall<
      (
        owner: PalletDemocracyMetadataOwner,
        maybeHash: H256 | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Democracy';
          palletCall: {
            name: 'SetMetadata';
            params: { owner: PalletDemocracyMetadataOwner; maybeHash: H256 | undefined };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Allow to force remove a vote for a referendum.
     *
     * Same as `remove_other_vote`, except the scope is overriden by forced flag.
     * The dispatch origin of this call must be `VoteRemovalOrigin`.
     *
     * Only allowed if the referendum is finished.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `target`: The account of the vote to be removed; this account must have voted for
     * referendum `index`.
     * - `index`: The index of referendum of the vote to be removed.
     *
     * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
     * Weight is calculated for the maximum number of vote.
     *
     * @param {AccountId32Like} target
     * @param {number} index
     **/
    forceRemoveVote: GenericTxCall<
      (
        target: AccountId32Like,
        index: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Democracy';
          palletCall: {
            name: 'ForceRemoveVote';
            params: { target: AccountId32Like; index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `TechnicalCommittee`'s transaction calls
   **/
  technicalCommittee: {
    /**
     * Set the collective's membership.
     *
     * - `new_members`: The new member list. Be nice to the chain and provide it sorted.
     * - `prime`: The prime member whose vote sets the default.
     * - `old_count`: The upper bound for the previous number of members in storage. Used for
     * weight estimation.
     *
     * The dispatch of this call must be `SetMembersOrigin`.
     *
     * NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
     * the weight estimations rely on it to estimate dispatchable weight.
     *
     * # WARNING:
     *
     * The `pallet-collective` can also be managed by logic outside of the pallet through the
     * implementation of the trait [`ChangeMembers`].
     * Any call to `set_members` must be careful that the member set doesn't get out of sync
     * with other logic managing the member set.
     *
     * ## Complexity:
     * - `O(MP + N)` where:
     * - `M` old-members-count (code- and governance-bounded)
     * - `N` new-members-count (code- and governance-bounded)
     * - `P` proposals-count (code-bounded)
     *
     * @param {Array<AccountId32Like>} newMembers
     * @param {AccountId32Like | undefined} prime
     * @param {number} oldCount
     **/
    setMembers: GenericTxCall<
      (
        newMembers: Array<AccountId32Like>,
        prime: AccountId32Like | undefined,
        oldCount: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'TechnicalCommittee';
          palletCall: {
            name: 'SetMembers';
            params: { newMembers: Array<AccountId32Like>; prime: AccountId32Like | undefined; oldCount: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     *
     * Origin must be a member of the collective.
     *
     * ## Complexity:
     * - `O(B + M + P)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` members-count (code-bounded)
     * - `P` complexity of dispatching `proposal`
     *
     * @param {HydradxRuntimeRuntimeCallLike} proposal
     * @param {number} lengthBound
     **/
    execute: GenericTxCall<
      (
        proposal: HydradxRuntimeRuntimeCallLike,
        lengthBound: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'TechnicalCommittee';
          palletCall: {
            name: 'Execute';
            params: { proposal: HydradxRuntimeRuntimeCallLike; lengthBound: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Add a new proposal to either be voted on or executed directly.
     *
     * Requires the sender to be member.
     *
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     *
     * ## Complexity
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` is members-count (code- and governance-bounded)
     * - branching is influenced by `threshold` where:
     * - `P1` is proposal execution complexity (`threshold < 2`)
     * - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *
     * @param {number} threshold
     * @param {HydradxRuntimeRuntimeCallLike} proposal
     * @param {number} lengthBound
     **/
    propose: GenericTxCall<
      (
        threshold: number,
        proposal: HydradxRuntimeRuntimeCallLike,
        lengthBound: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'TechnicalCommittee';
          palletCall: {
            name: 'Propose';
            params: { threshold: number; proposal: HydradxRuntimeRuntimeCallLike; lengthBound: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Add an aye or nay vote for the sender to the given proposal.
     *
     * Requires the sender to be a member.
     *
     * Transaction fees will be waived if the member is voting on any particular proposal
     * for the first time and the call is successful. Subsequent vote changes will charge a
     * fee.
     * ## Complexity
     * - `O(M)` where `M` is members-count (code- and governance-bounded)
     *
     * @param {H256} proposal
     * @param {number} index
     * @param {boolean} approve
     **/
    vote: GenericTxCall<
      (
        proposal: H256,
        index: number,
        approve: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'TechnicalCommittee';
          palletCall: {
            name: 'Vote';
            params: { proposal: H256; index: number; approve: boolean };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Disapprove a proposal, close, and remove it from the system, regardless of its current
     * state.
     *
     * Must be called by the Root origin.
     *
     * Parameters:
     * * `proposal_hash`: The hash of the proposal that should be disapproved.
     *
     * ## Complexity
     * O(P) where P is the number of max proposals
     *
     * @param {H256} proposalHash
     **/
    disapproveProposal: GenericTxCall<
      (proposalHash: H256) => ChainSubmittableExtrinsic<
        {
          pallet: 'TechnicalCommittee';
          palletCall: {
            name: 'DisapproveProposal';
            params: { proposalHash: H256 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Close a vote that is either approved, disapproved or whose voting period has ended.
     *
     * May be called by any signed account in order to finish voting and close the proposal.
     *
     * If called before the end of the voting period it will only close the vote if it is
     * has enough votes to be approved or disapproved.
     *
     * If called after the end of the voting period abstentions are counted as rejections
     * unless there is a prime member set and the prime member cast an approval.
     *
     * If the close operation completes successfully with disapproval, the transaction fee will
     * be waived. Otherwise execution of the approved operation will be charged to the caller.
     *
     * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
     * proposal.
     * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     *
     * ## Complexity
     * - `O(B + M + P1 + P2)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` is members-count (code- and governance-bounded)
     * - `P1` is the complexity of `proposal` preimage.
     * - `P2` is proposal-count (code-bounded)
     *
     * @param {H256} proposalHash
     * @param {number} index
     * @param {SpWeightsWeightV2Weight} proposalWeightBound
     * @param {number} lengthBound
     **/
    close: GenericTxCall<
      (
        proposalHash: H256,
        index: number,
        proposalWeightBound: SpWeightsWeightV2Weight,
        lengthBound: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'TechnicalCommittee';
          palletCall: {
            name: 'Close';
            params: {
              proposalHash: H256;
              index: number;
              proposalWeightBound: SpWeightsWeightV2Weight;
              lengthBound: number;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Disapprove the proposal and burn the cost held for storing this proposal.
     *
     * Parameters:
     * - `origin`: must be the `KillOrigin`.
     * - `proposal_hash`: The hash of the proposal that should be killed.
     *
     * Emits `Killed` and `ProposalCostBurned` if any cost was held for a given proposal.
     *
     * @param {H256} proposalHash
     **/
    kill: GenericTxCall<
      (proposalHash: H256) => ChainSubmittableExtrinsic<
        {
          pallet: 'TechnicalCommittee';
          palletCall: {
            name: 'Kill';
            params: { proposalHash: H256 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Release the cost held for storing a proposal once the given proposal is completed.
     *
     * If there is no associated cost for the given proposal, this call will have no effect.
     *
     * Parameters:
     * - `origin`: must be `Signed` or `Root`.
     * - `proposal_hash`: The hash of the proposal.
     *
     * Emits `ProposalCostReleased` if any cost held for a given proposal.
     *
     * @param {H256} proposalHash
     **/
    releaseProposalCost: GenericTxCall<
      (proposalHash: H256) => ChainSubmittableExtrinsic<
        {
          pallet: 'TechnicalCommittee';
          palletCall: {
            name: 'ReleaseProposalCost';
            params: { proposalHash: H256 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Proxy`'s transaction calls
   **/
  proxy: {
    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     *
     * @param {AccountId32Like} real
     * @param {HydradxRuntimeSystemProxyType | undefined} forceProxyType
     * @param {HydradxRuntimeRuntimeCallLike} call
     **/
    proxy: GenericTxCall<
      (
        real: AccountId32Like,
        forceProxyType: HydradxRuntimeSystemProxyType | undefined,
        call: HydradxRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'Proxy';
            params: {
              real: AccountId32Like;
              forceProxyType: HydradxRuntimeSystemProxyType | undefined;
              call: HydradxRuntimeRuntimeCallLike;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Register a proxy account for the sender that is able to make calls on its behalf.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `proxy`: The account that the `caller` would like to make a proxy.
     * - `proxy_type`: The permissions allowed for this proxy account.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     *
     * @param {AccountId32Like} delegate
     * @param {HydradxRuntimeSystemProxyType} proxyType
     * @param {number} delay
     **/
    addProxy: GenericTxCall<
      (
        delegate: AccountId32Like,
        proxyType: HydradxRuntimeSystemProxyType,
        delay: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'AddProxy';
            params: { delegate: AccountId32Like; proxyType: HydradxRuntimeSystemProxyType; delay: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Unregister a proxy account for the sender.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `proxy`: The account that the `caller` would like to remove as a proxy.
     * - `proxy_type`: The permissions currently enabled for the removed proxy account.
     *
     * @param {AccountId32Like} delegate
     * @param {HydradxRuntimeSystemProxyType} proxyType
     * @param {number} delay
     **/
    removeProxy: GenericTxCall<
      (
        delegate: AccountId32Like,
        proxyType: HydradxRuntimeSystemProxyType,
        delay: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'RemoveProxy';
            params: { delegate: AccountId32Like; proxyType: HydradxRuntimeSystemProxyType; delay: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Unregister all proxy accounts for the sender.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * WARNING: This may be called on accounts created by `pure`, however if done, then
     * the unreserved fees will be inaccessible. **All access to this account will be lost.**
     *
     **/
    removeProxies: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'RemoveProxies';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
     * initialize it with a proxy of `proxy_type` for `origin` sender.
     *
     * Requires a `Signed` origin.
     *
     * - `proxy_type`: The type of the proxy that the sender will be registered as over the
     * new account. This will almost always be the most permissive `ProxyType` possible to
     * allow for maximum flexibility.
     * - `index`: A disambiguation index, in case this is called multiple times in the same
     * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
     * want to use `0`.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     *
     * Fails with `Duplicate` if this has already been called in this transaction, from the
     * same sender, with the same parameters.
     *
     * Fails if there are insufficient funds to pay for deposit.
     *
     * @param {HydradxRuntimeSystemProxyType} proxyType
     * @param {number} delay
     * @param {number} index
     **/
    createPure: GenericTxCall<
      (
        proxyType: HydradxRuntimeSystemProxyType,
        delay: number,
        index: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'CreatePure';
            params: { proxyType: HydradxRuntimeSystemProxyType; delay: number; index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Removes a previously spawned pure proxy.
     *
     * WARNING: **All access to this account will be lost.** Any funds held in it will be
     * inaccessible.
     *
     * Requires a `Signed` origin, and the sender account must have been created by a call to
     * `pure` with corresponding parameters.
     *
     * - `spawner`: The account that originally called `pure` to create this account.
     * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
     * - `proxy_type`: The proxy type originally passed to `pure`.
     * - `height`: The height of the chain when the call to `pure` was processed.
     * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
     *
     * Fails with `NoPermission` in case the caller is not a previously created pure
     * account whose `pure` call has corresponding parameters.
     *
     * @param {AccountId32Like} spawner
     * @param {HydradxRuntimeSystemProxyType} proxyType
     * @param {number} index
     * @param {number} height
     * @param {number} extIndex
     **/
    killPure: GenericTxCall<
      (
        spawner: AccountId32Like,
        proxyType: HydradxRuntimeSystemProxyType,
        index: number,
        height: number,
        extIndex: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'KillPure';
            params: {
              spawner: AccountId32Like;
              proxyType: HydradxRuntimeSystemProxyType;
              index: number;
              height: number;
              extIndex: number;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Publish the hash of a proxy-call that will be made in the future.
     *
     * This must be called some number of blocks before the corresponding `proxy` is attempted
     * if the delay associated with the proxy relationship is greater than zero.
     *
     * No more than `MaxPending` announcements may be made at any one time.
     *
     * This will take a deposit of `AnnouncementDepositFactor` as well as
     * `AnnouncementDepositBase` if there are no other pending announcements.
     *
     * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     *
     * @param {AccountId32Like} real
     * @param {H256} callHash
     **/
    announce: GenericTxCall<
      (
        real: AccountId32Like,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'Announce';
            params: { real: AccountId32Like; callHash: H256 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove a given announcement.
     *
     * May be called by a proxy account to remove a call they previously announced and return
     * the deposit.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     *
     * @param {AccountId32Like} real
     * @param {H256} callHash
     **/
    removeAnnouncement: GenericTxCall<
      (
        real: AccountId32Like,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'RemoveAnnouncement';
            params: { real: AccountId32Like; callHash: H256 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove the given announcement of a delegate.
     *
     * May be called by a target (proxied) account to remove a call that one of their delegates
     * (`delegate`) has announced they want to execute. The deposit is returned.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `delegate`: The account that previously announced the call.
     * - `call_hash`: The hash of the call to be made.
     *
     * @param {AccountId32Like} delegate
     * @param {H256} callHash
     **/
    rejectAnnouncement: GenericTxCall<
      (
        delegate: AccountId32Like,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'RejectAnnouncement';
            params: { delegate: AccountId32Like; callHash: H256 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     *
     * Removes any corresponding announcement(s).
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     *
     * @param {AccountId32Like} delegate
     * @param {AccountId32Like} real
     * @param {HydradxRuntimeSystemProxyType | undefined} forceProxyType
     * @param {HydradxRuntimeRuntimeCallLike} call
     **/
    proxyAnnounced: GenericTxCall<
      (
        delegate: AccountId32Like,
        real: AccountId32Like,
        forceProxyType: HydradxRuntimeSystemProxyType | undefined,
        call: HydradxRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'ProxyAnnounced';
            params: {
              delegate: AccountId32Like;
              real: AccountId32Like;
              forceProxyType: HydradxRuntimeSystemProxyType | undefined;
              call: HydradxRuntimeRuntimeCallLike;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Poke / Adjust deposits made for proxies and announcements based on current values.
     * This can be used by accounts to possibly lower their locked amount.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * The transaction fee is waived if the deposit amount has changed.
     *
     * Emits `DepositPoked` if successful.
     *
     **/
    pokeDeposit: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'PokeDeposit';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Multisig`'s transaction calls
   **/
  multisig: {
    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     *
     * Result is equivalent to the dispatched result.
     *
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     *
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {HydradxRuntimeRuntimeCallLike} call
     **/
    asMultiThreshold1: GenericTxCall<
      (
        otherSignatories: Array<AccountId32Like>,
        call: HydradxRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'AsMultiThreshold1';
            params: { otherSignatories: Array<AccountId32Like>; call: HydradxRuntimeRuntimeCallLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     *
     * If there are enough, then dispatch the call.
     *
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     *
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     *
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     *
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     *
     * @param {number} threshold
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {PalletMultisigTimepoint | undefined} maybeTimepoint
     * @param {HydradxRuntimeRuntimeCallLike} call
     * @param {SpWeightsWeightV2Weight} maxWeight
     **/
    asMulti: GenericTxCall<
      (
        threshold: number,
        otherSignatories: Array<AccountId32Like>,
        maybeTimepoint: PalletMultisigTimepoint | undefined,
        call: HydradxRuntimeRuntimeCallLike,
        maxWeight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'AsMulti';
            params: {
              threshold: number;
              otherSignatories: Array<AccountId32Like>;
              maybeTimepoint: PalletMultisigTimepoint | undefined;
              call: HydradxRuntimeRuntimeCallLike;
              maxWeight: SpWeightsWeightV2Weight;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     *
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call_hash`: The hash of the call to be executed.
     *
     * NOTE: If this is the final approval, you will want to use `as_multi` instead.
     *
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     *
     * @param {number} threshold
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {PalletMultisigTimepoint | undefined} maybeTimepoint
     * @param {FixedBytes<32>} callHash
     * @param {SpWeightsWeightV2Weight} maxWeight
     **/
    approveAsMulti: GenericTxCall<
      (
        threshold: number,
        otherSignatories: Array<AccountId32Like>,
        maybeTimepoint: PalletMultisigTimepoint | undefined,
        callHash: FixedBytes<32>,
        maxWeight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'ApproveAsMulti';
            params: {
              threshold: number;
              otherSignatories: Array<AccountId32Like>;
              maybeTimepoint: PalletMultisigTimepoint | undefined;
              callHash: FixedBytes<32>;
              maxWeight: SpWeightsWeightV2Weight;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
     * for this operation will be unreserved on success.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `timepoint`: The timepoint (block number and transaction index) of the first approval
     * transaction for this dispatch.
     * - `call_hash`: The hash of the call to be executed.
     *
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - One event.
     * - I/O: 1 read `O(S)`, one remove.
     * - Storage: removes one item.
     *
     * @param {number} threshold
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {PalletMultisigTimepoint} timepoint
     * @param {FixedBytes<32>} callHash
     **/
    cancelAsMulti: GenericTxCall<
      (
        threshold: number,
        otherSignatories: Array<AccountId32Like>,
        timepoint: PalletMultisigTimepoint,
        callHash: FixedBytes<32>,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'CancelAsMulti';
            params: {
              threshold: number;
              otherSignatories: Array<AccountId32Like>;
              timepoint: PalletMultisigTimepoint;
              callHash: FixedBytes<32>;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Poke the deposit reserved for an existing multisig operation.
     *
     * The dispatch origin for this call must be _Signed_ and must be the original depositor of
     * the multisig operation.
     *
     * The transaction fee is waived if the deposit amount has changed.
     *
     * - `threshold`: The total number of approvals needed for this multisig.
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multisig.
     * - `call_hash`: The hash of the call this deposit is reserved for.
     *
     * Emits `DepositPoked` if successful.
     *
     * @param {number} threshold
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {FixedBytes<32>} callHash
     **/
    pokeDeposit: GenericTxCall<
      (
        threshold: number,
        otherSignatories: Array<AccountId32Like>,
        callHash: FixedBytes<32>,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'PokeDeposit';
            params: { threshold: number; otherSignatories: Array<AccountId32Like>; callHash: FixedBytes<32> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Uniques`'s transaction calls
   **/
  uniques: {
    /**
     * Issue a new collection of non-fungible items from a public origin.
     *
     * This new collection has no items initially and its owner is the origin.
     *
     * The origin must conform to the configured `CreateOrigin` and have sufficient funds free.
     *
     * `ItemDeposit` funds of sender are reserved.
     *
     * Parameters:
     * - `collection`: The identifier of the new collection. This must not be currently in use.
     * - `admin`: The admin of this collection. The admin is the initial address of each
     * member of the collection's admin team.
     *
     * Emits `Created` event when successful.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} collection
     * @param {AccountId32Like} admin
     **/
    create: GenericTxCall<
      (
        collection: bigint,
        admin: AccountId32Like,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'Create';
            params: { collection: bigint; admin: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Issue a new collection of non-fungible items from a privileged origin.
     *
     * This new collection has no items initially.
     *
     * The origin must conform to `ForceOrigin`.
     *
     * Unlike `create`, no funds are reserved.
     *
     * - `collection`: The identifier of the new item. This must not be currently in use.
     * - `owner`: The owner of this collection of items. The owner has full superuser
     * permissions
     * over this item, but may later change and configure the permissions using
     * `transfer_ownership` and `set_team`.
     *
     * Emits `ForceCreated` event when successful.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} collection
     * @param {AccountId32Like} owner
     * @param {boolean} freeHolding
     **/
    forceCreate: GenericTxCall<
      (
        collection: bigint,
        owner: AccountId32Like,
        freeHolding: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'ForceCreate';
            params: { collection: bigint; owner: AccountId32Like; freeHolding: boolean };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Destroy a collection of fungible items.
     *
     * The origin must conform to `ForceOrigin` or must be `Signed` and the sender must be the
     * owner of the `collection`.
     *
     * - `collection`: The identifier of the collection to be destroyed.
     * - `witness`: Information on the items minted in the collection. This must be
     * correct.
     *
     * Emits `Destroyed` event when successful.
     *
     * Weight: `O(n + m)` where:
     * - `n = witness.items`
     * - `m = witness.item_metadatas`
     * - `a = witness.attributes`
     *
     * @param {bigint} collection
     * @param {PalletUniquesDestroyWitness} witness
     **/
    destroy: GenericTxCall<
      (
        collection: bigint,
        witness: PalletUniquesDestroyWitness,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'Destroy';
            params: { collection: bigint; witness: PalletUniquesDestroyWitness };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Mint an item of a particular collection.
     *
     * The origin must be Signed and the sender must be the Issuer of the `collection`.
     *
     * - `collection`: The collection of the item to be minted.
     * - `item`: The item value of the item to be minted.
     * - `beneficiary`: The initial owner of the minted item.
     *
     * Emits `Issued` event when successful.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} collection
     * @param {bigint} item
     * @param {AccountId32Like} owner
     **/
    mint: GenericTxCall<
      (
        collection: bigint,
        item: bigint,
        owner: AccountId32Like,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'Mint';
            params: { collection: bigint; item: bigint; owner: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Destroy a single item.
     *
     * Origin must be Signed and the signing account must be either:
     * - the Admin of the `collection`;
     * - the Owner of the `item`;
     *
     * - `collection`: The collection of the item to be burned.
     * - `item`: The item of the item to be burned.
     * - `check_owner`: If `Some` then the operation will fail with `WrongOwner` unless the
     * item is owned by this value.
     *
     * Emits `Burned` with the actual amount burned.
     *
     * Weight: `O(1)`
     * Modes: `check_owner.is_some()`.
     *
     * @param {bigint} collection
     * @param {bigint} item
     * @param {AccountId32Like | undefined} checkOwner
     **/
    burn: GenericTxCall<
      (
        collection: bigint,
        item: bigint,
        checkOwner: AccountId32Like | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'Burn';
            params: { collection: bigint; item: bigint; checkOwner: AccountId32Like | undefined };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Move an item from the sender account to another.
     *
     * This resets the approved account of the item.
     *
     * Origin must be Signed and the signing account must be either:
     * - the Admin of the `collection`;
     * - the Owner of the `item`;
     * - the approved delegate for the `item` (in this case, the approval is reset).
     *
     * Arguments:
     * - `collection`: The collection of the item to be transferred.
     * - `item`: The item of the item to be transferred.
     * - `dest`: The account to receive ownership of the item.
     *
     * Emits `Transferred`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} collection
     * @param {bigint} item
     * @param {AccountId32Like} dest
     **/
    transfer: GenericTxCall<
      (
        collection: bigint,
        item: bigint,
        dest: AccountId32Like,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'Transfer';
            params: { collection: bigint; item: bigint; dest: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Reevaluate the deposits on some items.
     *
     * Origin must be Signed and the sender should be the Owner of the `collection`.
     *
     * - `collection`: The collection to be frozen.
     * - `items`: The items of the collection whose deposits will be reevaluated.
     *
     * NOTE: This exists as a best-effort function. Any items which are unknown or
     * in the case that the owner account does not have reservable funds to pay for a
     * deposit increase are ignored. Generally the owner isn't going to call this on items
     * whose existing deposit is less than the refreshed deposit as it would only cost them,
     * so it's of little consequence.
     *
     * It will still return an error in the case that the collection is unknown of the signer
     * is not permitted to call it.
     *
     * Weight: `O(items.len())`
     *
     * @param {bigint} collection
     * @param {Array<bigint>} items
     **/
    redeposit: GenericTxCall<
      (
        collection: bigint,
        items: Array<bigint>,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'Redeposit';
            params: { collection: bigint; items: Array<bigint> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Disallow further unprivileged transfer of an item.
     *
     * Origin must be Signed and the sender should be the Freezer of the `collection`.
     *
     * - `collection`: The collection of the item to be frozen.
     * - `item`: The item of the item to be frozen.
     *
     * Emits `Frozen`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} collection
     * @param {bigint} item
     **/
    freeze: GenericTxCall<
      (
        collection: bigint,
        item: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'Freeze';
            params: { collection: bigint; item: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Re-allow unprivileged transfer of an item.
     *
     * Origin must be Signed and the sender should be the Freezer of the `collection`.
     *
     * - `collection`: The collection of the item to be thawed.
     * - `item`: The item of the item to be thawed.
     *
     * Emits `Thawed`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} collection
     * @param {bigint} item
     **/
    thaw: GenericTxCall<
      (
        collection: bigint,
        item: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'Thaw';
            params: { collection: bigint; item: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Disallow further unprivileged transfers for a whole collection.
     *
     * Origin must be Signed and the sender should be the Freezer of the `collection`.
     *
     * - `collection`: The collection to be frozen.
     *
     * Emits `CollectionFrozen`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} collection
     **/
    freezeCollection: GenericTxCall<
      (collection: bigint) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'FreezeCollection';
            params: { collection: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Re-allow unprivileged transfers for a whole collection.
     *
     * Origin must be Signed and the sender should be the Admin of the `collection`.
     *
     * - `collection`: The collection to be thawed.
     *
     * Emits `CollectionThawed`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} collection
     **/
    thawCollection: GenericTxCall<
      (collection: bigint) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'ThawCollection';
            params: { collection: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Change the Owner of a collection.
     *
     * Origin must be Signed and the sender should be the Owner of the `collection`.
     *
     * - `collection`: The collection whose owner should be changed.
     * - `owner`: The new Owner of this collection. They must have called
     * `set_accept_ownership` with `collection` in order for this operation to succeed.
     *
     * Emits `OwnerChanged`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} collection
     * @param {AccountId32Like} newOwner
     **/
    transferOwnership: GenericTxCall<
      (
        collection: bigint,
        newOwner: AccountId32Like,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'TransferOwnership';
            params: { collection: bigint; newOwner: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Change the Issuer, Admin and Freezer of a collection.
     *
     * Origin must be Signed and the sender should be the Owner of the `collection`.
     *
     * - `collection`: The collection whose team should be changed.
     * - `issuer`: The new Issuer of this collection.
     * - `admin`: The new Admin of this collection.
     * - `freezer`: The new Freezer of this collection.
     *
     * Emits `TeamChanged`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} collection
     * @param {AccountId32Like} issuer
     * @param {AccountId32Like} admin
     * @param {AccountId32Like} freezer
     **/
    setTeam: GenericTxCall<
      (
        collection: bigint,
        issuer: AccountId32Like,
        admin: AccountId32Like,
        freezer: AccountId32Like,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'SetTeam';
            params: { collection: bigint; issuer: AccountId32Like; admin: AccountId32Like; freezer: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Approve an item to be transferred by a delegated third-party account.
     *
     * The origin must conform to `ForceOrigin` or must be `Signed` and the sender must be
     * either the owner of the `item` or the admin of the collection.
     *
     * - `collection`: The collection of the item to be approved for delegated transfer.
     * - `item`: The item of the item to be approved for delegated transfer.
     * - `delegate`: The account to delegate permission to transfer the item.
     *
     * Important NOTE: The `approved` account gets reset after each transfer.
     *
     * Emits `ApprovedTransfer` on success.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} collection
     * @param {bigint} item
     * @param {AccountId32Like} delegate
     **/
    approveTransfer: GenericTxCall<
      (
        collection: bigint,
        item: bigint,
        delegate: AccountId32Like,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'ApproveTransfer';
            params: { collection: bigint; item: bigint; delegate: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Cancel the prior approval for the transfer of an item by a delegate.
     *
     * Origin must be either:
     * - the `Force` origin;
     * - `Signed` with the signer being the Admin of the `collection`;
     * - `Signed` with the signer being the Owner of the `item`;
     *
     * Arguments:
     * - `collection`: The collection of the item of whose approval will be cancelled.
     * - `item`: The item of the item of whose approval will be cancelled.
     * - `maybe_check_delegate`: If `Some` will ensure that the given account is the one to
     * which permission of transfer is delegated.
     *
     * Emits `ApprovalCancelled` on success.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} collection
     * @param {bigint} item
     * @param {AccountId32Like | undefined} maybeCheckDelegate
     **/
    cancelApproval: GenericTxCall<
      (
        collection: bigint,
        item: bigint,
        maybeCheckDelegate: AccountId32Like | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'CancelApproval';
            params: { collection: bigint; item: bigint; maybeCheckDelegate: AccountId32Like | undefined };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Alter the attributes of a given item.
     *
     * Origin must be `ForceOrigin`.
     *
     * - `collection`: The identifier of the item.
     * - `owner`: The new Owner of this item.
     * - `issuer`: The new Issuer of this item.
     * - `admin`: The new Admin of this item.
     * - `freezer`: The new Freezer of this item.
     * - `free_holding`: Whether a deposit is taken for holding an item of this collection.
     * - `is_frozen`: Whether this collection is frozen except for permissioned/admin
     * instructions.
     *
     * Emits `ItemStatusChanged` with the identity of the item.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} collection
     * @param {AccountId32Like} owner
     * @param {AccountId32Like} issuer
     * @param {AccountId32Like} admin
     * @param {AccountId32Like} freezer
     * @param {boolean} freeHolding
     * @param {boolean} isFrozen
     **/
    forceItemStatus: GenericTxCall<
      (
        collection: bigint,
        owner: AccountId32Like,
        issuer: AccountId32Like,
        admin: AccountId32Like,
        freezer: AccountId32Like,
        freeHolding: boolean,
        isFrozen: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'ForceItemStatus';
            params: {
              collection: bigint;
              owner: AccountId32Like;
              issuer: AccountId32Like;
              admin: AccountId32Like;
              freezer: AccountId32Like;
              freeHolding: boolean;
              isFrozen: boolean;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set an attribute for a collection or item.
     *
     * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
     * `collection`.
     *
     * If the origin is Signed, then funds of signer are reserved according to the formula:
     * `MetadataDepositBase + DepositPerByte * (key.len + value.len)` taking into
     * account any already reserved funds.
     *
     * - `collection`: The identifier of the collection whose item's metadata to set.
     * - `maybe_item`: The identifier of the item whose metadata to set.
     * - `key`: The key of the attribute.
     * - `value`: The value to which to set the attribute.
     *
     * Emits `AttributeSet`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} collection
     * @param {bigint | undefined} maybeItem
     * @param {BytesLike} key
     * @param {BytesLike} value
     **/
    setAttribute: GenericTxCall<
      (
        collection: bigint,
        maybeItem: bigint | undefined,
        key: BytesLike,
        value: BytesLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'SetAttribute';
            params: { collection: bigint; maybeItem: bigint | undefined; key: BytesLike; value: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Clear an attribute for a collection or item.
     *
     * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
     * `collection`.
     *
     * Any deposit is freed for the collection's owner.
     *
     * - `collection`: The identifier of the collection whose item's metadata to clear.
     * - `maybe_item`: The identifier of the item whose metadata to clear.
     * - `key`: The key of the attribute.
     *
     * Emits `AttributeCleared`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} collection
     * @param {bigint | undefined} maybeItem
     * @param {BytesLike} key
     **/
    clearAttribute: GenericTxCall<
      (
        collection: bigint,
        maybeItem: bigint | undefined,
        key: BytesLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'ClearAttribute';
            params: { collection: bigint; maybeItem: bigint | undefined; key: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the metadata for an item.
     *
     * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
     * `collection`.
     *
     * If the origin is Signed, then funds of signer are reserved according to the formula:
     * `MetadataDepositBase + DepositPerByte * data.len` taking into
     * account any already reserved funds.
     *
     * - `collection`: The identifier of the collection whose item's metadata to set.
     * - `item`: The identifier of the item whose metadata to set.
     * - `data`: The general information of this item. Limited in length by `StringLimit`.
     * - `is_frozen`: Whether the metadata should be frozen against further changes.
     *
     * Emits `MetadataSet`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} collection
     * @param {bigint} item
     * @param {BytesLike} data
     * @param {boolean} isFrozen
     **/
    setMetadata: GenericTxCall<
      (
        collection: bigint,
        item: bigint,
        data: BytesLike,
        isFrozen: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'SetMetadata';
            params: { collection: bigint; item: bigint; data: BytesLike; isFrozen: boolean };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Clear the metadata for an item.
     *
     * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
     * `item`.
     *
     * Any deposit is freed for the collection's owner.
     *
     * - `collection`: The identifier of the collection whose item's metadata to clear.
     * - `item`: The identifier of the item whose metadata to clear.
     *
     * Emits `MetadataCleared`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} collection
     * @param {bigint} item
     **/
    clearMetadata: GenericTxCall<
      (
        collection: bigint,
        item: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'ClearMetadata';
            params: { collection: bigint; item: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the metadata for a collection.
     *
     * Origin must be either `ForceOrigin` or `Signed` and the sender should be the Owner of
     * the `collection`.
     *
     * If the origin is `Signed`, then funds of signer are reserved according to the formula:
     * `MetadataDepositBase + DepositPerByte * data.len` taking into
     * account any already reserved funds.
     *
     * - `collection`: The identifier of the item whose metadata to update.
     * - `data`: The general information of this item. Limited in length by `StringLimit`.
     * - `is_frozen`: Whether the metadata should be frozen against further changes.
     *
     * Emits `CollectionMetadataSet`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} collection
     * @param {BytesLike} data
     * @param {boolean} isFrozen
     **/
    setCollectionMetadata: GenericTxCall<
      (
        collection: bigint,
        data: BytesLike,
        isFrozen: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'SetCollectionMetadata';
            params: { collection: bigint; data: BytesLike; isFrozen: boolean };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Clear the metadata for a collection.
     *
     * Origin must be either `ForceOrigin` or `Signed` and the sender should be the Owner of
     * the `collection`.
     *
     * Any deposit is freed for the collection's owner.
     *
     * - `collection`: The identifier of the collection whose metadata to clear.
     *
     * Emits `CollectionMetadataCleared`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} collection
     **/
    clearCollectionMetadata: GenericTxCall<
      (collection: bigint) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'ClearCollectionMetadata';
            params: { collection: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set (or reset) the acceptance of ownership for a particular account.
     *
     * Origin must be `Signed` and if `maybe_collection` is `Some`, then the signer must have a
     * provider reference.
     *
     * - `maybe_collection`: The identifier of the collection whose ownership the signer is
     * willing to accept, or if `None`, an indication that the signer is willing to accept no
     * ownership transferal.
     *
     * Emits `OwnershipAcceptanceChanged`.
     *
     * @param {bigint | undefined} maybeCollection
     **/
    setAcceptOwnership: GenericTxCall<
      (maybeCollection: bigint | undefined) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'SetAcceptOwnership';
            params: { maybeCollection: bigint | undefined };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the maximum amount of items a collection could have.
     *
     * Origin must be either `ForceOrigin` or `Signed` and the sender should be the Owner of
     * the `collection`.
     *
     * Note: This function can only succeed once per collection.
     *
     * - `collection`: The identifier of the collection to change.
     * - `max_supply`: The maximum amount of items a collection could have.
     *
     * Emits `CollectionMaxSupplySet` event when successful.
     *
     * @param {bigint} collection
     * @param {number} maxSupply
     **/
    setCollectionMaxSupply: GenericTxCall<
      (
        collection: bigint,
        maxSupply: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'SetCollectionMaxSupply';
            params: { collection: bigint; maxSupply: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set (or reset) the price for an item.
     *
     * Origin must be Signed and must be the owner of the asset `item`.
     *
     * - `collection`: The collection of the item.
     * - `item`: The item to set the price for.
     * - `price`: The price for the item. Pass `None`, to reset the price.
     * - `buyer`: Restricts the buy operation to a specific account.
     *
     * Emits `ItemPriceSet` on success if the price is not `None`.
     * Emits `ItemPriceRemoved` on success if the price is `None`.
     *
     * @param {bigint} collection
     * @param {bigint} item
     * @param {bigint | undefined} price
     * @param {AccountId32Like | undefined} whitelistedBuyer
     **/
    setPrice: GenericTxCall<
      (
        collection: bigint,
        item: bigint,
        price: bigint | undefined,
        whitelistedBuyer: AccountId32Like | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'SetPrice';
            params: {
              collection: bigint;
              item: bigint;
              price: bigint | undefined;
              whitelistedBuyer: AccountId32Like | undefined;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Allows to buy an item if it's up for sale.
     *
     * Origin must be Signed and must not be the owner of the `item`.
     *
     * - `collection`: The collection of the item.
     * - `item`: The item the sender wants to buy.
     * - `bid_price`: The price the sender is willing to pay.
     *
     * Emits `ItemBought` on success.
     *
     * @param {bigint} collection
     * @param {bigint} item
     * @param {bigint} bidPrice
     **/
    buyItem: GenericTxCall<
      (
        collection: bigint,
        item: bigint,
        bidPrice: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Uniques';
          palletCall: {
            name: 'BuyItem';
            params: { collection: bigint; item: bigint; bidPrice: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `StateTrieMigration`'s transaction calls
   **/
  stateTrieMigration: {
    /**
     * Control the automatic migration.
     *
     * The dispatch origin of this call must be [`Config::ControlOrigin`].
     *
     * @param {PalletStateTrieMigrationMigrationLimits | undefined} maybeConfig
     **/
    controlAutoMigration: GenericTxCall<
      (maybeConfig: PalletStateTrieMigrationMigrationLimits | undefined) => ChainSubmittableExtrinsic<
        {
          pallet: 'StateTrieMigration';
          palletCall: {
            name: 'ControlAutoMigration';
            params: { maybeConfig: PalletStateTrieMigrationMigrationLimits | undefined };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Continue the migration for the given `limits`.
     *
     * The dispatch origin of this call can be any signed account.
     *
     * This transaction has NO MONETARY INCENTIVES. calling it will not reward anyone. Albeit,
     * Upon successful execution, the transaction fee is returned.
     *
     * The (potentially over-estimated) of the byte length of all the data read must be
     * provided for up-front fee-payment and weighing. In essence, the caller is guaranteeing
     * that executing the current `MigrationTask` with the given `limits` will not exceed
     * `real_size_upper` bytes of read data.
     *
     * The `witness_task` is merely a helper to prevent the caller from being slashed or
     * generally trigger a migration that they do not intend. This parameter is just a message
     * from caller, saying that they believed `witness_task` was the last state of the
     * migration, and they only wish for their transaction to do anything, if this assumption
     * holds. In case `witness_task` does not match, the transaction fails.
     *
     * Based on the documentation of [`MigrationTask::migrate_until_exhaustion`], the
     * recommended way of doing this is to pass a `limit` that only bounds `count`, as the
     * `size` limit can always be overwritten.
     *
     * @param {PalletStateTrieMigrationMigrationLimits} limits
     * @param {number} realSizeUpper
     * @param {PalletStateTrieMigrationMigrationTask} witnessTask
     **/
    continueMigrate: GenericTxCall<
      (
        limits: PalletStateTrieMigrationMigrationLimits,
        realSizeUpper: number,
        witnessTask: PalletStateTrieMigrationMigrationTask,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'StateTrieMigration';
          palletCall: {
            name: 'ContinueMigrate';
            params: {
              limits: PalletStateTrieMigrationMigrationLimits;
              realSizeUpper: number;
              witnessTask: PalletStateTrieMigrationMigrationTask;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Migrate the list of top keys by iterating each of them one by one.
     *
     * This does not affect the global migration process tracker ([`MigrationProcess`]), and
     * should only be used in case any keys are leftover due to a bug.
     *
     * @param {Array<BytesLike>} keys
     * @param {number} witnessSize
     **/
    migrateCustomTop: GenericTxCall<
      (
        keys: Array<BytesLike>,
        witnessSize: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'StateTrieMigration';
          palletCall: {
            name: 'MigrateCustomTop';
            params: { keys: Array<BytesLike>; witnessSize: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Migrate the list of child keys by iterating each of them one by one.
     *
     * All of the given child keys must be present under one `child_root`.
     *
     * This does not affect the global migration process tracker ([`MigrationProcess`]), and
     * should only be used in case any keys are leftover due to a bug.
     *
     * @param {BytesLike} root
     * @param {Array<BytesLike>} childKeys
     * @param {number} totalSize
     **/
    migrateCustomChild: GenericTxCall<
      (
        root: BytesLike,
        childKeys: Array<BytesLike>,
        totalSize: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'StateTrieMigration';
          palletCall: {
            name: 'MigrateCustomChild';
            params: { root: BytesLike; childKeys: Array<BytesLike>; totalSize: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the maximum limit of the signed migration.
     *
     * @param {PalletStateTrieMigrationMigrationLimits} limits
     **/
    setSignedMaxLimits: GenericTxCall<
      (limits: PalletStateTrieMigrationMigrationLimits) => ChainSubmittableExtrinsic<
        {
          pallet: 'StateTrieMigration';
          palletCall: {
            name: 'SetSignedMaxLimits';
            params: { limits: PalletStateTrieMigrationMigrationLimits };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Forcefully set the progress the running migration.
     *
     * This is only useful in one case: the next key to migrate is too big to be migrated with
     * a signed account, in a parachain context, and we simply want to skip it. A reasonable
     * example of this would be `:code:`, which is both very expensive to migrate, and commonly
     * used, so probably it is already migrated.
     *
     * In case you mess things up, you can also, in principle, use this to reset the migration
     * process.
     *
     * @param {PalletStateTrieMigrationProgress} progressTop
     * @param {PalletStateTrieMigrationProgress} progressChild
     **/
    forceSetProgress: GenericTxCall<
      (
        progressTop: PalletStateTrieMigrationProgress,
        progressChild: PalletStateTrieMigrationProgress,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'StateTrieMigration';
          palletCall: {
            name: 'ForceSetProgress';
            params: { progressTop: PalletStateTrieMigrationProgress; progressChild: PalletStateTrieMigrationProgress };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `ConvictionVoting`'s transaction calls
   **/
  convictionVoting: {
    /**
     * Vote in a poll. If `vote.is_aye()`, the vote is to enact the proposal;
     * otherwise it is a vote to keep the status quo.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `poll_index`: The index of the poll to vote for.
     * - `vote`: The vote configuration.
     *
     * Weight: `O(R)` where R is the number of polls the voter has voted on.
     *
     * @param {number} pollIndex
     * @param {PalletConvictionVotingVoteAccountVote} vote
     **/
    vote: GenericTxCall<
      (
        pollIndex: number,
        vote: PalletConvictionVotingVoteAccountVote,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ConvictionVoting';
          palletCall: {
            name: 'Vote';
            params: { pollIndex: number; vote: PalletConvictionVotingVoteAccountVote };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Delegate the voting power (with some given conviction) of the sending account for a
     * particular class of polls.
     *
     * The balance delegated is locked for as long as it's delegated, and thereafter for the
     * time appropriate for the conviction's lock period.
     *
     * The dispatch origin of this call must be _Signed_, and the signing account must either:
     * - be delegating already; or
     * - have no voting activity (if there is, then it will need to be removed through
     * `remove_vote`).
     *
     * - `to`: The account whose voting the `target` account's voting power will follow.
     * - `class`: The class of polls to delegate. To delegate multiple classes, multiple calls
     * to this function are required.
     * - `conviction`: The conviction that will be attached to the delegated votes. When the
     * account is undelegated, the funds will be locked for the corresponding period.
     * - `balance`: The amount of the account's balance to be used in delegating. This must not
     * be more than the account's current balance.
     *
     * Emits `Delegated`.
     *
     * Weight: `O(R)` where R is the number of polls the voter delegating to has
     * voted on. Weight is initially charged as if maximum votes, but is refunded later.
     *
     * @param {number} class_
     * @param {AccountId32Like} to
     * @param {PalletConvictionVotingConviction} conviction
     * @param {bigint} balance
     **/
    delegate: GenericTxCall<
      (
        class_: number,
        to: AccountId32Like,
        conviction: PalletConvictionVotingConviction,
        balance: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ConvictionVoting';
          palletCall: {
            name: 'Delegate';
            params: {
              class: number;
              to: AccountId32Like;
              conviction: PalletConvictionVotingConviction;
              balance: bigint;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Undelegate the voting power of the sending account for a particular class of polls.
     *
     * Tokens may be unlocked following once an amount of time consistent with the lock period
     * of the conviction with which the delegation was issued has passed.
     *
     * The dispatch origin of this call must be _Signed_ and the signing account must be
     * currently delegating.
     *
     * - `class`: The class of polls to remove the delegation from.
     *
     * Emits `Undelegated`.
     *
     * Weight: `O(R)` where R is the number of polls the voter delegating to has
     * voted on. Weight is initially charged as if maximum votes, but is refunded later.
     *
     * @param {number} class_
     **/
    undelegate: GenericTxCall<
      (class_: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'ConvictionVoting';
          palletCall: {
            name: 'Undelegate';
            params: { class: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove the lock caused by prior voting/delegating which has expired within a particular
     * class.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `class`: The class of polls to unlock.
     * - `target`: The account to remove the lock on.
     *
     * Weight: `O(R)` with R number of vote of target.
     *
     * @param {number} class_
     * @param {AccountId32Like} target
     **/
    unlock: GenericTxCall<
      (
        class_: number,
        target: AccountId32Like,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ConvictionVoting';
          palletCall: {
            name: 'Unlock';
            params: { class: number; target: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove a vote for a poll.
     *
     * If:
     * - the poll was cancelled, or
     * - the poll is ongoing, or
     * - the poll has ended such that
     * - the vote of the account was in opposition to the result; or
     * - there was no conviction to the account's vote; or
     * - the account made a split vote
     * ...then the vote is removed cleanly and a following call to `unlock` may result in more
     * funds being available.
     *
     * If, however, the poll has ended and:
     * - it finished corresponding to the vote of the account, and
     * - the account made a standard vote with conviction, and
     * - the lock period of the conviction is not over
     * ...then the lock will be aggregated into the overall account's lock, which may involve
     * *overlocking* (where the two locks are combined into a single lock that is the maximum
     * of both the amount locked and the time is it locked for).
     *
     * The dispatch origin of this call must be _Signed_, and the signer must have a vote
     * registered for poll `index`.
     *
     * - `index`: The index of poll of the vote to be removed.
     * - `class`: Optional parameter, if given it indicates the class of the poll. For polls
     * which have finished or are cancelled, this must be `Some`.
     *
     * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
     * Weight is calculated for the maximum number of vote.
     *
     * @param {number | undefined} class_
     * @param {number} index
     **/
    removeVote: GenericTxCall<
      (
        class_: number | undefined,
        index: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ConvictionVoting';
          palletCall: {
            name: 'RemoveVote';
            params: { class: number | undefined; index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove a vote for a poll.
     *
     * If the `target` is equal to the signer, then this function is exactly equivalent to
     * `remove_vote`. If not equal to the signer, then the vote must have expired,
     * either because the poll was cancelled, because the voter lost the poll or
     * because the conviction period is over.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `target`: The account of the vote to be removed; this account must have voted for poll
     * `index`.
     * - `index`: The index of poll of the vote to be removed.
     * - `class`: The class of the poll.
     *
     * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
     * Weight is calculated for the maximum number of vote.
     *
     * @param {AccountId32Like} target
     * @param {number} class_
     * @param {number} index
     **/
    removeOtherVote: GenericTxCall<
      (
        target: AccountId32Like,
        class_: number,
        index: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ConvictionVoting';
          palletCall: {
            name: 'RemoveOtherVote';
            params: { target: AccountId32Like; class: number; index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Allow to force remove a vote for a referendum.
     *
     * The dispatch origin of this call must be `VoteRemovalOrigin`.
     *
     * Only allowed if the referendum is finished.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `target`: The account of the vote to be removed; this account must have voted for
     * referendum `index`.
     * - `index`: The index of referendum of the vote to be removed.
     *
     * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
     * Weight is calculated for the maximum number of vote.
     *
     * @param {AccountId32Like} target
     * @param {number} class_
     * @param {number} index
     **/
    forceRemoveVote: GenericTxCall<
      (
        target: AccountId32Like,
        class_: number,
        index: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'ConvictionVoting';
          palletCall: {
            name: 'ForceRemoveVote';
            params: { target: AccountId32Like; class: number; index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Referenda`'s transaction calls
   **/
  referenda: {
    /**
     * Propose a referendum on a privileged action.
     *
     * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
     * available.
     * - `proposal_origin`: The origin from which the proposal should be executed.
     * - `proposal`: The proposal.
     * - `enactment_moment`: The moment that the proposal should be enacted.
     *
     * Emits `Submitted`.
     *
     * @param {HydradxRuntimeOriginCaller} proposalOrigin
     * @param {FrameSupportPreimagesBounded} proposal
     * @param {FrameSupportScheduleDispatchTime} enactmentMoment
     **/
    submit: GenericTxCall<
      (
        proposalOrigin: HydradxRuntimeOriginCaller,
        proposal: FrameSupportPreimagesBounded,
        enactmentMoment: FrameSupportScheduleDispatchTime,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'Submit';
            params: {
              proposalOrigin: HydradxRuntimeOriginCaller;
              proposal: FrameSupportPreimagesBounded;
              enactmentMoment: FrameSupportScheduleDispatchTime;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Post the Decision Deposit for a referendum.
     *
     * - `origin`: must be `Signed` and the account must have funds available for the
     * referendum's track's Decision Deposit.
     * - `index`: The index of the submitted referendum whose Decision Deposit is yet to be
     * posted.
     *
     * Emits `DecisionDepositPlaced`.
     *
     * @param {number} index
     **/
    placeDecisionDeposit: GenericTxCall<
      (index: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'PlaceDecisionDeposit';
            params: { index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Refund the Decision Deposit for a closed referendum back to the depositor.
     *
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Decision Deposit has not yet been
     * refunded.
     *
     * Emits `DecisionDepositRefunded`.
     *
     * @param {number} index
     **/
    refundDecisionDeposit: GenericTxCall<
      (index: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'RefundDecisionDeposit';
            params: { index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Cancel an ongoing referendum.
     *
     * - `origin`: must be the `CancelOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     *
     * Emits `Cancelled`.
     *
     * @param {number} index
     **/
    cancel: GenericTxCall<
      (index: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'Cancel';
            params: { index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Cancel an ongoing referendum and slash the deposits.
     *
     * - `origin`: must be the `KillOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     *
     * Emits `Killed` and `DepositSlashed`.
     *
     * @param {number} index
     **/
    kill: GenericTxCall<
      (index: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'Kill';
            params: { index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Advance a referendum onto its next logical state. Only used internally.
     *
     * - `origin`: must be `Root`.
     * - `index`: the referendum to be advanced.
     *
     * @param {number} index
     **/
    nudgeReferendum: GenericTxCall<
      (index: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'NudgeReferendum';
            params: { index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Advance a track onto its next logical state. Only used internally.
     *
     * - `origin`: must be `Root`.
     * - `track`: the track to be advanced.
     *
     * Action item for when there is now one fewer referendum in the deciding phase and the
     * `DecidingCount` is not yet updated. This means that we should either:
     * - begin deciding another referendum (and leave `DecidingCount` alone); or
     * - decrement `DecidingCount`.
     *
     * @param {number} track
     **/
    oneFewerDeciding: GenericTxCall<
      (track: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'OneFewerDeciding';
            params: { track: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Refund the Submission Deposit for a closed referendum back to the depositor.
     *
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Submission Deposit has not yet been
     * refunded.
     *
     * Emits `SubmissionDepositRefunded`.
     *
     * @param {number} index
     **/
    refundSubmissionDeposit: GenericTxCall<
      (index: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'RefundSubmissionDeposit';
            params: { index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set or clear metadata of a referendum.
     *
     * Parameters:
     * - `origin`: Must be `Signed` by a creator of a referendum or by anyone to clear a
     * metadata of a finished referendum.
     * - `index`: The index of a referendum to set or clear metadata for.
     * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
     *
     * @param {number} index
     * @param {H256 | undefined} maybeHash
     **/
    setMetadata: GenericTxCall<
      (
        index: number,
        maybeHash: H256 | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'SetMetadata';
            params: { index: number; maybeHash: H256 | undefined };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Whitelist`'s transaction calls
   **/
  whitelist: {
    /**
     *
     * @param {H256} callHash
     **/
    whitelistCall: GenericTxCall<
      (callHash: H256) => ChainSubmittableExtrinsic<
        {
          pallet: 'Whitelist';
          palletCall: {
            name: 'WhitelistCall';
            params: { callHash: H256 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {H256} callHash
     **/
    removeWhitelistedCall: GenericTxCall<
      (callHash: H256) => ChainSubmittableExtrinsic<
        {
          pallet: 'Whitelist';
          palletCall: {
            name: 'RemoveWhitelistedCall';
            params: { callHash: H256 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {H256} callHash
     * @param {number} callEncodedLen
     * @param {SpWeightsWeightV2Weight} callWeightWitness
     **/
    dispatchWhitelistedCall: GenericTxCall<
      (
        callHash: H256,
        callEncodedLen: number,
        callWeightWitness: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Whitelist';
          palletCall: {
            name: 'DispatchWhitelistedCall';
            params: { callHash: H256; callEncodedLen: number; callWeightWitness: SpWeightsWeightV2Weight };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {HydradxRuntimeRuntimeCallLike} call
     **/
    dispatchWhitelistedCallWithPreimage: GenericTxCall<
      (call: HydradxRuntimeRuntimeCallLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'Whitelist';
          palletCall: {
            name: 'DispatchWhitelistedCallWithPreimage';
            params: { call: HydradxRuntimeRuntimeCallLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Dispatcher`'s transaction calls
   **/
  dispatcher: {
    /**
     *
     * @param {HydradxRuntimeRuntimeCallLike} call
     **/
    dispatchAsTreasury: GenericTxCall<
      (call: HydradxRuntimeRuntimeCallLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'Dispatcher';
          palletCall: {
            name: 'DispatchAsTreasury';
            params: { call: HydradxRuntimeRuntimeCallLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {HydradxRuntimeRuntimeCallLike} call
     **/
    dispatchAsAaveManager: GenericTxCall<
      (call: HydradxRuntimeRuntimeCallLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'Dispatcher';
          palletCall: {
            name: 'DispatchAsAaveManager';
            params: { call: HydradxRuntimeRuntimeCallLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Sets the Aave manager account to be used as origin for dispatching calls.
     *
     * This doesn't actually changes any ACL in the pool.
     *
     * This is intented to be mainly used in testnet environments, where the manager account
     * can be different.
     *
     * @param {AccountId32Like} account
     **/
    noteAaveManager: GenericTxCall<
      (account: AccountId32Like) => ChainSubmittableExtrinsic<
        {
          pallet: 'Dispatcher';
          palletCall: {
            name: 'NoteAaveManager';
            params: { account: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Dispatch a call with extra gas.
     *
     * This allows executing calls with additional weight (gas) limit.
     * The extra gas is not refunded, even if not used.
     *
     * @param {HydradxRuntimeRuntimeCallLike} call
     * @param {bigint} extraGas
     **/
    dispatchWithExtraGas: GenericTxCall<
      (
        call: HydradxRuntimeRuntimeCallLike,
        extraGas: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Dispatcher';
          palletCall: {
            name: 'DispatchWithExtraGas';
            params: { call: HydradxRuntimeRuntimeCallLike; extraGas: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Execute a single EVM call.
     * This extrinsic will fail if the EVM call returns any other ExitReason than `ExitSucceed(Returned)` or `ExitSucceed(Stopped)`.
     * Look the [hydradx_runtime::evm::runner::WrapRunner] implementation for details.
     *
     * Parameters:
     * - `origin`: Signed origin.
     * - `call`: presumably `pallet_evm::Call::call` as boxed `RuntimeCall`.
     *
     * Emits `EvmCallFailed` event when failed.
     *
     * @param {HydradxRuntimeRuntimeCallLike} call
     **/
    dispatchEvmCall: GenericTxCall<
      (call: HydradxRuntimeRuntimeCallLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'Dispatcher';
          palletCall: {
            name: 'DispatchEvmCall';
            params: { call: HydradxRuntimeRuntimeCallLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `AssetRegistry`'s transaction calls
   **/
  assetRegistry: {
    /**
     * Register a new asset.
     *
     * New asset is given `NextAssetId` - sequential asset id
     *
     * Asset's id is optional and it can't be used by another asset if it's provided.
     * Provided `asset_id` must be from within reserved range.
     * If `asset_id` is `None`, new asset is given id for sequential ids.
     *
     * Asset's name is optional and it can't be used by another asset if it's provided.
     * Adds mapping between `name` and assigned `asset_id` so asset id can be retrieved by name too (Note: this approach is used in AMM implementation (xyk))
     *
     * Emits 'Registered` event when successful.
     *
     * @param {number | undefined} assetId
     * @param {BytesLike | undefined} name
     * @param {PalletAssetRegistryAssetType} assetType
     * @param {bigint | undefined} existentialDeposit
     * @param {BytesLike | undefined} symbol
     * @param {number | undefined} decimals
     * @param {HydradxRuntimeXcmAssetLocation | undefined} location
     * @param {bigint | undefined} xcmRateLimit
     * @param {boolean} isSufficient
     **/
    register: GenericTxCall<
      (
        assetId: number | undefined,
        name: BytesLike | undefined,
        assetType: PalletAssetRegistryAssetType,
        existentialDeposit: bigint | undefined,
        symbol: BytesLike | undefined,
        decimals: number | undefined,
        location: HydradxRuntimeXcmAssetLocation | undefined,
        xcmRateLimit: bigint | undefined,
        isSufficient: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'AssetRegistry';
          palletCall: {
            name: 'Register';
            params: {
              assetId: number | undefined;
              name: BytesLike | undefined;
              assetType: PalletAssetRegistryAssetType;
              existentialDeposit: bigint | undefined;
              symbol: BytesLike | undefined;
              decimals: number | undefined;
              location: HydradxRuntimeXcmAssetLocation | undefined;
              xcmRateLimit: bigint | undefined;
              isSufficient: boolean;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Update registered asset.
     *
     * All parameteres are optional and value is not updated if param is `None`.
     *
     * `decimals` - can be update by `UpdateOrigin` only if it wasn't set yet. Only
     * `RegistryOrigin` can update `decimals` if it was previously set.
     *
     * `location` - can be updated only by `RegistryOrigin`.
     *
     * Emits `Updated` event when successful.
     *
     * @param {number} assetId
     * @param {BytesLike | undefined} name
     * @param {PalletAssetRegistryAssetType | undefined} assetType
     * @param {bigint | undefined} existentialDeposit
     * @param {bigint | undefined} xcmRateLimit
     * @param {boolean | undefined} isSufficient
     * @param {BytesLike | undefined} symbol
     * @param {number | undefined} decimals
     * @param {HydradxRuntimeXcmAssetLocation | undefined} location
     **/
    update: GenericTxCall<
      (
        assetId: number,
        name: BytesLike | undefined,
        assetType: PalletAssetRegistryAssetType | undefined,
        existentialDeposit: bigint | undefined,
        xcmRateLimit: bigint | undefined,
        isSufficient: boolean | undefined,
        symbol: BytesLike | undefined,
        decimals: number | undefined,
        location: HydradxRuntimeXcmAssetLocation | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'AssetRegistry';
          palletCall: {
            name: 'Update';
            params: {
              assetId: number;
              name: BytesLike | undefined;
              assetType: PalletAssetRegistryAssetType | undefined;
              existentialDeposit: bigint | undefined;
              xcmRateLimit: bigint | undefined;
              isSufficient: boolean | undefined;
              symbol: BytesLike | undefined;
              decimals: number | undefined;
              location: HydradxRuntimeXcmAssetLocation | undefined;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {HydradxRuntimeXcmAssetLocation} location
     **/
    registerExternal: GenericTxCall<
      (location: HydradxRuntimeXcmAssetLocation) => ChainSubmittableExtrinsic<
        {
          pallet: 'AssetRegistry';
          palletCall: {
            name: 'RegisterExternal';
            params: { location: HydradxRuntimeXcmAssetLocation };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {number} assetId
     **/
    banAsset: GenericTxCall<
      (assetId: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'AssetRegistry';
          palletCall: {
            name: 'BanAsset';
            params: { assetId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {number} assetId
     **/
    unbanAsset: GenericTxCall<
      (assetId: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'AssetRegistry';
          palletCall: {
            name: 'UnbanAsset';
            params: { assetId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Claims`'s transaction calls
   **/
  claims: {
    /**
     * Claim xHDX by providing signed message with Ethereum address.
     *
     * @param {PalletClaimsEcdsaSignature} ethereumSignature
     **/
    claim: GenericTxCall<
      (ethereumSignature: PalletClaimsEcdsaSignature) => ChainSubmittableExtrinsic<
        {
          pallet: 'Claims';
          palletCall: {
            name: 'Claim';
            params: { ethereumSignature: PalletClaimsEcdsaSignature };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `GenesisHistory`'s transaction calls
   **/
  genesisHistory: {
    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Omnipool`'s transaction calls
   **/
  omnipool: {
    /**
     * Add new token to omnipool in quantity `amount` at price `initial_price`
     *
     * Initial liquidity must be transferred to pool's account for this new token manually prior to calling `add_token`.
     *
     * Initial liquidity is pool's account balance of the token.
     *
     * Position NFT token is minted for `position_owner`.
     *
     * Parameters:
     * - `asset`: The identifier of the new asset added to the pool. Must be registered in Asset registry
     * - `initial_price`: Initial price
     * - `position_owner`: account id for which share are distributed in form on NFT
     * - `weight_cap`: asset weight cap
     *
     * Emits `TokenAdded` event when successful.
     *
     *
     * @param {number} asset
     * @param {FixedU128} initialPrice
     * @param {Permill} weightCap
     * @param {AccountId32Like} positionOwner
     **/
    addToken: GenericTxCall<
      (
        asset: number,
        initialPrice: FixedU128,
        weightCap: Permill,
        positionOwner: AccountId32Like,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Omnipool';
          palletCall: {
            name: 'AddToken';
            params: { asset: number; initialPrice: FixedU128; weightCap: Permill; positionOwner: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Add liquidity of asset `asset` in quantity `amount` to Omnipool
     *
     * `add_liquidity` adds specified asset amount to Omnipool and in exchange gives the origin
     * corresponding shares amount in form of NFT at current price.
     *
     * Asset's tradable state must contain ADD_LIQUIDITY flag, otherwise `NotAllowed` error is returned.
     *
     * NFT is minted using NTFHandler which implements non-fungibles traits from frame_support.
     *
     * Asset weight cap must be respected, otherwise `AssetWeightExceeded` error is returned.
     * Asset weight is ratio between new HubAsset reserve and total reserve of Hub asset in Omnipool.
     *
     * Add liquidity fails if price difference between spot price and oracle price is higher than allowed by `PriceBarrier`.
     *
     * Parameters:
     * - `asset`: The identifier of the new asset added to the pool. Must be already in the pool
     * - `amount`: Amount of asset added to omnipool
     *
     * Emits `LiquidityAdded` event when successful.
     *
     *
     * @param {number} asset
     * @param {bigint} amount
     **/
    addLiquidity: GenericTxCall<
      (
        asset: number,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Omnipool';
          palletCall: {
            name: 'AddLiquidity';
            params: { asset: number; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Add liquidity of asset `asset` in quantity `amount` to Omnipool.
     *
     * Limit protection is applied.
     *
     * `add_liquidity` adds specified asset amount to Omnipool and in exchange gives the origin
     * corresponding shares amount in form of NFT at current price.
     *
     * Asset's tradable state must contain ADD_LIQUIDITY flag, otherwise `NotAllowed` error is returned.
     *
     * NFT is minted using NTFHandler which implements non-fungibles traits from frame_support.
     *
     * Asset weight cap must be respected, otherwise `AssetWeightExceeded` error is returned.
     * Asset weight is ratio between new HubAsset reserve and total reserve of Hub asset in Omnipool.
     *
     * Add liquidity fails if price difference between spot price and oracle price is higher than allowed by `PriceBarrier`.
     *
     * Parameters:
     * - `asset`: The identifier of the new asset added to the pool. Must be already in the pool
     * - `amount`: Amount of asset added to omnipool
     * - `min_shares_limit`: The min amount of delta share asset the user should receive in the position
     *
     * Emits `LiquidityAdded` event when successful.
     *
     *
     * @param {number} asset
     * @param {bigint} amount
     * @param {bigint} minSharesLimit
     **/
    addLiquidityWithLimit: GenericTxCall<
      (
        asset: number,
        amount: bigint,
        minSharesLimit: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Omnipool';
          palletCall: {
            name: 'AddLiquidityWithLimit';
            params: { asset: number; amount: bigint; minSharesLimit: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove liquidity of asset `asset` in quantity `amount` from Omnipool
     *
     * `remove_liquidity` removes specified shares amount from given PositionId (NFT instance).
     *
     * Asset's tradable state must contain REMOVE_LIQUIDITY flag, otherwise `NotAllowed` error is returned.
     *
     * if all shares from given position are removed, position is destroyed and NFT is burned.
     *
     * Remove liquidity fails if price difference between spot price and oracle price is higher than allowed by `PriceBarrier`.
     *
     * Dynamic withdrawal fee is applied if withdrawal is not safe. It is calculated using spot price and external price oracle.
     * Withdrawal is considered safe when trading is disabled.
     *
     * Parameters:
     * - `position_id`: The identifier of position which liquidity is removed from.
     * - `amount`: Amount of shares removed from omnipool
     *
     * Emits `LiquidityRemoved` event when successful.
     *
     *
     * @param {bigint} positionId
     * @param {bigint} amount
     **/
    removeLiquidity: GenericTxCall<
      (
        positionId: bigint,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Omnipool';
          palletCall: {
            name: 'RemoveLiquidity';
            params: { positionId: bigint; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove liquidity of asset `asset` in quantity `amount` from Omnipool
     *
     * Limit protection is applied.
     *
     * `remove_liquidity` removes specified shares amount from given PositionId (NFT instance).
     *
     * Asset's tradable state must contain REMOVE_LIQUIDITY flag, otherwise `NotAllowed` error is returned.
     *
     * if all shares from given position are removed, position is destroyed and NFT is burned.
     *
     * Remove liquidity fails if price difference between spot price and oracle price is higher than allowed by `PriceBarrier`.
     *
     * Dynamic withdrawal fee is applied if withdrawal is not safe. It is calculated using spot price and external price oracle.
     * Withdrawal is considered safe when trading is disabled.
     *
     * Parameters:
     * - `position_id`: The identifier of position which liquidity is removed from.
     * - `amount`: Amount of shares removed from omnipool
     * - `min_limit`: The min amount of asset to be removed for the user
     *
     * Emits `LiquidityRemoved` event when successful.
     *
     *
     * @param {bigint} positionId
     * @param {bigint} amount
     * @param {bigint} minLimit
     **/
    removeLiquidityWithLimit: GenericTxCall<
      (
        positionId: bigint,
        amount: bigint,
        minLimit: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Omnipool';
          palletCall: {
            name: 'RemoveLiquidityWithLimit';
            params: { positionId: bigint; amount: bigint; minLimit: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove all liquidity from position
     *
     * Limit protection is applied.
     *
     * `remove_all_liquidity` removes all shares amount from given PositionId (NFT instance).
     *
     * Asset's tradable state must contain REMOVE_LIQUIDITY flag, otherwise `NotAllowed` error is returned.
     *
     * if all shares from given position are removed, position is destroyed and NFT is burned.
     *
     * Remove all liquidity fails if price difference between spot price and oracle price is higher than allowed by `PriceBarrier`.
     *
     * Dynamic withdrawal fee is applied if withdrawal is not safe. It is calculated using spot price and external price oracle.
     * Withdrawal is considered safe when trading is disabled.
     *
     * Parameters:
     * - `position_id`: The identifier of position which liquidity is entirely removed from.
     *
     * Emits `LiquidityRemoved` event when successful.
     *
     *
     * @param {bigint} positionId
     * @param {bigint} minLimit
     **/
    removeAllLiquidity: GenericTxCall<
      (
        positionId: bigint,
        minLimit: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Omnipool';
          palletCall: {
            name: 'RemoveAllLiquidity';
            params: { positionId: bigint; minLimit: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Sacrifice LP position in favor of pool.
     *
     * A position is destroyed and liquidity owned by LP becomes pool owned liquidity.
     *
     * Only owner of position can perform this action.
     *
     * Emits `PositionDestroyed`.
     *
     * @param {bigint} positionId
     **/
    sacrificePosition: GenericTxCall<
      (positionId: bigint) => ChainSubmittableExtrinsic<
        {
          pallet: 'Omnipool';
          palletCall: {
            name: 'SacrificePosition';
            params: { positionId: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Execute a swap of `asset_in` for `asset_out`.
     *
     * Price is determined by the Omnipool.
     *
     * Hub asset is traded separately.
     *
     * Asset's tradable states must contain SELL flag for asset_in and BUY flag for asset_out, otherwise `NotAllowed` error is returned.
     *
     * Parameters:
     * - `asset_in`: ID of asset sold to the pool
     * - `asset_out`: ID of asset bought from the pool
     * - `amount`: Amount of asset sold
     * - `min_buy_amount`: Minimum amount required to receive
     *
     * Emits `SellExecuted` event when successful. Deprecated.
     * Emits `pallet_broadcast::Swapped` event when successful.
     *
     *
     * @param {number} assetIn
     * @param {number} assetOut
     * @param {bigint} amount
     * @param {bigint} minBuyAmount
     **/
    sell: GenericTxCall<
      (
        assetIn: number,
        assetOut: number,
        amount: bigint,
        minBuyAmount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Omnipool';
          palletCall: {
            name: 'Sell';
            params: { assetIn: number; assetOut: number; amount: bigint; minBuyAmount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Execute a swap of `asset_out` for `asset_in`.
     *
     * Price is determined by the Omnipool.
     *
     * Hub asset is traded separately.
     *
     * Asset's tradable states must contain SELL flag for asset_in and BUY flag for asset_out, otherwise `NotAllowed` error is returned.
     *
     * Parameters:
     * - `asset_in`: ID of asset sold to the pool
     * - `asset_out`: ID of asset bought from the pool
     * - `amount`: Amount of asset sold
     * - `max_sell_amount`: Maximum amount to be sold.
     *
     * Emits `BuyExecuted` event when successful. Deprecated.
     * Emits `pallet_broadcast::Swapped` event when successful.
     *
     *
     * @param {number} assetOut
     * @param {number} assetIn
     * @param {bigint} amount
     * @param {bigint} maxSellAmount
     **/
    buy: GenericTxCall<
      (
        assetOut: number,
        assetIn: number,
        amount: bigint,
        maxSellAmount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Omnipool';
          palletCall: {
            name: 'Buy';
            params: { assetOut: number; assetIn: number; amount: bigint; maxSellAmount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Update asset's tradable state.
     *
     * Parameters:
     * - `asset_id`: asset id
     * - `state`: new state
     *
     * Emits `TradableStateUpdated` event when successful.
     *
     *
     * @param {number} assetId
     * @param {PalletOmnipoolTradability} state
     **/
    setAssetTradableState: GenericTxCall<
      (
        assetId: number,
        state: PalletOmnipoolTradability,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Omnipool';
          palletCall: {
            name: 'SetAssetTradableState';
            params: { assetId: number; state: PalletOmnipoolTradability };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Refund given amount of asset to a recipient.
     *
     * A refund is needed when a token is refused to be added to Omnipool, and initial liquidity of the asset has been already transferred to pool's account.
     *
     * Transfer can be executed only if asset is not in Omnipool and pool's balance has sufficient amount.
     *
     * Only `AuthorityOrigin` can perform this operation.
     *
     * Emits `AssetRefunded`
     *
     * @param {number} assetId
     * @param {bigint} amount
     * @param {AccountId32Like} recipient
     **/
    refundRefusedAsset: GenericTxCall<
      (
        assetId: number,
        amount: bigint,
        recipient: AccountId32Like,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Omnipool';
          palletCall: {
            name: 'RefundRefusedAsset';
            params: { assetId: number; amount: bigint; recipient: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Update asset's weight cap
     *
     * Parameters:
     * - `asset_id`: asset id
     * - `cap`: new weight cap
     *
     * Emits `AssetWeightCapUpdated` event when successful.
     *
     *
     * @param {number} assetId
     * @param {Permill} cap
     **/
    setAssetWeightCap: GenericTxCall<
      (
        assetId: number,
        cap: Permill,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Omnipool';
          palletCall: {
            name: 'SetAssetWeightCap';
            params: { assetId: number; cap: Permill };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Removes protocol liquidity.
     *
     * Protocol liquidity is liquidity from sacrificed positions. In order to remove protocol liquidity,
     * we need the know the price of the position at the time of sacrifice. Hence this specific call.
     *
     * Only `AuthorityOrigin` can perform this call.
     *
     * Note that sacrifice position will be deprecated in future. There is no longer a need for that.
     *
     * It works the same way as remove liquidity call, but position is temporary reconstructed.
     *
     *
     * @param {number} assetId
     * @param {bigint} amount
     * @param {[bigint, bigint]} price
     * @param {AccountId32Like} dest
     **/
    withdrawProtocolLiquidity: GenericTxCall<
      (
        assetId: number,
        amount: bigint,
        price: [bigint, bigint],
        dest: AccountId32Like,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Omnipool';
          palletCall: {
            name: 'WithdrawProtocolLiquidity';
            params: { assetId: number; amount: bigint; price: [bigint, bigint]; dest: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Removes token from Omnipool.
     *
     * Asset's tradability must be FROZEN, otherwise `AssetNotFrozen` error is returned.
     *
     * Remaining shares must belong to protocol, otherwise `SharesRemaining` error is returned.
     *
     * Protocol's liquidity is transferred to the beneficiary account and hub asset amount is burned.
     *
     * Only `AuthorityOrigin` can perform this call.
     *
     * Emits `TokenRemoved` event when successful.
     *
     * @param {number} assetId
     * @param {AccountId32Like} beneficiary
     **/
    removeToken: GenericTxCall<
      (
        assetId: number,
        beneficiary: AccountId32Like,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Omnipool';
          palletCall: {
            name: 'RemoveToken';
            params: { assetId: number; beneficiary: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `TransactionPause`'s transaction calls
   **/
  transactionPause: {
    /**
     *
     * @param {BytesLike} palletName
     * @param {BytesLike} functionName
     **/
    pauseTransaction: GenericTxCall<
      (
        palletName: BytesLike,
        functionName: BytesLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'TransactionPause';
          palletCall: {
            name: 'PauseTransaction';
            params: { palletName: BytesLike; functionName: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {BytesLike} palletName
     * @param {BytesLike} functionName
     **/
    unpauseTransaction: GenericTxCall<
      (
        palletName: BytesLike,
        functionName: BytesLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'TransactionPause';
          palletCall: {
            name: 'UnpauseTransaction';
            params: { palletName: BytesLike; functionName: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Duster`'s transaction calls
   **/
  duster: {
    /**
     * Dust specified account.
     * IF account balance is < min. existential deposit of given currency, and account is allowed to
     * be dusted, the remaining balance is transferred to treasury account.
     *
     * In case of AToken, we perform an erc20 dust, which does a wihtdraw all then supply atoken on behalf of the dust receiver
     *
     * The transaction fee is returned back in case of successful dusting.
     *
     * Treasury account can never be dusted.
     *
     * Emits `Dusted` event when successful.
     *
     * @param {AccountId32Like} account
     * @param {number} currencyId
     **/
    dustAccount: GenericTxCall<
      (
        account: AccountId32Like,
        currencyId: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Duster';
          palletCall: {
            name: 'DustAccount';
            params: { account: AccountId32Like; currencyId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Add account to list of whitelist accounts. Account which are excluded from dusting.
     * If such account should be dusted - `AccountWhitelisted` error is returned.
     * Only root can perform this action.
     *
     * Emits `Added` event when successful.
     *
     *
     * @param {AccountId32Like} account
     **/
    whitelistAccount: GenericTxCall<
      (account: AccountId32Like) => ChainSubmittableExtrinsic<
        {
          pallet: 'Duster';
          palletCall: {
            name: 'WhitelistAccount';
            params: { account: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove account from list of whitelist accounts. That means account can be dusted again.
     *
     * Emits `Removed` event when successful.
     *
     *
     * @param {AccountId32Like} account
     **/
    removeFromWhitelist: GenericTxCall<
      (account: AccountId32Like) => ChainSubmittableExtrinsic<
        {
          pallet: 'Duster';
          palletCall: {
            name: 'RemoveFromWhitelist';
            params: { account: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `OmnipoolWarehouseLM`'s transaction calls
   **/
  omnipoolWarehouseLM: {
    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `OmnipoolLiquidityMining`'s transaction calls
   **/
  omnipoolLiquidityMining: {
    /**
     * Create a new liquidity mining program with provided parameters.
     *
     * `owner` account has to have at least `total_rewards` balance. These funds will be
     * transferred from `owner` to farm account.
     *
     * The dispatch origin for this call must be `T::CreateOrigin`.
     * !!!WARN: `T::CreateOrigin` has power over funds of `owner`'s account and it should be
     * configured to trusted origin e.g Sudo or Governance.
     *
     * Parameters:
     * - `origin`: account allowed to create new liquidity mining program(root, governance).
     * - `total_rewards`: total rewards planned to distribute. These rewards will be
     * distributed between all yield farms in the global farm.
     * - `planned_yielding_periods`: planned number of periods to distribute `total_rewards`.
     * WARN: THIS IS NOT HARD DEADLINE. Not all rewards have to be distributed in
     * `planned_yielding_periods`. Rewards are distributed based on the situation in the yield
     * farms and can be distributed in a longer, though never in a shorter, time frame.
     * - `blocks_per_period`: number of blocks in a single period. Min. number of blocks per
     * period is 1.
     * - `reward_currency`: payoff currency of rewards.
     * - `owner`: liq. mining farm owner. This account will be able to manage created
     * liquidity mining program.
     * - `yield_per_period`: percentage return on `reward_currency` of all farms.
     * - `min_deposit`: minimum amount of LP shares to be deposited into the liquidity mining by each user.
     * - `lrna_price_adjustment`: price adjustment between `[LRNA]` and `reward_currency`.
     *
     * Emits `GlobalFarmCreated` when successful.
     *
     *
     * @param {bigint} totalRewards
     * @param {number} plannedYieldingPeriods
     * @param {number} blocksPerPeriod
     * @param {number} rewardCurrency
     * @param {AccountId32Like} owner
     * @param {Perquintill} yieldPerPeriod
     * @param {bigint} minDeposit
     * @param {FixedU128} lrnaPriceAdjustment
     **/
    createGlobalFarm: GenericTxCall<
      (
        totalRewards: bigint,
        plannedYieldingPeriods: number,
        blocksPerPeriod: number,
        rewardCurrency: number,
        owner: AccountId32Like,
        yieldPerPeriod: Perquintill,
        minDeposit: bigint,
        lrnaPriceAdjustment: FixedU128,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'OmnipoolLiquidityMining';
          palletCall: {
            name: 'CreateGlobalFarm';
            params: {
              totalRewards: bigint;
              plannedYieldingPeriods: number;
              blocksPerPeriod: number;
              rewardCurrency: number;
              owner: AccountId32Like;
              yieldPerPeriod: Perquintill;
              minDeposit: bigint;
              lrnaPriceAdjustment: FixedU128;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Terminate existing liq. mining program.
     *
     * Only farm owner can perform this action.
     *
     * WARN: To successfully terminate a global farm, farm have to be empty
     * (all yield farms in the global farm must be terminated).
     *
     * Parameters:
     * - `origin`: global farm's owner.
     * - `global_farm_id`: id of global farm to be terminated.
     *
     * Emits `GlobalFarmTerminated` event when successful.
     *
     *
     * @param {number} globalFarmId
     **/
    terminateGlobalFarm: GenericTxCall<
      (globalFarmId: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'OmnipoolLiquidityMining';
          palletCall: {
            name: 'TerminateGlobalFarm';
            params: { globalFarmId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Create yield farm for given `asset_id` in the omnipool.
     *
     * Only farm owner can perform this action.
     *
     * Asset with `asset_id` has to be registered in the omnipool.
     * At most one `active` yield farm can exist in one global farm for the same `asset_id`.
     *
     * Parameters:
     * - `origin`: global farm's owner.
     * - `global_farm_id`: global farm id to which a yield farm will be added.
     * - `asset_id`: id of a asset in the omnipool. Yield farm will be created
     * for this asset and user will be able to lock LP shares into this yield farm immediately.
     * - `multiplier`: yield farm's multiplier.
     * - `loyalty_curve`: curve to calculate loyalty multiplier to distribute rewards to users
     * with time incentive. `None` means no loyalty multiplier.
     *
     * Emits `YieldFarmCreated` event when successful.
     *
     *
     * @param {number} globalFarmId
     * @param {number} assetId
     * @param {FixedU128} multiplier
     * @param {PalletLiquidityMiningLoyaltyCurve | undefined} loyaltyCurve
     **/
    createYieldFarm: GenericTxCall<
      (
        globalFarmId: number,
        assetId: number,
        multiplier: FixedU128,
        loyaltyCurve: PalletLiquidityMiningLoyaltyCurve | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'OmnipoolLiquidityMining';
          palletCall: {
            name: 'CreateYieldFarm';
            params: {
              globalFarmId: number;
              assetId: number;
              multiplier: FixedU128;
              loyaltyCurve: PalletLiquidityMiningLoyaltyCurve | undefined;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Update yield farm's multiplier.
     *
     * Only farm owner can perform this action.
     *
     * Parameters:
     * - `origin`: global farm's owner.
     * - `global_farm_id`: global farm id in which yield farm will be updated.
     * - `asset_id`: id of the asset identifying yield farm in the global farm.
     * - `multiplier`: new yield farm's multiplier.
     *
     * Emits `YieldFarmUpdated` event when successful.
     *
     *
     * @param {number} globalFarmId
     * @param {number} assetId
     * @param {FixedU128} multiplier
     **/
    updateYieldFarm: GenericTxCall<
      (
        globalFarmId: number,
        assetId: number,
        multiplier: FixedU128,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'OmnipoolLiquidityMining';
          palletCall: {
            name: 'UpdateYieldFarm';
            params: { globalFarmId: number; assetId: number; multiplier: FixedU128 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Stop liquidity miming for specific yield farm.
     *
     * This function claims rewards from `GlobalFarm` last time and stop yield farm
     * incentivization from a `GlobalFarm`. Users will be able to only withdraw
     * shares(with claiming) after calling this function.
     * `deposit_shares()` is not allowed on stopped yield farm.
     *
     * Only farm owner can perform this action.
     *
     * Parameters:
     * - `origin`: global farm's owner.
     * - `global_farm_id`: farm id in which yield farm will be canceled.
     * - `asset_id`: id of the asset identifying yield farm in the global farm.
     *
     * Emits `YieldFarmStopped` event when successful.
     *
     *
     * @param {number} globalFarmId
     * @param {number} assetId
     **/
    stopYieldFarm: GenericTxCall<
      (
        globalFarmId: number,
        assetId: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'OmnipoolLiquidityMining';
          palletCall: {
            name: 'StopYieldFarm';
            params: { globalFarmId: number; assetId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Resume incentivization of the asset represented by yield farm.
     *
     * This function resume incentivization of the asset from the `GlobalFarm` and
     * restore full functionality or the yield farm. Users will be able to deposit,
     * claim and withdraw again.
     *
     * WARN: Yield farm(and users) is NOT rewarded for time it was stopped.
     *
     * Only farm owner can perform this action.
     *
     * Parameters:
     * - `origin`: global farm's owner.
     * - `global_farm_id`: global farm id in which yield farm will be resumed.
     * - `yield_farm_id`: id of the yield farm to be resumed.
     * - `asset_id`: id of the asset identifying yield farm in the global farm.
     * - `multiplier`: yield farm multiplier.
     *
     * Emits `YieldFarmResumed` event when successful.
     *
     *
     * @param {number} globalFarmId
     * @param {number} yieldFarmId
     * @param {number} assetId
     * @param {FixedU128} multiplier
     **/
    resumeYieldFarm: GenericTxCall<
      (
        globalFarmId: number,
        yieldFarmId: number,
        assetId: number,
        multiplier: FixedU128,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'OmnipoolLiquidityMining';
          palletCall: {
            name: 'ResumeYieldFarm';
            params: { globalFarmId: number; yieldFarmId: number; assetId: number; multiplier: FixedU128 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Terminate yield farm.
     *
     * This function marks a yield farm as ready to be removed from storage when it's empty. Users will
     * be able to only withdraw shares(without claiming rewards from yield farm). Unpaid rewards
     * will be transferred back to global farm and it will be used to distribute to other yield farms.
     *
     * Yield farm must be stopped before it can be terminated.
     *
     * Only global farm's owner can perform this action. Yield farm stays in the storage until it's
     * empty(all farm entries are withdrawn). Last withdrawn from yield farm trigger removing from
     * the storage.
     *
     * Parameters:
     * - `origin`: global farm's owner.
     * - `global_farm_id`: global farm id in which yield farm should be terminated.
     * - `yield_farm_id`: id of yield farm to be terminated.
     * - `asset_id`: id of the asset identifying yield farm.
     *
     * Emits `YieldFarmTerminated` event when successful.
     *
     *
     * @param {number} globalFarmId
     * @param {number} yieldFarmId
     * @param {number} assetId
     **/
    terminateYieldFarm: GenericTxCall<
      (
        globalFarmId: number,
        yieldFarmId: number,
        assetId: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'OmnipoolLiquidityMining';
          palletCall: {
            name: 'TerminateYieldFarm';
            params: { globalFarmId: number; yieldFarmId: number; assetId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Deposit omnipool position(LP shares) to a liquidity mining.
     *
     * This function transfers omnipool position from `origin` to pallet's account and mint NFT for
     * `origin` account. Minted NFT represents deposit in the liquidity mining. User can
     * deposit omnipool position as a whole(all the LP shares in the position).
     *
     * Parameters:
     * - `origin`: owner of the omnipool position to deposit into the liquidity mining.
     * - `global_farm_id`: id of global farm to which user wants to deposit LP shares.
     * - `yield_farm_id`: id of yield farm to deposit to.
     * - `position_id`: id of the omnipool position to be deposited into the liquidity mining.
     *
     * Emits `SharesDeposited` event when successful.
     *
     *
     * @param {number} globalFarmId
     * @param {number} yieldFarmId
     * @param {bigint} positionId
     **/
    depositShares: GenericTxCall<
      (
        globalFarmId: number,
        yieldFarmId: number,
        positionId: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'OmnipoolLiquidityMining';
          palletCall: {
            name: 'DepositShares';
            params: { globalFarmId: number; yieldFarmId: number; positionId: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Redeposit LP shares in the already locked omnipool position.
     *
     * This function create yield farm entry for existing deposit. Amount of redeposited LP
     * shares is same as amount shares which are already deposited in the deposit.
     *
     * This function DOESN'T create new deposit(NFT).
     *
     * Parameters:
     * - `origin`: owner of the deposit to redeposit.
     * - `global_farm_id`: id of the global farm to which user wants to redeposit LP shares.
     * - `yield_farm_id`: id of the yield farm to redeposit to.
     * - `deposit_id`: identifier of the deposit to redeposit.
     *
     * Emits `SharesRedeposited` event when successful.
     *
     *
     * @param {number} globalFarmId
     * @param {number} yieldFarmId
     * @param {bigint} depositId
     **/
    redepositShares: GenericTxCall<
      (
        globalFarmId: number,
        yieldFarmId: number,
        depositId: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'OmnipoolLiquidityMining';
          palletCall: {
            name: 'RedepositShares';
            params: { globalFarmId: number; yieldFarmId: number; depositId: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Claim rewards from liquidity mining program for deposit represented by the `deposit_id`.
     *
     * This function calculate user rewards from liquidity mining and transfer rewards to `origin`
     * account. Claiming multiple time the same period is not allowed.
     *
     * Parameters:
     * - `origin`: owner of deposit.
     * - `deposit_id`: id of the deposit to claim rewards for.
     * - `yield_farm_id`: id of the yield farm to claim rewards from.
     *
     * Emits `RewardClaimed` event when successful.
     *
     *
     * @param {bigint} depositId
     * @param {number} yieldFarmId
     **/
    claimRewards: GenericTxCall<
      (
        depositId: bigint,
        yieldFarmId: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'OmnipoolLiquidityMining';
          palletCall: {
            name: 'ClaimRewards';
            params: { depositId: bigint; yieldFarmId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * This function claim rewards and withdraw LP shares from yield farm. Omnipool position
     * is transferred to origin only if this is last withdraw in the deposit and deposit is
     * destroyed. This function claim rewards only if yield farm is not terminated and user
     * didn't already claim rewards in current period.
     *
     * Unclaimable rewards represents rewards which user won't be able to claim because of
     * exiting early and these rewards will be transferred back to global farm for future
     * redistribution.
     *
     * Parameters:
     * - `origin`: owner of deposit.
     * - `deposit_id`: id of the deposit to claim rewards for.
     * - `yield_farm_id`: id of the yield farm to claim rewards from.
     *
     * Emits:
     * * `RewardClaimed` event if claimed rewards is > 0
     * * `SharesWithdrawn` event when successful
     * * `DepositDestroyed` event when this was last withdraw from the deposit and deposit was
     * destroyed.
     *
     *
     * @param {bigint} depositId
     * @param {number} yieldFarmId
     **/
    withdrawShares: GenericTxCall<
      (
        depositId: bigint,
        yieldFarmId: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'OmnipoolLiquidityMining';
          palletCall: {
            name: 'WithdrawShares';
            params: { depositId: bigint; yieldFarmId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * This extrinsic updates global farm's main parameters.
     *
     * The dispatch origin for this call must be `T::CreateOrigin`.
     * !!!WARN: `T::CreateOrigin` has power over funds of `owner`'s account and it should be
     * configured to trusted origin e.g Sudo or Governance.
     *
     * Parameters:
     * - `origin`: account allowed to create new liquidity mining program(root, governance).
     * - `global_farm_id`: id of the global farm to update.
     * - `planned_yielding_periods`: planned number of periods to distribute `total_rewards`.
     * - `yield_per_period`: percentage return on `reward_currency` of all farms.
     * - `min_deposit`: minimum amount of LP shares to be deposited into the liquidity mining by each user.
     *
     * Emits `GlobalFarmUpdated` event when successful.
     *
     * @param {number} globalFarmId
     * @param {number} plannedYieldingPeriods
     * @param {Perquintill} yieldPerPeriod
     * @param {bigint} minDeposit
     **/
    updateGlobalFarm: GenericTxCall<
      (
        globalFarmId: number,
        plannedYieldingPeriods: number,
        yieldPerPeriod: Perquintill,
        minDeposit: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'OmnipoolLiquidityMining';
          palletCall: {
            name: 'UpdateGlobalFarm';
            params: {
              globalFarmId: number;
              plannedYieldingPeriods: number;
              yieldPerPeriod: Perquintill;
              minDeposit: bigint;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * This function allows user to join multiple farms with a single omnipool position.
     *
     * Parameters:
     * - `origin`: owner of the omnipool position to deposit into the liquidity mining.
     * - `farm_entries`: list of farms to join.
     * - `position_id`: id of the omnipool position to be deposited into the liquidity mining.
     *
     * Emits `SharesDeposited` event for the first farm entry
     * Emits `SharesRedeposited` event for each farm entry after the first one
     *
     * @param {Array<[number, number]>} farmEntries
     * @param {bigint} positionId
     **/
    joinFarms: GenericTxCall<
      (
        farmEntries: Array<[number, number]>,
        positionId: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'OmnipoolLiquidityMining';
          palletCall: {
            name: 'JoinFarms';
            params: { farmEntries: Array<[number, number]>; positionId: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * This function allows user to add liquidity then use that shares to join multiple farms.
     *
     * Parameters:
     * - `origin`: owner of the omnipool position to deposit into the liquidity mining.
     * - `farm_entries`: list of farms to join.
     * - `asset`: id of the asset to be deposited into the liquidity mining.
     * - `amount`: amount of the asset to be deposited into the liquidity mining.
     * - `min_shares_limit`: The min amount of delta share asset the user should receive in the position
     *
     * Emits `SharesDeposited` event for the first farm entry
     * Emits `SharesRedeposited` event for each farm entry after the first one
     *
     * @param {Array<[number, number]>} farmEntries
     * @param {number} asset
     * @param {bigint} amount
     * @param {bigint | undefined} minSharesLimit
     **/
    addLiquidityAndJoinFarms: GenericTxCall<
      (
        farmEntries: Array<[number, number]>,
        asset: number,
        amount: bigint,
        minSharesLimit: bigint | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'OmnipoolLiquidityMining';
          palletCall: {
            name: 'AddLiquidityAndJoinFarms';
            params: {
              farmEntries: Array<[number, number]>;
              asset: number;
              amount: bigint;
              minSharesLimit: bigint | undefined;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Exit from all specified yield farms
     *
     * This function will attempt to withdraw shares and claim rewards (if available) from all
     * specified yield farms for a given deposit.
     *
     * Parameters:
     * - `origin`: account owner of deposit(nft).
     * - `deposit_id`: id of the deposit to claim rewards for.
     * - `yield_farm_ids`: id(s) of yield farm(s) to exit from.
     *
     * Emits:
     * * `RewardClaimed` for each successful claim
     * * `SharesWithdrawn` for each successful withdrawal
     * * `DepositDestroyed` if the deposit is fully withdrawn
     *
     *
     * @param {bigint} depositId
     * @param {Array<number>} yieldFarmIds
     **/
    exitFarms: GenericTxCall<
      (
        depositId: bigint,
        yieldFarmIds: Array<number>,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'OmnipoolLiquidityMining';
          palletCall: {
            name: 'ExitFarms';
            params: { depositId: bigint; yieldFarmIds: Array<number> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * This function allows user to add liquidity to stableswap pool,
     * then adding the stable shares as liquidity to omnipool
     * then use that omnipool shares to join multiple farms.
     *
     * If farm entries are not specified (empty vectoo), then the liquidities are still added to the pools
     *
     * Parameters:
     * - `origin`: owner of the omnipool position to deposit into the liquidity mining.
     * - `stable_pool_id`: id of the stableswap pool to add liquidity to.
     * - `stable_asset_amounts`: amount of each asset to be deposited into the stableswap pool.
     * - `farm_entries`: list of farms to join.
     * - `min_shares_limit`: optional minimum Omnipool shares to receive (slippage protection).
     * Applies to Omnipool step only. None defaults to no protection.
     *
     * Emits `LiquidityAdded` events from both pool
     * Emits `SharesDeposited` event for the first farm entry
     * Emits `SharesRedeposited` event for each farm entry after the first one
     *
     *
     * @param {number} stablePoolId
     * @param {Array<HydradxTraitsStableswapAssetAmount>} stableAssetAmounts
     * @param {Array<[number, number]> | undefined} farmEntries
     * @param {bigint | undefined} minSharesLimit
     **/
    addLiquidityStableswapOmnipoolAndJoinFarms: GenericTxCall<
      (
        stablePoolId: number,
        stableAssetAmounts: Array<HydradxTraitsStableswapAssetAmount>,
        farmEntries: Array<[number, number]> | undefined,
        minSharesLimit: bigint | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'OmnipoolLiquidityMining';
          palletCall: {
            name: 'AddLiquidityStableswapOmnipoolAndJoinFarms';
            params: {
              stablePoolId: number;
              stableAssetAmounts: Array<HydradxTraitsStableswapAssetAmount>;
              farmEntries: Array<[number, number]> | undefined;
              minSharesLimit: bigint | undefined;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove liquidity from stableswap and omnipool, optionally exiting associated yield farms.
     *
     * This extrinsic reverses the operation performed by `add_liquidity_stableswap_omnipool_and_join_farms`,
     * with optional farm exit to match the optional farm join in the add function.
     *
     * It performs the following steps in order:
     * 1. [OPTIONAL] If deposit_id is provided: Exits from ALL yield farms associated with the deposit (claiming rewards)
     * 2. Removes liquidity from the omnipool to retrieve stableswap shares (protected by omnipool_min_limit)
     * 3. Removes liquidity from the stableswap pool to retrieve underlying assets (protected by stableswap_min_amounts_out)
     *
     * The stabelswap liquidity asset removal strategy is determined by the `min_amounts_out` parameter length:
     * - If 1 asset is specified: Uses `remove_liquidity_one_asset` (trading fee applies)
     * - If multiple assets: Uses `remove_liquidity` (proportional, no trading fee)
     *
     * Parameters:
     * - `origin`: Owner of the omnipool position
     * - `position_id`: The omnipool position NFT ID to remove liquidity from
     * - `omnipool_min_limit`: The min amount of asset to be removed from omnipool (slippage protection)
     * - `stableswap_min_amounts_out`: Asset IDs and minimum amounts minimum amounts of each asset to receive from omnipool.
     * - `deposit_id`: Optional liquidity mining deposit NFT ID. If provided, exits all farms first.
     *
     * Emits events:
     * - If deposit_id provided: `RewardClaimed`, `SharesWithdrawn`, `DepositDestroyed`
     * - Always: Omnipool's `LiquidityRemoved`, Stableswap's `LiquidityRemoved`
     *
     *
     * @param {bigint} positionId
     * @param {bigint} omnipoolMinLimit
     * @param {Array<HydradxTraitsStableswapAssetAmount>} stableswapMinAmountsOut
     * @param {bigint | undefined} depositId
     **/
    removeLiquidityStableswapOmnipoolAndExitFarms: GenericTxCall<
      (
        positionId: bigint,
        omnipoolMinLimit: bigint,
        stableswapMinAmountsOut: Array<HydradxTraitsStableswapAssetAmount>,
        depositId: bigint | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'OmnipoolLiquidityMining';
          palletCall: {
            name: 'RemoveLiquidityStableswapOmnipoolAndExitFarms';
            params: {
              positionId: bigint;
              omnipoolMinLimit: bigint;
              stableswapMinAmountsOut: Array<HydradxTraitsStableswapAssetAmount>;
              depositId: bigint | undefined;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `OTC`'s transaction calls
   **/
  otc: {
    /**
     * Create a new OTC order
     *
     * Parameters:
     * - `asset_in`: Asset which is being bought
     * - `asset_out`: Asset which is being sold
     * - `amount_in`: Amount that the order is seeking to buy
     * - `amount_out`: Amount that the order is selling
     * - `partially_fillable`: Flag indicating whether users can fill the order partially
     *
     * Validations:
     * - asset_in must be registered
     * - amount_in must be higher than the existential deposit of asset_in multiplied by
     * ExistentialDepositMultiplier
     * - amount_out must be higher than the existential deposit of asset_out multiplied by
     * ExistentialDepositMultiplier
     *
     * Events:
     * - `Placed` event when successful.
     *
     * @param {number} assetIn
     * @param {number} assetOut
     * @param {bigint} amountIn
     * @param {bigint} amountOut
     * @param {boolean} partiallyFillable
     **/
    placeOrder: GenericTxCall<
      (
        assetIn: number,
        assetOut: number,
        amountIn: bigint,
        amountOut: bigint,
        partiallyFillable: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Otc';
          palletCall: {
            name: 'PlaceOrder';
            params: {
              assetIn: number;
              assetOut: number;
              amountIn: bigint;
              amountOut: bigint;
              partiallyFillable: boolean;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Fill an OTC order (partially)
     *
     * Parameters:
     * - `order_id`: ID of the order
     * - `amount_in`: Amount with which the order is being filled
     *
     * Validations:
     * - order must be partially_fillable
     * - after the partial_fill, the remaining order.amount_in must be higher than the existential deposit
     * of asset_in multiplied by ExistentialDepositMultiplier
     * - after the partial_fill, the remaining order.amount_out must be higher than the existential deposit
     * of asset_out multiplied by ExistentialDepositMultiplier
     *
     * Events:
     * `PartiallyFilled` event when successful. Deprecated.
     * `pallet_broadcast::Swapped` event when successful.
     *
     * @param {number} orderId
     * @param {bigint} amountIn
     **/
    partialFillOrder: GenericTxCall<
      (
        orderId: number,
        amountIn: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Otc';
          palletCall: {
            name: 'PartialFillOrder';
            params: { orderId: number; amountIn: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Fill an OTC order (completely)
     *
     * Parameters:
     * - `order_id`: ID of the order
     *
     * Events:
     * `Filled` event when successful. Deprecated.
     * `pallet_broadcast::Swapped` event when successful.
     *
     * @param {number} orderId
     **/
    fillOrder: GenericTxCall<
      (orderId: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Otc';
          palletCall: {
            name: 'FillOrder';
            params: { orderId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Cancel an open OTC order
     *
     * Parameters:
     * - `order_id`: ID of the order
     * - `asset`: Asset which is being filled
     * - `amount`: Amount which is being filled
     *
     * Validations:
     * - caller is order owner
     *
     * Emits `Cancelled` event when successful.
     *
     * @param {number} orderId
     **/
    cancelOrder: GenericTxCall<
      (orderId: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Otc';
          palletCall: {
            name: 'CancelOrder';
            params: { orderId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `CircuitBreaker`'s transaction calls
   **/
  circuitBreaker: {
    /**
     * Set trade volume limit for an asset.
     *
     * Parameters:
     * - `origin`: The dispatch origin for this call. Must be `UpdateLimitsOrigin`
     * - `asset_id`: The identifier of an asset
     * - `trade_volume_limit`: New trade volume limit represented as a percentage
     *
     * Emits `TradeVolumeLimitChanged` event when successful.
     *
     *
     * @param {number} assetId
     * @param {[number, number]} tradeVolumeLimit
     **/
    setTradeVolumeLimit: GenericTxCall<
      (
        assetId: number,
        tradeVolumeLimit: [number, number],
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'CircuitBreaker';
          palletCall: {
            name: 'SetTradeVolumeLimit';
            params: { assetId: number; tradeVolumeLimit: [number, number] };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set add liquidity limit for an asset.
     *
     * Parameters:
     * - `origin`: The dispatch origin for this call. Must be `UpdateLimitsOrigin`
     * - `asset_id`: The identifier of an asset
     * - `liquidity_limit`: Optional add liquidity limit represented as a percentage
     *
     * Emits `AddLiquidityLimitChanged` event when successful.
     *
     *
     * @param {number} assetId
     * @param {[number, number] | undefined} liquidityLimit
     **/
    setAddLiquidityLimit: GenericTxCall<
      (
        assetId: number,
        liquidityLimit: [number, number] | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'CircuitBreaker';
          palletCall: {
            name: 'SetAddLiquidityLimit';
            params: { assetId: number; liquidityLimit: [number, number] | undefined };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set remove liquidity limit for an asset.
     *
     * Parameters:
     * - `origin`: The dispatch origin for this call. Must be `UpdateLimitsOrigin`
     * - `asset_id`: The identifier of an asset
     * - `liquidity_limit`: Optional remove liquidity limit represented as a percentage
     *
     * Emits `RemoveLiquidityLimitChanged` event when successful.
     *
     *
     * @param {number} assetId
     * @param {[number, number] | undefined} liquidityLimit
     **/
    setRemoveLiquidityLimit: GenericTxCall<
      (
        assetId: number,
        liquidityLimit: [number, number] | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'CircuitBreaker';
          palletCall: {
            name: 'SetRemoveLiquidityLimit';
            params: { assetId: number; liquidityLimit: [number, number] | undefined };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Lockdown an asset for minting
     *
     * Can be called only by an authority origin
     *
     * Parameters:
     * - `origin`: The dispatch origin for this call. Must be `AuthorityOrigin`
     * - `asset_id`: The identifier of an asset
     * - `until`: The block number until which the asset is locked
     *
     * /// Emits `AssetLockdowned` event when successful.
     *
     * @param {number} assetId
     * @param {number} until
     **/
    lockdownAsset: GenericTxCall<
      (
        assetId: number,
        until: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'CircuitBreaker';
          palletCall: {
            name: 'LockdownAsset';
            params: { assetId: number; until: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove asset lockdown regardless of the state.
     *
     * Can be called only by an authority origin
     *
     * Parameters:
     *
     * - `origin`: The dispatch origin for this call. Must be `AuthorityOrigin`
     * - `asset_id`: The identifier of an asset
     *
     * Emits `AssetLockdownRemoved` event when successful.
     *
     * @param {number} assetId
     **/
    forceLiftLockdown: GenericTxCall<
      (assetId: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'CircuitBreaker';
          palletCall: {
            name: 'ForceLiftLockdown';
            params: { assetId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Release deposit of an asset.
     *
     * It releases all the pallet reserved balance of the asset for the given account
     *
     * Can be called by any origin, but only if the asset is not in active lockdown.
     *
     * The caller does not pay for this call if successful.
     *
     * Parameters:
     * - `origin`: The dispatch origin for this call. Can be signed or root.
     * - `who`: The account that is saving the deposit.
     * - `asset_id`: The identifier of the asset.
     *
     * Emits `DepositReleased` event when successful.
     *
     * @param {AccountId32Like} who
     * @param {number} assetId
     **/
    releaseDeposit: GenericTxCall<
      (
        who: AccountId32Like,
        assetId: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'CircuitBreaker';
          palletCall: {
            name: 'ReleaseDeposit';
            params: { who: AccountId32Like; assetId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Router`'s transaction calls
   **/
  router: {
    /**
     * Executes a sell with a series of trades specified in the route.
     * The price for each trade is determined by the corresponding AMM.
     *
     * - `origin`: The executor of the trade
     * - `asset_in`: The identifier of the asset to sell
     * - `asset_out`: The identifier of the asset to receive
     * - `amount_in`: The amount of `asset_in` to sell
     * - `min_amount_out`: The minimum amount of `asset_out` to receive.
     * - `route`: Series of [`Trade<AssetId>`] to be executed. A [`Trade<AssetId>`] specifies the asset pair (`asset_in`, `asset_out`) and the AMM (`pool`) in which the trade is executed.
     * If not specified, than the on-chain route is used.
     * If no on-chain is present, then omnipool route is used as default
     *
     * Emits `RouteExecuted` when successful.
     *
     * @param {number} assetIn
     * @param {number} assetOut
     * @param {bigint} amountIn
     * @param {bigint} minAmountOut
     * @param {Array<HydradxTraitsRouterTrade>} route
     **/
    sell: GenericTxCall<
      (
        assetIn: number,
        assetOut: number,
        amountIn: bigint,
        minAmountOut: bigint,
        route: Array<HydradxTraitsRouterTrade>,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Router';
          palletCall: {
            name: 'Sell';
            params: {
              assetIn: number;
              assetOut: number;
              amountIn: bigint;
              minAmountOut: bigint;
              route: Array<HydradxTraitsRouterTrade>;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Executes a buy with a series of trades specified in the route.
     * The price for each trade is determined by the corresponding AMM.
     *
     * - `origin`: The executor of the trade
     * - `asset_in`: The identifier of the asset to be swapped to buy `asset_out`
     * - `asset_out`: The identifier of the asset to buy
     * - `amount_out`: The amount of `asset_out` to buy
     * - `max_amount_in`: The max amount of `asset_in` to spend on the buy.
     * - `route`: Series of [`Trade<AssetId>`] to be executed. A [`Trade<AssetId>`] specifies the asset pair (`asset_in`, `asset_out`) and the AMM (`pool`) in which the trade is executed.
     * If not specified, than the on-chain route is used.
     * If no on-chain is present, then omnipool route is used as default
     *
     * Emits `RouteExecuted` when successful.
     *
     * @param {number} assetIn
     * @param {number} assetOut
     * @param {bigint} amountOut
     * @param {bigint} maxAmountIn
     * @param {Array<HydradxTraitsRouterTrade>} route
     **/
    buy: GenericTxCall<
      (
        assetIn: number,
        assetOut: number,
        amountOut: bigint,
        maxAmountIn: bigint,
        route: Array<HydradxTraitsRouterTrade>,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Router';
          palletCall: {
            name: 'Buy';
            params: {
              assetIn: number;
              assetOut: number;
              amountOut: bigint;
              maxAmountIn: bigint;
              route: Array<HydradxTraitsRouterTrade>;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Sets the on-chain route for a given asset pair.
     *
     * The new route is validated by being executed in a dry-run mode
     *
     * If there is no route explicitly set for an asset pair, then we use the omnipool route as default.
     *
     * When a new route is set, we compare it to the existing (or default) route.
     * The comparison happens by calculating sell amount_outs for the routes, but also for the inversed routes.
     *
     * The route is stored in an ordered manner, based on the oder of the ids in the asset pair.
     *
     * If the route is set successfully, then the fee is payed back.
     *
     * - `origin`: The origin of the route setter
     * - `asset_pair`: The identifier of the asset-pair for which the route is set
     * - `new_route`: Series of [`Trade<AssetId>`] to be executed. A [`Trade<AssetId>`] specifies the asset pair (`asset_in`, `asset_out`) and the AMM (`pool`) in which the trade is executed.
     *
     * Emits `RouteUpdated` when successful.
     *
     * Fails with `RouteUpdateIsNotSuccessful` error when failed to set the route
     *
     *
     * @param {HydradxTraitsRouterAssetPair} assetPair
     * @param {Array<HydradxTraitsRouterTrade>} newRoute
     **/
    setRoute: GenericTxCall<
      (
        assetPair: HydradxTraitsRouterAssetPair,
        newRoute: Array<HydradxTraitsRouterTrade>,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Router';
          palletCall: {
            name: 'SetRoute';
            params: { assetPair: HydradxTraitsRouterAssetPair; newRoute: Array<HydradxTraitsRouterTrade> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Force inserts the on-chain route for a given asset pair, so there is no any validation for the route
     *
     * Can only be called by T::ForceInsertOrigin
     *
     * The route is stored in an ordered manner, based on the oder of the ids in the asset pair.
     *
     * If the route is set successfully, then the fee is payed back.
     *
     * - `origin`: The origin of the route setter
     * - `asset_pair`: The identifier of the asset-pair for which the route is set
     * - `new_route`: Series of [`Trade<AssetId>`] to be executed. A [`Trade<AssetId>`] specifies the asset pair (`asset_in`, `asset_out`) and the AMM (`pool`) in which the trade is executed.
     *
     * Emits `RouteUpdated` when successful.
     *
     *
     * @param {HydradxTraitsRouterAssetPair} assetPair
     * @param {Array<HydradxTraitsRouterTrade>} newRoute
     **/
    forceInsertRoute: GenericTxCall<
      (
        assetPair: HydradxTraitsRouterAssetPair,
        newRoute: Array<HydradxTraitsRouterTrade>,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Router';
          palletCall: {
            name: 'ForceInsertRoute';
            params: { assetPair: HydradxTraitsRouterAssetPair; newRoute: Array<HydradxTraitsRouterTrade> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Executes a sell with a series of trades specified in the route.
     * It sells all reducible user balance of `asset_in`
     * The price for each trade is determined by the corresponding AMM.
     *
     * - `origin`: The executor of the trade
     * - `asset_in`: The identifier of the asset to sell
     * - `asset_out`: The identifier of the asset to receive
     * - `min_amount_out`: The minimum amount of `asset_out` to receive.
     * - `route`: Series of [`Trade<AssetId>`] to be executed. A [`Trade<AssetId>`] specifies the asset pair (`asset_in`, `asset_out`) and the AMM (`pool`) in which the trade is executed.
     * If not specified, than the on-chain route is used.
     * If no on-chain is present, then omnipool route is used as default
     *
     * Emits `RouteExecuted` when successful.
     *
     *
     * @param {number} assetIn
     * @param {number} assetOut
     * @param {bigint} minAmountOut
     * @param {Array<HydradxTraitsRouterTrade>} route
     **/
    sellAll: GenericTxCall<
      (
        assetIn: number,
        assetOut: number,
        minAmountOut: bigint,
        route: Array<HydradxTraitsRouterTrade>,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Router';
          palletCall: {
            name: 'SellAll';
            params: { assetIn: number; assetOut: number; minAmountOut: bigint; route: Array<HydradxTraitsRouterTrade> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `DynamicFees`'s transaction calls
   **/
  dynamicFees: {
    /**
     * Set fee configuration for an asset
     *
     * This function allows setting either fixed or dynamic fee configuration for a specific asset.
     *
     * # Arguments
     * * `origin` - Authority origin required
     * * `asset_id` - The asset ID to configure
     * * `config` - Fee configuration (Fixed or Dynamic)
     *
     * @param {number} assetId
     * @param {PalletDynamicFeesAssetFeeConfig} config
     **/
    setAssetFee: GenericTxCall<
      (
        assetId: number,
        config: PalletDynamicFeesAssetFeeConfig,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'DynamicFees';
          palletCall: {
            name: 'SetAssetFee';
            params: { assetId: number; config: PalletDynamicFeesAssetFeeConfig };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove fee configuration for an asset (will use default parameters)
     *
     * This function removes any custom fee configuration for the specified asset.
     * After removal, the asset will use the default dynamic fee parameters configured in the runtime.
     *
     * # Arguments
     * * `origin` - Authority origin required
     * * `asset_id` - The asset ID to remove configuration for
     *
     * @param {number} assetId
     **/
    removeAssetFee: GenericTxCall<
      (assetId: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'DynamicFees';
          palletCall: {
            name: 'RemoveAssetFee';
            params: { assetId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Staking`'s transaction calls
   **/
  staking: {
    /**
     * Staking pallet initialization. This call will reserved `pot`'s balance to prevent
     * account dusting and start collecting fees from trades as rewards.
     *
     * `pot`s account has to have a balance which will be reserved to prevent account dusting.
     *
     * Emits `StakingInitialized` event when successful.
     *
     *
     **/
    initializeStaking: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'InitializeStaking';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Stake `amount` into a new staking position.
     *
     * `stake` locks specified `amount` into staking and creates new NFT representing staking
     * position.
     * Users can stake `NativeAssetId` balance which is not vested or already staked.
     *
     * Staking pallet must be initialized otherwise extrinsic will fail with error.
     *
     * Parameters:
     * - `amount`: Amount of native asset to be staked. `amount` can't be vested or already
     * staked
     *
     * Emits `PositionCreated` event when successful.
     *
     *
     * @param {bigint} amount
     **/
    stake: GenericTxCall<
      (amount: bigint) => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'Stake';
            params: { amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Extrinsic to increase staked amount of existing staking position by specified `amount`.
     *
     * `increase_stake` increases staked amount of position specified by `postion_id` by the
     * `amount` specified by the user.
     * Staking position must exist and `origin` has to be the owner of the position.
     * Users can stake tokens which are not vested or already staked.
     * Position's params e.g points are updated to offset stake increase and rewards
     * accumulated until this point are paid and locked to the user.
     *
     * Parameters:
     * - `position_id`: The identifier of the position which stake will be increased.
     * - `amount`: Amount of native asset to be added to staked amount. `amount` can't be vested or
     * already staked
     *
     * Emits `StakeAdded` event when successful.
     *
     *
     * @param {bigint} positionId
     * @param {bigint} amount
     **/
    increaseStake: GenericTxCall<
      (
        positionId: bigint,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'IncreaseStake';
            params: { positionId: bigint; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Claim rewards accumulated for specific staking position.
     *
     * Function calculates amount of rewards to pay for specified staking position based on
     * the amount of points position accumulated. Function also unlocks all the rewards locked
     * from `increase_stake` based on the amount of the points.
     *
     * This action is penalized by removing all the points and returning allocated unpaid rewards
     * for redistribution.
     *
     * Parameters:
     * - `position_id`: The identifier of the position to claim rewards for.
     *
     * Emits `RewardsClaimed` event when successful.
     *
     *
     * @param {bigint} positionId
     **/
    claim: GenericTxCall<
      (positionId: bigint) => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'Claim';
            params: { positionId: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Function pays rewards, unlocks all the staked assets and destroys staking position
     * specified by `position_id`.
     *
     * Function calculates and pays latest rewards, unlocks all the locked rewards and staked
     * tokens for staking position and burns NFT representing staking position.
     * Unpaid allocated rewards are returned to the Staking for redistribution.
     *
     * Parameters:
     * - `position_id`: The identifier of the position to be destroyed.
     *
     * Emits `RewardsClaimed` and `Unstaked` events when successful.
     *
     *
     * @param {bigint} positionId
     **/
    unstake: GenericTxCall<
      (positionId: bigint) => ChainSubmittableExtrinsic<
        {
          pallet: 'Staking';
          palletCall: {
            name: 'Unstake';
            params: { positionId: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Stableswap`'s transaction calls
   **/
  stableswap: {
    /**
     * Create a stable pool with given list of assets.
     *
     * All assets must be correctly registered in `T::AssetRegistry`.
     * Note that this does not seed the pool with liquidity. Use `add_assets_liquidity` to provide
     * initial liquidity.
     *
     * Parameters:
     * - `origin`: Must be T::AuthorityOrigin
     * - `share_asset`: Preregistered share asset identifier
     * - `assets`: List of Asset ids
     * - `amplification`: Pool amplification
     * - `fee`: fee to be applied on trade and liquidity operations
     *
     * Emits `PoolCreated` event if successful.
     *
     * @param {number} shareAsset
     * @param {Array<number>} assets
     * @param {number} amplification
     * @param {Permill} fee
     **/
    createPool: GenericTxCall<
      (
        shareAsset: number,
        assets: Array<number>,
        amplification: number,
        fee: Permill,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Stableswap';
          palletCall: {
            name: 'CreatePool';
            params: { shareAsset: number; assets: Array<number>; amplification: number; fee: Permill };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Update pool's fee.
     *
     * if pool does not exist, `PoolNotFound` is returned.
     *
     * Parameters:
     * - `origin`: Must be T::AuthorityOrigin
     * - `pool_id`: pool to update
     * - `fee`: new pool fee
     *
     * Emits `FeeUpdated` event if successful.
     *
     * @param {number} poolId
     * @param {Permill} fee
     **/
    updatePoolFee: GenericTxCall<
      (
        poolId: number,
        fee: Permill,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Stableswap';
          palletCall: {
            name: 'UpdatePoolFee';
            params: { poolId: number; fee: Permill };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Update pool's amplification.
     *
     * Parameters:
     * - `origin`: Must be T::AuthorityOrigin
     * - `pool_id`: pool to update
     * - `final_amplification`: new desired pool amplification
     * - `start_block`: block number when the amplification starts to move towards final_amplication
     * - `end_block`: block number when the amplification reaches final_amplification
     *
     * Emits `AmplificationUpdated` event if successful.
     *
     * @param {number} poolId
     * @param {number} finalAmplification
     * @param {number} startBlock
     * @param {number} endBlock
     **/
    updateAmplification: GenericTxCall<
      (
        poolId: number,
        finalAmplification: number,
        startBlock: number,
        endBlock: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Stableswap';
          palletCall: {
            name: 'UpdateAmplification';
            params: { poolId: number; finalAmplification: number; startBlock: number; endBlock: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Add liquidity to selected pool given exact amount of shares to receive.
     *
     * Similar to `add_liquidity` but LP specifies exact amount of shares to receive.
     *
     * This functionality is used mainly by on-chain routing when a swap between Omnipool asset and stable asset is performed.
     *
     * Parameters:
     * - `origin`: liquidity provider
     * - `pool_id`: Pool Id
     * - `shares`: amount of shares to receive
     * - `asset_id`: asset id of an asset to provide as liquidity
     * - `max_asset_amount`: slippage limit. Max amount of asset.
     *
     * Emits `LiquidityAdded` event when successful.
     * Emits `pallet_broadcast::Swapped` event when successful.
     *
     * @param {number} poolId
     * @param {bigint} shares
     * @param {number} assetId
     * @param {bigint} maxAssetAmount
     **/
    addLiquidityShares: GenericTxCall<
      (
        poolId: number,
        shares: bigint,
        assetId: number,
        maxAssetAmount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Stableswap';
          palletCall: {
            name: 'AddLiquidityShares';
            params: { poolId: number; shares: bigint; assetId: number; maxAssetAmount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove liquidity from selected pool.
     *
     * Withdraws liquidity of selected asset from a pool.
     *
     * Share amount is burned and LP receives corresponding amount of chosen asset.
     *
     * Withdraw fee is applied to the asset amount.
     *
     * Parameters:
     * - `origin`: liquidity provider
     * - `pool_id`: Pool Id
     * - `asset_id`: id of asset to receive
     * - 'share_amount': amount of shares to withdraw
     * - 'min_amount_out': minimum amount to receive
     *
     * Emits `LiquidityRemoved` event when successful.
     * Emits `pallet_broadcast::Swapped` event when successful.
     *
     * @param {number} poolId
     * @param {number} assetId
     * @param {bigint} shareAmount
     * @param {bigint} minAmountOut
     **/
    removeLiquidityOneAsset: GenericTxCall<
      (
        poolId: number,
        assetId: number,
        shareAmount: bigint,
        minAmountOut: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Stableswap';
          palletCall: {
            name: 'RemoveLiquidityOneAsset';
            params: { poolId: number; assetId: number; shareAmount: bigint; minAmountOut: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove liquidity from selected pool by specifying exact amount of asset to receive.
     *
     * Similar to `remove_liquidity_one_asset` but LP specifies exact amount of asset to receive instead of share amount.
     *
     * Parameters:
     * - `origin`: liquidity provider
     * - `pool_id`: Pool Id
     * - `asset_id`: id of asset to receive
     * - 'amount': amount of asset to receive
     * - 'max_share_amount': Slippage limit. Max amount of shares to burn.
     *
     * Emits `LiquidityRemoved` event when successful.
     * Emits `pallet_broadcast::Swapped` event when successful.
     *
     * @param {number} poolId
     * @param {number} assetId
     * @param {bigint} amount
     * @param {bigint} maxShareAmount
     **/
    withdrawAssetAmount: GenericTxCall<
      (
        poolId: number,
        assetId: number,
        amount: bigint,
        maxShareAmount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Stableswap';
          palletCall: {
            name: 'WithdrawAssetAmount';
            params: { poolId: number; assetId: number; amount: bigint; maxShareAmount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Execute a swap of `asset_in` for `asset_out`.
     *
     * Parameters:
     * - `origin`: origin of the caller
     * - `pool_id`: Id of a pool
     * - `asset_in`: ID of asset sold to the pool
     * - `asset_out`: ID of asset bought from the pool
     * - `amount_in`: Amount of asset to be sold to the pool
     * - `min_buy_amount`: Minimum amount required to receive
     *
     * Emits `SellExecuted` event when successful. Deprecated.
     * Emits `pallet_broadcast::Swapped` event when successful.
     *
     *
     * @param {number} poolId
     * @param {number} assetIn
     * @param {number} assetOut
     * @param {bigint} amountIn
     * @param {bigint} minBuyAmount
     **/
    sell: GenericTxCall<
      (
        poolId: number,
        assetIn: number,
        assetOut: number,
        amountIn: bigint,
        minBuyAmount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Stableswap';
          palletCall: {
            name: 'Sell';
            params: { poolId: number; assetIn: number; assetOut: number; amountIn: bigint; minBuyAmount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Execute a swap of `asset_out` for `asset_in`.
     *
     * Parameters:
     * - `origin`:
     * - `pool_id`: Id of a pool
     * - `asset_out`: ID of asset bought from the pool
     * - `asset_in`: ID of asset sold to the pool
     * - `amount_out`: Amount of asset to receive from the pool
     * - `max_sell_amount`: Maximum amount allowed to be sold
     *
     * Emits `BuyExecuted` event when successful. Deprecated.
     * Emits `pallet_broadcast::Swapped` event when successful.
     *
     *
     * @param {number} poolId
     * @param {number} assetOut
     * @param {number} assetIn
     * @param {bigint} amountOut
     * @param {bigint} maxSellAmount
     **/
    buy: GenericTxCall<
      (
        poolId: number,
        assetOut: number,
        assetIn: number,
        amountOut: bigint,
        maxSellAmount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Stableswap';
          palletCall: {
            name: 'Buy';
            params: { poolId: number; assetOut: number; assetIn: number; amountOut: bigint; maxSellAmount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Update the tradable state of a specific asset in a pool.
     *
     * This function allows updating the tradability state of an asset within a pool. The tradability state determines whether the asset can be used for specific operations such as adding liquidity, removing liquidity, buying, or selling.
     *
     * Parameters:
     * - `origin`: Must be `T::UpdateTradabilityOrigin`.
     * - `pool_id`: The ID of the pool containing the asset.
     * - `asset_id`: The ID of the asset whose tradability state is to be updated.
     * - `state`: The new tradability state of the asset.
     *
     * Emits `TradableStateUpdated` event when successful.
     *
     * # Errors
     * - `PoolNotFound`: If the specified pool does not exist.
     * - `AssetNotInPool`: If the specified asset is not part of the pool.
     *
     *
     * @param {number} poolId
     * @param {number} assetId
     * @param {PalletStableswapTradability} state
     **/
    setAssetTradableState: GenericTxCall<
      (
        poolId: number,
        assetId: number,
        state: PalletStableswapTradability,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Stableswap';
          palletCall: {
            name: 'SetAssetTradableState';
            params: { poolId: number; assetId: number; state: PalletStableswapTradability };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove liquidity from a selected pool uniformly.
     *
     * This function allows a liquidity provider to withdraw liquidity from a pool.
     * The provider specifies the amount of shares to burn and the minimum amounts of each asset to receive.
     *
     * Parameters:
     * - `origin`: The liquidity provider.
     * - `pool_id`: The ID of the pool from which to remove liquidity.
     * - `share_amount`: The amount of shares to burn.
     * - `min_amounts_out`: A bounded vector specifying the minimum amounts of each asset to receive.
     *
     * Emits `LiquidityRemoved` event when successful.
     * Emits `pallet_broadcast::Swapped` event when successful.
     *
     * # Errors
     * - `InvalidAssetAmount`: If the `share_amount` is zero.
     * - `InsufficientShares`: If the provider does not have enough shares.
     * - `PoolNotFound`: If the specified pool does not exist.
     * - `UnknownDecimals`: If the asset decimals cannot be retrieved.
     * - `IncorrectAssets`: If the provided `min_amounts_out` does not match the pool assets.
     * - `NotAllowed`: If the asset is not allowed for the operation.
     * - `SlippageLimit`: If the amount received is less than the specified minimum amount.
     * - `InsufficientLiquidityRemaining`: If the remaining liquidity in the pool is below the minimum required.
     *
     * # Invariants
     * - Ensures that the pool's reserves are updated correctly after liquidity removal.
     * - Ensures that the pool's invariant is maintained.
     *
     * @param {number} poolId
     * @param {bigint} shareAmount
     * @param {Array<HydradxTraitsStableswapAssetAmount>} minAmountsOut
     **/
    removeLiquidity: GenericTxCall<
      (
        poolId: number,
        shareAmount: bigint,
        minAmountsOut: Array<HydradxTraitsStableswapAssetAmount>,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Stableswap';
          palletCall: {
            name: 'RemoveLiquidity';
            params: { poolId: number; shareAmount: bigint; minAmountsOut: Array<HydradxTraitsStableswapAssetAmount> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Create a stable pool with a given list of assets and pegs.
     *
     * This function allows the creation of a new stable pool with specified assets, amplification, fee, and peg sources. The pool is identified by a share asset.
     *
     * Peg target price is determined by retrieving the target peg from the oracle - it is the price of the asset from the peg sourcedenominated in the other pool assets.
     *
     * Parameters:
     * - `origin`: Must be `T::AuthorityOrigin`.
     * - `share_asset`: Preregistered share asset identifier.
     * - `assets`: List of asset IDs to be included in the pool.
     * - `amplification`: Pool amplification parameter.
     * - `fee`: Fee to be applied on trade and liquidity operations.
     * - `peg_source`: Bounded vector specifying the source of the peg for each asset.
     * - `max_peg_update`: Maximum allowed peg update per block.
     *
     * Emits `PoolCreated` event if successful.
     * Emits `AmplificationChanging` event if successful.
     *
     * # Errors
     * - `IncorrectAssets`: If the assets are the same or less than 2 assets are provided.
     * - `MaxAssetsExceeded`: If the maximum number of assets is exceeded.
     * - `PoolExists`: If a pool with the given assets already exists.
     * - `ShareAssetInPoolAssets`: If the share asset is among the pool assets.
     * - `AssetNotRegistered`: If one or more assets are not registered in the AssetRegistry.
     * - `InvalidAmplification`: If the amplification parameter is invalid.
     * - `IncorrectInitialPegs`: If the initial pegs are incorrect.
     * - `MissingTargetPegOracle`: If the target peg oracle entry is missing.
     * - `IncorrectAssetDecimals`: If the assets have different decimals.
     *
     *
     * @param {number} shareAsset
     * @param {Array<number>} assets
     * @param {number} amplification
     * @param {Permill} fee
     * @param {Array<PalletStableswapPegSource>} pegSource
     * @param {Perbill} maxPegUpdate
     **/
    createPoolWithPegs: GenericTxCall<
      (
        shareAsset: number,
        assets: Array<number>,
        amplification: number,
        fee: Permill,
        pegSource: Array<PalletStableswapPegSource>,
        maxPegUpdate: Perbill,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Stableswap';
          palletCall: {
            name: 'CreatePoolWithPegs';
            params: {
              shareAsset: number;
              assets: Array<number>;
              amplification: number;
              fee: Permill;
              pegSource: Array<PalletStableswapPegSource>;
              maxPegUpdate: Perbill;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Add liquidity to selected pool.
     *
     * First call of `add_assets_liquidity` must provide "initial liquidity" of all assets.
     *
     * If there is liquidity already in the pool, LP can provide liquidity of any number of pool assets.
     *
     * LP must have sufficient amount of each asset.
     *
     * Origin is given corresponding amount of shares.
     *
     * Parameters:
     * - `origin`: liquidity provider
     * - `pool_id`: Pool Id
     * - `assets`: asset id and liquidity amount provided
     * - `min_shares`: minimum amount of shares to receive
     *
     * Emits `LiquidityAdded` event when successful.
     * Emits `pallet_broadcast::Swapped` event when successful.
     *
     * @param {number} poolId
     * @param {Array<HydradxTraitsStableswapAssetAmount>} assets
     * @param {bigint} minShares
     **/
    addAssetsLiquidity: GenericTxCall<
      (
        poolId: number,
        assets: Array<HydradxTraitsStableswapAssetAmount>,
        minShares: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Stableswap';
          palletCall: {
            name: 'AddAssetsLiquidity';
            params: { poolId: number; assets: Array<HydradxTraitsStableswapAssetAmount>; minShares: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Update the peg source for a specific asset in a pool.
     *
     * This function allows updating the peg source for an asset within a pool.
     * The pool must exist and have pegs configured. The asset must be part of the pool.
     * The current price is always preserved when updating the peg source.
     *
     * Parameters:
     * - `origin`: Must be `T::AuthorityOrigin`.
     * - `pool_id`: The ID of the pool containing the asset.
     * - `asset_id`: The ID of the asset whose peg source is to be updated.
     * - `peg_source`: The new peg source for the asset.
     *
     * Emits `PoolPegSourceUpdated` event when successful.
     *
     * # Errors
     * - `PoolNotFound`: If the specified pool does not exist.
     * - `NoPegSource`: If the pool does not have pegs configured.
     * - `AssetNotInPool`: If the specified asset is not part of the pool.
     *
     *
     * @param {number} poolId
     * @param {number} assetId
     * @param {PalletStableswapPegSource} pegSource
     **/
    updateAssetPegSource: GenericTxCall<
      (
        poolId: number,
        assetId: number,
        pegSource: PalletStableswapPegSource,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Stableswap';
          palletCall: {
            name: 'UpdateAssetPegSource';
            params: { poolId: number; assetId: number; pegSource: PalletStableswapPegSource };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Update the maximum peg update percentage for a pool.
     *
     * This function allows updating the maximum percentage by which peg values
     * can change in a pool with pegs configured.
     *
     * Parameters:
     * - `origin`: Must be `T::AuthorityOrigin`.
     * - `pool_id`: The ID of the pool to update.
     * - `max_peg_update`: The new maximum peg update percentage.
     *
     * Emits `PoolMaxPegUpdateUpdated` event when successful.
     *
     * # Errors
     * - `PoolNotFound`: If the specified pool does not exist.
     * - `NoPegSource`: If the pool does not have pegs configured.
     *
     *
     * @param {number} poolId
     * @param {Perbill} maxPegUpdate
     **/
    updatePoolMaxPegUpdate: GenericTxCall<
      (
        poolId: number,
        maxPegUpdate: Perbill,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Stableswap';
          palletCall: {
            name: 'UpdatePoolMaxPegUpdate';
            params: { poolId: number; maxPegUpdate: Perbill };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Bonds`'s transaction calls
   **/
  bonds: {
    /**
     * Issue new fungible bonds.
     * New asset id is registered and assigned to the bonds.
     * The number of bonds the issuer receives is 1:1 to the `amount` of the underlying asset
     * minus the protocol fee.
     * The bond asset is registered with the empty string for the asset name,
     * and with the same existential deposit as of the underlying asset.
     * Bonds can be redeemed for the underlying asset once mature.
     * Protocol fee is applied to the amount, and transferred to `T::FeeReceiver`.
     * When issuing new bonds with the underlying asset and maturity that matches existing bonds,
     * new amount of these existing bonds is issued, instead of registering new bonds.
     * It's possible to issue new bonds for bonds that are already mature.
     *
     * Parameters:
     * - `origin`: issuer of new bonds, needs to be `T::IssueOrigin`
     * - `asset_id`: underlying asset id
     * - `amount`: the amount of the underlying asset
     * - `maturity`: Unix time in milliseconds, when the bonds will be mature.
     *
     * Emits `BondTokenCreated` event when successful and new bonds were registered.
     * Emits `BondsIssued` event when successful.
     *
     *
     * @param {number} assetId
     * @param {bigint} amount
     * @param {bigint} maturity
     **/
    issue: GenericTxCall<
      (
        assetId: number,
        amount: bigint,
        maturity: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Bonds';
          palletCall: {
            name: 'Issue';
            params: { assetId: number; amount: bigint; maturity: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Redeem bonds for the underlying asset.
     * The amount of the underlying asset the `origin` receives is 1:1 to the `amount` of the bonds.
     * Anyone who holds the bonds is able to redeem them.
     * Bonds can be both partially or fully redeemed.
     *
     * Parameters:
     * - `origin`: account id
     * - `asset_id`: bond asset id
     * - `amount`: the amount of the bonds to redeem for the underlying asset
     *
     * Emits `BondsRedeemed` event when successful.
     *
     *
     * @param {number} bondId
     * @param {bigint} amount
     **/
    redeem: GenericTxCall<
      (
        bondId: number,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Bonds';
          palletCall: {
            name: 'Redeem';
            params: { bondId: number; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `OtcSettlements`'s transaction calls
   **/
  otcSettlements: {
    /**
     * Close an existing OTC arbitrage opportunity.
     *
     * Executes a trade between an OTC order and some route.
     * If the OTC order is partially fillable, the extrinsic fails if the existing arbitrage
     * opportunity is not closed or reduced after the trade.
     * If the OTC order is not partially fillable, fails if there is no profit after the trade.
     *
     * `Origin` calling this extrinsic is not paying or receiving anything.
     *
     * The profit made by closing the arbitrage is transferred to `FeeReceiver`.
     *
     * Parameters:
     * - `origin`: Signed or unsigned origin. Unsigned origin doesn't pay the TX fee,
     * but can be submitted only by a collator.
     * - `otc_id`: ID of the OTC order with existing arbitrage opportunity.
     * - `amount`: Amount necessary to close the arb.
     * - `route`: The route we trade against. Required for the fee calculation.
     *
     * Emits `Executed` event when successful.
     *
     *
     * @param {number} otcId
     * @param {bigint} amount
     * @param {Array<HydradxTraitsRouterTrade>} route
     **/
    settleOtcOrder: GenericTxCall<
      (
        otcId: number,
        amount: bigint,
        route: Array<HydradxTraitsRouterTrade>,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'OtcSettlements';
          palletCall: {
            name: 'SettleOtcOrder';
            params: { otcId: number; amount: bigint; route: Array<HydradxTraitsRouterTrade> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `LBP`'s transaction calls
   **/
  lbp: {
    /**
     * Create a new liquidity bootstrapping pool for given asset pair.
     *
     * For any asset pair, only one pool can exist at a time.
     *
     * The dispatch origin for this call must be `T::CreatePoolOrigin`.
     * The pool is created with initial liquidity provided by the `pool_owner` who must have
     * sufficient funds free.
     *
     * The pool starts uninitialized and update_pool call should be called once created to set the start block.
     *
     * This function should be dispatched from governing entity `T::CreatePoolOrigin`
     *
     * Parameters:
     * - `pool_owner`: the future owner of the new pool.
     * - `asset_a`: { asset_id, amount } Asset ID and initial liquidity amount.
     * - `asset_b`: { asset_id, amount } Asset ID and initial liquidity amount.
     * - `initial_weight`: Initial weight of the asset_a. 1_000_000 corresponding to 1% and 100_000_000 to 100%
     * this should be higher than final weight
     * - `final_weight`: Final weight of the asset_a. 1_000_000 corresponding to 1% and 100_000_000 to 100%
     * this should be lower than initial weight
     * - `weight_curve`: The weight function used to update the LBP weights. Currently,
     * there is only one weight function implemented, the linear function.
     * - `fee`: The trading fee charged on every trade distributed to `fee_collector`.
     * - `fee_collector`: The account to which trading fees will be transferred.
     * - `repay_target`: The amount of tokens to repay to separate fee_collector account. Until this amount is
     * reached, fee will be increased to 20% and taken from the pool
     *
     * Emits `PoolCreated` event when successful.
     *
     * BEWARE: We are taking the fee from the accumulated asset. If the accumulated asset is sold to the pool,
     * the fee cost is transferred to the pool. If its bought from the pool the buyer bears the cost.
     * This increases the price of the sold asset on every trade. Make sure to only run this with
     * previously illiquid assets.
     *
     * @param {AccountId32Like} poolOwner
     * @param {number} assetA
     * @param {bigint} assetAAmount
     * @param {number} assetB
     * @param {bigint} assetBAmount
     * @param {number} initialWeight
     * @param {number} finalWeight
     * @param {PalletLbpWeightCurveType} weightCurve
     * @param {[number, number]} fee
     * @param {AccountId32Like} feeCollector
     * @param {bigint} repayTarget
     **/
    createPool: GenericTxCall<
      (
        poolOwner: AccountId32Like,
        assetA: number,
        assetAAmount: bigint,
        assetB: number,
        assetBAmount: bigint,
        initialWeight: number,
        finalWeight: number,
        weightCurve: PalletLbpWeightCurveType,
        fee: [number, number],
        feeCollector: AccountId32Like,
        repayTarget: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Lbp';
          palletCall: {
            name: 'CreatePool';
            params: {
              poolOwner: AccountId32Like;
              assetA: number;
              assetAAmount: bigint;
              assetB: number;
              assetBAmount: bigint;
              initialWeight: number;
              finalWeight: number;
              weightCurve: PalletLbpWeightCurveType;
              fee: [number, number];
              feeCollector: AccountId32Like;
              repayTarget: bigint;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Update pool data of a pool.
     *
     * The dispatch origin for this call must be signed by the pool owner.
     *
     * The pool can be updated only if the sale has not already started.
     *
     * At least one of the following optional parameters has to be specified.
     *
     * Parameters:
     * - `pool_id`: The identifier of the pool to be updated.
     * - `start`: The new starting time of the sale. This parameter is optional.
     * - `end`: The new ending time of the sale. This parameter is optional.
     * - `initial_weight`: The new initial weight. This parameter is optional.
     * - `final_weight`: The new final weight. This parameter is optional.
     * - `fee`: The new trading fee charged on every trade. This parameter is optional.
     * - `fee_collector`: The new receiver of trading fees. This parameter is optional.
     *
     * Emits `PoolUpdated` event when successful.
     *
     * @param {AccountId32Like} poolId
     * @param {AccountId32Like | undefined} poolOwner
     * @param {number | undefined} start
     * @param {number | undefined} end
     * @param {number | undefined} initialWeight
     * @param {number | undefined} finalWeight
     * @param {[number, number] | undefined} fee
     * @param {AccountId32Like | undefined} feeCollector
     * @param {bigint | undefined} repayTarget
     **/
    updatePoolData: GenericTxCall<
      (
        poolId: AccountId32Like,
        poolOwner: AccountId32Like | undefined,
        start: number | undefined,
        end: number | undefined,
        initialWeight: number | undefined,
        finalWeight: number | undefined,
        fee: [number, number] | undefined,
        feeCollector: AccountId32Like | undefined,
        repayTarget: bigint | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Lbp';
          palletCall: {
            name: 'UpdatePoolData';
            params: {
              poolId: AccountId32Like;
              poolOwner: AccountId32Like | undefined;
              start: number | undefined;
              end: number | undefined;
              initialWeight: number | undefined;
              finalWeight: number | undefined;
              fee: [number, number] | undefined;
              feeCollector: AccountId32Like | undefined;
              repayTarget: bigint | undefined;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Add liquidity to a pool.
     *
     * Assets to add has to match the pool assets. At least one amount has to be non-zero.
     *
     * The dispatch origin for this call must be signed by the pool owner.
     *
     * Parameters:
     * - `pool_id`: The identifier of the pool
     * - `amount_a`: The identifier of the asset and the amount to add.
     * - `amount_b`: The identifier of the second asset and the amount to add.
     *
     * Emits `LiquidityAdded` event when successful.
     *
     * @param {[number, bigint]} amountA
     * @param {[number, bigint]} amountB
     **/
    addLiquidity: GenericTxCall<
      (
        amountA: [number, bigint],
        amountB: [number, bigint],
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Lbp';
          palletCall: {
            name: 'AddLiquidity';
            params: { amountA: [number, bigint]; amountB: [number, bigint] };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Transfer all the liquidity from a pool back to the pool owner and destroy the pool.
     * The pool data are also removed from the storage.
     *
     * The pool can't be destroyed during the sale.
     *
     * The dispatch origin for this call must be signed by the pool owner.
     *
     * Parameters:
     * - `amount_a`: The identifier of the asset and the amount to add.
     *
     * Emits 'LiquidityRemoved' when successful.
     *
     * @param {AccountId32Like} poolId
     **/
    removeLiquidity: GenericTxCall<
      (poolId: AccountId32Like) => ChainSubmittableExtrinsic<
        {
          pallet: 'Lbp';
          palletCall: {
            name: 'RemoveLiquidity';
            params: { poolId: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Trade `asset_in` for `asset_out`.
     *
     * Executes a swap of `asset_in` for `asset_out`. Price is determined by the pool and is
     * affected by the amount and proportion of the pool assets and the weights.
     *
     * Trading `fee` is distributed to the `fee_collector`.
     *
     * Parameters:
     * - `asset_in`: The identifier of the asset being transferred from the account to the pool.
     * - `asset_out`: The identifier of the asset being transferred from the pool to the account.
     * - `amount`: The amount of `asset_in`
     * - `max_limit`: minimum amount of `asset_out` / amount of asset_out to be obtained from the pool in exchange for `asset_in`.
     *
     * Emits `SellExecuted` when successful. Deprecated.
     * Emits `pallet_broadcast::Swapped` when successful.
     *
     * @param {number} assetIn
     * @param {number} assetOut
     * @param {bigint} amount
     * @param {bigint} maxLimit
     **/
    sell: GenericTxCall<
      (
        assetIn: number,
        assetOut: number,
        amount: bigint,
        maxLimit: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Lbp';
          palletCall: {
            name: 'Sell';
            params: { assetIn: number; assetOut: number; amount: bigint; maxLimit: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Trade `asset_in` for `asset_out`.
     *
     * Executes a swap of `asset_in` for `asset_out`. Price is determined by the pool and is
     * affected by the amount and the proportion of the pool assets and the weights.
     *
     * Trading `fee` is distributed to the `fee_collector`.
     *
     * Parameters:
     * - `asset_in`: The identifier of the asset being transferred from the account to the pool.
     * - `asset_out`: The identifier of the asset being transferred from the pool to the account.
     * - `amount`: The amount of `asset_out`.
     * - `max_limit`: maximum amount of `asset_in` to be sold in exchange for `asset_out`.
     *
     * Emits `BuyExecuted` when successful. Deprecated.
     * Emits `pallet_broadcast::Swapped` when successful.
     *
     * @param {number} assetOut
     * @param {number} assetIn
     * @param {bigint} amount
     * @param {bigint} maxLimit
     **/
    buy: GenericTxCall<
      (
        assetOut: number,
        assetIn: number,
        amount: bigint,
        maxLimit: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Lbp';
          palletCall: {
            name: 'Buy';
            params: { assetOut: number; assetIn: number; amount: bigint; maxLimit: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `XYK`'s transaction calls
   **/
  xyk: {
    /**
     * Create new pool for given asset pair.
     *
     * Registers new pool for given asset pair (`asset a` and `asset b`) in asset registry.
     * Asset registry creates new id or returns previously created one if such pool existed before.
     *
     * Pool is created with initial liquidity provided by `origin`.
     * Shares are issued with specified initial price and represents proportion of asset in the pool.
     *
     * Emits `PoolCreated` event when successful.
     *
     * @param {number} assetA
     * @param {bigint} amountA
     * @param {number} assetB
     * @param {bigint} amountB
     **/
    createPool: GenericTxCall<
      (
        assetA: number,
        amountA: bigint,
        assetB: number,
        amountB: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Xyk';
          palletCall: {
            name: 'CreatePool';
            params: { assetA: number; amountA: bigint; assetB: number; amountB: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Add liquidity to previously created asset pair pool.
     *
     * Shares are issued with current price.
     *
     * Emits `LiquidityAdded` event when successful.
     *
     * @param {number} assetA
     * @param {number} assetB
     * @param {bigint} amountA
     * @param {bigint} amountBMaxLimit
     **/
    addLiquidity: GenericTxCall<
      (
        assetA: number,
        assetB: number,
        amountA: bigint,
        amountBMaxLimit: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Xyk';
          palletCall: {
            name: 'AddLiquidity';
            params: { assetA: number; assetB: number; amountA: bigint; amountBMaxLimit: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {number} assetA
     * @param {number} assetB
     * @param {bigint} amountA
     * @param {bigint} amountBMaxLimit
     * @param {bigint} minShares
     **/
    addLiquidityWithLimits: GenericTxCall<
      (
        assetA: number,
        assetB: number,
        amountA: bigint,
        amountBMaxLimit: bigint,
        minShares: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Xyk';
          palletCall: {
            name: 'AddLiquidityWithLimits';
            params: { assetA: number; assetB: number; amountA: bigint; amountBMaxLimit: bigint; minShares: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove liquidity from specific liquidity pool in the form of burning shares.
     *
     * If liquidity in the pool reaches 0, it is destroyed.
     *
     * Emits 'LiquidityRemoved' when successful.
     * Emits 'PoolDestroyed' when pool is destroyed.
     *
     * @param {number} assetA
     * @param {number} assetB
     * @param {bigint} shareAmount
     **/
    removeLiquidity: GenericTxCall<
      (
        assetA: number,
        assetB: number,
        shareAmount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Xyk';
          palletCall: {
            name: 'RemoveLiquidity';
            params: { assetA: number; assetB: number; shareAmount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {number} assetA
     * @param {number} assetB
     * @param {bigint} shareAmount
     * @param {bigint} minAmountA
     * @param {bigint} minAmountB
     **/
    removeLiquidityWithLimits: GenericTxCall<
      (
        assetA: number,
        assetB: number,
        shareAmount: bigint,
        minAmountA: bigint,
        minAmountB: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Xyk';
          palletCall: {
            name: 'RemoveLiquidityWithLimits';
            params: { assetA: number; assetB: number; shareAmount: bigint; minAmountA: bigint; minAmountB: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Trade asset in for asset out.
     *
     * Executes a swap of `asset_in` for `asset_out`. Price is determined by the liquidity pool.
     *
     * `max_limit` - minimum amount of `asset_out` / amount of asset_out to be obtained from the pool in exchange for `asset_in`.
     *
     * Emits `SellExecuted` when successful. Deprecated.
     * Emits `pallet_broadcast::Swapped` when successful.
     *
     * @param {number} assetIn
     * @param {number} assetOut
     * @param {bigint} amount
     * @param {bigint} maxLimit
     * @param {boolean} discount
     **/
    sell: GenericTxCall<
      (
        assetIn: number,
        assetOut: number,
        amount: bigint,
        maxLimit: bigint,
        discount: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Xyk';
          palletCall: {
            name: 'Sell';
            params: { assetIn: number; assetOut: number; amount: bigint; maxLimit: bigint; discount: boolean };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Trade asset in for asset out.
     *
     * Executes a swap of `asset_in` for `asset_out`. Price is determined by the liquidity pool.
     *
     * `max_limit` - maximum amount of `asset_in` to be sold in exchange for `asset_out`.
     * Emits `BuyExecuted` when successful. Deprecated.
     * Emits `pallet_broadcast::Swapped` when successful.
     *
     * @param {number} assetOut
     * @param {number} assetIn
     * @param {bigint} amount
     * @param {bigint} maxLimit
     * @param {boolean} discount
     **/
    buy: GenericTxCall<
      (
        assetOut: number,
        assetIn: number,
        amount: bigint,
        maxLimit: bigint,
        discount: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Xyk';
          palletCall: {
            name: 'Buy';
            params: { assetOut: number; assetIn: number; amount: bigint; maxLimit: bigint; discount: boolean };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Referrals`'s transaction calls
   **/
  referrals: {
    /**
     * Register new referral code.
     *
     * `origin` pays the registration fee.
     * `code` is assigned to the given `account`.
     *
     * Length of the `code` must be at least `T::MinCodeLength`.
     * Maximum length is limited to `T::CodeLength`.
     * `code` must contain only alfa-numeric characters and all characters will be converted to upper case.
     *
     * Parameters:
     * - `code`: Code to register. Must follow the restrictions.
     *
     * Emits `CodeRegistered` event when successful.
     *
     * @param {BytesLike} code
     **/
    registerCode: GenericTxCall<
      (code: BytesLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'Referrals';
          palletCall: {
            name: 'RegisterCode';
            params: { code: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Link a code to an account.
     *
     * `Code` must be valid registered code. Otherwise `InvalidCode` is returned.
     *
     * Signer account is linked to the referral account of the code.
     *
     * Parameters:
     * - `code`: Code to use to link the signer account to.
     *
     * Emits `CodeLinked` event when successful.
     *
     * @param {BytesLike} code
     **/
    linkCode: GenericTxCall<
      (code: BytesLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'Referrals';
          palletCall: {
            name: 'LinkCode';
            params: { code: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Convert accrued asset amount to reward currency.
     *
     * Parameters:
     * - `asset_id`: Id of an asset to convert to RewardAsset.
     *
     * Emits `Converted` event when successful.
     *
     * @param {number} assetId
     **/
    convert: GenericTxCall<
      (assetId: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Referrals';
          palletCall: {
            name: 'Convert';
            params: { assetId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Claim accumulated rewards
     *
     * IF there is any asset in the reward pot, all is converted to RewardCurrency first.
     *
     * Reward amount is calculated based on the shares of the signer account.
     *
     * if the signer account is referrer account, total accumulated rewards is updated as well as referrer level if reached.
     *
     * Emits `Claimed` event when successful.
     *
     **/
    claimRewards: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'Referrals';
          palletCall: {
            name: 'ClaimRewards';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set asset reward percentages
     *
     * Parameters:
     * - `asset_id`: asset id
     * - `level`: level
     * - `rewards`: reward fee percentages
     *
     * Emits `AssetRewardsUpdated` event when successful.
     *
     * @param {number} assetId
     * @param {PalletReferralsLevel} level
     * @param {PalletReferralsFeeDistribution} rewards
     **/
    setRewardPercentage: GenericTxCall<
      (
        assetId: number,
        level: PalletReferralsLevel,
        rewards: PalletReferralsFeeDistribution,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Referrals';
          palletCall: {
            name: 'SetRewardPercentage';
            params: { assetId: number; level: PalletReferralsLevel; rewards: PalletReferralsFeeDistribution };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Liquidation`'s transaction calls
   **/
  liquidation: {
    /**
     * Liquidates an existing money market position.
     * Can be both signed and unsigned.
     *
     * Performs a flash loan to get funds to pay for the debt.
     * Received collateral is swapped and the profit is transferred to `FeeReceiver`.
     *
     * Parameters:
     * - `origin`: Signed origin.
     * - `collateral_asset`: Asset ID used as collateral in the MM position.
     * - `debt_asset`: Asset ID used as debt in the MM position.
     * - `user`: EVM address of the MM position that we want to liquidate.
     * - `debt_to_cover`: Amount of debt we want to liquidate.
     * - `route`: The route we trade against. Required for the fee calculation.
     *
     * Emits `Liquidated` event when successful.
     *
     *
     * @param {number} collateralAsset
     * @param {number} debtAsset
     * @param {H160} user
     * @param {bigint} debtToCover
     * @param {Array<HydradxTraitsRouterTrade>} route
     **/
    liquidate: GenericTxCall<
      (
        collateralAsset: number,
        debtAsset: number,
        user: H160,
        debtToCover: bigint,
        route: Array<HydradxTraitsRouterTrade>,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Liquidation';
          palletCall: {
            name: 'Liquidate';
            params: {
              collateralAsset: number;
              debtAsset: number;
              user: H160;
              debtToCover: bigint;
              route: Array<HydradxTraitsRouterTrade>;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the borrowing market contract address.
     *
     * @param {H160} contract
     **/
    setBorrowingContract: GenericTxCall<
      (contract: H160) => ChainSubmittableExtrinsic<
        {
          pallet: 'Liquidation';
          palletCall: {
            name: 'SetBorrowingContract';
            params: { contract: H160 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `HSM`'s transaction calls
   **/
  hsm: {
    /**
     * Add a new collateral asset
     *
     * This function adds a new asset as an approved collateral for Hollar. Only callable by
     * the governance (root origin).
     *
     * Parameters:
     * - `origin`: Must be Root
     * - `asset_id`: Asset ID to be added as collateral
     * - `pool_id`: StableSwap pool ID where this asset and Hollar are paired
     * - `purchase_fee`: Fee applied when buying Hollar with this asset (added to purchase price)
     * - `max_buy_price_coefficient`: Maximum buy price coefficient for HSM to buy back Hollar
     * - `buy_back_fee`: Fee applied when buying back Hollar (subtracted from buy price)
     * - `buyback_rate`: Parameter that controls how quickly HSM can buy Hollar with this asset
     * - `max_in_holding`: Optional maximum amount of collateral HSM can hold
     *
     * Emits:
     * - `CollateralAdded` when the collateral is successfully added
     *
     * Errors:
     * - `AssetAlreadyApproved` if the asset is already registered as a collateral
     * - `PoolAlreadyHasCollateral` if another asset from the same pool is already approved
     * - `HollarNotInPool` if Hollar is not found in the specified pool
     * - `AssetNotInPool` if the collateral asset is not found in the specified pool
     * - Other errors from underlying calls
     *
     * @param {number} assetId
     * @param {number} poolId
     * @param {Permill} purchaseFee
     * @param {FixedU128} maxBuyPriceCoefficient
     * @param {Permill} buyBackFee
     * @param {Perbill} buybackRate
     * @param {bigint | undefined} maxInHolding
     **/
    addCollateralAsset: GenericTxCall<
      (
        assetId: number,
        poolId: number,
        purchaseFee: Permill,
        maxBuyPriceCoefficient: FixedU128,
        buyBackFee: Permill,
        buybackRate: Perbill,
        maxInHolding: bigint | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Hsm';
          palletCall: {
            name: 'AddCollateralAsset';
            params: {
              assetId: number;
              poolId: number;
              purchaseFee: Permill;
              maxBuyPriceCoefficient: FixedU128;
              buyBackFee: Permill;
              buybackRate: Perbill;
              maxInHolding: bigint | undefined;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove a collateral asset
     *
     * Removes an asset from the approved collaterals list. Only callable by the governance (root origin).
     * The collateral must have a zero balance in the HSM account before it can be removed.
     *
     * Parameters:
     * - `origin`: Must be Root
     * - `asset_id`: Asset ID to remove from collaterals
     *
     * Emits:
     * - `CollateralRemoved` when the collateral is successfully removed
     *
     * Errors:
     * - `AssetNotApproved` if the asset is not a registered collateral
     * - `CollateralNotEmpty` if the HSM account still holds some of this asset
     *
     * @param {number} assetId
     **/
    removeCollateralAsset: GenericTxCall<
      (assetId: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'Hsm';
          palletCall: {
            name: 'RemoveCollateralAsset';
            params: { assetId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Update collateral asset parameters
     *
     * Updates the parameters for an existing collateral asset. Only callable by the governance (root origin).
     * Each parameter is optional and only provided parameters will be updated.
     *
     * Parameters:
     * - `origin`: Must be Root
     * - `asset_id`: Asset ID to update
     * - `purchase_fee`: New purchase fee (optional)
     * - `max_buy_price_coefficient`: New max buy price coefficient (optional)
     * - `buy_back_fee`: New buy back fee (optional)
     * - `buyback_rate`: New buyback rate parameter (optional)
     * - `max_in_holding`: New maximum holding amount (optional)
     *
     * Emits:
     * - `CollateralUpdated` when the collateral is successfully updated
     *
     * Errors:
     * - `AssetNotApproved` if the asset is not a registered collateral
     *
     * @param {number} assetId
     * @param {Permill | undefined} purchaseFee
     * @param {FixedU128 | undefined} maxBuyPriceCoefficient
     * @param {Permill | undefined} buyBackFee
     * @param {Perbill | undefined} buybackRate
     * @param {bigint | undefined | undefined} maxInHolding
     **/
    updateCollateralAsset: GenericTxCall<
      (
        assetId: number,
        purchaseFee: Permill | undefined,
        maxBuyPriceCoefficient: FixedU128 | undefined,
        buyBackFee: Permill | undefined,
        buybackRate: Perbill | undefined,
        maxInHolding: bigint | undefined | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Hsm';
          palletCall: {
            name: 'UpdateCollateralAsset';
            params: {
              assetId: number;
              purchaseFee: Permill | undefined;
              maxBuyPriceCoefficient: FixedU128 | undefined;
              buyBackFee: Permill | undefined;
              buybackRate: Perbill | undefined;
              maxInHolding: bigint | undefined | undefined;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Sell asset to HSM
     *
     * This function allows users to:
     * 1. Sell Hollar back to HSM in exchange for collateral assets
     * 2. Sell collateral assets to HSM in exchange for newly minted Hollar
     *
     * The valid pairs must include Hollar as one side and an approved collateral as the other side.
     *
     * Parameters:
     * - `origin`: Account selling the asset
     * - `asset_in`: Asset ID being sold
     * - `asset_out`: Asset ID being bought
     * - `amount_in`: Amount of asset_in to sell
     * - `slippage_limit`: Minimum amount out for slippage protection
     *
     * Emits:
     * - `Swapped3` when the sell is successful
     *
     * Errors:
     * - `InvalidAssetPair` if the pair is not Hollar and an approved collateral
     * - `AssetNotApproved` if the collateral asset isn't registered
     * - `SlippageLimitExceeded` if the amount received is less than the slippage limit
     * - `MaxBuyBackExceeded` if the sell would exceed the maximum buy back rate
     * - `MaxBuyPriceExceeded` if the sell would exceed the maximum buy price
     * - `InsufficientCollateralBalance` if HSM doesn't have enough collateral
     * - `InvalidEVMInteraction` if there's an error interacting with the Hollar ERC20 contract
     * - Other errors from underlying calls
     *
     * @param {number} assetIn
     * @param {number} assetOut
     * @param {bigint} amountIn
     * @param {bigint} slippageLimit
     **/
    sell: GenericTxCall<
      (
        assetIn: number,
        assetOut: number,
        amountIn: bigint,
        slippageLimit: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Hsm';
          palletCall: {
            name: 'Sell';
            params: { assetIn: number; assetOut: number; amountIn: bigint; slippageLimit: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Buy asset from HSM
     *
     * This function allows users to:
     * 1. Buy Hollar from HSM using collateral assets
     * 2. Buy collateral assets from HSM using Hollar
     *
     * The valid pairs must include Hollar as one side and an approved collateral as the other side.
     *
     * Parameters:
     * - `origin`: Account buying the asset
     * - `asset_in`: Asset ID being sold by the user
     * - `asset_out`: Asset ID being bought by the user
     * - `amount_out`: Amount of asset_out to buy
     * - `slippage_limit`: Maximum amount in for slippage protection
     *
     * Emits:
     * - `Swapped3` when the buy is successful
     *
     * Errors:
     * - `InvalidAssetPair` if the pair is not Hollar and an approved collateral
     * - `AssetNotApproved` if the collateral asset isn't registered
     * - `SlippageLimitExceeded` if the amount input exceeds the slippage limit
     * - `MaxHoldingExceeded` if the buy would cause HSM to exceed its maximum holding
     * - `InvalidEVMInteraction` if there's an error interacting with the Hollar ERC20 contract
     * - Other errors from underlying calls
     *
     * @param {number} assetIn
     * @param {number} assetOut
     * @param {bigint} amountOut
     * @param {bigint} slippageLimit
     **/
    buy: GenericTxCall<
      (
        assetIn: number,
        assetOut: number,
        amountOut: bigint,
        slippageLimit: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Hsm';
          palletCall: {
            name: 'Buy';
            params: { assetIn: number; assetOut: number; amountOut: bigint; slippageLimit: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Execute arbitrage opportunity between HSM and collateral stable pool using flash loans
     *
     * This call is designed to be triggered automatically by offchain workers. It executes
     * arbitrage by taking a flash loan from the GHO contract and performing trades to profit
     * from price imbalances between HSM and the StableSwap pool.
     *
     * The arbitrage execution flow:
     * 1. Takes a flash loan of Hollar from the GHO contract
     * 2. Executes trades between HSM and StableSwap pool based on arbitrage direction:
     * - For HollarIn (buy direction): Sell Hollar to HSM for collateral, then sell collateral back for Hollar in pool
     * - For HollarOut (sell direction): Sell Hollar for collateral in pool, then buy Hollar back from HSM
     * 3. Repays the flash loan
     * 4. Any remaining profit (in collateral) is transferred to the ArbitrageProfitReceiver
     *
     * This helps maintain the peg of Hollar by profiting from and correcting price imbalances.
     * The call is unsigned and should only be executed by offchain workers.
     *
     * Parameters:
     * - `origin`: Must be None (unsigned)
     * - `collateral_asset_id`: The ID of the collateral asset to use for arbitrage
     * - `arbitrage`: Optional arbitrage parameters (direction and amount). If None, the function
     * will automatically find and calculate the optimal arbitrage opportunity.
     *
     * Emits:
     * - `ArbitrageExecuted` when the arbitrage is successful
     *
     * Errors:
     * - `FlashMinterNotSet` if the flash minter contract address has not been configured
     * - `AssetNotApproved` if the asset is not a registered collateral
     * - `NoArbitrageOpportunity` if there's no profitable arbitrage opportunity
     * - `MaxBuyPriceExceeded` if the arbitrage would exceed the maximum buy price
     * - `MaxBuyBackExceeded` if the arbitrage would exceed the buyback limit
     * - `InvalidEVMInteraction` if there's an error interacting with the Hollar ERC20 contract
     * - Other errors from underlying calls
     *
     * @param {number} collateralAssetId
     * @param {PalletHsmArbitrage | undefined} arbitrage
     **/
    executeArbitrage: GenericTxCall<
      (
        collateralAssetId: number,
        arbitrage: PalletHsmArbitrage | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Hsm';
          palletCall: {
            name: 'ExecuteArbitrage';
            params: { collateralAssetId: number; arbitrage: PalletHsmArbitrage | undefined };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the flash minter contract address
     *
     * Configures the EVM address of the flash loan contract that will be used for arbitrage
     * operations. This contract must support the ERC-3156 flash loan standard and be trusted
     * to handle flash loans of Hollar tokens.
     *
     * Parameters:
     * - `origin`: Must be authorized (governance/root)
     * - `flash_minter_addr`: The EVM address of the flash minter contract
     *
     * Emits:
     * - `FlashMinterSet` when the address is successfully configured
     *
     * Errors:
     * - Authorization errors if origin is not authorized
     *
     * @param {H160} flashMinterAddr
     **/
    setFlashMinter: GenericTxCall<
      (flashMinterAddr: H160) => ChainSubmittableExtrinsic<
        {
          pallet: 'Hsm';
          palletCall: {
            name: 'SetFlashMinter';
            params: { flashMinterAddr: H160 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Signet`'s transaction calls
   **/
  signet: {
    /**
     * Initialize the pallet with admin, deposit, and chain ID
     *
     * @param {AccountId32Like} admin
     * @param {bigint} signatureDeposit
     * @param {BytesLike} chainId
     **/
    initialize: GenericTxCall<
      (
        admin: AccountId32Like,
        signatureDeposit: bigint,
        chainId: BytesLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Signet';
          palletCall: {
            name: 'Initialize';
            params: { admin: AccountId32Like; signatureDeposit: bigint; chainId: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Update the signature deposit amount (admin only)
     *
     * @param {bigint} newDeposit
     **/
    updateDeposit: GenericTxCall<
      (newDeposit: bigint) => ChainSubmittableExtrinsic<
        {
          pallet: 'Signet';
          palletCall: {
            name: 'UpdateDeposit';
            params: { newDeposit: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Withdraw funds from the pallet account (admin only)
     *
     * @param {AccountId32Like} recipient
     * @param {bigint} amount
     **/
    withdrawFunds: GenericTxCall<
      (
        recipient: AccountId32Like,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Signet';
          palletCall: {
            name: 'WithdrawFunds';
            params: { recipient: AccountId32Like; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Request a signature for a payload
     *
     * @param {FixedBytes<32>} payload
     * @param {number} keyVersion
     * @param {BytesLike} path
     * @param {BytesLike} algo
     * @param {BytesLike} dest
     * @param {BytesLike} params
     **/
    sign: GenericTxCall<
      (
        payload: FixedBytes<32>,
        keyVersion: number,
        path: BytesLike,
        algo: BytesLike,
        dest: BytesLike,
        params: BytesLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Signet';
          palletCall: {
            name: 'Sign';
            params: {
              payload: FixedBytes<32>;
              keyVersion: number;
              path: BytesLike;
              algo: BytesLike;
              dest: BytesLike;
              params: BytesLike;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Request a signature for a serialized transaction
     *
     * @param {BytesLike} serializedTransaction
     * @param {BytesLike} caip2Id
     * @param {number} keyVersion
     * @param {BytesLike} path
     * @param {BytesLike} algo
     * @param {BytesLike} dest
     * @param {BytesLike} params
     * @param {BytesLike} outputDeserializationSchema
     * @param {BytesLike} respondSerializationSchema
     **/
    signBidirectional: GenericTxCall<
      (
        serializedTransaction: BytesLike,
        caip2Id: BytesLike,
        keyVersion: number,
        path: BytesLike,
        algo: BytesLike,
        dest: BytesLike,
        params: BytesLike,
        outputDeserializationSchema: BytesLike,
        respondSerializationSchema: BytesLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Signet';
          palletCall: {
            name: 'SignBidirectional';
            params: {
              serializedTransaction: BytesLike;
              caip2Id: BytesLike;
              keyVersion: number;
              path: BytesLike;
              algo: BytesLike;
              dest: BytesLike;
              params: BytesLike;
              outputDeserializationSchema: BytesLike;
              respondSerializationSchema: BytesLike;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Respond to signature requests (batch support)
     *
     * @param {Array<FixedBytes<32>>} requestIds
     * @param {Array<PalletSignetSignature>} signatures
     **/
    respond: GenericTxCall<
      (
        requestIds: Array<FixedBytes<32>>,
        signatures: Array<PalletSignetSignature>,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Signet';
          palletCall: {
            name: 'Respond';
            params: { requestIds: Array<FixedBytes<32>>; signatures: Array<PalletSignetSignature> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Report signature generation errors (batch support)
     *
     * @param {Array<PalletSignetErrorResponse>} errors
     **/
    respondError: GenericTxCall<
      (errors: Array<PalletSignetErrorResponse>) => ChainSubmittableExtrinsic<
        {
          pallet: 'Signet';
          palletCall: {
            name: 'RespondError';
            params: { errors: Array<PalletSignetErrorResponse> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Provide a read response with signature
     *
     * @param {FixedBytes<32>} requestId
     * @param {BytesLike} serializedOutput
     * @param {PalletSignetSignature} signature
     **/
    respondBidirectional: GenericTxCall<
      (
        requestId: FixedBytes<32>,
        serializedOutput: BytesLike,
        signature: PalletSignetSignature,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Signet';
          palletCall: {
            name: 'RespondBidirectional';
            params: { requestId: FixedBytes<32>; serializedOutput: BytesLike; signature: PalletSignetSignature };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `EthDispenser`'s transaction calls
   **/
  ethDispenser: {
    /**
     * Request ETH from the external faucet for a given EVM address.
     *
     * This call:
     * - Verifies amount bounds and EVM transaction parameters.
     * - Checks the tracked faucet ETH balance against `MinFaucetEthThreshold`.
     * - Charges the configured fee in `FeeAsset`.
     * - Transfers the requested faucet asset from the user to `FeeDestination`.
     * - Builds an EVM transaction calling `IGasFaucet::fund`.
     * - Submits a signing request to SigNet via `pallet_signet::sign_bidirectional`.
     *
     * The `request_id` must match the ID derived internally from the inputs,
     * otherwise the call will fail with `InvalidRequestId`.
     * Parameters:
     * - `to`: Target EVM address to receive ETH.
     * - `amount`: Amount of ETH (in wei) to request.
     * - `request_id`: Client-supplied request ID; must match derived ID.
     * - `tx`: Parameters for the EVM transaction submitted to the faucet.
     *
     * @param {H160} to
     * @param {bigint} amount
     * @param {FixedBytes<32>} requestId
     * @param {PalletDispenserEvmTransactionParams} tx
     **/
    requestFund: GenericTxCall<
      (
        to: H160,
        amount: bigint,
        requestId: FixedBytes<32>,
        tx: PalletDispenserEvmTransactionParams,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'EthDispenser';
          palletCall: {
            name: 'RequestFund';
            params: { to: H160; amount: bigint; requestId: FixedBytes<32>; tx: PalletDispenserEvmTransactionParams };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Pause the dispenser so that no new funding requests can be made.
     *
     * Parameters:
     * - `origin`: Must satisfy `UpdateOrigin`.
     *
     **/
    pause: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'EthDispenser';
          palletCall: {
            name: 'Pause';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Unpause the dispenser so that funding requests are allowed again.
     *
     * Parameters:
     * - `origin`: Must satisfy `UpdateOrigin`
     *
     **/
    unpause: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'EthDispenser';
          palletCall: {
            name: 'Unpause';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Increase the tracked faucet ETH balance (in wei).
     *
     * This is an accounting helper used to keep `FaucetBalanceWei`
     * roughly in sync with the real faucet balance on the EVM chain.
     *
     * Parameters:
     * - `origin`: Must satisfy `UpdateOrigin`.
     * - `balance_wei`: Amount (in wei) to add to the currently stored balance.
     *
     * @param {bigint} balanceWei
     **/
    setFaucetBalance: GenericTxCall<
      (balanceWei: bigint) => ChainSubmittableExtrinsic<
        {
          pallet: 'EthDispenser';
          palletCall: {
            name: 'SetFaucetBalance';
            params: { balanceWei: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Tokens`'s transaction calls
   **/
  tokens: {
    /**
     * Transfer some liquid free balance to another account.
     *
     * `transfer` will set the `FreeBalance` of the sender and receiver.
     * It will decrease the total issuance of the system by the
     * `TransferFee`. If the sender's account is below the existential
     * deposit as a result of the transfer, the account will be reaped.
     *
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     *
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to transfer.
     *
     * @param {AccountId32Like} dest
     * @param {number} currencyId
     * @param {bigint} amount
     **/
    transfer: GenericTxCall<
      (
        dest: AccountId32Like,
        currencyId: number,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Tokens';
          palletCall: {
            name: 'Transfer';
            params: { dest: AccountId32Like; currencyId: number; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Transfer all remaining balance to the given account.
     *
     * NOTE: This function only attempts to transfer _transferable_
     * balances. This means that any locked, reserved, or existential
     * deposits (when `keep_alive` is `true`), will not be transferred by
     * this function. To ensure that this function results in a killed
     * account, you might need to prepare the account by removing any
     * reference counters, storage deposits, etc...
     *
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     *
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `keep_alive`: A boolean to determine if the `transfer_all`
     * operation should send all of the funds the account has, causing
     * the sender account to be killed (false), or transfer everything
     * except at least the existential deposit, which will guarantee to
     * keep the sender account alive (true).
     *
     * @param {AccountId32Like} dest
     * @param {number} currencyId
     * @param {boolean} keepAlive
     **/
    transferAll: GenericTxCall<
      (
        dest: AccountId32Like,
        currencyId: number,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Tokens';
          palletCall: {
            name: 'TransferAll';
            params: { dest: AccountId32Like; currencyId: number; keepAlive: boolean };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Same as the [`transfer`] call, but with a check that the transfer
     * will not kill the origin account.
     *
     * 99% of the time you want [`transfer`] instead.
     *
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     *
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to transfer.
     *
     * @param {AccountId32Like} dest
     * @param {number} currencyId
     * @param {bigint} amount
     **/
    transferKeepAlive: GenericTxCall<
      (
        dest: AccountId32Like,
        currencyId: number,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Tokens';
          palletCall: {
            name: 'TransferKeepAlive';
            params: { dest: AccountId32Like; currencyId: number; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Exactly as `transfer`, except the origin must be root and the source
     * account may be specified.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * - `source`: The sender of the transfer.
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to transfer.
     *
     * @param {AccountId32Like} source
     * @param {AccountId32Like} dest
     * @param {number} currencyId
     * @param {bigint} amount
     **/
    forceTransfer: GenericTxCall<
      (
        source: AccountId32Like,
        dest: AccountId32Like,
        currencyId: number,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Tokens';
          palletCall: {
            name: 'ForceTransfer';
            params: { source: AccountId32Like; dest: AccountId32Like; currencyId: number; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the balances of a given account.
     *
     * This will alter `FreeBalance` and `ReservedBalance` in storage. it
     * will also decrease the total issuance of the system
     * (`TotalIssuance`). If the new free or reserved balance is below the
     * existential deposit, it will reap the `AccountInfo`.
     *
     * The dispatch origin for this call is `root`.
     *
     * @param {AccountId32Like} who
     * @param {number} currencyId
     * @param {bigint} newFree
     * @param {bigint} newReserved
     **/
    setBalance: GenericTxCall<
      (
        who: AccountId32Like,
        currencyId: number,
        newFree: bigint,
        newReserved: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Tokens';
          palletCall: {
            name: 'SetBalance';
            params: { who: AccountId32Like; currencyId: number; newFree: bigint; newReserved: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Currencies`'s transaction calls
   **/
  currencies: {
    /**
     * Transfer some balance to another account under `currency_id`.
     *
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     *
     * @param {AccountId32Like} dest
     * @param {number} currencyId
     * @param {bigint} amount
     **/
    transfer: GenericTxCall<
      (
        dest: AccountId32Like,
        currencyId: number,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Currencies';
          palletCall: {
            name: 'Transfer';
            params: { dest: AccountId32Like; currencyId: number; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Transfer some native currency to another account.
     *
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     *
     * @param {AccountId32Like} dest
     * @param {bigint} amount
     **/
    transferNativeCurrency: GenericTxCall<
      (
        dest: AccountId32Like,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Currencies';
          palletCall: {
            name: 'TransferNativeCurrency';
            params: { dest: AccountId32Like; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * update amount of account `who` under `currency_id`.
     *
     * The dispatch origin of this call must be _Root_.
     *
     * @param {AccountId32Like} who
     * @param {number} currencyId
     * @param {bigint} amount
     **/
    updateBalance: GenericTxCall<
      (
        who: AccountId32Like,
        currencyId: number,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Currencies';
          palletCall: {
            name: 'UpdateBalance';
            params: { who: AccountId32Like; currencyId: number; amount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Vesting`'s transaction calls
   **/
  vesting: {
    /**
     *
     **/
    claim: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'Vesting';
          palletCall: {
            name: 'Claim';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {AccountId32Like} dest
     * @param {OrmlVestingVestingSchedule} schedule
     **/
    vestedTransfer: GenericTxCall<
      (
        dest: AccountId32Like,
        schedule: OrmlVestingVestingSchedule,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Vesting';
          palletCall: {
            name: 'VestedTransfer';
            params: { dest: AccountId32Like; schedule: OrmlVestingVestingSchedule };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {AccountId32Like} who
     * @param {Array<OrmlVestingVestingSchedule>} vestingSchedules
     **/
    updateVestingSchedules: GenericTxCall<
      (
        who: AccountId32Like,
        vestingSchedules: Array<OrmlVestingVestingSchedule>,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Vesting';
          palletCall: {
            name: 'UpdateVestingSchedules';
            params: { who: AccountId32Like; vestingSchedules: Array<OrmlVestingVestingSchedule> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {AccountId32Like} dest
     **/
    claimFor: GenericTxCall<
      (dest: AccountId32Like) => ChainSubmittableExtrinsic<
        {
          pallet: 'Vesting';
          palletCall: {
            name: 'ClaimFor';
            params: { dest: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `EVM`'s transaction calls
   **/
  evm: {
    /**
     * Withdraw balance from EVM into currency/balances pallet.
     *
     * @param {H160} address
     * @param {bigint} value
     **/
    withdraw: GenericTxCall<
      (
        address: H160,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Evm';
          palletCall: {
            name: 'Withdraw';
            params: { address: H160; value: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Issue an EVM call operation. This is similar to a message call transaction in Ethereum.
     *
     * @param {H160} source
     * @param {H160} target
     * @param {BytesLike} input
     * @param {U256} value
     * @param {bigint} gasLimit
     * @param {U256} maxFeePerGas
     * @param {U256 | undefined} maxPriorityFeePerGas
     * @param {U256 | undefined} nonce
     * @param {Array<[H160, Array<H256>]>} accessList
     * @param {Array<EthereumTransactionEip7702AuthorizationListItem>} authorizationList
     **/
    call: GenericTxCall<
      (
        source: H160,
        target: H160,
        input: BytesLike,
        value: U256,
        gasLimit: bigint,
        maxFeePerGas: U256,
        maxPriorityFeePerGas: U256 | undefined,
        nonce: U256 | undefined,
        accessList: Array<[H160, Array<H256>]>,
        authorizationList: Array<EthereumTransactionEip7702AuthorizationListItem>,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Evm';
          palletCall: {
            name: 'Call';
            params: {
              source: H160;
              target: H160;
              input: BytesLike;
              value: U256;
              gasLimit: bigint;
              maxFeePerGas: U256;
              maxPriorityFeePerGas: U256 | undefined;
              nonce: U256 | undefined;
              accessList: Array<[H160, Array<H256>]>;
              authorizationList: Array<EthereumTransactionEip7702AuthorizationListItem>;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Issue an EVM create operation. This is similar to a contract creation transaction in
     * Ethereum.
     *
     * @param {H160} source
     * @param {BytesLike} init
     * @param {U256} value
     * @param {bigint} gasLimit
     * @param {U256} maxFeePerGas
     * @param {U256 | undefined} maxPriorityFeePerGas
     * @param {U256 | undefined} nonce
     * @param {Array<[H160, Array<H256>]>} accessList
     * @param {Array<EthereumTransactionEip7702AuthorizationListItem>} authorizationList
     **/
    create: GenericTxCall<
      (
        source: H160,
        init: BytesLike,
        value: U256,
        gasLimit: bigint,
        maxFeePerGas: U256,
        maxPriorityFeePerGas: U256 | undefined,
        nonce: U256 | undefined,
        accessList: Array<[H160, Array<H256>]>,
        authorizationList: Array<EthereumTransactionEip7702AuthorizationListItem>,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Evm';
          palletCall: {
            name: 'Create';
            params: {
              source: H160;
              init: BytesLike;
              value: U256;
              gasLimit: bigint;
              maxFeePerGas: U256;
              maxPriorityFeePerGas: U256 | undefined;
              nonce: U256 | undefined;
              accessList: Array<[H160, Array<H256>]>;
              authorizationList: Array<EthereumTransactionEip7702AuthorizationListItem>;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Issue an EVM create2 operation.
     *
     * @param {H160} source
     * @param {BytesLike} init
     * @param {H256} salt
     * @param {U256} value
     * @param {bigint} gasLimit
     * @param {U256} maxFeePerGas
     * @param {U256 | undefined} maxPriorityFeePerGas
     * @param {U256 | undefined} nonce
     * @param {Array<[H160, Array<H256>]>} accessList
     * @param {Array<EthereumTransactionEip7702AuthorizationListItem>} authorizationList
     **/
    create2: GenericTxCall<
      (
        source: H160,
        init: BytesLike,
        salt: H256,
        value: U256,
        gasLimit: bigint,
        maxFeePerGas: U256,
        maxPriorityFeePerGas: U256 | undefined,
        nonce: U256 | undefined,
        accessList: Array<[H160, Array<H256>]>,
        authorizationList: Array<EthereumTransactionEip7702AuthorizationListItem>,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Evm';
          palletCall: {
            name: 'Create2';
            params: {
              source: H160;
              init: BytesLike;
              salt: H256;
              value: U256;
              gasLimit: bigint;
              maxFeePerGas: U256;
              maxPriorityFeePerGas: U256 | undefined;
              nonce: U256 | undefined;
              accessList: Array<[H160, Array<H256>]>;
              authorizationList: Array<EthereumTransactionEip7702AuthorizationListItem>;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Ethereum`'s transaction calls
   **/
  ethereum: {
    /**
     * Transact an Ethereum transaction.
     *
     * @param {EthereumTransactionTransactionV3} transaction
     **/
    transact: GenericTxCall<
      (transaction: EthereumTransactionTransactionV3) => ChainSubmittableExtrinsic<
        {
          pallet: 'Ethereum';
          palletCall: {
            name: 'Transact';
            params: { transaction: EthereumTransactionTransactionV3 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `EVMAccounts`'s transaction calls
   **/
  evmAccounts: {
    /**
     * Binds a Substrate address to EVM address.
     * After binding, the EVM is able to convert an EVM address to the original Substrate address.
     * Without binding, the EVM converts an EVM address to a truncated Substrate address, which doesn't correspond
     * to the origin address.
     *
     * Binding an address is not necessary for interacting with the EVM.
     * Increases `sufficients` for the account.
     *
     * Parameters:
     * - `origin`: Substrate account binding an address
     *
     * Emits `EvmAccountBound` event when successful.
     *
     **/
    bindEvmAddress: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'EvmAccounts';
          palletCall: {
            name: 'BindEvmAddress';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Adds an EVM address to the list of addresses that are allowed to deploy smart contracts.
     *
     * Parameters:
     * - `origin`: Substrate account whitelisting an address. Must be `ControllerOrigin`.
     * - `address`: EVM address that is whitelisted
     *
     * Emits `DeployerAdded` event when successful.
     *
     * @param {H160} address
     **/
    addContractDeployer: GenericTxCall<
      (address: H160) => ChainSubmittableExtrinsic<
        {
          pallet: 'EvmAccounts';
          palletCall: {
            name: 'AddContractDeployer';
            params: { address: H160 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Removes an EVM address from the list of addresses that are allowed to deploy smart contracts.
     *
     * Parameters:
     * - `origin`: Substrate account removing the EVM address from the whitelist. Must be `ControllerOrigin`.
     * - `address`: EVM address that is removed from the whitelist
     *
     * Emits `DeployerRemoved` event when successful.
     *
     * @param {H160} address
     **/
    removeContractDeployer: GenericTxCall<
      (address: H160) => ChainSubmittableExtrinsic<
        {
          pallet: 'EvmAccounts';
          palletCall: {
            name: 'RemoveContractDeployer';
            params: { address: H160 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Removes the account's EVM address from the list of addresses that are allowed to deploy smart contracts.
     * Based on the best practices, this extrinsic can be called by any whitelisted account to renounce their own permission.
     *
     * Parameters:
     * - `origin`: Substrate account removing their EVM address from the whitelist.
     *
     * Emits `DeployerRemoved` event when successful.
     *
     **/
    renounceContractDeployer: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'EvmAccounts';
          palletCall: {
            name: 'RenounceContractDeployer';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Adds address of the contract to the list of approved contracts to manage balances.
     *
     * Effectively giving it allowance to for any balances and tokens.
     *
     * Parameters:
     * - `origin`: Must be `ControllerOrigin`.
     * - `address`: Contract address that will be approved
     *
     * Emits `ContractApproved` event when successful.
     *
     * @param {H160} address
     **/
    approveContract: GenericTxCall<
      (address: H160) => ChainSubmittableExtrinsic<
        {
          pallet: 'EvmAccounts';
          palletCall: {
            name: 'ApproveContract';
            params: { address: H160 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Removes address of the contract from the list of approved contracts to manage balances.
     *
     * Parameters:
     * - `origin`: Must be `ControllerOrigin`.
     * - `address`: Contract address that will be disapproved
     *
     * Emits `ContractDisapproved` event when successful.
     *
     * @param {H160} address
     **/
    disapproveContract: GenericTxCall<
      (address: H160) => ChainSubmittableExtrinsic<
        {
          pallet: 'EvmAccounts';
          palletCall: {
            name: 'DisapproveContract';
            params: { address: H160 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Proves ownership of an account and binds it to the EVM address.
     * This is useful for accounts that want to submit some substrate transaction, but only
     * received some ERC20 balance and `System` pallet doesn't register them as a substrate account.
     *
     * Parameters:
     * - `origin`: Unsigned origin.
     * - `account`: Account proving ownership of the address.
     * - `asset_id`: Asset ID to be set as fee currency for the account.
     * - `signature`: Signed message by the account that proves ownership of the account.
     *
     * Emits `AccountClaimed` event when successful.
     *
     * @param {AccountId32Like} account
     * @param {number} assetId
     * @param {SpRuntimeMultiSignature} signature
     **/
    claimAccount: GenericTxCall<
      (
        account: AccountId32Like,
        assetId: number,
        signature: SpRuntimeMultiSignature,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'EvmAccounts';
          palletCall: {
            name: 'ClaimAccount';
            params: { account: AccountId32Like; assetId: number; signature: SpRuntimeMultiSignature };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `XYKLiquidityMining`'s transaction calls
   **/
  xykLiquidityMining: {
    /**
     * Create new liquidity mining program with provided parameters.
     *
     * `owner` account has to have at least `total_rewards` balance. This fund will be
     * transferred from `owner` to farm account.
     * In case of `reward_currency` is insufficient asset, farm's `owner` has to pay existential
     * deposit for global farm account and for liquidity mining `pot` account.
     *
     * The dispatch origin for this call must be `T::CreateOrigin`.
     * !!!WARN: `T::CreateOrigin` has power over funds of `owner`'s account and it should be
     * configured to trusted origin e.g Sudo or Governance.
     *
     * Parameters:
     * - `origin`: global farm's owner.
     * - `total_rewards`: total rewards planned to distribute. This rewards will be
     * distributed between all yield farms in the global farm.
     * - `planned_yielding_periods`: planned number of periods to distribute `total_rewards`.
     * WARN: THIS IS NOT HARD DEADLINE. Not all rewards have to be distributed in
     * `planned_yielding_periods`. Rewards are distributed based on the situation in the yield
     * farms and can be distributed in a longer time frame but never in the shorter time frame.
     * - `blocks_per_period`: number of blocks in a single period. Min. number of blocks per
     * period is 1.
     * - `incentivized_asset`: asset to be incentivized in XYK pools. All yield farms added into
     * liq. mining program have to have `incentivized_asset` in their pair.
     * - `reward_currency`: payoff currency of rewards.
     * - `owner`: liq. mining program owner.
     * - `yield_per_period`: percentage return on `reward_currency` of all farms p.a.
     * - `min_deposit`: minimum amount which can be deposited to the farm
     * - `price_adjustment`:
     * Emits `GlobalFarmCreated` event when successful.
     *
     * @param {bigint} totalRewards
     * @param {number} plannedYieldingPeriods
     * @param {number} blocksPerPeriod
     * @param {number} incentivizedAsset
     * @param {number} rewardCurrency
     * @param {AccountId32Like} owner
     * @param {Perquintill} yieldPerPeriod
     * @param {bigint} minDeposit
     * @param {FixedU128} priceAdjustment
     **/
    createGlobalFarm: GenericTxCall<
      (
        totalRewards: bigint,
        plannedYieldingPeriods: number,
        blocksPerPeriod: number,
        incentivizedAsset: number,
        rewardCurrency: number,
        owner: AccountId32Like,
        yieldPerPeriod: Perquintill,
        minDeposit: bigint,
        priceAdjustment: FixedU128,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'XykLiquidityMining';
          palletCall: {
            name: 'CreateGlobalFarm';
            params: {
              totalRewards: bigint;
              plannedYieldingPeriods: number;
              blocksPerPeriod: number;
              incentivizedAsset: number;
              rewardCurrency: number;
              owner: AccountId32Like;
              yieldPerPeriod: Perquintill;
              minDeposit: bigint;
              priceAdjustment: FixedU128;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Update global farm's prices adjustment.
     *
     * Only farm's owner can perform this action.
     *
     * Parameters:
     * - `origin`: global farm's owner.
     * - `global_farm_id`: id of the global farm to update
     * - `price_adjustment`: new value for price adjustment
     *
     * Emits `GlobalFarmUpdated` event when successful.
     *
     * @param {number} globalFarmId
     * @param {FixedU128} priceAdjustment
     **/
    updateGlobalFarm: GenericTxCall<
      (
        globalFarmId: number,
        priceAdjustment: FixedU128,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'XykLiquidityMining';
          palletCall: {
            name: 'UpdateGlobalFarm';
            params: { globalFarmId: number; priceAdjustment: FixedU128 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Terminate existing liq. mining program.
     *
     * Only farm owner can perform this action.
     *
     * WARN: To successfully terminate a farm, farm have to be empty(all yield farms in he global farm must be terminated).
     *
     * Parameters:
     * - `origin`: global farm's owner.
     * - `global_farm_id`: id of global farm to be terminated.
     *
     * Emits `GlobalFarmTerminated` event when successful.
     *
     * @param {number} globalFarmId
     **/
    terminateGlobalFarm: GenericTxCall<
      (globalFarmId: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'XykLiquidityMining';
          palletCall: {
            name: 'TerminateGlobalFarm';
            params: { globalFarmId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Add yield farm for given `asset_pair` XYK pool.
     *
     * Only farm owner can perform this action.
     *
     * Only XYKs with `asset_pair` with `incentivized_asset` can be added into the farm. XYK
     * pool for `asset_pair` has to exist to successfully create yield farm.
     * Yield farm for same `asset_pair` can exist only once in the global farm.
     *
     * Parameters:
     * - `origin`: global farm's owner.
     * - `farm_id`: global farm id to which a yield farm will be added.
     * - `asset_pair`: asset pair identifying yield farm. Liq. mining will be allowed for this
     * `asset_pair` and one of the assets in the pair must be `incentivized_asset`.
     * - `multiplier`: yield farm multiplier.
     * - `loyalty_curve`: curve to calculate loyalty multiplier to distribute rewards to users
     * with time incentive. `None` means no loyalty multiplier.
     *
     * Emits `YieldFarmCreated` event when successful.
     *
     * @param {number} globalFarmId
     * @param {PalletXykAssetPair} assetPair
     * @param {FixedU128} multiplier
     * @param {PalletLiquidityMiningLoyaltyCurve | undefined} loyaltyCurve
     **/
    createYieldFarm: GenericTxCall<
      (
        globalFarmId: number,
        assetPair: PalletXykAssetPair,
        multiplier: FixedU128,
        loyaltyCurve: PalletLiquidityMiningLoyaltyCurve | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'XykLiquidityMining';
          palletCall: {
            name: 'CreateYieldFarm';
            params: {
              globalFarmId: number;
              assetPair: PalletXykAssetPair;
              multiplier: FixedU128;
              loyaltyCurve: PalletLiquidityMiningLoyaltyCurve | undefined;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Update yield farm multiplier.
     *
     * Only farm owner can perform this action.
     *
     * Parameters:
     * - `origin`: global farm's owner.
     * - `global_farm_id`: global farm id in which yield farm will be updated.
     * - `asset_pair`: asset pair identifying yield farm in global farm.
     * - `multiplier`: new yield farm multiplier.
     *
     * Emits `YieldFarmUpdated` event when successful.
     *
     * @param {number} globalFarmId
     * @param {PalletXykAssetPair} assetPair
     * @param {FixedU128} multiplier
     **/
    updateYieldFarm: GenericTxCall<
      (
        globalFarmId: number,
        assetPair: PalletXykAssetPair,
        multiplier: FixedU128,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'XykLiquidityMining';
          palletCall: {
            name: 'UpdateYieldFarm';
            params: { globalFarmId: number; assetPair: PalletXykAssetPair; multiplier: FixedU128 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Stop liq. miming for specific yield farm.
     *
     * This function claims rewards from `GlobalFarm` last time and stops yield farm
     * incentivization from a `GlobalFarm`. Users will be able to only withdraw
     * shares(with claiming) after calling this function.
     * `deposit_shares()` and `claim_rewards()` are not allowed on canceled yield farm.
     *
     * Only farm owner can perform this action.
     *
     * Parameters:
     * - `origin`: global farm's owner.
     * - `global_farm_id`: farm id in which yield farm will be canceled.
     * - `asset_pair`: asset pair identifying yield farm in the farm.
     *
     * Emits `YieldFarmStopped` event when successful.
     *
     * @param {number} globalFarmId
     * @param {PalletXykAssetPair} assetPair
     **/
    stopYieldFarm: GenericTxCall<
      (
        globalFarmId: number,
        assetPair: PalletXykAssetPair,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'XykLiquidityMining';
          palletCall: {
            name: 'StopYieldFarm';
            params: { globalFarmId: number; assetPair: PalletXykAssetPair };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Resume yield farm for stopped yield farm.
     *
     * This function resume incentivization from `GlobalFarm` and restore full functionality
     * for yield farm. Users will be able to deposit, claim and withdraw again.
     *
     * WARN: Yield farm is NOT rewarded for time it was stopped.
     *
     * Only farm owner can perform this action.
     *
     * Parameters:
     * - `origin`: global farm's owner.
     * - `global_farm_id`: global farm id in which yield farm will be resumed.
     * - `yield_farm_id`: id of yield farm to be resumed.
     * - `asset_pair`: asset pair identifying yield farm in global farm.
     * - `multiplier`: yield farm multiplier in the farm.
     *
     * Emits `YieldFarmResumed` event when successful.
     *
     * @param {number} globalFarmId
     * @param {number} yieldFarmId
     * @param {PalletXykAssetPair} assetPair
     * @param {FixedU128} multiplier
     **/
    resumeYieldFarm: GenericTxCall<
      (
        globalFarmId: number,
        yieldFarmId: number,
        assetPair: PalletXykAssetPair,
        multiplier: FixedU128,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'XykLiquidityMining';
          palletCall: {
            name: 'ResumeYieldFarm';
            params: { globalFarmId: number; yieldFarmId: number; assetPair: PalletXykAssetPair; multiplier: FixedU128 };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove yield farm
     *
     * This function marks a yield farm as ready to be removed from storage when it's empty. Users will
     * be able to only withdraw shares(without claiming rewards from yield farm). Unpaid rewards
     * will be transferred back to global farm and will be used to distribute to other yield farms.
     *
     * Yield farm must be stopped before calling this function.
     *
     * Only global farm's owner can perform this action. Yield farm stays in the storage until it's
     * empty(all farm entries are withdrawn). Last withdrawn from yield farm trigger removing from
     * the storage.
     *
     * Parameters:
     * - `origin`: global farm's owner.
     * - `global_farm_id`: farm id from which yield farm should be terminated.
     * - `yield_farm_id`: id of yield farm to be terminated.
     * - `asset_pair`: asset pair identifying yield farm in the global farm.
     *
     * Emits `YieldFarmTerminated` event when successful.
     *
     * @param {number} globalFarmId
     * @param {number} yieldFarmId
     * @param {PalletXykAssetPair} assetPair
     **/
    terminateYieldFarm: GenericTxCall<
      (
        globalFarmId: number,
        yieldFarmId: number,
        assetPair: PalletXykAssetPair,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'XykLiquidityMining';
          palletCall: {
            name: 'TerminateYieldFarm';
            params: { globalFarmId: number; yieldFarmId: number; assetPair: PalletXykAssetPair };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Deposit LP shares to a liq. mining.
     *
     * This function transfers LP shares from `origin` to pallet's account and mint nft for
     * `origin` account. Minted nft represents deposit in the liq. mining.
     *
     * Parameters:
     * - `origin`: account depositing LP shares. This account has to have at least
     * `shares_amount` of LP shares.
     * - `global_farm_id`: id of global farm to which user wants to deposit LP shares.
     * - `yield_farm_id`: id of yield farm to deposit to.
     * - `asset_pair`: asset pair identifying LP shares user wants to deposit.
     * - `shares_amount`: amount of LP shares user wants to deposit.
     *
     * Emits `SharesDeposited` event when successful.
     *
     * @param {number} globalFarmId
     * @param {number} yieldFarmId
     * @param {PalletXykAssetPair} assetPair
     * @param {bigint} sharesAmount
     **/
    depositShares: GenericTxCall<
      (
        globalFarmId: number,
        yieldFarmId: number,
        assetPair: PalletXykAssetPair,
        sharesAmount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'XykLiquidityMining';
          palletCall: {
            name: 'DepositShares';
            params: { globalFarmId: number; yieldFarmId: number; assetPair: PalletXykAssetPair; sharesAmount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Join multiple farms with a given share amount
     *
     * The share is deposited to the first farm of the specified fams,
     * and then redeposit the shares to the remaining farms
     *
     * Parameters:
     * - `origin`: account depositing LP shares. This account has to have at least
     * - `farm_entries`: list of global farm id and yield farm id pairs to join
     * - `asset_pair`: asset pair identifying LP shares user wants to deposit.
     * - `shares_amount`: amount of LP shares user wants to deposit.
     *
     * Emits `SharesDeposited` event for the first farm entry
     * Emits `SharesRedeposited` event for each farm entry after the first one
     *
     * @param {Array<[number, number]>} farmEntries
     * @param {PalletXykAssetPair} assetPair
     * @param {bigint} sharesAmount
     **/
    joinFarms: GenericTxCall<
      (
        farmEntries: Array<[number, number]>,
        assetPair: PalletXykAssetPair,
        sharesAmount: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'XykLiquidityMining';
          palletCall: {
            name: 'JoinFarms';
            params: { farmEntries: Array<[number, number]>; assetPair: PalletXykAssetPair; sharesAmount: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Add liquidity to XYK pool and join multiple farms with a given share amount
     *
     * The share is deposited to the first farm of the specified entries,
     * and then redeposit the shares to the remaining farms
     *
     * Parameters:
     * - `origin`: account depositing LP shares. This account has to have at least
     * - `asset_a`: asset id of the first asset in the pair
     * - `asset_b`: asset id of the second asset in the pair
     * - `amount_a`: amount of the first asset to deposit
     * - `amount_b_max_limit`: maximum amount of the second asset to deposit
     * - `farm_entries`: list of global farm id and yield farm id pairs to join
     *
     * Emits `SharesDeposited` event for the first farm entry
     * Emits `SharesRedeposited` event for each farm entry after the first one
     *
     * @param {number} assetA
     * @param {number} assetB
     * @param {bigint} amountA
     * @param {bigint} amountBMaxLimit
     * @param {Array<[number, number]>} farmEntries
     **/
    addLiquidityAndJoinFarms: GenericTxCall<
      (
        assetA: number,
        assetB: number,
        amountA: bigint,
        amountBMaxLimit: bigint,
        farmEntries: Array<[number, number]>,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'XykLiquidityMining';
          palletCall: {
            name: 'AddLiquidityAndJoinFarms';
            params: {
              assetA: number;
              assetB: number;
              amountA: bigint;
              amountBMaxLimit: bigint;
              farmEntries: Array<[number, number]>;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Redeposit already locked LP shares to another yield farm.
     *
     * This function create yield farm entry for existing deposit. LP shares are not transferred
     * and amount of LP shares is based on existing deposit.
     *
     * This function DOESN'T create new deposit.
     *
     * Parameters:
     * - `origin`: account depositing LP shares. This account have to have at least
     * - `global_farm_id`: global farm identifier.
     * - `yield_farm_id`: yield farm identifier redepositing to.
     * - `asset_pair`: asset pair identifying LP shares user want to deposit.
     * - `deposit_id`: identifier of the deposit.
     *
     * Emits `SharesRedeposited` event when successful.
     *
     * @param {number} globalFarmId
     * @param {number} yieldFarmId
     * @param {PalletXykAssetPair} assetPair
     * @param {bigint} depositId
     **/
    redepositShares: GenericTxCall<
      (
        globalFarmId: number,
        yieldFarmId: number,
        assetPair: PalletXykAssetPair,
        depositId: bigint,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'XykLiquidityMining';
          palletCall: {
            name: 'RedepositShares';
            params: { globalFarmId: number; yieldFarmId: number; assetPair: PalletXykAssetPair; depositId: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Claim rewards from liq. mining for deposit represented by `nft_id`.
     *
     * This function calculate user rewards from liq. mining and transfer rewards to `origin`
     * account. Claiming in the same period is allowed only once.
     *
     * Parameters:
     * - `origin`: account owner of deposit(nft).
     * - `deposit_id`: nft id representing deposit in the yield farm.
     * - `yield_farm_id`: yield farm identifier to claim rewards from.
     *
     * Emits `RewardClaimed` event when successful.
     *
     * @param {bigint} depositId
     * @param {number} yieldFarmId
     **/
    claimRewards: GenericTxCall<
      (
        depositId: bigint,
        yieldFarmId: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'XykLiquidityMining';
          palletCall: {
            name: 'ClaimRewards';
            params: { depositId: bigint; yieldFarmId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Withdraw LP shares from liq. mining with reward claiming if possible.
     *
     * List of possible cases of transfers of LP shares and claimed rewards:
     *
     * * yield farm is active(yield farm is not stopped) - claim and transfer rewards(if it
     * wasn't claimed in this period) and transfer LP shares.
     * * liq. mining is stopped - claim and transfer rewards(if it
     * wasn't claimed in this period) and transfer LP shares.
     * * yield farm was terminated - only LP shares will be transferred.
     * * farm was terminated - only LP shares will be transferred.
     *
     * User's unclaimable rewards will be transferred back to global farm's account.
     *
     * Parameters:
     * - `origin`: account owner of deposit(nft).
     * - `deposit_id`: nft id representing deposit in the yield farm.
     * - `yield_farm_id`: yield farm identifier to dithdraw shares from.
     * - `asset_pair`: asset pair identifying yield farm in global farm.
     *
     * Emits:
     * * `RewardClaimed` if claim happen
     * * `SharesWithdrawn` event when successful
     *
     * @param {bigint} depositId
     * @param {number} yieldFarmId
     * @param {PalletXykAssetPair} assetPair
     **/
    withdrawShares: GenericTxCall<
      (
        depositId: bigint,
        yieldFarmId: number,
        assetPair: PalletXykAssetPair,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'XykLiquidityMining';
          palletCall: {
            name: 'WithdrawShares';
            params: { depositId: bigint; yieldFarmId: number; assetPair: PalletXykAssetPair };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Exit from all specified yield farms
     *
     * This function will attempt to withdraw shares and claim rewards (if available) from all
     * specified yield farms for a given deposit.
     *
     * Parameters:
     * - `origin`: account owner of deposit(nft).
     * - `deposit_id`: nft id representing deposit in the yield farm.
     * - `asset_pair`: asset pair identifying yield farm(s) in global farm(s).
     * - `farm_entries`: id(s) of yield farm(s) to exit from.
     *
     * Emits:
     * * `RewardClaimed` for each successful claim
     * * `SharesWithdrawn` for each successful withdrawal
     * * `DepositDestroyed` if the deposit is fully withdrawn
     *
     *
     * @param {bigint} depositId
     * @param {PalletXykAssetPair} assetPair
     * @param {Array<number>} farmEntries
     **/
    exitFarms: GenericTxCall<
      (
        depositId: bigint,
        assetPair: PalletXykAssetPair,
        farmEntries: Array<number>,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'XykLiquidityMining';
          palletCall: {
            name: 'ExitFarms';
            params: { depositId: bigint; assetPair: PalletXykAssetPair; farmEntries: Array<number> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `XYKWarehouseLM`'s transaction calls
   **/
  xykWarehouseLM: {
    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `RelayChainInfo`'s transaction calls
   **/
  relayChainInfo: {
    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `DCA`'s transaction calls
   **/
  dca: {
    /**
     * Creates a new DCA (Dollar-Cost Averaging) schedule and plans the next execution
     * for the specified block.
     *
     * If the block is not specified, the execution is planned for the next block.
     * If the given block is full, the execution will be planned in the subsequent block.
     *
     * Once the schedule is created, the specified `total_amount` will be reserved for DCA.
     * The reservation currency will be the `amount_in` currency of the order.
     *
     * Trades are executed as long as there is budget remaining
     * from the initial `total_amount` allocation, unless `total_amount` is 0, then trades
     * are executed until schedule is terminated.
     *
     * If a trade fails due to slippage limit or price stability errors, it will be retried.
     * If the number of retries reaches the maximum allowed,
     * the schedule will be terminated permanently.
     * In the case of a successful trade, the retry counter is reset.
     *
     * Parameters:
     * - `origin`: schedule owner
     * - `schedule`: schedule details
     * - `start_execution_block`: first possible execution block for the schedule
     *
     * Emits `Scheduled` and `ExecutionPlanned` event when successful.
     *
     *
     * @param {PalletDcaSchedule} schedule
     * @param {number | undefined} startExecutionBlock
     **/
    schedule: GenericTxCall<
      (
        schedule: PalletDcaSchedule,
        startExecutionBlock: number | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Dca';
          palletCall: {
            name: 'Schedule';
            params: { schedule: PalletDcaSchedule; startExecutionBlock: number | undefined };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Terminates a DCA schedule and remove it completely from the chain.
     *
     * This can be called by both schedule owner or the configured `T::TerminateOrigin`
     *
     * Parameters:
     * - `origin`: schedule owner
     * - `schedule_id`: schedule id
     * - `next_execution_block`: block number where the schedule is planned.
     *
     * Emits `Terminated` event when successful.
     *
     *
     * @param {number} scheduleId
     * @param {number | undefined} nextExecutionBlock
     **/
    terminate: GenericTxCall<
      (
        scheduleId: number,
        nextExecutionBlock: number | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Dca';
          palletCall: {
            name: 'Terminate';
            params: { scheduleId: number; nextExecutionBlock: number | undefined };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Unlocks DCA reserves of provided asset for the caller if they have no active schedules.
     *
     * This is a utility function to help users recover their reserved funds in case
     * a DCA schedule was terminated but left some reserved amounts.
     *
     * This can only be called when the user has no active DCA schedules.
     *
     * Parameters:
     * - `origin`: The account to unlock reserves for (must be signed)
     * - `asset_id`: The asset ID for which reserves should be unlocked.
     *
     * Emits `ReserveUnlocked` event when successful.
     *
     *
     * @param {AccountId32Like} who
     * @param {number} assetId
     **/
    unlockReserves: GenericTxCall<
      (
        who: AccountId32Like,
        assetId: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Dca';
          palletCall: {
            name: 'UnlockReserves';
            params: { who: AccountId32Like; assetId: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Scheduler`'s transaction calls
   **/
  scheduler: {
    /**
     * Anonymously schedule a task.
     *
     * @param {number} when
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {HydradxRuntimeRuntimeCallLike} call
     **/
    schedule: GenericTxCall<
      (
        when: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: HydradxRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'Schedule';
            params: {
              when: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: HydradxRuntimeRuntimeCallLike;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Cancel an anonymously scheduled task.
     *
     * @param {number} when
     * @param {number} index
     **/
    cancel: GenericTxCall<
      (
        when: number,
        index: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'Cancel';
            params: { when: number; index: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Schedule a named task.
     *
     * @param {FixedBytes<32>} id
     * @param {number} when
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {HydradxRuntimeRuntimeCallLike} call
     **/
    scheduleNamed: GenericTxCall<
      (
        id: FixedBytes<32>,
        when: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: HydradxRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'ScheduleNamed';
            params: {
              id: FixedBytes<32>;
              when: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: HydradxRuntimeRuntimeCallLike;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Cancel a named scheduled task.
     *
     * @param {FixedBytes<32>} id
     **/
    cancelNamed: GenericTxCall<
      (id: FixedBytes<32>) => ChainSubmittableExtrinsic<
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'CancelNamed';
            params: { id: FixedBytes<32> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Anonymously schedule a task after a delay.
     *
     * @param {number} after
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {HydradxRuntimeRuntimeCallLike} call
     **/
    scheduleAfter: GenericTxCall<
      (
        after: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: HydradxRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'ScheduleAfter';
            params: {
              after: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: HydradxRuntimeRuntimeCallLike;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Schedule a named task after a delay.
     *
     * @param {FixedBytes<32>} id
     * @param {number} after
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {HydradxRuntimeRuntimeCallLike} call
     **/
    scheduleNamedAfter: GenericTxCall<
      (
        id: FixedBytes<32>,
        after: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: HydradxRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'ScheduleNamedAfter';
            params: {
              id: FixedBytes<32>;
              after: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: HydradxRuntimeRuntimeCallLike;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set a retry configuration for a task so that, in case its scheduled run fails, it will
     * be retried after `period` blocks, for a total amount of `retries` retries or until it
     * succeeds.
     *
     * Tasks which need to be scheduled for a retry are still subject to weight metering and
     * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
     * normally while the task is retrying.
     *
     * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
     * clones of the original task. Their retry configuration will be derived from the
     * original task's configuration, but will have a lower value for `remaining` than the
     * original `total_retries`.
     *
     * @param {[number, number]} task
     * @param {number} retries
     * @param {number} period
     **/
    setRetry: GenericTxCall<
      (
        task: [number, number],
        retries: number,
        period: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'SetRetry';
            params: { task: [number, number]; retries: number; period: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set a retry configuration for a named task so that, in case its scheduled run fails, it
     * will be retried after `period` blocks, for a total amount of `retries` retries or until
     * it succeeds.
     *
     * Tasks which need to be scheduled for a retry are still subject to weight metering and
     * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
     * normally while the task is retrying.
     *
     * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
     * clones of the original task. Their retry configuration will be derived from the
     * original task's configuration, but will have a lower value for `remaining` than the
     * original `total_retries`.
     *
     * @param {FixedBytes<32>} id
     * @param {number} retries
     * @param {number} period
     **/
    setRetryNamed: GenericTxCall<
      (
        id: FixedBytes<32>,
        retries: number,
        period: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'SetRetryNamed';
            params: { id: FixedBytes<32>; retries: number; period: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Removes the retry configuration of a task.
     *
     * @param {[number, number]} task
     **/
    cancelRetry: GenericTxCall<
      (task: [number, number]) => ChainSubmittableExtrinsic<
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'CancelRetry';
            params: { task: [number, number] };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Cancel the retry configuration of a named task.
     *
     * @param {FixedBytes<32>} id
     **/
    cancelRetryNamed: GenericTxCall<
      (id: FixedBytes<32>) => ChainSubmittableExtrinsic<
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'CancelRetryNamed';
            params: { id: FixedBytes<32> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `ParachainSystem`'s transaction calls
   **/
  parachainSystem: {
    /**
     * Set the current validation data.
     *
     * This should be invoked exactly once per block. It will panic at the finalization
     * phase if the call was not invoked.
     *
     * The dispatch origin for this call must be `Inherent`
     *
     * As a side effect, this function upgrades the current validation function
     * if the appropriate time has come.
     *
     * @param {CumulusPrimitivesParachainInherentParachainInherentData} data
     **/
    setValidationData: GenericTxCall<
      (data: CumulusPrimitivesParachainInherentParachainInherentData) => ChainSubmittableExtrinsic<
        {
          pallet: 'ParachainSystem';
          palletCall: {
            name: 'SetValidationData';
            params: { data: CumulusPrimitivesParachainInherentParachainInherentData };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {BytesLike} message
     **/
    sudoSendUpwardMessage: GenericTxCall<
      (message: BytesLike) => ChainSubmittableExtrinsic<
        {
          pallet: 'ParachainSystem';
          palletCall: {
            name: 'SudoSendUpwardMessage';
            params: { message: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `ParachainInfo`'s transaction calls
   **/
  parachainInfo: {
    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `PolkadotXcm`'s transaction calls
   **/
  polkadotXcm: {
    /**
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedXcm} message
     **/
    send: GenericTxCall<
      (
        dest: XcmVersionedLocation,
        message: XcmVersionedXcm,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'Send';
            params: { dest: XcmVersionedLocation; message: XcmVersionedXcm };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Teleport some assets from the local chain to some destination chain.
     *
     * **This function is deprecated: Use `limited_teleport_assets` instead.**
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` chain.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedLocation} beneficiary
     * @param {XcmVersionedAssets} assets
     * @param {number} feeAssetItem
     **/
    teleportAssets: GenericTxCall<
      (
        dest: XcmVersionedLocation,
        beneficiary: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        feeAssetItem: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'TeleportAssets';
            params: {
              dest: XcmVersionedLocation;
              beneficiary: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              feeAssetItem: number;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Transfer some assets from the local chain to the destination chain through their local,
     * destination or remote reserve.
     *
     * `assets` must have same reserve location and may not be teleportable to `dest`.
     * - `assets` have local reserve: transfer assets to sovereign account of destination
     * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
     * assets to `beneficiary`.
     * - `assets` have destination reserve: burn local assets and forward a notification to
     * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
     * deposit them to `beneficiary`.
     * - `assets` have remote reserve: burn local assets, forward XCM to reserve chain to move
     * reserves from this chain's SA to `dest` chain's SA, and forward another XCM to `dest`
     * to mint and deposit reserve-based assets to `beneficiary`.
     *
     * **This function is deprecated: Use `limited_reserve_transfer_assets` instead.**
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` (and possibly reserve) chains.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedLocation} beneficiary
     * @param {XcmVersionedAssets} assets
     * @param {number} feeAssetItem
     **/
    reserveTransferAssets: GenericTxCall<
      (
        dest: XcmVersionedLocation,
        beneficiary: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        feeAssetItem: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'ReserveTransferAssets';
            params: {
              dest: XcmVersionedLocation;
              beneficiary: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              feeAssetItem: number;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Execute an XCM message from a local, signed, origin.
     *
     * An event is deposited indicating whether `msg` could be executed completely or only
     * partially.
     *
     * No more than `max_weight` will be used in its attempted execution. If this is less than
     * the maximum amount of weight that the message could take to be executed, then no
     * execution attempt will be made.
     *
     * @param {XcmVersionedXcm} message
     * @param {SpWeightsWeightV2Weight} maxWeight
     **/
    execute: GenericTxCall<
      (
        message: XcmVersionedXcm,
        maxWeight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'Execute';
            params: { message: XcmVersionedXcm; maxWeight: SpWeightsWeightV2Weight };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Extoll that a particular destination can be communicated with through a particular
     * version of XCM.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The destination that is being described.
     * - `xcm_version`: The latest version of XCM that `location` supports.
     *
     * @param {StagingXcmV5Location} location
     * @param {number} version
     **/
    forceXcmVersion: GenericTxCall<
      (
        location: StagingXcmV5Location,
        version: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'ForceXcmVersion';
            params: { location: StagingXcmV5Location; version: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set a safe XCM version (the version that XCM should be encoded with if the most recent
     * version a destination can accept is unknown).
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `maybe_xcm_version`: The default XCM encoding version, or `None` to disable.
     *
     * @param {number | undefined} maybeXcmVersion
     **/
    forceDefaultXcmVersion: GenericTxCall<
      (maybeXcmVersion: number | undefined) => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'ForceDefaultXcmVersion';
            params: { maybeXcmVersion: number | undefined };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Ask a location to notify us regarding their XCM version and any changes to it.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The location to which we should subscribe for XCM version notifications.
     *
     * @param {XcmVersionedLocation} location
     **/
    forceSubscribeVersionNotify: GenericTxCall<
      (location: XcmVersionedLocation) => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'ForceSubscribeVersionNotify';
            params: { location: XcmVersionedLocation };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Require that a particular destination should no longer notify us regarding any XCM
     * version changes.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The location to which we are currently subscribed for XCM version
     * notifications which we no longer desire.
     *
     * @param {XcmVersionedLocation} location
     **/
    forceUnsubscribeVersionNotify: GenericTxCall<
      (location: XcmVersionedLocation) => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'ForceUnsubscribeVersionNotify';
            params: { location: XcmVersionedLocation };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Transfer some assets from the local chain to the destination chain through their local,
     * destination or remote reserve.
     *
     * `assets` must have same reserve location and may not be teleportable to `dest`.
     * - `assets` have local reserve: transfer assets to sovereign account of destination
     * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
     * assets to `beneficiary`.
     * - `assets` have destination reserve: burn local assets and forward a notification to
     * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
     * deposit them to `beneficiary`.
     * - `assets` have remote reserve: burn local assets, forward XCM to reserve chain to move
     * reserves from this chain's SA to `dest` chain's SA, and forward another XCM to `dest`
     * to mint and deposit reserve-based assets to `beneficiary`.
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the sent assets may be
     * at risk.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` (and possibly reserve) chains.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedLocation} beneficiary
     * @param {XcmVersionedAssets} assets
     * @param {number} feeAssetItem
     * @param {XcmV3WeightLimit} weightLimit
     **/
    limitedReserveTransferAssets: GenericTxCall<
      (
        dest: XcmVersionedLocation,
        beneficiary: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        feeAssetItem: number,
        weightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'LimitedReserveTransferAssets';
            params: {
              dest: XcmVersionedLocation;
              beneficiary: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              feeAssetItem: number;
              weightLimit: XcmV3WeightLimit;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Teleport some assets from the local chain to some destination chain.
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the sent assets may be
     * at risk.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` chain.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedLocation} beneficiary
     * @param {XcmVersionedAssets} assets
     * @param {number} feeAssetItem
     * @param {XcmV3WeightLimit} weightLimit
     **/
    limitedTeleportAssets: GenericTxCall<
      (
        dest: XcmVersionedLocation,
        beneficiary: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        feeAssetItem: number,
        weightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'LimitedTeleportAssets';
            params: {
              dest: XcmVersionedLocation;
              beneficiary: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              feeAssetItem: number;
              weightLimit: XcmV3WeightLimit;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set or unset the global suspension state of the XCM executor.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `suspended`: `true` to suspend, `false` to resume.
     *
     * @param {boolean} suspended
     **/
    forceSuspension: GenericTxCall<
      (suspended: boolean) => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'ForceSuspension';
            params: { suspended: boolean };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Transfer some assets from the local chain to the destination chain through their local,
     * destination or remote reserve, or through teleports.
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item` (hence referred to as `fees`), up to enough to pay for
     * `weight_limit` of weight. If more weight is needed than `weight_limit`, then the
     * operation will fail and the sent assets may be at risk.
     *
     * `assets` (excluding `fees`) must have same reserve location or otherwise be teleportable
     * to `dest`, no limitations imposed on `fees`.
     * - for local reserve: transfer assets to sovereign account of destination chain and
     * forward a notification XCM to `dest` to mint and deposit reserve-based assets to
     * `beneficiary`.
     * - for destination reserve: burn local assets and forward a notification to `dest` chain
     * to withdraw the reserve assets from this chain's sovereign account and deposit them
     * to `beneficiary`.
     * - for remote reserve: burn local assets, forward XCM to reserve chain to move reserves
     * from this chain's SA to `dest` chain's SA, and forward another XCM to `dest` to mint
     * and deposit reserve-based assets to `beneficiary`.
     * - for teleports: burn local assets and forward XCM to `dest` chain to mint/teleport
     * assets and deposit them to `beneficiary`.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent,
     * Parachain(..))` to send from parachain to parachain, or `X1(Parachain(..))` to send
     * from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` (and possibly reserve) chains.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedLocation} beneficiary
     * @param {XcmVersionedAssets} assets
     * @param {number} feeAssetItem
     * @param {XcmV3WeightLimit} weightLimit
     **/
    transferAssets: GenericTxCall<
      (
        dest: XcmVersionedLocation,
        beneficiary: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        feeAssetItem: number,
        weightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'TransferAssets';
            params: {
              dest: XcmVersionedLocation;
              beneficiary: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              feeAssetItem: number;
              weightLimit: XcmV3WeightLimit;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Claims assets trapped on this pallet because of leftover assets during XCM execution.
     *
     * - `origin`: Anyone can call this extrinsic.
     * - `assets`: The exact assets that were trapped. Use the version to specify what version
     * was the latest when they were trapped.
     * - `beneficiary`: The location/account where the claimed assets will be deposited.
     *
     * @param {XcmVersionedAssets} assets
     * @param {XcmVersionedLocation} beneficiary
     **/
    claimAssets: GenericTxCall<
      (
        assets: XcmVersionedAssets,
        beneficiary: XcmVersionedLocation,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'ClaimAssets';
            params: { assets: XcmVersionedAssets; beneficiary: XcmVersionedLocation };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Transfer assets from the local chain to the destination chain using explicit transfer
     * types for assets and fees.
     *
     * `assets` must have same reserve location or may be teleportable to `dest`. Caller must
     * provide the `assets_transfer_type` to be used for `assets`:
     * - `TransferType::LocalReserve`: transfer assets to sovereign account of destination
     * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
     * assets to `beneficiary`.
     * - `TransferType::DestinationReserve`: burn local assets and forward a notification to
     * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
     * deposit them to `beneficiary`.
     * - `TransferType::RemoteReserve(reserve)`: burn local assets, forward XCM to `reserve`
     * chain to move reserves from this chain's SA to `dest` chain's SA, and forward another
     * XCM to `dest` to mint and deposit reserve-based assets to `beneficiary`. Typically
     * the remote `reserve` is Asset Hub.
     * - `TransferType::Teleport`: burn local assets and forward XCM to `dest` chain to
     * mint/teleport assets and deposit them to `beneficiary`.
     *
     * On the destination chain, as well as any intermediary hops, `BuyExecution` is used to
     * buy execution using transferred `assets` identified by `remote_fees_id`.
     * Make sure enough of the specified `remote_fees_id` asset is included in the given list
     * of `assets`. `remote_fees_id` should be enough to pay for `weight_limit`. If more weight
     * is needed than `weight_limit`, then the operation will fail and the sent assets may be
     * at risk.
     *
     * `remote_fees_id` may use different transfer type than rest of `assets` and can be
     * specified through `fees_transfer_type`.
     *
     * The caller needs to specify what should happen to the transferred assets once they reach
     * the `dest` chain. This is done through the `custom_xcm_on_dest` parameter, which
     * contains the instructions to execute on `dest` as a final step.
     * This is usually as simple as:
     * `Xcm(vec![DepositAsset { assets: Wild(AllCounted(assets.len())), beneficiary }])`,
     * but could be something more exotic like sending the `assets` even further.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain, or `(parents: 2, (GlobalConsensus(..), ..))` to send from
     * parachain across a bridge to another ecosystem destination.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` (and possibly reserve) chains.
     * - `assets_transfer_type`: The XCM `TransferType` used to transfer the `assets`.
     * - `remote_fees_id`: One of the included `assets` to be used to pay fees.
     * - `fees_transfer_type`: The XCM `TransferType` used to transfer the `fees` assets.
     * - `custom_xcm_on_dest`: The XCM to be executed on `dest` chain as the last step of the
     * transfer, which also determines what happens to the assets on the destination chain.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedAssets} assets
     * @param {StagingXcmExecutorAssetTransferTransferType} assetsTransferType
     * @param {XcmVersionedAssetId} remoteFeesId
     * @param {StagingXcmExecutorAssetTransferTransferType} feesTransferType
     * @param {XcmVersionedXcm} customXcmOnDest
     * @param {XcmV3WeightLimit} weightLimit
     **/
    transferAssetsUsingTypeAndThen: GenericTxCall<
      (
        dest: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        assetsTransferType: StagingXcmExecutorAssetTransferTransferType,
        remoteFeesId: XcmVersionedAssetId,
        feesTransferType: StagingXcmExecutorAssetTransferTransferType,
        customXcmOnDest: XcmVersionedXcm,
        weightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'TransferAssetsUsingTypeAndThen';
            params: {
              dest: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              assetsTransferType: StagingXcmExecutorAssetTransferTransferType;
              remoteFeesId: XcmVersionedAssetId;
              feesTransferType: StagingXcmExecutorAssetTransferTransferType;
              customXcmOnDest: XcmVersionedXcm;
              weightLimit: XcmV3WeightLimit;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Authorize another `aliaser` location to alias into the local `origin` making this call.
     * The `aliaser` is only authorized until the provided `expiry` block number.
     * The call can also be used for a previously authorized alias in order to update its
     * `expiry` block number.
     *
     * Usually useful to allow your local account to be aliased into from a remote location
     * also under your control (like your account on another chain).
     *
     * WARNING: make sure the caller `origin` (you) trusts the `aliaser` location to act in
     * their/your name. Once authorized using this call, the `aliaser` can freely impersonate
     * `origin` in XCM programs executed on the local chain.
     *
     * @param {XcmVersionedLocation} aliaser
     * @param {bigint | undefined} expires
     **/
    addAuthorizedAlias: GenericTxCall<
      (
        aliaser: XcmVersionedLocation,
        expires: bigint | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'AddAuthorizedAlias';
            params: { aliaser: XcmVersionedLocation; expires: bigint | undefined };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove a previously authorized `aliaser` from the list of locations that can alias into
     * the local `origin` making this call.
     *
     * @param {XcmVersionedLocation} aliaser
     **/
    removeAuthorizedAlias: GenericTxCall<
      (aliaser: XcmVersionedLocation) => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'RemoveAuthorizedAlias';
            params: { aliaser: XcmVersionedLocation };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove all previously authorized `aliaser`s that can alias into the local `origin`
     * making this call.
     *
     **/
    removeAllAuthorizedAliases: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'RemoveAllAuthorizedAliases';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `CumulusXcm`'s transaction calls
   **/
  cumulusXcm: {
    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `MessageQueue`'s transaction calls
   **/
  messageQueue: {
    /**
     * Remove a page which has no more messages remaining to be processed or is stale.
     *
     * @param {CumulusPrimitivesCoreAggregateMessageOrigin} messageOrigin
     * @param {number} pageIndex
     **/
    reapPage: GenericTxCall<
      (
        messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin,
        pageIndex: number,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'MessageQueue';
          palletCall: {
            name: 'ReapPage';
            params: { messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin; pageIndex: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Execute an overweight message.
     *
     * Temporary processing errors will be propagated whereas permanent errors are treated
     * as success condition.
     *
     * - `origin`: Must be `Signed`.
     * - `message_origin`: The origin from which the message to be executed arrived.
     * - `page`: The page in the queue in which the message to be executed is sitting.
     * - `index`: The index into the queue of the message to be executed.
     * - `weight_limit`: The maximum amount of weight allowed to be consumed in the execution
     * of the message.
     *
     * Benchmark complexity considerations: O(index + weight_limit).
     *
     * @param {CumulusPrimitivesCoreAggregateMessageOrigin} messageOrigin
     * @param {number} page
     * @param {number} index
     * @param {SpWeightsWeightV2Weight} weightLimit
     **/
    executeOverweight: GenericTxCall<
      (
        messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin,
        page: number,
        index: number,
        weightLimit: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'MessageQueue';
          palletCall: {
            name: 'ExecuteOverweight';
            params: {
              messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin;
              page: number;
              index: number;
              weightLimit: SpWeightsWeightV2Weight;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `MultiBlockMigrations`'s transaction calls
   **/
  multiBlockMigrations: {
    /**
     * Allows root to set a cursor to forcefully start, stop or forward the migration process.
     *
     * Should normally not be needed and is only in place as emergency measure. Note that
     * restarting the migration process in this manner will not call the
     * [`MigrationStatusHandler::started`] hook or emit an `UpgradeStarted` event.
     *
     * @param {PalletMigrationsMigrationCursor | undefined} cursor
     **/
    forceSetCursor: GenericTxCall<
      (cursor: PalletMigrationsMigrationCursor | undefined) => ChainSubmittableExtrinsic<
        {
          pallet: 'MultiBlockMigrations';
          palletCall: {
            name: 'ForceSetCursor';
            params: { cursor: PalletMigrationsMigrationCursor | undefined };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Allows root to set an active cursor to forcefully start/forward the migration process.
     *
     * This is an edge-case version of [`Self::force_set_cursor`] that allows to set the
     * `started_at` value to the next block number. Otherwise this would not be possible, since
     * `force_set_cursor` takes an absolute block number. Setting `started_at` to `None`
     * indicates that the current block number plus one should be used.
     *
     * @param {number} index
     * @param {BytesLike | undefined} innerCursor
     * @param {number | undefined} startedAt
     **/
    forceSetActiveCursor: GenericTxCall<
      (
        index: number,
        innerCursor: BytesLike | undefined,
        startedAt: number | undefined,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'MultiBlockMigrations';
          palletCall: {
            name: 'ForceSetActiveCursor';
            params: { index: number; innerCursor: BytesLike | undefined; startedAt: number | undefined };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Forces the onboarding of the migrations.
     *
     * This process happens automatically on a runtime upgrade. It is in place as an emergency
     * measurement. The cursor needs to be `None` for this to succeed.
     *
     **/
    forceOnboardMbms: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'MultiBlockMigrations';
          palletCall: {
            name: 'ForceOnboardMbms';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Clears the `Historic` set.
     *
     * `map_cursor` must be set to the last value that was returned by the
     * `HistoricCleared` event. The first time `None` can be used. `limit` must be chosen in a
     * way that will result in a sensible weight.
     *
     * @param {PalletMigrationsHistoricCleanupSelector} selector
     **/
    clearHistoric: GenericTxCall<
      (selector: PalletMigrationsHistoricCleanupSelector) => ChainSubmittableExtrinsic<
        {
          pallet: 'MultiBlockMigrations';
          palletCall: {
            name: 'ClearHistoric';
            params: { selector: PalletMigrationsHistoricCleanupSelector };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `OrmlXcm`'s transaction calls
   **/
  ormlXcm: {
    /**
     * Send an XCM message as parachain sovereign.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedXcm} message
     **/
    sendAsSovereign: GenericTxCall<
      (
        dest: XcmVersionedLocation,
        message: XcmVersionedXcm,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'OrmlXcm';
          palletCall: {
            name: 'SendAsSovereign';
            params: { dest: XcmVersionedLocation; message: XcmVersionedXcm };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `XTokens`'s transaction calls
   **/
  xTokens: {
    /**
     * Transfer native currencies.
     *
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     *
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     *
     * @param {number} currencyId
     * @param {bigint} amount
     * @param {XcmVersionedLocation} dest
     * @param {XcmV3WeightLimit} destWeightLimit
     **/
    transfer: GenericTxCall<
      (
        currencyId: number,
        amount: bigint,
        dest: XcmVersionedLocation,
        destWeightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'XTokens';
          palletCall: {
            name: 'Transfer';
            params: {
              currencyId: number;
              amount: bigint;
              dest: XcmVersionedLocation;
              destWeightLimit: XcmV3WeightLimit;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Transfer `Asset`.
     *
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     *
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     *
     * @param {XcmVersionedAsset} asset
     * @param {XcmVersionedLocation} dest
     * @param {XcmV3WeightLimit} destWeightLimit
     **/
    transferMultiasset: GenericTxCall<
      (
        asset: XcmVersionedAsset,
        dest: XcmVersionedLocation,
        destWeightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'XTokens';
          palletCall: {
            name: 'TransferMultiasset';
            params: { asset: XcmVersionedAsset; dest: XcmVersionedLocation; destWeightLimit: XcmV3WeightLimit };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Transfer native currencies specifying the fee and amount as
     * separate.
     *
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     *
     * `fee` is the amount to be spent to pay for execution in destination
     * chain. Both fee and amount will be subtracted form the callers
     * balance.
     *
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     *
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     *
     * @param {number} currencyId
     * @param {bigint} amount
     * @param {bigint} fee
     * @param {XcmVersionedLocation} dest
     * @param {XcmV3WeightLimit} destWeightLimit
     **/
    transferWithFee: GenericTxCall<
      (
        currencyId: number,
        amount: bigint,
        fee: bigint,
        dest: XcmVersionedLocation,
        destWeightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'XTokens';
          palletCall: {
            name: 'TransferWithFee';
            params: {
              currencyId: number;
              amount: bigint;
              fee: bigint;
              dest: XcmVersionedLocation;
              destWeightLimit: XcmV3WeightLimit;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Transfer `Asset` specifying the fee and amount as separate.
     *
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     *
     * `fee` is the Asset to be spent to pay for execution in
     * destination chain. Both fee and amount will be subtracted form the
     * callers balance For now we only accept fee and asset having the same
     * `Location` id.
     *
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     *
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     *
     * @param {XcmVersionedAsset} asset
     * @param {XcmVersionedAsset} fee
     * @param {XcmVersionedLocation} dest
     * @param {XcmV3WeightLimit} destWeightLimit
     **/
    transferMultiassetWithFee: GenericTxCall<
      (
        asset: XcmVersionedAsset,
        fee: XcmVersionedAsset,
        dest: XcmVersionedLocation,
        destWeightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'XTokens';
          palletCall: {
            name: 'TransferMultiassetWithFee';
            params: {
              asset: XcmVersionedAsset;
              fee: XcmVersionedAsset;
              dest: XcmVersionedLocation;
              destWeightLimit: XcmV3WeightLimit;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Transfer several currencies specifying the item to be used as fee
     *
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     *
     * `fee_item` is index of the currencies tuple that we want to use for
     * payment
     *
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     *
     * @param {Array<[number, bigint]>} currencies
     * @param {number} feeItem
     * @param {XcmVersionedLocation} dest
     * @param {XcmV3WeightLimit} destWeightLimit
     **/
    transferMulticurrencies: GenericTxCall<
      (
        currencies: Array<[number, bigint]>,
        feeItem: number,
        dest: XcmVersionedLocation,
        destWeightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'XTokens';
          palletCall: {
            name: 'TransferMulticurrencies';
            params: {
              currencies: Array<[number, bigint]>;
              feeItem: number;
              dest: XcmVersionedLocation;
              destWeightLimit: XcmV3WeightLimit;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Transfer several `Asset` specifying the item to be used as fee
     *
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     *
     * `fee_item` is index of the Assets that we want to use for
     * payment
     *
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     *
     * @param {XcmVersionedAssets} assets
     * @param {number} feeItem
     * @param {XcmVersionedLocation} dest
     * @param {XcmV3WeightLimit} destWeightLimit
     **/
    transferMultiassets: GenericTxCall<
      (
        assets: XcmVersionedAssets,
        feeItem: number,
        dest: XcmVersionedLocation,
        destWeightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'XTokens';
          palletCall: {
            name: 'TransferMultiassets';
            params: {
              assets: XcmVersionedAssets;
              feeItem: number;
              dest: XcmVersionedLocation;
              destWeightLimit: XcmV3WeightLimit;
            };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `CollatorSelection`'s transaction calls
   **/
  collatorSelection: {
    /**
     * Set the list of invulnerable (fixed) collators. These collators must do some
     * preparation, namely to have registered session keys.
     *
     * The call will remove any accounts that have not registered keys from the set. That is,
     * it is non-atomic; the caller accepts all `AccountId`s passed in `new` _individually_ as
     * acceptable Invulnerables, and is not proposing a _set_ of new Invulnerables.
     *
     * This call does not maintain mutual exclusivity of `Invulnerables` and `Candidates`. It
     * is recommended to use a batch of `add_invulnerable` and `remove_invulnerable` instead. A
     * `batch_all` can also be used to enforce atomicity. If any candidates are included in
     * `new`, they should be removed with `remove_invulnerable_candidate` after execution.
     *
     * Must be called by the `UpdateOrigin`.
     *
     * @param {Array<AccountId32Like>} new_
     **/
    setInvulnerables: GenericTxCall<
      (new_: Array<AccountId32Like>) => ChainSubmittableExtrinsic<
        {
          pallet: 'CollatorSelection';
          palletCall: {
            name: 'SetInvulnerables';
            params: { new: Array<AccountId32Like> };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the ideal number of non-invulnerable collators. If lowering this number, then the
     * number of running collators could be higher than this figure. Aside from that edge case,
     * there should be no other way to have more candidates than the desired number.
     *
     * The origin for this call must be the `UpdateOrigin`.
     *
     * @param {number} max
     **/
    setDesiredCandidates: GenericTxCall<
      (max: number) => ChainSubmittableExtrinsic<
        {
          pallet: 'CollatorSelection';
          palletCall: {
            name: 'SetDesiredCandidates';
            params: { max: number };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Set the candidacy bond amount.
     *
     * If the candidacy bond is increased by this call, all current candidates which have a
     * deposit lower than the new bond will be kicked from the list and get their deposits
     * back.
     *
     * The origin for this call must be the `UpdateOrigin`.
     *
     * @param {bigint} bond
     **/
    setCandidacyBond: GenericTxCall<
      (bond: bigint) => ChainSubmittableExtrinsic<
        {
          pallet: 'CollatorSelection';
          palletCall: {
            name: 'SetCandidacyBond';
            params: { bond: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Register this account as a collator candidate. The account must (a) already have
     * registered session keys and (b) be able to reserve the `CandidacyBond`.
     *
     * This call is not available to `Invulnerable` collators.
     *
     **/
    registerAsCandidate: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'CollatorSelection';
          palletCall: {
            name: 'RegisterAsCandidate';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Deregister `origin` as a collator candidate. Note that the collator can only leave on
     * session change. The `CandidacyBond` will be unreserved immediately.
     *
     * This call will fail if the total number of candidates would drop below
     * `MinEligibleCollators`.
     *
     **/
    leaveIntent: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'CollatorSelection';
          palletCall: {
            name: 'LeaveIntent';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Add a new account `who` to the list of `Invulnerables` collators. `who` must have
     * registered session keys. If `who` is a candidate, they will be removed.
     *
     * The origin for this call must be the `UpdateOrigin`.
     *
     * @param {AccountId32Like} who
     **/
    addInvulnerable: GenericTxCall<
      (who: AccountId32Like) => ChainSubmittableExtrinsic<
        {
          pallet: 'CollatorSelection';
          palletCall: {
            name: 'AddInvulnerable';
            params: { who: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Remove an account `who` from the list of `Invulnerables` collators. `Invulnerables` must
     * be sorted.
     *
     * The origin for this call must be the `UpdateOrigin`.
     *
     * @param {AccountId32Like} who
     **/
    removeInvulnerable: GenericTxCall<
      (who: AccountId32Like) => ChainSubmittableExtrinsic<
        {
          pallet: 'CollatorSelection';
          palletCall: {
            name: 'RemoveInvulnerable';
            params: { who: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Update the candidacy bond of collator candidate `origin` to a new amount `new_deposit`.
     *
     * Setting a `new_deposit` that is lower than the current deposit while `origin` is
     * occupying a top-`DesiredCandidates` slot is not allowed.
     *
     * This call will fail if `origin` is not a collator candidate, the updated bond is lower
     * than the minimum candidacy bond, and/or the amount cannot be reserved.
     *
     * @param {bigint} newDeposit
     **/
    updateBond: GenericTxCall<
      (newDeposit: bigint) => ChainSubmittableExtrinsic<
        {
          pallet: 'CollatorSelection';
          palletCall: {
            name: 'UpdateBond';
            params: { newDeposit: bigint };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * The caller `origin` replaces a candidate `target` in the collator candidate list by
     * reserving `deposit`. The amount `deposit` reserved by the caller must be greater than
     * the existing bond of the target it is trying to replace.
     *
     * This call will fail if the caller is already a collator candidate or invulnerable, the
     * caller does not have registered session keys, the target is not a collator candidate,
     * and/or the `deposit` amount cannot be reserved.
     *
     * @param {bigint} deposit
     * @param {AccountId32Like} target
     **/
    takeCandidateSlot: GenericTxCall<
      (
        deposit: bigint,
        target: AccountId32Like,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'CollatorSelection';
          palletCall: {
            name: 'TakeCandidateSlot';
            params: { deposit: bigint; target: AccountId32Like };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Session`'s transaction calls
   **/
  session: {
    /**
     * Sets the session key(s) of the function caller to `keys`.
     * Allows an account to set its session key prior to becoming a validator.
     * This doesn't take effect until the next session.
     *
     * The dispatch origin of this function must be signed.
     *
     * ## Complexity
     * - `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is
     * fixed.
     *
     * @param {HydradxRuntimeOpaqueSessionKeys} keys
     * @param {BytesLike} proof
     **/
    setKeys: GenericTxCall<
      (
        keys: HydradxRuntimeOpaqueSessionKeys,
        proof: BytesLike,
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'Session';
          palletCall: {
            name: 'SetKeys';
            params: { keys: HydradxRuntimeOpaqueSessionKeys; proof: BytesLike };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Removes any session key(s) of the function caller.
     *
     * This doesn't take effect until the next session.
     *
     * The dispatch origin of this function must be Signed and the account must be either be
     * convertible to a validator ID using the chain's typical addressing system (this usually
     * means being a controller account) or directly convertible into a validator ID (which
     * usually means being a stash account).
     *
     * ## Complexity
     * - `O(1)` in number of key types. Actual cost depends on the number of length of
     * `T::Keys::key_ids()` which is fixed.
     *
     **/
    purgeKeys: GenericTxCall<
      () => ChainSubmittableExtrinsic<
        {
          pallet: 'Session';
          palletCall: {
            name: 'PurgeKeys';
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `EmaOracle`'s transaction calls
   **/
  emaOracle: {
    /**
     *
     * @param {FixedBytes<8>} source
     * @param {[number, number]} assets
     **/
    addOracle: GenericTxCall<
      (
        source: FixedBytes<8>,
        assets: [number, number],
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'EmaOracle';
          palletCall: {
            name: 'AddOracle';
            params: { source: FixedBytes<8>; assets: [number, number] };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {FixedBytes<8>} source
     * @param {[number, number]} assets
     **/
    removeOracle: GenericTxCall<
      (
        source: FixedBytes<8>,
        assets: [number, number],
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'EmaOracle';
          palletCall: {
            name: 'RemoveOracle';
            params: { source: FixedBytes<8>; assets: [number, number] };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     *
     * @param {XcmVersionedLocation} assetA
     * @param {XcmVersionedLocation} assetB
     * @param {[bigint, bigint]} price
     **/
    updateBifrostOracle: GenericTxCall<
      (
        assetA: XcmVersionedLocation,
        assetB: XcmVersionedLocation,
        price: [bigint, bigint],
      ) => ChainSubmittableExtrinsic<
        {
          pallet: 'EmaOracle';
          palletCall: {
            name: 'UpdateBifrostOracle';
            params: { assetA: XcmVersionedLocation; assetB: XcmVersionedLocation; price: [bigint, bigint] };
          };
        },
        ChainKnownTypes
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
  /**
   * Pallet `Broadcast`'s transaction calls
   **/
  broadcast: {
    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<TxCall<ChainKnownTypes>>;
  };
}
