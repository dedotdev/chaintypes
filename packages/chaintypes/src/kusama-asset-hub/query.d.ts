// Generated by dedot cli

import type { GenericChainStorage, GenericStorageQuery, Callback, RpcVersion } from 'dedot/types';
import type {
  AccountId32,
  AccountId32Like,
  H256,
  Bytes,
  Digest,
  Phase,
  FixedU128,
  BytesLike,
  FixedBytes,
  EthereumAddress,
  EthereumAddressLike,
  H160,
  Perbill,
  Percent,
} from 'dedot/codecs';
import type {
  FrameSystemAccountInfo,
  FrameSupportDispatchPerDispatchClass,
  FrameSystemEventRecord,
  FrameSystemLastRuntimeUpgradeInfo,
  FrameSystemCodeUpgradeAuthorization,
  SpWeightsWeightV2Weight,
  CumulusPalletParachainSystemUnincludedSegmentAncestor,
  CumulusPalletParachainSystemUnincludedSegmentSegmentTracker,
  PolkadotPrimitivesV8PersistedValidationData,
  PolkadotPrimitivesV8UpgradeRestriction,
  PolkadotPrimitivesV8UpgradeGoAhead,
  SpTrieStorageProof,
  CumulusPalletParachainSystemRelayStateSnapshotMessagingStateSnapshot,
  PolkadotPrimitivesV8AbridgedHostConfiguration,
  CumulusPrimitivesParachainInherentMessageQueueChain,
  PolkadotParachainPrimitivesPrimitivesId,
  CumulusPalletParachainSystemParachainInherentInboundMessageId,
  PolkadotCorePrimitivesOutboundHrmpMessage,
  PalletMigrationsMigrationCursor,
  PalletPreimageOldRequestStatus,
  PalletPreimageRequestStatus,
  PalletSchedulerScheduled,
  PalletSchedulerRetryConfig,
  AssetHubKusamaRuntimeRuntimeParametersValue,
  AssetHubKusamaRuntimeRuntimeParametersKey,
  PalletBalancesAccountData,
  PalletBalancesBalanceLock,
  PalletBalancesReserveData,
  FrameSupportTokensMiscIdAmountRuntimeHoldReason,
  FrameSupportTokensMiscIdAmountRuntimeFreezeReason,
  PalletTransactionPaymentReleases,
  PalletVestingVestingInfo,
  PalletVestingReleases,
  PolkadotRuntimeCommonClaimsStatementKind,
  PalletCollatorSelectionCandidateInfo,
  AssetHubKusamaRuntimeSessionKeys,
  SpStakingOffenceOffenceSeverity,
  SpCoreCryptoKeyTypeId,
  SpConsensusAuraSr25519AppSr25519Public,
  SpConsensusSlotsSlot,
  CumulusPalletXcmpQueueOutboundChannelDetails,
  CumulusPalletXcmpQueueQueueConfigData,
  PalletXcmQueryStatus,
  XcmVersionedLocation,
  PalletXcmVersionMigrationStage,
  PalletXcmRemoteLockedFungibleRecord,
  XcmVersionedAssetId,
  StagingXcmV5Xcm,
  PalletXcmAuthorizedAliasesEntry,
  BpXcmBridgeHubRouterBridgeState,
  PalletMessageQueueBookState,
  CumulusPrimitivesCoreAggregateMessageOrigin,
  PalletMessageQueuePage,
  PalletMultisigMultisig,
  PalletProxyProxyDefinitionProxyType,
  PalletProxyAnnouncement,
  PalletAssetsAssetDetails,
  PalletAssetsAssetAccount,
  PalletAssetsApproval,
  PalletAssetsAssetMetadata,
  PalletUniquesCollectionDetails,
  PalletUniquesItemDetails,
  PalletUniquesCollectionMetadata,
  PalletUniquesItemMetadata,
  PalletNftsCollectionDetails,
  PalletNftsBitFlagsCollectionRole,
  PalletNftsItemDetails,
  PalletNftsCollectionMetadata,
  PalletNftsItemMetadata,
  PalletNftsAttributeDeposit,
  PalletNftsAttributeNamespace,
  PalletNftsPendingSwap,
  PalletNftsCollectionConfig,
  PalletNftsItemConfig,
  StagingXcmV5Location,
  PalletNftFractionalizationDetails,
  PalletAssetConversionPoolInfo,
  PalletRecoveryRecoveryConfig,
  PalletRecoveryActiveRecovery,
  PalletSocietyGroupParams,
  PalletSocietyMemberRecord,
  PalletSocietyPayoutRecord,
  PalletSocietyBid,
  PalletSocietyCandidacy,
  PalletSocietyVote,
  PalletSocietyIntakeRecord,
  PalletSocietyTally,
  PalletReviveVmCodeInfo,
  PalletReviveStorageAccountInfo,
  PalletReviveStorageDeletionQueueManager,
  PalletStateTrieMigrationMigrationTask,
  PalletStateTrieMigrationMigrationLimits,
  PalletNominationPoolsPoolMember,
  PalletNominationPoolsBondedPoolInner,
  PalletNominationPoolsRewardPool,
  PalletNominationPoolsSubPools,
  PalletNominationPoolsClaimPermission,
  PalletBagsListListNode,
  PalletBagsListListBag,
  PalletDelegatedStakingDelegation,
  PalletDelegatedStakingAgentLedger,
  PalletStakingAsyncRcClientSessionReport,
  PalletElectionProviderMultiBlockPhase,
  FrameElectionProviderSupportBoundedSupports,
  PalletElectionProviderMultiBlockVerifierImplsValidSolution,
  PalletElectionProviderMultiBlockVerifierImplsPartialBackings,
  SpNposElectionsElectionScore,
  PalletElectionProviderMultiBlockVerifierImplsStatus,
  AssetHubKusamaRuntimeStakingNposCompactSolution24,
  PalletElectionProviderMultiBlockSignedSubmissionMetadata,
  PalletStakingAsyncLedgerStakingLedger,
  PalletStakingAsyncRewardDestination,
  PalletStakingAsyncValidatorPrefs,
  PalletStakingAsyncNominations,
  PalletStakingAsyncActiveEraInfo,
  SpStakingPagedExposureMetadata,
  PalletStakingAsyncPalletBoundedExposurePage,
  PalletStakingAsyncEraRewardPoints,
  PalletStakingAsyncForcing,
  PalletStakingAsyncSlashingOffenceRecord,
  PalletStakingAsyncUnappliedSlash,
  PalletStakingAsyncSnapshotStatus,
  PalletStakingAsyncPalletPruningStep,
  PalletTreasuryProposal,
  PalletTreasurySpendStatus,
  PalletConvictionVotingVoteVoting,
  PalletReferendaReferendumInfoOriginCaller,
  PalletBountiesBounty,
  PalletChildBountiesChildBounty,
  PolkadotRuntimeCommonImplsVersionedLocatableAsset,
  PalletRcMigratorAccountsAccount,
  PalletAhMigratorMigrationStage,
  PalletAhMigratorBalancesBefore,
  PalletRcMigratorQueuePriority,
} from './types.js';

export interface ChainStorage<Rv extends RpcVersion> extends GenericChainStorage<Rv> {
  /**
   * Pallet `System`'s storage queries
   **/
  system: {
    /**
     * The full account information for a particular account ID.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<FrameSystemAccountInfo> =} callback
     **/
    account: GenericStorageQuery<Rv, (arg: AccountId32Like) => FrameSystemAccountInfo, AccountId32>;

    /**
     * Total extrinsics count for the current block.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    extrinsicCount: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Whether all inherents have been applied.
     *
     * @param {Callback<boolean> =} callback
     **/
    inherentsApplied: GenericStorageQuery<Rv, () => boolean>;

    /**
     * The current weight for the block.
     *
     * @param {Callback<FrameSupportDispatchPerDispatchClass> =} callback
     **/
    blockWeight: GenericStorageQuery<Rv, () => FrameSupportDispatchPerDispatchClass>;

    /**
     * Total length (in bytes) for all extrinsics put together, for the current block.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    allExtrinsicsLen: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Map of block numbers to block hashes.
     *
     * @param {number} arg
     * @param {Callback<H256> =} callback
     **/
    blockHash: GenericStorageQuery<Rv, (arg: number) => H256, number>;

    /**
     * Extrinsics data for the current block (maps an extrinsic's index to its data).
     *
     * @param {number} arg
     * @param {Callback<Bytes> =} callback
     **/
    extrinsicData: GenericStorageQuery<Rv, (arg: number) => Bytes, number>;

    /**
     * The current block number being processed. Set by `execute_block`.
     *
     * @param {Callback<number> =} callback
     **/
    number: GenericStorageQuery<Rv, () => number>;

    /**
     * Hash of the previous block.
     *
     * @param {Callback<H256> =} callback
     **/
    parentHash: GenericStorageQuery<Rv, () => H256>;

    /**
     * Digest of the current block, also part of the block header.
     *
     * @param {Callback<Digest> =} callback
     **/
    digest: GenericStorageQuery<Rv, () => Digest>;

    /**
     * Events deposited for the current block.
     *
     * NOTE: The item is unbound and should therefore never be read on chain.
     * It could otherwise inflate the PoV size of a block.
     *
     * Events have a large in-memory size. Box the events to not go out-of-memory
     * just in case someone still reads them from within the runtime.
     *
     * @param {Callback<Array<FrameSystemEventRecord>> =} callback
     **/
    events: GenericStorageQuery<Rv, () => Array<FrameSystemEventRecord>>;

    /**
     * The number of events in the `Events<T>` list.
     *
     * @param {Callback<number> =} callback
     **/
    eventCount: GenericStorageQuery<Rv, () => number>;

    /**
     * Mapping between a topic (represented by T::Hash) and a vector of indexes
     * of events in the `<Events<T>>` list.
     *
     * All topic vectors have deterministic storage locations depending on the topic. This
     * allows light-clients to leverage the changes trie storage tracking mechanism and
     * in case of changes fetch the list of events of interest.
     *
     * The value has the type `(BlockNumberFor<T>, EventIndex)` because if we used only just
     * the `EventIndex` then in case if the topic has the same contents on the next block
     * no notification will be triggered thus the event might be lost.
     *
     * @param {H256} arg
     * @param {Callback<Array<[number, number]>> =} callback
     **/
    eventTopics: GenericStorageQuery<Rv, (arg: H256) => Array<[number, number]>, H256>;

    /**
     * Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened.
     *
     * @param {Callback<FrameSystemLastRuntimeUpgradeInfo | undefined> =} callback
     **/
    lastRuntimeUpgrade: GenericStorageQuery<Rv, () => FrameSystemLastRuntimeUpgradeInfo | undefined>;

    /**
     * True if we have upgraded so that `type RefCount` is `u32`. False (default) if not.
     *
     * @param {Callback<boolean> =} callback
     **/
    upgradedToU32RefCount: GenericStorageQuery<Rv, () => boolean>;

    /**
     * True if we have upgraded so that AccountInfo contains three types of `RefCount`. False
     * (default) if not.
     *
     * @param {Callback<boolean> =} callback
     **/
    upgradedToTripleRefCount: GenericStorageQuery<Rv, () => boolean>;

    /**
     * The execution phase of the block.
     *
     * @param {Callback<Phase | undefined> =} callback
     **/
    executionPhase: GenericStorageQuery<Rv, () => Phase | undefined>;

    /**
     * `Some` if a code upgrade has been authorized.
     *
     * @param {Callback<FrameSystemCodeUpgradeAuthorization | undefined> =} callback
     **/
    authorizedUpgrade: GenericStorageQuery<Rv, () => FrameSystemCodeUpgradeAuthorization | undefined>;

    /**
     * The weight reclaimed for the extrinsic.
     *
     * This information is available until the end of the extrinsic execution.
     * More precisely this information is removed in `note_applied_extrinsic`.
     *
     * Logic doing some post dispatch weight reduction must update this storage to avoid duplicate
     * reduction.
     *
     * @param {Callback<SpWeightsWeightV2Weight> =} callback
     **/
    extrinsicWeightReclaimed: GenericStorageQuery<Rv, () => SpWeightsWeightV2Weight>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `ParachainSystem`'s storage queries
   **/
  parachainSystem: {
    /**
     * Latest included block descendants the runtime accepted. In other words, these are
     * ancestors of the currently executing block which have not been included in the observed
     * relay-chain state.
     *
     * The segment length is limited by the capacity returned from the [`ConsensusHook`] configured
     * in the pallet.
     *
     * @param {Callback<Array<CumulusPalletParachainSystemUnincludedSegmentAncestor>> =} callback
     **/
    unincludedSegment: GenericStorageQuery<Rv, () => Array<CumulusPalletParachainSystemUnincludedSegmentAncestor>>;

    /**
     * Storage field that keeps track of bandwidth used by the unincluded segment along with the
     * latest HRMP watermark. Used for limiting the acceptance of new blocks with
     * respect to relay chain constraints.
     *
     * @param {Callback<CumulusPalletParachainSystemUnincludedSegmentSegmentTracker | undefined> =} callback
     **/
    aggregatedUnincludedSegment: GenericStorageQuery<
      Rv,
      () => CumulusPalletParachainSystemUnincludedSegmentSegmentTracker | undefined
    >;

    /**
     * In case of a scheduled upgrade, this storage field contains the validation code to be
     * applied.
     *
     * As soon as the relay chain gives us the go-ahead signal, we will overwrite the
     * [`:code`][sp_core::storage::well_known_keys::CODE] which will result the next block process
     * with the new validation code. This concludes the upgrade process.
     *
     * @param {Callback<Bytes> =} callback
     **/
    pendingValidationCode: GenericStorageQuery<Rv, () => Bytes>;

    /**
     * Validation code that is set by the parachain and is to be communicated to collator and
     * consequently the relay-chain.
     *
     * This will be cleared in `on_initialize` of each new block if no other pallet already set
     * the value.
     *
     * @param {Callback<Bytes | undefined> =} callback
     **/
    newValidationCode: GenericStorageQuery<Rv, () => Bytes | undefined>;

    /**
     * The [`PersistedValidationData`] set for this block.
     * This value is expected to be set only once per block and it's never stored
     * in the trie.
     *
     * @param {Callback<PolkadotPrimitivesV8PersistedValidationData | undefined> =} callback
     **/
    validationData: GenericStorageQuery<Rv, () => PolkadotPrimitivesV8PersistedValidationData | undefined>;

    /**
     * Were the validation data set to notify the relay chain?
     *
     * @param {Callback<boolean> =} callback
     **/
    didSetValidationCode: GenericStorageQuery<Rv, () => boolean>;

    /**
     * The relay chain block number associated with the last parachain block.
     *
     * This is updated in `on_finalize`.
     *
     * @param {Callback<number> =} callback
     **/
    lastRelayChainBlockNumber: GenericStorageQuery<Rv, () => number>;

    /**
     * An option which indicates if the relay-chain restricts signalling a validation code upgrade.
     * In other words, if this is `Some` and [`NewValidationCode`] is `Some` then the produced
     * candidate will be invalid.
     *
     * This storage item is a mirror of the corresponding value for the current parachain from the
     * relay-chain. This value is ephemeral which means it doesn't hit the storage. This value is
     * set after the inherent.
     *
     * @param {Callback<PolkadotPrimitivesV8UpgradeRestriction | undefined> =} callback
     **/
    upgradeRestrictionSignal: GenericStorageQuery<Rv, () => PolkadotPrimitivesV8UpgradeRestriction | undefined>;

    /**
     * Optional upgrade go-ahead signal from the relay-chain.
     *
     * This storage item is a mirror of the corresponding value for the current parachain from the
     * relay-chain. This value is ephemeral which means it doesn't hit the storage. This value is
     * set after the inherent.
     *
     * @param {Callback<PolkadotPrimitivesV8UpgradeGoAhead | undefined> =} callback
     **/
    upgradeGoAhead: GenericStorageQuery<Rv, () => PolkadotPrimitivesV8UpgradeGoAhead | undefined>;

    /**
     * The state proof for the last relay parent block.
     *
     * This field is meant to be updated each block with the validation data inherent. Therefore,
     * before processing of the inherent, e.g. in `on_initialize` this data may be stale.
     *
     * This data is also absent from the genesis.
     *
     * @param {Callback<SpTrieStorageProof | undefined> =} callback
     **/
    relayStateProof: GenericStorageQuery<Rv, () => SpTrieStorageProof | undefined>;

    /**
     * The snapshot of some state related to messaging relevant to the current parachain as per
     * the relay parent.
     *
     * This field is meant to be updated each block with the validation data inherent. Therefore,
     * before processing of the inherent, e.g. in `on_initialize` this data may be stale.
     *
     * This data is also absent from the genesis.
     *
     * @param {Callback<CumulusPalletParachainSystemRelayStateSnapshotMessagingStateSnapshot | undefined> =} callback
     **/
    relevantMessagingState: GenericStorageQuery<
      Rv,
      () => CumulusPalletParachainSystemRelayStateSnapshotMessagingStateSnapshot | undefined
    >;

    /**
     * The parachain host configuration that was obtained from the relay parent.
     *
     * This field is meant to be updated each block with the validation data inherent. Therefore,
     * before processing of the inherent, e.g. in `on_initialize` this data may be stale.
     *
     * This data is also absent from the genesis.
     *
     * @param {Callback<PolkadotPrimitivesV8AbridgedHostConfiguration | undefined> =} callback
     **/
    hostConfiguration: GenericStorageQuery<Rv, () => PolkadotPrimitivesV8AbridgedHostConfiguration | undefined>;

    /**
     * The last downward message queue chain head we have observed.
     *
     * This value is loaded before and saved after processing inbound downward messages carried
     * by the system inherent.
     *
     * @param {Callback<CumulusPrimitivesParachainInherentMessageQueueChain> =} callback
     **/
    lastDmqMqcHead: GenericStorageQuery<Rv, () => CumulusPrimitivesParachainInherentMessageQueueChain>;

    /**
     * The message queue chain heads we have observed per each channel incoming channel.
     *
     * This value is loaded before and saved after processing inbound downward messages carried
     * by the system inherent.
     *
     * @param {Callback<Array<[PolkadotParachainPrimitivesPrimitivesId, CumulusPrimitivesParachainInherentMessageQueueChain]>> =} callback
     **/
    lastHrmpMqcHeads: GenericStorageQuery<
      Rv,
      () => Array<[PolkadotParachainPrimitivesPrimitivesId, CumulusPrimitivesParachainInherentMessageQueueChain]>
    >;

    /**
     * Number of downward messages processed in a block.
     *
     * This will be cleared in `on_initialize` of each new block.
     *
     * @param {Callback<number> =} callback
     **/
    processedDownwardMessages: GenericStorageQuery<Rv, () => number>;

    /**
     * The last processed downward message.
     *
     * We need to keep track of this to filter the messages that have been already processed.
     *
     * @param {Callback<CumulusPalletParachainSystemParachainInherentInboundMessageId | undefined> =} callback
     **/
    lastProcessedDownwardMessage: GenericStorageQuery<
      Rv,
      () => CumulusPalletParachainSystemParachainInherentInboundMessageId | undefined
    >;

    /**
     * HRMP watermark that was set in a block.
     *
     * @param {Callback<number> =} callback
     **/
    hrmpWatermark: GenericStorageQuery<Rv, () => number>;

    /**
     * The last processed HRMP message.
     *
     * We need to keep track of this to filter the messages that have been already processed.
     *
     * @param {Callback<CumulusPalletParachainSystemParachainInherentInboundMessageId | undefined> =} callback
     **/
    lastProcessedHrmpMessage: GenericStorageQuery<
      Rv,
      () => CumulusPalletParachainSystemParachainInherentInboundMessageId | undefined
    >;

    /**
     * HRMP messages that were sent in a block.
     *
     * This will be cleared in `on_initialize` of each new block.
     *
     * @param {Callback<Array<PolkadotCorePrimitivesOutboundHrmpMessage>> =} callback
     **/
    hrmpOutboundMessages: GenericStorageQuery<Rv, () => Array<PolkadotCorePrimitivesOutboundHrmpMessage>>;

    /**
     * Upward messages that were sent in a block.
     *
     * This will be cleared in `on_initialize` of each new block.
     *
     * @param {Callback<Array<Bytes>> =} callback
     **/
    upwardMessages: GenericStorageQuery<Rv, () => Array<Bytes>>;

    /**
     * Upward messages that are still pending and not yet send to the relay chain.
     *
     * @param {Callback<Array<Bytes>> =} callback
     **/
    pendingUpwardMessages: GenericStorageQuery<Rv, () => Array<Bytes>>;

    /**
     * The factor to multiply the base delivery fee by for UMP.
     *
     * @param {Callback<FixedU128> =} callback
     **/
    upwardDeliveryFeeFactor: GenericStorageQuery<Rv, () => FixedU128>;

    /**
     * The number of HRMP messages we observed in `on_initialize` and thus used that number for
     * announcing the weight of `on_initialize` and `on_finalize`.
     *
     * @param {Callback<number> =} callback
     **/
    announcedHrmpMessagesPerCandidate: GenericStorageQuery<Rv, () => number>;

    /**
     * The weight we reserve at the beginning of the block for processing XCMP messages. This
     * overrides the amount set in the Config trait.
     *
     * @param {Callback<SpWeightsWeightV2Weight | undefined> =} callback
     **/
    reservedXcmpWeightOverride: GenericStorageQuery<Rv, () => SpWeightsWeightV2Weight | undefined>;

    /**
     * The weight we reserve at the beginning of the block for processing DMP messages. This
     * overrides the amount set in the Config trait.
     *
     * @param {Callback<SpWeightsWeightV2Weight | undefined> =} callback
     **/
    reservedDmpWeightOverride: GenericStorageQuery<Rv, () => SpWeightsWeightV2Weight | undefined>;

    /**
     * A custom head data that should be returned as result of `validate_block`.
     *
     * See `Pallet::set_custom_validation_head_data` for more information.
     *
     * @param {Callback<Bytes | undefined> =} callback
     **/
    customValidationHeadData: GenericStorageQuery<Rv, () => Bytes | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Timestamp`'s storage queries
   **/
  timestamp: {
    /**
     * The current time for the current block.
     *
     * @param {Callback<bigint> =} callback
     **/
    now: GenericStorageQuery<Rv, () => bigint>;

    /**
     * Whether the timestamp has been updated in this block.
     *
     * This value is updated to `true` upon successful submission of a timestamp by a node.
     * It is then checked at the end of each block execution in the `on_finalize` hook.
     *
     * @param {Callback<boolean> =} callback
     **/
    didUpdate: GenericStorageQuery<Rv, () => boolean>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `ParachainInfo`'s storage queries
   **/
  parachainInfo: {
    /**
     *
     * @param {Callback<PolkadotParachainPrimitivesPrimitivesId> =} callback
     **/
    parachainId: GenericStorageQuery<Rv, () => PolkadotParachainPrimitivesPrimitivesId>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `MultiBlockMigrations`'s storage queries
   **/
  multiBlockMigrations: {
    /**
     * The currently active migration to run and its cursor.
     *
     * `None` indicates that no migration is running.
     *
     * @param {Callback<PalletMigrationsMigrationCursor | undefined> =} callback
     **/
    cursor: GenericStorageQuery<Rv, () => PalletMigrationsMigrationCursor | undefined>;

    /**
     * Set of all successfully executed migrations.
     *
     * This is used as blacklist, to not re-execute migrations that have not been removed from the
     * codebase yet. Governance can regularly clear this out via `clear_historic`.
     *
     * @param {BytesLike} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    historic: GenericStorageQuery<Rv, (arg: BytesLike) => [] | undefined, Bytes>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Preimage`'s storage queries
   **/
  preimage: {
    /**
     * The request status of a given hash.
     *
     * @param {H256} arg
     * @param {Callback<PalletPreimageOldRequestStatus | undefined> =} callback
     *
     * @deprecated RequestStatusFor
     **/
    statusFor: GenericStorageQuery<Rv, (arg: H256) => PalletPreimageOldRequestStatus | undefined, H256>;

    /**
     * The request status of a given hash.
     *
     * @param {H256} arg
     * @param {Callback<PalletPreimageRequestStatus | undefined> =} callback
     **/
    requestStatusFor: GenericStorageQuery<Rv, (arg: H256) => PalletPreimageRequestStatus | undefined, H256>;

    /**
     *
     * @param {[H256, number]} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    preimageFor: GenericStorageQuery<Rv, (arg: [H256, number]) => Bytes | undefined, [H256, number]>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Scheduler`'s storage queries
   **/
  scheduler: {
    /**
     * Block number at which the agenda began incomplete execution.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    incompleteSince: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Items to be executed, indexed by the block number that they should be executed on.
     *
     * @param {number} arg
     * @param {Callback<Array<PalletSchedulerScheduled | undefined>> =} callback
     **/
    agenda: GenericStorageQuery<Rv, (arg: number) => Array<PalletSchedulerScheduled | undefined>, number>;

    /**
     * Retry configurations for items to be executed, indexed by task address.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletSchedulerRetryConfig | undefined> =} callback
     **/
    retries: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => PalletSchedulerRetryConfig | undefined,
      [number, number]
    >;

    /**
     * Lookup from a name to the block number and index of the task.
     *
     * For v3 -> v4 the previously unbounded identities are Blake2-256 hashed to form the v4
     * identities.
     *
     * @param {FixedBytes<32>} arg
     * @param {Callback<[number, number] | undefined> =} callback
     **/
    lookup: GenericStorageQuery<Rv, (arg: FixedBytes<32>) => [number, number] | undefined, FixedBytes<32>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Parameters`'s storage queries
   **/
  parameters: {
    /**
     * Stored parameters.
     *
     * @param {AssetHubKusamaRuntimeRuntimeParametersKey} arg
     * @param {Callback<AssetHubKusamaRuntimeRuntimeParametersValue | undefined> =} callback
     **/
    parameters: GenericStorageQuery<
      Rv,
      (arg: AssetHubKusamaRuntimeRuntimeParametersKey) => AssetHubKusamaRuntimeRuntimeParametersValue | undefined,
      AssetHubKusamaRuntimeRuntimeParametersKey
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Balances`'s storage queries
   **/
  balances: {
    /**
     * The total units issued in the system.
     *
     * @param {Callback<bigint> =} callback
     **/
    totalIssuance: GenericStorageQuery<Rv, () => bigint>;

    /**
     * The total units of outstanding deactivated balance in the system.
     *
     * @param {Callback<bigint> =} callback
     **/
    inactiveIssuance: GenericStorageQuery<Rv, () => bigint>;

    /**
     * The Balances pallet example of storing the balance of an account.
     *
     * # Example
     *
     * ```nocompile
     * impl pallet_balances::Config for Runtime {
     * type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>
     * }
     * ```
     *
     * You can also store the balance of an account in the `System` pallet.
     *
     * # Example
     *
     * ```nocompile
     * impl pallet_balances::Config for Runtime {
     * type AccountStore = System
     * }
     * ```
     *
     * But this comes with tradeoffs, storing account balances in the system pallet stores
     * `frame_system` data alongside the account data contrary to storing account balances in the
     * `Balances` pallet, which uses a `StorageMap` to store balances data only.
     * NOTE: This is only used in the case that this pallet is used to store balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletBalancesAccountData> =} callback
     **/
    account: GenericStorageQuery<Rv, (arg: AccountId32Like) => PalletBalancesAccountData, AccountId32>;

    /**
     * Any liquidity locks on some account balances.
     * NOTE: Should only be accessed when setting, changing and freeing a lock.
     *
     * Use of locks is deprecated in favour of freezes. See `https://github.com/paritytech/substrate/pull/12951/`
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletBalancesBalanceLock>> =} callback
     **/
    locks: GenericStorageQuery<Rv, (arg: AccountId32Like) => Array<PalletBalancesBalanceLock>, AccountId32>;

    /**
     * Named reserves on some account balances.
     *
     * Use of reserves is deprecated in favour of holds. See `https://github.com/paritytech/substrate/pull/12951/`
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletBalancesReserveData>> =} callback
     **/
    reserves: GenericStorageQuery<Rv, (arg: AccountId32Like) => Array<PalletBalancesReserveData>, AccountId32>;

    /**
     * Holds on account balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<FrameSupportTokensMiscIdAmountRuntimeHoldReason>> =} callback
     **/
    holds: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => Array<FrameSupportTokensMiscIdAmountRuntimeHoldReason>,
      AccountId32
    >;

    /**
     * Freeze locks on account balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<FrameSupportTokensMiscIdAmountRuntimeFreezeReason>> =} callback
     **/
    freezes: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => Array<FrameSupportTokensMiscIdAmountRuntimeFreezeReason>,
      AccountId32
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `TransactionPayment`'s storage queries
   **/
  transactionPayment: {
    /**
     *
     * @param {Callback<FixedU128> =} callback
     **/
    nextFeeMultiplier: GenericStorageQuery<Rv, () => FixedU128>;

    /**
     *
     * @param {Callback<PalletTransactionPaymentReleases> =} callback
     **/
    storageVersion: GenericStorageQuery<Rv, () => PalletTransactionPaymentReleases>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Vesting`'s storage queries
   **/
  vesting: {
    /**
     * Information regarding the vesting of a given account.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletVestingVestingInfo> | undefined> =} callback
     **/
    vesting: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => Array<PalletVestingVestingInfo> | undefined,
      AccountId32
    >;

    /**
     * Storage version of the pallet.
     *
     * New networks start with latest version, as determined by the genesis build.
     *
     * @param {Callback<PalletVestingReleases> =} callback
     **/
    storageVersion: GenericStorageQuery<Rv, () => PalletVestingReleases>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Claims`'s storage queries
   **/
  claims: {
    /**
     *
     * @param {EthereumAddressLike} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    claims: GenericStorageQuery<Rv, (arg: EthereumAddressLike) => bigint | undefined, EthereumAddress>;

    /**
     *
     * @param {Callback<bigint> =} callback
     **/
    total: GenericStorageQuery<Rv, () => bigint>;

    /**
     * Vesting schedule for a claim.
     * First balance is the total amount that should be held for vesting.
     * Second balance is how much should be unlocked per block.
     * The block number is when the vesting should start.
     *
     * @param {EthereumAddressLike} arg
     * @param {Callback<[bigint, bigint, number] | undefined> =} callback
     **/
    vesting: GenericStorageQuery<
      Rv,
      (arg: EthereumAddressLike) => [bigint, bigint, number] | undefined,
      EthereumAddress
    >;

    /**
     * The statement kind that must be signed, if any.
     *
     * @param {EthereumAddressLike} arg
     * @param {Callback<PolkadotRuntimeCommonClaimsStatementKind | undefined> =} callback
     **/
    signing: GenericStorageQuery<
      Rv,
      (arg: EthereumAddressLike) => PolkadotRuntimeCommonClaimsStatementKind | undefined,
      EthereumAddress
    >;

    /**
     * Pre-claimed Ethereum accounts, by the Account ID that they are claimed to.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<EthereumAddress | undefined> =} callback
     **/
    preclaims: GenericStorageQuery<Rv, (arg: AccountId32Like) => EthereumAddress | undefined, AccountId32>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Authorship`'s storage queries
   **/
  authorship: {
    /**
     * Author of current block.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    author: GenericStorageQuery<Rv, () => AccountId32 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `CollatorSelection`'s storage queries
   **/
  collatorSelection: {
    /**
     * The invulnerable, permissioned collators. This list must be sorted.
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    invulnerables: GenericStorageQuery<Rv, () => Array<AccountId32>>;

    /**
     * The (community, limited) collation candidates. `Candidates` and `Invulnerables` should be
     * mutually exclusive.
     *
     * This list is sorted in ascending order by deposit and when the deposits are equal, the least
     * recently updated is considered greater.
     *
     * @param {Callback<Array<PalletCollatorSelectionCandidateInfo>> =} callback
     **/
    candidateList: GenericStorageQuery<Rv, () => Array<PalletCollatorSelectionCandidateInfo>>;

    /**
     * Last block authored by collator.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<number> =} callback
     **/
    lastAuthoredBlock: GenericStorageQuery<Rv, (arg: AccountId32Like) => number, AccountId32>;

    /**
     * Desired number of candidates.
     *
     * This should ideally always be less than [`Config::MaxCandidates`] for weights to be correct.
     *
     * @param {Callback<number> =} callback
     **/
    desiredCandidates: GenericStorageQuery<Rv, () => number>;

    /**
     * Fixed amount to deposit to become a collator.
     *
     * When a collator calls `leave_intent` they immediately receive the deposit back.
     *
     * @param {Callback<bigint> =} callback
     **/
    candidacyBond: GenericStorageQuery<Rv, () => bigint>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Session`'s storage queries
   **/
  session: {
    /**
     * The current set of validators.
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    validators: GenericStorageQuery<Rv, () => Array<AccountId32>>;

    /**
     * Current index of the session.
     *
     * @param {Callback<number> =} callback
     **/
    currentIndex: GenericStorageQuery<Rv, () => number>;

    /**
     * True if the underlying economic identities or weighting behind the validators
     * has changed in the queued validator set.
     *
     * @param {Callback<boolean> =} callback
     **/
    queuedChanged: GenericStorageQuery<Rv, () => boolean>;

    /**
     * The queued keys for the next session. When the next session begins, these keys
     * will be used to determine the validator's session keys.
     *
     * @param {Callback<Array<[AccountId32, AssetHubKusamaRuntimeSessionKeys]>> =} callback
     **/
    queuedKeys: GenericStorageQuery<Rv, () => Array<[AccountId32, AssetHubKusamaRuntimeSessionKeys]>>;

    /**
     * Indices of disabled validators.
     *
     * The vec is always kept sorted so that we can find whether a given validator is
     * disabled using binary search. It gets cleared when `on_session_ending` returns
     * a new set of identities.
     *
     * @param {Callback<Array<[number, SpStakingOffenceOffenceSeverity]>> =} callback
     **/
    disabledValidators: GenericStorageQuery<Rv, () => Array<[number, SpStakingOffenceOffenceSeverity]>>;

    /**
     * The next session keys for a validator.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<AssetHubKusamaRuntimeSessionKeys | undefined> =} callback
     **/
    nextKeys: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => AssetHubKusamaRuntimeSessionKeys | undefined,
      AccountId32
    >;

    /**
     * The owner of a key. The key is the `KeyTypeId` + the encoded key.
     *
     * @param {[SpCoreCryptoKeyTypeId, BytesLike]} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    keyOwner: GenericStorageQuery<
      Rv,
      (arg: [SpCoreCryptoKeyTypeId, BytesLike]) => AccountId32 | undefined,
      [SpCoreCryptoKeyTypeId, Bytes]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Aura`'s storage queries
   **/
  aura: {
    /**
     * The current authority set.
     *
     * @param {Callback<Array<SpConsensusAuraSr25519AppSr25519Public>> =} callback
     **/
    authorities: GenericStorageQuery<Rv, () => Array<SpConsensusAuraSr25519AppSr25519Public>>;

    /**
     * The current slot of this block.
     *
     * This will be set in `on_initialize`.
     *
     * @param {Callback<SpConsensusSlotsSlot> =} callback
     **/
    currentSlot: GenericStorageQuery<Rv, () => SpConsensusSlotsSlot>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `AuraExt`'s storage queries
   **/
  auraExt: {
    /**
     * Serves as cache for the authorities.
     *
     * The authorities in AuRa are overwritten in `on_initialize` when we switch to a new session,
     * but we require the old authorities to verify the seal when validating a PoV. This will
     * always be updated to the latest AuRa authorities in `on_finalize`.
     *
     * @param {Callback<Array<SpConsensusAuraSr25519AppSr25519Public>> =} callback
     **/
    authorities: GenericStorageQuery<Rv, () => Array<SpConsensusAuraSr25519AppSr25519Public>>;

    /**
     * Current relay chain slot paired with a number of authored blocks.
     *
     * This is updated in [`FixedVelocityConsensusHook::on_state_proof`] with the current relay
     * chain slot as provided by the relay chain state proof.
     *
     * @param {Callback<[SpConsensusSlotsSlot, number] | undefined> =} callback
     **/
    relaySlotInfo: GenericStorageQuery<Rv, () => [SpConsensusSlotsSlot, number] | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `XcmpQueue`'s storage queries
   **/
  xcmpQueue: {
    /**
     * The suspended inbound XCMP channels. All others are not suspended.
     *
     * This is a `StorageValue` instead of a `StorageMap` since we expect multiple reads per block
     * to different keys with a one byte payload. The access to `BoundedBTreeSet` will be cached
     * within the block and therefore only included once in the proof size.
     *
     * NOTE: The PoV benchmarking cannot know this and will over-estimate, but the actual proof
     * will be smaller.
     *
     * @param {Callback<Array<PolkadotParachainPrimitivesPrimitivesId>> =} callback
     **/
    inboundXcmpSuspended: GenericStorageQuery<Rv, () => Array<PolkadotParachainPrimitivesPrimitivesId>>;

    /**
     * The non-empty XCMP channels in order of becoming non-empty, and the index of the first
     * and last outbound message. If the two indices are equal, then it indicates an empty
     * queue and there must be a non-`Ok` `OutboundStatus`. We assume queues grow no greater
     * than 65535 items. Queue indices for normal messages begin at one; zero is reserved in
     * case of the need to send a high-priority signal message this block.
     * The bool is true if there is a signal message waiting to be sent.
     *
     * @param {Callback<Array<CumulusPalletXcmpQueueOutboundChannelDetails>> =} callback
     **/
    outboundXcmpStatus: GenericStorageQuery<Rv, () => Array<CumulusPalletXcmpQueueOutboundChannelDetails>>;

    /**
     * The messages outbound in a given XCMP channel.
     *
     * @param {[PolkadotParachainPrimitivesPrimitivesId, number]} arg
     * @param {Callback<Bytes> =} callback
     **/
    outboundXcmpMessages: GenericStorageQuery<
      Rv,
      (arg: [PolkadotParachainPrimitivesPrimitivesId, number]) => Bytes,
      [PolkadotParachainPrimitivesPrimitivesId, number]
    >;

    /**
     * Any signal messages waiting to be sent.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<Bytes> =} callback
     **/
    signalMessages: GenericStorageQuery<
      Rv,
      (arg: PolkadotParachainPrimitivesPrimitivesId) => Bytes,
      PolkadotParachainPrimitivesPrimitivesId
    >;

    /**
     * The configuration which controls the dynamics of the outbound queue.
     *
     * @param {Callback<CumulusPalletXcmpQueueQueueConfigData> =} callback
     **/
    queueConfig: GenericStorageQuery<Rv, () => CumulusPalletXcmpQueueQueueConfigData>;

    /**
     * Whether or not the XCMP queue is suspended from executing incoming XCMs or not.
     *
     * @param {Callback<boolean> =} callback
     **/
    queueSuspended: GenericStorageQuery<Rv, () => boolean>;

    /**
     * The factor to multiply the base delivery fee by.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<FixedU128> =} callback
     **/
    deliveryFeeFactor: GenericStorageQuery<
      Rv,
      (arg: PolkadotParachainPrimitivesPrimitivesId) => FixedU128,
      PolkadotParachainPrimitivesPrimitivesId
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `PolkadotXcm`'s storage queries
   **/
  polkadotXcm: {
    /**
     * The latest available query index.
     *
     * @param {Callback<bigint> =} callback
     **/
    queryCounter: GenericStorageQuery<Rv, () => bigint>;

    /**
     * The ongoing queries.
     *
     * @param {bigint} arg
     * @param {Callback<PalletXcmQueryStatus | undefined> =} callback
     **/
    queries: GenericStorageQuery<Rv, (arg: bigint) => PalletXcmQueryStatus | undefined, bigint>;

    /**
     * The existing asset traps.
     *
     * Key is the blake2 256 hash of (origin, versioned `Assets`) pair. Value is the number of
     * times this pair has been trapped (usually just 1 if it exists at all).
     *
     * @param {H256} arg
     * @param {Callback<number> =} callback
     **/
    assetTraps: GenericStorageQuery<Rv, (arg: H256) => number, H256>;

    /**
     * Default version to encode XCM when latest version of destination is unknown. If `None`,
     * then the destinations whose XCM version is unknown are considered unreachable.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    safeXcmVersion: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * The Latest versions that we know various locations support.
     *
     * @param {[number, XcmVersionedLocation]} arg
     * @param {Callback<number | undefined> =} callback
     **/
    supportedVersion: GenericStorageQuery<
      Rv,
      (arg: [number, XcmVersionedLocation]) => number | undefined,
      [number, XcmVersionedLocation]
    >;

    /**
     * All locations that we have requested version notifications from.
     *
     * @param {[number, XcmVersionedLocation]} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    versionNotifiers: GenericStorageQuery<
      Rv,
      (arg: [number, XcmVersionedLocation]) => bigint | undefined,
      [number, XcmVersionedLocation]
    >;

    /**
     * The target locations that are subscribed to our version changes, as well as the most recent
     * of our versions we informed them of.
     *
     * @param {[number, XcmVersionedLocation]} arg
     * @param {Callback<[bigint, SpWeightsWeightV2Weight, number] | undefined> =} callback
     **/
    versionNotifyTargets: GenericStorageQuery<
      Rv,
      (arg: [number, XcmVersionedLocation]) => [bigint, SpWeightsWeightV2Weight, number] | undefined,
      [number, XcmVersionedLocation]
    >;

    /**
     * Destinations whose latest XCM version we would like to know. Duplicates not allowed, and
     * the `u32` counter is the number of times that a send to the destination has been attempted,
     * which is used as a prioritization.
     *
     * @param {Callback<Array<[XcmVersionedLocation, number]>> =} callback
     **/
    versionDiscoveryQueue: GenericStorageQuery<Rv, () => Array<[XcmVersionedLocation, number]>>;

    /**
     * The current migration's stage, if any.
     *
     * @param {Callback<PalletXcmVersionMigrationStage | undefined> =} callback
     **/
    currentMigration: GenericStorageQuery<Rv, () => PalletXcmVersionMigrationStage | undefined>;

    /**
     * Fungible assets which we know are locked on a remote chain.
     *
     * @param {[number, AccountId32Like, XcmVersionedAssetId]} arg
     * @param {Callback<PalletXcmRemoteLockedFungibleRecord | undefined> =} callback
     **/
    remoteLockedFungibles: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like, XcmVersionedAssetId]) => PalletXcmRemoteLockedFungibleRecord | undefined,
      [number, AccountId32, XcmVersionedAssetId]
    >;

    /**
     * Fungible assets which we know are locked on this chain.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<[bigint, XcmVersionedLocation]> | undefined> =} callback
     **/
    lockedFungibles: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => Array<[bigint, XcmVersionedLocation]> | undefined,
      AccountId32
    >;

    /**
     * Global suspension state of the XCM executor.
     *
     * @param {Callback<boolean> =} callback
     **/
    xcmExecutionSuspended: GenericStorageQuery<Rv, () => boolean>;

    /**
     * Whether or not incoming XCMs (both executed locally and received) should be recorded.
     * Only one XCM program will be recorded at a time.
     * This is meant to be used in runtime APIs, and it's advised it stays false
     * for all other use cases, so as to not degrade regular performance.
     *
     * Only relevant if this pallet is being used as the [`xcm_executor::traits::RecordXcm`]
     * implementation in the XCM executor configuration.
     *
     * @param {Callback<boolean> =} callback
     **/
    shouldRecordXcm: GenericStorageQuery<Rv, () => boolean>;

    /**
     * If [`ShouldRecordXcm`] is set to true, then the last XCM program executed locally
     * will be stored here.
     * Runtime APIs can fetch the XCM that was executed by accessing this value.
     *
     * Only relevant if this pallet is being used as the [`xcm_executor::traits::RecordXcm`]
     * implementation in the XCM executor configuration.
     *
     * @param {Callback<StagingXcmV5Xcm | undefined> =} callback
     **/
    recordedXcm: GenericStorageQuery<Rv, () => StagingXcmV5Xcm | undefined>;

    /**
     * Map of authorized aliasers of local origins. Each local location can authorize a list of
     * other locations to alias into it. Each aliaser is only valid until its inner `expiry`
     * block number.
     *
     * @param {XcmVersionedLocation} arg
     * @param {Callback<PalletXcmAuthorizedAliasesEntry | undefined> =} callback
     **/
    authorizedAliases: GenericStorageQuery<
      Rv,
      (arg: XcmVersionedLocation) => PalletXcmAuthorizedAliasesEntry | undefined,
      XcmVersionedLocation
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `ToPolkadotXcmRouter`'s storage queries
   **/
  toPolkadotXcmRouter: {
    /**
     * Bridge that we are using.
     *
     * **bridges-v1** assumptions: all outbound messages through this router are using single lane
     * and to single remote consensus. If there is some other remote consensus that uses the same
     * bridge hub, the separate pallet instance shall be used, In `v2` we'll have all required
     * primitives (lane-id aka bridge-id, derived from XCM locations) to support multiple bridges
     * by the same pallet instance.
     *
     * @param {Callback<BpXcmBridgeHubRouterBridgeState> =} callback
     **/
    bridge: GenericStorageQuery<Rv, () => BpXcmBridgeHubRouterBridgeState>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `MessageQueue`'s storage queries
   **/
  messageQueue: {
    /**
     * The index of the first and last (non-empty) pages.
     *
     * @param {CumulusPrimitivesCoreAggregateMessageOrigin} arg
     * @param {Callback<PalletMessageQueueBookState> =} callback
     **/
    bookStateFor: GenericStorageQuery<
      Rv,
      (arg: CumulusPrimitivesCoreAggregateMessageOrigin) => PalletMessageQueueBookState,
      CumulusPrimitivesCoreAggregateMessageOrigin
    >;

    /**
     * The origin at which we should begin servicing.
     *
     * @param {Callback<CumulusPrimitivesCoreAggregateMessageOrigin | undefined> =} callback
     **/
    serviceHead: GenericStorageQuery<Rv, () => CumulusPrimitivesCoreAggregateMessageOrigin | undefined>;

    /**
     * The map of page indices to pages.
     *
     * @param {[CumulusPrimitivesCoreAggregateMessageOrigin, number]} arg
     * @param {Callback<PalletMessageQueuePage | undefined> =} callback
     **/
    pages: GenericStorageQuery<
      Rv,
      (arg: [CumulusPrimitivesCoreAggregateMessageOrigin, number]) => PalletMessageQueuePage | undefined,
      [CumulusPrimitivesCoreAggregateMessageOrigin, number]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Multisig`'s storage queries
   **/
  multisig: {
    /**
     * The set of open multisig operations.
     *
     * @param {[AccountId32Like, FixedBytes<32>]} arg
     * @param {Callback<PalletMultisigMultisig | undefined> =} callback
     **/
    multisigs: GenericStorageQuery<
      Rv,
      (arg: [AccountId32Like, FixedBytes<32>]) => PalletMultisigMultisig | undefined,
      [AccountId32, FixedBytes<32>]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Proxy`'s storage queries
   **/
  proxy: {
    /**
     * The set of account proxies. Maps the account which has delegated to the accounts
     * which are being delegated to, together with the amount held on deposit.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[Array<PalletProxyProxyDefinitionProxyType>, bigint]> =} callback
     **/
    proxies: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => [Array<PalletProxyProxyDefinitionProxyType>, bigint],
      AccountId32
    >;

    /**
     * The announcements made by the proxy (key).
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[Array<PalletProxyAnnouncement>, bigint]> =} callback
     **/
    announcements: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => [Array<PalletProxyAnnouncement>, bigint],
      AccountId32
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `RemoteProxyRelayChain`'s storage queries
   **/
  remoteProxyRelayChain: {
    /**
     * Stores the last [`Config::MaxStorageRootsToKeep`] block to storage root mappings of the
     * target chain.
     *
     * @param {Callback<Array<[number, H256]>> =} callback
     **/
    blockToRoot: GenericStorageQuery<Rv, () => Array<[number, H256]>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Indices`'s storage queries
   **/
  indices: {
    /**
     * The lookup from index to account.
     *
     * @param {number} arg
     * @param {Callback<[AccountId32, bigint, boolean] | undefined> =} callback
     **/
    accounts: GenericStorageQuery<Rv, (arg: number) => [AccountId32, bigint, boolean] | undefined, number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Assets`'s storage queries
   **/
  assets: {
    /**
     * Details of an asset.
     *
     * @param {number} arg
     * @param {Callback<PalletAssetsAssetDetails | undefined> =} callback
     **/
    asset: GenericStorageQuery<Rv, (arg: number) => PalletAssetsAssetDetails | undefined, number>;

    /**
     * The holdings of a specific account for a specific asset.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<PalletAssetsAssetAccount | undefined> =} callback
     **/
    account: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => PalletAssetsAssetAccount | undefined,
      [number, AccountId32]
    >;

    /**
     * Approved balance transfers. First balance is the amount approved for transfer. Second
     * is the amount of `T::Currency` reserved for storing this.
     * First key is the asset ID, second key is the owner and third key is the delegate.
     *
     * @param {[number, AccountId32Like, AccountId32Like]} arg
     * @param {Callback<PalletAssetsApproval | undefined> =} callback
     **/
    approvals: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like, AccountId32Like]) => PalletAssetsApproval | undefined,
      [number, AccountId32, AccountId32]
    >;

    /**
     * Metadata of an asset.
     *
     * @param {number} arg
     * @param {Callback<PalletAssetsAssetMetadata> =} callback
     **/
    metadata: GenericStorageQuery<Rv, (arg: number) => PalletAssetsAssetMetadata, number>;

    /**
     * The asset ID enforced for the next asset creation, if any present. Otherwise, this storage
     * item has no effect.
     *
     * This can be useful for setting up constraints for IDs of the new assets. For example, by
     * providing an initial [`NextAssetId`] and using the [`crate::AutoIncAssetId`] callback, an
     * auto-increment model can be applied to all new asset IDs.
     *
     * The initial next asset ID can be set using the [`GenesisConfig`] or the
     * [SetNextAssetId](`migration::next_asset_id::SetNextAssetId`) migration.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    nextAssetId: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Uniques`'s storage queries
   **/
  uniques: {
    /**
     * Details of a collection.
     *
     * @param {number} arg
     * @param {Callback<PalletUniquesCollectionDetails | undefined> =} callback
     **/
    class: GenericStorageQuery<Rv, (arg: number) => PalletUniquesCollectionDetails | undefined, number>;

    /**
     * The collection, if any, of which an account is willing to take ownership.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<number | undefined> =} callback
     **/
    ownershipAcceptance: GenericStorageQuery<Rv, (arg: AccountId32Like) => number | undefined, AccountId32>;

    /**
     * The items held by any given account; set out this way so that items owned by a single
     * account can be enumerated.
     *
     * @param {[AccountId32Like, number, number]} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    account: GenericStorageQuery<
      Rv,
      (arg: [AccountId32Like, number, number]) => [] | undefined,
      [AccountId32, number, number]
    >;

    /**
     * The collections owned by any given account; set out this way so that collections owned by
     * a single account can be enumerated.
     *
     * @param {[AccountId32Like, number]} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    classAccount: GenericStorageQuery<Rv, (arg: [AccountId32Like, number]) => [] | undefined, [AccountId32, number]>;

    /**
     * The items in existence and their ownership details.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletUniquesItemDetails | undefined> =} callback
     **/
    asset: GenericStorageQuery<Rv, (arg: [number, number]) => PalletUniquesItemDetails | undefined, [number, number]>;

    /**
     * Metadata of a collection.
     *
     * @param {number} arg
     * @param {Callback<PalletUniquesCollectionMetadata | undefined> =} callback
     **/
    classMetadataOf: GenericStorageQuery<Rv, (arg: number) => PalletUniquesCollectionMetadata | undefined, number>;

    /**
     * Metadata of an item.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletUniquesItemMetadata | undefined> =} callback
     **/
    instanceMetadataOf: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => PalletUniquesItemMetadata | undefined,
      [number, number]
    >;

    /**
     * Attributes of a collection.
     *
     * @param {[number, number | undefined, BytesLike]} arg
     * @param {Callback<[Bytes, bigint] | undefined> =} callback
     **/
    attribute: GenericStorageQuery<
      Rv,
      (arg: [number, number | undefined, BytesLike]) => [Bytes, bigint] | undefined,
      [number, number | undefined, Bytes]
    >;

    /**
     * Price of an asset instance.
     *
     * @param {[number, number]} arg
     * @param {Callback<[bigint, AccountId32 | undefined] | undefined> =} callback
     **/
    itemPriceOf: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => [bigint, AccountId32 | undefined] | undefined,
      [number, number]
    >;

    /**
     * Keeps track of the number of items a collection might have.
     *
     * @param {number} arg
     * @param {Callback<number | undefined> =} callback
     **/
    collectionMaxSupply: GenericStorageQuery<Rv, (arg: number) => number | undefined, number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Nfts`'s storage queries
   **/
  nfts: {
    /**
     * Details of a collection.
     *
     * @param {number} arg
     * @param {Callback<PalletNftsCollectionDetails | undefined> =} callback
     **/
    collection: GenericStorageQuery<Rv, (arg: number) => PalletNftsCollectionDetails | undefined, number>;

    /**
     * The collection, if any, of which an account is willing to take ownership.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<number | undefined> =} callback
     **/
    ownershipAcceptance: GenericStorageQuery<Rv, (arg: AccountId32Like) => number | undefined, AccountId32>;

    /**
     * The items held by any given account; set out this way so that items owned by a single
     * account can be enumerated.
     *
     * @param {[AccountId32Like, number, number]} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    account: GenericStorageQuery<
      Rv,
      (arg: [AccountId32Like, number, number]) => [] | undefined,
      [AccountId32, number, number]
    >;

    /**
     * The collections owned by any given account; set out this way so that collections owned by
     * a single account can be enumerated.
     *
     * @param {[AccountId32Like, number]} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    collectionAccount: GenericStorageQuery<
      Rv,
      (arg: [AccountId32Like, number]) => [] | undefined,
      [AccountId32, number]
    >;

    /**
     * The items in existence and their ownership details.
     * Stores collection roles as per account.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<PalletNftsBitFlagsCollectionRole | undefined> =} callback
     **/
    collectionRoleOf: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => PalletNftsBitFlagsCollectionRole | undefined,
      [number, AccountId32]
    >;

    /**
     * The items in existence and their ownership details.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletNftsItemDetails | undefined> =} callback
     **/
    item: GenericStorageQuery<Rv, (arg: [number, number]) => PalletNftsItemDetails | undefined, [number, number]>;

    /**
     * Metadata of a collection.
     *
     * @param {number} arg
     * @param {Callback<PalletNftsCollectionMetadata | undefined> =} callback
     **/
    collectionMetadataOf: GenericStorageQuery<Rv, (arg: number) => PalletNftsCollectionMetadata | undefined, number>;

    /**
     * Metadata of an item.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletNftsItemMetadata | undefined> =} callback
     **/
    itemMetadataOf: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => PalletNftsItemMetadata | undefined,
      [number, number]
    >;

    /**
     * Attributes of a collection.
     *
     * @param {[number, number | undefined, PalletNftsAttributeNamespace, BytesLike]} arg
     * @param {Callback<[Bytes, PalletNftsAttributeDeposit] | undefined> =} callback
     **/
    attribute: GenericStorageQuery<
      Rv,
      (
        arg: [number, number | undefined, PalletNftsAttributeNamespace, BytesLike],
      ) => [Bytes, PalletNftsAttributeDeposit] | undefined,
      [number, number | undefined, PalletNftsAttributeNamespace, Bytes]
    >;

    /**
     * A price of an item.
     *
     * @param {[number, number]} arg
     * @param {Callback<[bigint, AccountId32 | undefined] | undefined> =} callback
     **/
    itemPriceOf: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => [bigint, AccountId32 | undefined] | undefined,
      [number, number]
    >;

    /**
     * Item attribute approvals.
     *
     * @param {[number, number]} arg
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    itemAttributesApprovalsOf: GenericStorageQuery<Rv, (arg: [number, number]) => Array<AccountId32>, [number, number]>;

    /**
     * Stores the `CollectionId` that is going to be used for the next collection.
     * This gets incremented whenever a new collection is created.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    nextCollectionId: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Handles all the pending swaps.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletNftsPendingSwap | undefined> =} callback
     **/
    pendingSwapOf: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => PalletNftsPendingSwap | undefined,
      [number, number]
    >;

    /**
     * Config of a collection.
     *
     * @param {number} arg
     * @param {Callback<PalletNftsCollectionConfig | undefined> =} callback
     **/
    collectionConfigOf: GenericStorageQuery<Rv, (arg: number) => PalletNftsCollectionConfig | undefined, number>;

    /**
     * Config of an item.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletNftsItemConfig | undefined> =} callback
     **/
    itemConfigOf: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => PalletNftsItemConfig | undefined,
      [number, number]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `ForeignAssets`'s storage queries
   **/
  foreignAssets: {
    /**
     * Details of an asset.
     *
     * @param {StagingXcmV5Location} arg
     * @param {Callback<PalletAssetsAssetDetails | undefined> =} callback
     **/
    asset: GenericStorageQuery<
      Rv,
      (arg: StagingXcmV5Location) => PalletAssetsAssetDetails | undefined,
      StagingXcmV5Location
    >;

    /**
     * The holdings of a specific account for a specific asset.
     *
     * @param {[StagingXcmV5Location, AccountId32Like]} arg
     * @param {Callback<PalletAssetsAssetAccount | undefined> =} callback
     **/
    account: GenericStorageQuery<
      Rv,
      (arg: [StagingXcmV5Location, AccountId32Like]) => PalletAssetsAssetAccount | undefined,
      [StagingXcmV5Location, AccountId32]
    >;

    /**
     * Approved balance transfers. First balance is the amount approved for transfer. Second
     * is the amount of `T::Currency` reserved for storing this.
     * First key is the asset ID, second key is the owner and third key is the delegate.
     *
     * @param {[StagingXcmV5Location, AccountId32Like, AccountId32Like]} arg
     * @param {Callback<PalletAssetsApproval | undefined> =} callback
     **/
    approvals: GenericStorageQuery<
      Rv,
      (arg: [StagingXcmV5Location, AccountId32Like, AccountId32Like]) => PalletAssetsApproval | undefined,
      [StagingXcmV5Location, AccountId32, AccountId32]
    >;

    /**
     * Metadata of an asset.
     *
     * @param {StagingXcmV5Location} arg
     * @param {Callback<PalletAssetsAssetMetadata> =} callback
     **/
    metadata: GenericStorageQuery<Rv, (arg: StagingXcmV5Location) => PalletAssetsAssetMetadata, StagingXcmV5Location>;

    /**
     * The asset ID enforced for the next asset creation, if any present. Otherwise, this storage
     * item has no effect.
     *
     * This can be useful for setting up constraints for IDs of the new assets. For example, by
     * providing an initial [`NextAssetId`] and using the [`crate::AutoIncAssetId`] callback, an
     * auto-increment model can be applied to all new asset IDs.
     *
     * The initial next asset ID can be set using the [`GenesisConfig`] or the
     * [SetNextAssetId](`migration::next_asset_id::SetNextAssetId`) migration.
     *
     * @param {Callback<StagingXcmV5Location | undefined> =} callback
     **/
    nextAssetId: GenericStorageQuery<Rv, () => StagingXcmV5Location | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `NftFractionalization`'s storage queries
   **/
  nftFractionalization: {
    /**
     * Keeps track of the corresponding NFT ID, asset ID and amount minted.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletNftFractionalizationDetails | undefined> =} callback
     **/
    nftToAsset: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => PalletNftFractionalizationDetails | undefined,
      [number, number]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `PoolAssets`'s storage queries
   **/
  poolAssets: {
    /**
     * Details of an asset.
     *
     * @param {number} arg
     * @param {Callback<PalletAssetsAssetDetails | undefined> =} callback
     **/
    asset: GenericStorageQuery<Rv, (arg: number) => PalletAssetsAssetDetails | undefined, number>;

    /**
     * The holdings of a specific account for a specific asset.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<PalletAssetsAssetAccount | undefined> =} callback
     **/
    account: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => PalletAssetsAssetAccount | undefined,
      [number, AccountId32]
    >;

    /**
     * Approved balance transfers. First balance is the amount approved for transfer. Second
     * is the amount of `T::Currency` reserved for storing this.
     * First key is the asset ID, second key is the owner and third key is the delegate.
     *
     * @param {[number, AccountId32Like, AccountId32Like]} arg
     * @param {Callback<PalletAssetsApproval | undefined> =} callback
     **/
    approvals: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like, AccountId32Like]) => PalletAssetsApproval | undefined,
      [number, AccountId32, AccountId32]
    >;

    /**
     * Metadata of an asset.
     *
     * @param {number} arg
     * @param {Callback<PalletAssetsAssetMetadata> =} callback
     **/
    metadata: GenericStorageQuery<Rv, (arg: number) => PalletAssetsAssetMetadata, number>;

    /**
     * The asset ID enforced for the next asset creation, if any present. Otherwise, this storage
     * item has no effect.
     *
     * This can be useful for setting up constraints for IDs of the new assets. For example, by
     * providing an initial [`NextAssetId`] and using the [`crate::AutoIncAssetId`] callback, an
     * auto-increment model can be applied to all new asset IDs.
     *
     * The initial next asset ID can be set using the [`GenesisConfig`] or the
     * [SetNextAssetId](`migration::next_asset_id::SetNextAssetId`) migration.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    nextAssetId: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `AssetConversion`'s storage queries
   **/
  assetConversion: {
    /**
     * Map from `PoolAssetId` to `PoolInfo`. This establishes whether a pool has been officially
     * created rather than people sending tokens directly to a pool's public account.
     *
     * @param {[StagingXcmV5Location, StagingXcmV5Location]} arg
     * @param {Callback<PalletAssetConversionPoolInfo | undefined> =} callback
     **/
    pools: GenericStorageQuery<
      Rv,
      (arg: [StagingXcmV5Location, StagingXcmV5Location]) => PalletAssetConversionPoolInfo | undefined,
      [StagingXcmV5Location, StagingXcmV5Location]
    >;

    /**
     * Stores the `PoolAssetId` that is going to be used for the next lp token.
     * This gets incremented whenever a new lp pool is created.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    nextPoolAssetId: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Recovery`'s storage queries
   **/
  recovery: {
    /**
     * The set of recoverable accounts and their recovery configuration.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletRecoveryRecoveryConfig | undefined> =} callback
     **/
    recoverable: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletRecoveryRecoveryConfig | undefined,
      AccountId32
    >;

    /**
     * Active recovery attempts.
     *
     * First account is the account to be recovered, and the second account
     * is the user trying to recover the account.
     *
     * @param {[AccountId32Like, AccountId32Like]} arg
     * @param {Callback<PalletRecoveryActiveRecovery | undefined> =} callback
     **/
    activeRecoveries: GenericStorageQuery<
      Rv,
      (arg: [AccountId32Like, AccountId32Like]) => PalletRecoveryActiveRecovery | undefined,
      [AccountId32, AccountId32]
    >;

    /**
     * The list of allowed proxy accounts.
     *
     * Map from the user who can access it to the recovered account.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    proxy: GenericStorageQuery<Rv, (arg: AccountId32Like) => AccountId32 | undefined, AccountId32>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Society`'s storage queries
   **/
  society: {
    /**
     * The max number of members for the society at one time.
     *
     * @param {Callback<PalletSocietyGroupParams | undefined> =} callback
     **/
    parameters: GenericStorageQuery<Rv, () => PalletSocietyGroupParams | undefined>;

    /**
     * Amount of our account balance that is specifically for the next round's bid(s).
     *
     * @param {Callback<bigint> =} callback
     **/
    pot: GenericStorageQuery<Rv, () => bigint>;

    /**
     * The first member.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    founder: GenericStorageQuery<Rv, () => AccountId32 | undefined>;

    /**
     * The most primary from the most recently approved rank 0 members in the society.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    head: GenericStorageQuery<Rv, () => AccountId32 | undefined>;

    /**
     * A hash of the rules of this society concerning membership. Can only be set once and
     * only by the founder.
     *
     * @param {Callback<H256 | undefined> =} callback
     **/
    rules: GenericStorageQuery<Rv, () => H256 | undefined>;

    /**
     * The current members and their rank. Doesn't include `SuspendedMembers`.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletSocietyMemberRecord | undefined> =} callback
     **/
    members: GenericStorageQuery<Rv, (arg: AccountId32Like) => PalletSocietyMemberRecord | undefined, AccountId32>;

    /**
     * Information regarding rank-0 payouts, past and future.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletSocietyPayoutRecord> =} callback
     **/
    payouts: GenericStorageQuery<Rv, (arg: AccountId32Like) => PalletSocietyPayoutRecord, AccountId32>;

    /**
     * The number of items in `Members` currently. (Doesn't include `SuspendedMembers`.)
     *
     * @param {Callback<number> =} callback
     **/
    memberCount: GenericStorageQuery<Rv, () => number>;

    /**
     * The current items in `Members` keyed by their unique index. Keys are densely populated
     * `0..MemberCount` (does not include `MemberCount`).
     *
     * @param {number} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    memberByIndex: GenericStorageQuery<Rv, (arg: number) => AccountId32 | undefined, number>;

    /**
     * The set of suspended members, with their old membership record.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletSocietyMemberRecord | undefined> =} callback
     **/
    suspendedMembers: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletSocietyMemberRecord | undefined,
      AccountId32
    >;

    /**
     * The number of rounds which have passed.
     *
     * @param {Callback<number> =} callback
     **/
    roundCount: GenericStorageQuery<Rv, () => number>;

    /**
     * The current bids, stored ordered by the value of the bid.
     *
     * @param {Callback<Array<PalletSocietyBid>> =} callback
     **/
    bids: GenericStorageQuery<Rv, () => Array<PalletSocietyBid>>;

    /**
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletSocietyCandidacy | undefined> =} callback
     **/
    candidates: GenericStorageQuery<Rv, (arg: AccountId32Like) => PalletSocietyCandidacy | undefined, AccountId32>;

    /**
     * The current skeptic.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    skeptic: GenericStorageQuery<Rv, () => AccountId32 | undefined>;

    /**
     * Double map from Candidate -> Voter -> (Maybe) Vote.
     *
     * @param {[AccountId32Like, AccountId32Like]} arg
     * @param {Callback<PalletSocietyVote | undefined> =} callback
     **/
    votes: GenericStorageQuery<
      Rv,
      (arg: [AccountId32Like, AccountId32Like]) => PalletSocietyVote | undefined,
      [AccountId32, AccountId32]
    >;

    /**
     * Clear-cursor for Vote, map from Candidate -> (Maybe) Cursor.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    voteClearCursor: GenericStorageQuery<Rv, (arg: AccountId32Like) => Bytes | undefined, AccountId32>;

    /**
     * At the end of the claim period, this contains the most recently approved members (along with
     * their bid and round ID) who is from the most recent round with the lowest bid. They will
     * become the new `Head`.
     *
     * @param {Callback<PalletSocietyIntakeRecord | undefined> =} callback
     **/
    nextHead: GenericStorageQuery<Rv, () => PalletSocietyIntakeRecord | undefined>;

    /**
     * The number of challenge rounds there have been. Used to identify stale DefenderVotes.
     *
     * @param {Callback<number> =} callback
     **/
    challengeRoundCount: GenericStorageQuery<Rv, () => number>;

    /**
     * The defending member currently being challenged, along with a running tally of votes.
     *
     * @param {Callback<[AccountId32, AccountId32, PalletSocietyTally] | undefined> =} callback
     **/
    defending: GenericStorageQuery<Rv, () => [AccountId32, AccountId32, PalletSocietyTally] | undefined>;

    /**
     * Votes for the defender, keyed by challenge round.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<PalletSocietyVote | undefined> =} callback
     **/
    defenderVotes: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => PalletSocietyVote | undefined,
      [number, AccountId32]
    >;

    /**
     * Next intake rotation scheduled with [Config::BlockNumberProvider].
     *
     * @param {Callback<number | undefined> =} callback
     **/
    nextIntakeAt: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Next challenge rotation scheduled with [Config::BlockNumberProvider].
     *
     * @param {Callback<number | undefined> =} callback
     **/
    nextChallengeAt: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Revive`'s storage queries
   **/
  revive: {
    /**
     * A mapping from a contract's code hash to its code.
     *
     * @param {H256} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    pristineCode: GenericStorageQuery<Rv, (arg: H256) => Bytes | undefined, H256>;

    /**
     * A mapping from a contract's code hash to its code info.
     *
     * @param {H256} arg
     * @param {Callback<PalletReviveVmCodeInfo | undefined> =} callback
     **/
    codeInfoOf: GenericStorageQuery<Rv, (arg: H256) => PalletReviveVmCodeInfo | undefined, H256>;

    /**
     * The data associated to a contract or externally owned account.
     *
     * @param {H160} arg
     * @param {Callback<PalletReviveStorageAccountInfo | undefined> =} callback
     **/
    accountInfoOf: GenericStorageQuery<Rv, (arg: H160) => PalletReviveStorageAccountInfo | undefined, H160>;

    /**
     * The immutable data associated with a given account.
     *
     * @param {H160} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    immutableDataOf: GenericStorageQuery<Rv, (arg: H160) => Bytes | undefined, H160>;

    /**
     * Evicted contracts that await child trie deletion.
     *
     * Child trie deletion is a heavy operation depending on the amount of storage items
     * stored in said trie. Therefore this operation is performed lazily in `on_idle`.
     *
     * @param {number} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    deletionQueue: GenericStorageQuery<Rv, (arg: number) => Bytes | undefined, number>;

    /**
     * A pair of monotonic counters used to track the latest contract marked for deletion
     * and the latest deleted contract in queue.
     *
     * @param {Callback<PalletReviveStorageDeletionQueueManager> =} callback
     **/
    deletionQueueCounter: GenericStorageQuery<Rv, () => PalletReviveStorageDeletionQueueManager>;

    /**
     * Map a Ethereum address to its original `AccountId32`.
     *
     * When deriving a `H160` from an `AccountId32` we use a hash function. In order to
     * reconstruct the original account we need to store the reverse mapping here.
     * Register your `AccountId32` using [`Pallet::map_account`] in order to
     * use it with this pallet.
     *
     * @param {H160} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    originalAccount: GenericStorageQuery<Rv, (arg: H160) => AccountId32 | undefined, H160>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `StateTrieMigration`'s storage queries
   **/
  stateTrieMigration: {
    /**
     * Migration progress.
     *
     * This stores the snapshot of the last migrated keys. It can be set into motion and move
     * forward by any of the means provided by this pallet.
     *
     * @param {Callback<PalletStateTrieMigrationMigrationTask> =} callback
     **/
    migrationProcess: GenericStorageQuery<Rv, () => PalletStateTrieMigrationMigrationTask>;

    /**
     * The limits that are imposed on automatic migrations.
     *
     * If set to None, then no automatic migration happens.
     *
     * @param {Callback<PalletStateTrieMigrationMigrationLimits | undefined> =} callback
     **/
    autoLimits: GenericStorageQuery<Rv, () => PalletStateTrieMigrationMigrationLimits | undefined>;

    /**
     * The maximum limits that the signed migration could use.
     *
     * If not set, no signed submission is allowed.
     *
     * @param {Callback<PalletStateTrieMigrationMigrationLimits | undefined> =} callback
     **/
    signedMigrationMaxLimits: GenericStorageQuery<Rv, () => PalletStateTrieMigrationMigrationLimits | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `NominationPools`'s storage queries
   **/
  nominationPools: {
    /**
     * The sum of funds across all pools.
     *
     * This might be lower but never higher than the sum of `total_balance` of all [`PoolMembers`]
     * because calling `pool_withdraw_unbonded` might decrease the total stake of the pool's
     * `bonded_account` without adjusting the pallet-internal `UnbondingPool`'s.
     *
     * @param {Callback<bigint> =} callback
     **/
    totalValueLocked: GenericStorageQuery<Rv, () => bigint>;

    /**
     * Minimum amount to bond to join a pool.
     *
     * @param {Callback<bigint> =} callback
     **/
    minJoinBond: GenericStorageQuery<Rv, () => bigint>;

    /**
     * Minimum bond required to create a pool.
     *
     * This is the amount that the depositor must put as their initial stake in the pool, as an
     * indication of "skin in the game".
     *
     * This is the value that will always exist in the staking ledger of the pool bonded account
     * while all other accounts leave.
     *
     * @param {Callback<bigint> =} callback
     **/
    minCreateBond: GenericStorageQuery<Rv, () => bigint>;

    /**
     * Maximum number of nomination pools that can exist. If `None`, then an unbounded number of
     * pools can exist.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    maxPools: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Maximum number of members that can exist in the system. If `None`, then the count
     * members are not bound on a system wide basis.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    maxPoolMembers: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Maximum number of members that may belong to pool. If `None`, then the count of
     * members is not bound on a per pool basis.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    maxPoolMembersPerPool: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * The maximum commission that can be charged by a pool. Used on commission payouts to bound
     * pool commissions that are > `GlobalMaxCommission`, necessary if a future
     * `GlobalMaxCommission` is lower than some current pool commissions.
     *
     * @param {Callback<Perbill | undefined> =} callback
     **/
    globalMaxCommission: GenericStorageQuery<Rv, () => Perbill | undefined>;

    /**
     * Active members.
     *
     * TWOX-NOTE: SAFE since `AccountId` is a secure hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletNominationPoolsPoolMember | undefined> =} callback
     **/
    poolMembers: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletNominationPoolsPoolMember | undefined,
      AccountId32
    >;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForPoolMembers: GenericStorageQuery<Rv, () => number>;

    /**
     * Storage for bonded pools.
     *
     * @param {number} arg
     * @param {Callback<PalletNominationPoolsBondedPoolInner | undefined> =} callback
     **/
    bondedPools: GenericStorageQuery<Rv, (arg: number) => PalletNominationPoolsBondedPoolInner | undefined, number>;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForBondedPools: GenericStorageQuery<Rv, () => number>;

    /**
     * Reward pools. This is where there rewards for each pool accumulate. When a members payout is
     * claimed, the balance comes out of the reward pool. Keyed by the bonded pools account.
     *
     * @param {number} arg
     * @param {Callback<PalletNominationPoolsRewardPool | undefined> =} callback
     **/
    rewardPools: GenericStorageQuery<Rv, (arg: number) => PalletNominationPoolsRewardPool | undefined, number>;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForRewardPools: GenericStorageQuery<Rv, () => number>;

    /**
     * Groups of unbonding pools. Each group of unbonding pools belongs to a
     * bonded pool, hence the name sub-pools. Keyed by the bonded pools account.
     *
     * @param {number} arg
     * @param {Callback<PalletNominationPoolsSubPools | undefined> =} callback
     **/
    subPoolsStorage: GenericStorageQuery<Rv, (arg: number) => PalletNominationPoolsSubPools | undefined, number>;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForSubPoolsStorage: GenericStorageQuery<Rv, () => number>;

    /**
     * Metadata for the pool.
     *
     * @param {number} arg
     * @param {Callback<Bytes> =} callback
     **/
    metadata: GenericStorageQuery<Rv, (arg: number) => Bytes, number>;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForMetadata: GenericStorageQuery<Rv, () => number>;

    /**
     * Ever increasing number of all pools created so far.
     *
     * @param {Callback<number> =} callback
     **/
    lastPoolId: GenericStorageQuery<Rv, () => number>;

    /**
     * A reverse lookup from the pool's account id to its id.
     *
     * This is only used for slashing and on automatic withdraw update. In all other instances, the
     * pool id is used, and the accounts are deterministically derived from it.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<number | undefined> =} callback
     **/
    reversePoolIdLookup: GenericStorageQuery<Rv, (arg: AccountId32Like) => number | undefined, AccountId32>;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForReversePoolIdLookup: GenericStorageQuery<Rv, () => number>;

    /**
     * Map from a pool member account to their opted claim permission.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletNominationPoolsClaimPermission> =} callback
     **/
    claimPermissions: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletNominationPoolsClaimPermission,
      AccountId32
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `VoterList`'s storage queries
   **/
  voterList: {
    /**
     * A single node, within some bag.
     *
     * Nodes store links forward and back within their respective bags.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletBagsListListNode | undefined> =} callback
     **/
    listNodes: GenericStorageQuery<Rv, (arg: AccountId32Like) => PalletBagsListListNode | undefined, AccountId32>;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForListNodes: GenericStorageQuery<Rv, () => number>;

    /**
     * A bag stored in storage.
     *
     * Stores a `Bag` struct, which stores head and tail pointers to itself.
     *
     * @param {bigint} arg
     * @param {Callback<PalletBagsListListBag | undefined> =} callback
     **/
    listBags: GenericStorageQuery<Rv, (arg: bigint) => PalletBagsListListBag | undefined, bigint>;

    /**
     * Pointer that remembers the next node that will be auto-rebagged.
     * When `None`, the next scan will start from the list head again.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    nextNodeAutoRebagged: GenericStorageQuery<Rv, () => AccountId32 | undefined>;

    /**
     * Lock all updates to this pallet.
     *
     * If any nodes needs updating, removal or addition due to a temporary lock, the
     * [`Call::rebag`] can be used.
     *
     * @param {Callback<[] | undefined> =} callback
     **/
    lock: GenericStorageQuery<Rv, () => [] | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `DelegatedStaking`'s storage queries
   **/
  delegatedStaking: {
    /**
     * Map of Delegators to their `Delegation`.
     *
     * Implementation note: We are not using a double map with `delegator` and `agent` account
     * as keys since we want to restrict delegators to delegate only to one account at a time.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletDelegatedStakingDelegation | undefined> =} callback
     **/
    delegators: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletDelegatedStakingDelegation | undefined,
      AccountId32
    >;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForDelegators: GenericStorageQuery<Rv, () => number>;

    /**
     * Map of `Agent` to their `Ledger`.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletDelegatedStakingAgentLedger | undefined> =} callback
     **/
    agents: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletDelegatedStakingAgentLedger | undefined,
      AccountId32
    >;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForAgents: GenericStorageQuery<Rv, () => number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `StakingRcClient`'s storage queries
   **/
  stakingRcClient: {
    /**
     * An incomplete incoming session report that we have not acted upon yet.
     *
     * @param {Callback<PalletStakingAsyncRcClientSessionReport | undefined> =} callback
     **/
    incompleteSessionReport: GenericStorageQuery<Rv, () => PalletStakingAsyncRcClientSessionReport | undefined>;

    /**
     * The last session report's `end_index` that we have acted upon.
     *
     * This allows this pallet to ensure a sequentially increasing sequence of session reports
     * passed to staking.
     *
     * Note that with the XCM being the backbone of communication, we have a guarantee on the
     * ordering of messages. As long as the RC sends session reports in order, we _eventually_
     * receive them in the same correct order as well.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    lastSessionReportEndingIndex: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `MultiBlockElection`'s storage queries
   **/
  multiBlockElection: {
    /**
     * Internal counter for the number of rounds.
     *
     * This is useful for de-duplication of transactions submitted to the pool, and general
     * diagnostics of the pallet.
     *
     * This is merely incremented once per every time that an upstream `elect` is called.
     *
     * @param {Callback<number> =} callback
     **/
    round: GenericStorageQuery<Rv, () => number>;

    /**
     * Current phase.
     *
     * @param {Callback<PalletElectionProviderMultiBlockPhase> =} callback
     **/
    currentPhase: GenericStorageQuery<Rv, () => PalletElectionProviderMultiBlockPhase>;

    /**
     * Desired number of targets to elect for this round.
     *
     * @param {number} arg
     * @param {Callback<number | undefined> =} callback
     **/
    desiredTargets: GenericStorageQuery<Rv, (arg: number) => number | undefined, number>;

    /**
     * Paginated voter snapshot. At most [`T::Pages`] keys will exist.
     *
     * @param {[number, number]} arg
     * @param {Callback<Array<[AccountId32, bigint, Array<AccountId32>]> | undefined> =} callback
     **/
    pagedVoterSnapshot: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => Array<[AccountId32, bigint, Array<AccountId32>]> | undefined,
      [number, number]
    >;

    /**
     * Same as [`PagedVoterSnapshot`], but it will store the hash of the snapshot.
     *
     * The hash is generated using [`frame_system::Config::Hashing`].
     *
     * @param {[number, number]} arg
     * @param {Callback<H256 | undefined> =} callback
     **/
    pagedVoterSnapshotHash: GenericStorageQuery<Rv, (arg: [number, number]) => H256 | undefined, [number, number]>;

    /**
     * Paginated target snapshot.
     *
     * For the time being, since we assume one pages of targets, at most ONE key will exist.
     *
     * @param {[number, number]} arg
     * @param {Callback<Array<AccountId32> | undefined> =} callback
     **/
    pagedTargetSnapshot: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => Array<AccountId32> | undefined,
      [number, number]
    >;

    /**
     * Same as [`PagedTargetSnapshot`], but it will store the hash of the snapshot.
     *
     * The hash is generated using [`frame_system::Config::Hashing`].
     *
     * @param {[number, number]} arg
     * @param {Callback<H256 | undefined> =} callback
     **/
    pagedTargetSnapshotHash: GenericStorageQuery<Rv, (arg: [number, number]) => H256 | undefined, [number, number]>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `MultiBlockElectionVerifier`'s storage queries
   **/
  multiBlockElectionVerifier: {
    /**
     * The `X` variant of the current queued solution. Might be the valid one or not.
     *
     * The two variants of this storage item is to avoid the need of copying. Recall that once a
     * `VerifyingSolution` is being processed, it needs to write its partial supports *somewhere*.
     * Writing theses supports on top of a *good* queued supports is wrong, since we might bail.
     * Writing them to a bugger and copying at the ned is slightly better, but expensive. This flag
     * system is best of both worlds.
     *
     * @param {[number, number]} arg
     * @param {Callback<FrameElectionProviderSupportBoundedSupports | undefined> =} callback
     **/
    queuedSolutionX: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => FrameElectionProviderSupportBoundedSupports | undefined,
      [number, number]
    >;

    /**
     * The `Y` variant of the current queued solution. Might be the valid one or not.
     *
     * @param {[number, number]} arg
     * @param {Callback<FrameElectionProviderSupportBoundedSupports | undefined> =} callback
     **/
    queuedSolutionY: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => FrameElectionProviderSupportBoundedSupports | undefined,
      [number, number]
    >;

    /**
     * Pointer to the variant of [`QueuedSolutionX`] or [`QueuedSolutionY`] that is currently
     * valid.
     *
     * @param {number} arg
     * @param {Callback<PalletElectionProviderMultiBlockVerifierImplsValidSolution> =} callback
     **/
    queuedValidVariant: GenericStorageQuery<
      Rv,
      (arg: number) => PalletElectionProviderMultiBlockVerifierImplsValidSolution,
      number
    >;

    /**
     * The `(amount, count)` of backings, divided per page.
     *
     * This is stored because in the last block of verification we need them to compute the score,
     * and check `MaxBackersPerWinnerFinal`.
     *
     * This can only ever live for the invalid variant of the solution. Once it is valid, we don't
     * need this information anymore; the score is already computed once in
     * [`QueuedSolutionScore`], and the backing counts are checked.
     *
     * @param {[number, number]} arg
     * @param {Callback<Array<[AccountId32, PalletElectionProviderMultiBlockVerifierImplsPartialBackings]> | undefined> =} callback
     **/
    queuedSolutionBackings: GenericStorageQuery<
      Rv,
      (
        arg: [number, number],
      ) => Array<[AccountId32, PalletElectionProviderMultiBlockVerifierImplsPartialBackings]> | undefined,
      [number, number]
    >;

    /**
     * The score of the valid variant of [`QueuedSolution`].
     *
     * This only ever lives for the `valid` variant.
     *
     * @param {number} arg
     * @param {Callback<SpNposElectionsElectionScore | undefined> =} callback
     **/
    queuedSolutionScore: GenericStorageQuery<Rv, (arg: number) => SpNposElectionsElectionScore | undefined, number>;

    /**
     * The minimum score that each solution must attain in order to be considered feasible.
     *
     * @param {Callback<SpNposElectionsElectionScore | undefined> =} callback
     **/
    minimumScore: GenericStorageQuery<Rv, () => SpNposElectionsElectionScore | undefined>;

    /**
     * Storage item for [`Status`].
     *
     * @param {Callback<PalletElectionProviderMultiBlockVerifierImplsStatus> =} callback
     **/
    statusStorage: GenericStorageQuery<Rv, () => PalletElectionProviderMultiBlockVerifierImplsStatus>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `MultiBlockElectionSigned`'s storage queries
   **/
  multiBlockElectionSigned: {
    /**
     * Accounts whitelisted by governance to always submit their solutions.
     *
     * They are different in that:
     *
     * * They always pay a fixed deposit for submission, specified by
     * [`Config::InvulnerableDeposit`]. They pay no page deposit.
     * * If _ejected_ by better solution from [`SortedScores`], they will get their full deposit
     * back.
     * * They always get their tx-fee back even if they are _discarded_.
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    invulnerables: GenericStorageQuery<Rv, () => Array<AccountId32>>;

    /**
     *
     * @param {number} arg
     * @param {Callback<Array<[AccountId32, SpNposElectionsElectionScore]>> =} callback
     **/
    sortedScores: GenericStorageQuery<Rv, (arg: number) => Array<[AccountId32, SpNposElectionsElectionScore]>, number>;

    /**
     * Triple map from (round, account, page) to a solution page.
     *
     * @param {[number, AccountId32Like, number]} arg
     * @param {Callback<AssetHubKusamaRuntimeStakingNposCompactSolution24 | undefined> =} callback
     **/
    submissionStorage: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like, number]) => AssetHubKusamaRuntimeStakingNposCompactSolution24 | undefined,
      [number, AccountId32, number]
    >;

    /**
     * Map from account to the metadata of their submission.
     *
     * invariant: for any Key1 of type `AccountId` in [`Submissions`], this storage map also has a
     * value.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<PalletElectionProviderMultiBlockSignedSubmissionMetadata | undefined> =} callback
     **/
    submissionMetadataStorage: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => PalletElectionProviderMultiBlockSignedSubmissionMetadata | undefined,
      [number, AccountId32]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Staking`'s storage queries
   **/
  staking: {
    /**
     * The ideal number of active validators.
     *
     * @param {Callback<number> =} callback
     **/
    validatorCount: GenericStorageQuery<Rv, () => number>;

    /**
     * Any validators that may never be slashed or forcibly kicked. It's a Vec since they're
     * easy to initialize and the performance hit is minimal (we expect no more than four
     * invulnerables) and restricted to testnets.
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    invulnerables: GenericStorageQuery<Rv, () => Array<AccountId32>>;

    /**
     * Map from all locked "stash" accounts to the controller account.
     *
     * TWOX-NOTE: SAFE since `AccountId` is a secure hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    bonded: GenericStorageQuery<Rv, (arg: AccountId32Like) => AccountId32 | undefined, AccountId32>;

    /**
     * The minimum active bond to become and maintain the role of a nominator.
     *
     * @param {Callback<bigint> =} callback
     **/
    minNominatorBond: GenericStorageQuery<Rv, () => bigint>;

    /**
     * The minimum active bond to become and maintain the role of a validator.
     *
     * @param {Callback<bigint> =} callback
     **/
    minValidatorBond: GenericStorageQuery<Rv, () => bigint>;

    /**
     * The minimum active nominator stake of the last successful election.
     *
     * @param {Callback<bigint> =} callback
     **/
    minimumActiveStake: GenericStorageQuery<Rv, () => bigint>;

    /**
     * The minimum amount of commission that validators can set.
     *
     * If set to `0`, no limit exists.
     *
     * @param {Callback<Perbill> =} callback
     **/
    minCommission: GenericStorageQuery<Rv, () => Perbill>;

    /**
     * Map from all (unlocked) "controller" accounts to the info regarding the staking.
     *
     * Note: All the reads and mutations to this storage *MUST* be done through the methods exposed
     * by [`StakingLedger`] to ensure data and lock consistency.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletStakingAsyncLedgerStakingLedger | undefined> =} callback
     **/
    ledger: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletStakingAsyncLedgerStakingLedger | undefined,
      AccountId32
    >;

    /**
     * Where the reward payment should be made. Keyed by stash.
     *
     * TWOX-NOTE: SAFE since `AccountId` is a secure hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletStakingAsyncRewardDestination | undefined> =} callback
     **/
    payee: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletStakingAsyncRewardDestination | undefined,
      AccountId32
    >;

    /**
     * The map from (wannabe) validator stash key to the preferences of that validator.
     *
     * TWOX-NOTE: SAFE since `AccountId` is a secure hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletStakingAsyncValidatorPrefs> =} callback
     **/
    validators: GenericStorageQuery<Rv, (arg: AccountId32Like) => PalletStakingAsyncValidatorPrefs, AccountId32>;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForValidators: GenericStorageQuery<Rv, () => number>;

    /**
     * The maximum validator count before we stop allowing new validators to join.
     *
     * When this value is not set, no limits are enforced.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    maxValidatorsCount: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * The map from nominator stash key to their nomination preferences, namely the validators that
     * they wish to support.
     *
     * Note that the keys of this storage map might become non-decodable in case the
     * account's [`NominationsQuota::MaxNominations`] configuration is decreased.
     * In this rare case, these nominators
     * are still existent in storage, their key is correct and retrievable (i.e. `contains_key`
     * indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable
     * nominators will effectively not-exist, until they re-submit their preferences such that it
     * is within the bounds of the newly set `Config::MaxNominations`.
     *
     * This implies that `::iter_keys().count()` and `::iter().count()` might return different
     * values for this map. Moreover, the main `::count()` is aligned with the former, namely the
     * number of keys that exist.
     *
     * Lastly, if any of the nominators become non-decodable, they can be chilled immediately via
     * [`Call::chill_other`] dispatchable by anyone.
     *
     * TWOX-NOTE: SAFE since `AccountId` is a secure hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletStakingAsyncNominations | undefined> =} callback
     **/
    nominators: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletStakingAsyncNominations | undefined,
      AccountId32
    >;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForNominators: GenericStorageQuery<Rv, () => number>;

    /**
     * Stakers whose funds are managed by other pallets.
     *
     * This pallet does not apply any locks on them, therefore they are only virtually bonded. They
     * are expected to be keyless accounts and hence should not be allowed to mutate their ledger
     * directly via this pallet. Instead, these accounts are managed by other pallets and accessed
     * via low level apis. We keep track of them to do minimal integrity checks.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    virtualStakers: GenericStorageQuery<Rv, (arg: AccountId32Like) => [] | undefined, AccountId32>;

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForVirtualStakers: GenericStorageQuery<Rv, () => number>;

    /**
     * The maximum nominator count before we stop allowing new validators to join.
     *
     * When this value is not set, no limits are enforced.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    maxNominatorsCount: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * The current planned era index.
     *
     * This is the latest planned era, depending on how the Session pallet queues the validator
     * set, it might be active or not.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    currentEra: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * The active era information, it holds index and start.
     *
     * The active era is the era being currently rewarded. Validator set of this era must be
     * equal to what is RC's session pallet.
     *
     * @param {Callback<PalletStakingAsyncActiveEraInfo | undefined> =} callback
     **/
    activeEra: GenericStorageQuery<Rv, () => PalletStakingAsyncActiveEraInfo | undefined>;

    /**
     * A mapping from still-bonded eras to the first session index of that era.
     *
     * Must contains information for eras for the range:
     * `[active_era - bounding_duration; active_era]`
     *
     * @param {Callback<Array<[number, number]>> =} callback
     **/
    bondedEras: GenericStorageQuery<Rv, () => Array<[number, number]>>;

    /**
     * Summary of validator exposure at a given era.
     *
     * This contains the total stake in support of the validator and their own stake. In addition,
     * it can also be used to get the number of nominators backing this validator and the number of
     * exposure pages they are divided into. The page count is useful to determine the number of
     * pages of rewards that needs to be claimed.
     *
     * This is keyed first by the era index to allow bulk deletion and then the stash account.
     * Should only be accessed through `Eras`.
     *
     * Is it removed after [`Config::HistoryDepth`] eras.
     * If stakers hasn't been set or has been removed then empty overview is returned.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<SpStakingPagedExposureMetadata | undefined> =} callback
     **/
    erasStakersOverview: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => SpStakingPagedExposureMetadata | undefined,
      [number, AccountId32]
    >;

    /**
     * Paginated exposure of a validator at given era.
     *
     * This is keyed first by the era index to allow bulk deletion, then stash account and finally
     * the page. Should only be accessed through `Eras`.
     *
     * This is cleared after [`Config::HistoryDepth`] eras.
     *
     * @param {[number, AccountId32Like, number]} arg
     * @param {Callback<PalletStakingAsyncPalletBoundedExposurePage | undefined> =} callback
     **/
    erasStakersPaged: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like, number]) => PalletStakingAsyncPalletBoundedExposurePage | undefined,
      [number, AccountId32, number]
    >;

    /**
     * History of claimed paged rewards by era and validator.
     *
     * This is keyed by era and validator stash which maps to the set of page indexes which have
     * been claimed.
     *
     * It is removed after [`Config::HistoryDepth`] eras.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<Array<number>> =} callback
     **/
    claimedRewards: GenericStorageQuery<Rv, (arg: [number, AccountId32Like]) => Array<number>, [number, AccountId32]>;

    /**
     * Exposure of validator at era with the preferences of validators.
     *
     * This is keyed first by the era index to allow bulk deletion and then the stash account.
     *
     * Is it removed after [`Config::HistoryDepth`] eras.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<PalletStakingAsyncValidatorPrefs> =} callback
     **/
    erasValidatorPrefs: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => PalletStakingAsyncValidatorPrefs,
      [number, AccountId32]
    >;

    /**
     * The total validator era payout for the last [`Config::HistoryDepth`] eras.
     *
     * Eras that haven't finished yet or has been removed doesn't have reward.
     *
     * @param {number} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    erasValidatorReward: GenericStorageQuery<Rv, (arg: number) => bigint | undefined, number>;

    /**
     * Rewards for the last [`Config::HistoryDepth`] eras.
     * If reward hasn't been set or has been removed then 0 reward is returned.
     *
     * @param {number} arg
     * @param {Callback<PalletStakingAsyncEraRewardPoints> =} callback
     **/
    erasRewardPoints: GenericStorageQuery<Rv, (arg: number) => PalletStakingAsyncEraRewardPoints, number>;

    /**
     * The total amount staked for the last [`Config::HistoryDepth`] eras.
     * If total hasn't been set or has been removed then 0 stake is returned.
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    erasTotalStake: GenericStorageQuery<Rv, (arg: number) => bigint, number>;

    /**
     * Mode of era forcing.
     *
     * @param {Callback<PalletStakingAsyncForcing> =} callback
     **/
    forceEra: GenericStorageQuery<Rv, () => PalletStakingAsyncForcing>;

    /**
     * Maximum staked rewards, i.e. the percentage of the era inflation that
     * is used for stake rewards.
     * See [Era payout](./index.html#era-payout).
     *
     * @param {Callback<Percent | undefined> =} callback
     **/
    maxStakedRewards: GenericStorageQuery<Rv, () => Percent | undefined>;

    /**
     * The percentage of the slash that is distributed to reporters.
     *
     * The rest of the slashed value is handled by the `Slash`.
     *
     * @param {Callback<Perbill> =} callback
     **/
    slashRewardFraction: GenericStorageQuery<Rv, () => Perbill>;

    /**
     * The amount of currency given to reporters of a slash event which was
     * canceled by extraordinary circumstances (e.g. governance).
     *
     * @param {Callback<bigint> =} callback
     **/
    canceledSlashPayout: GenericStorageQuery<Rv, () => bigint>;

    /**
     * Stores reported offences in a queue until they are processed in subsequent blocks.
     *
     * Each offence is recorded under the corresponding era index and the offending validator's
     * account. If an offence spans multiple pages, only one page is processed at a time. Offences
     * are handled sequentially, with their associated slashes computed and stored in
     * `UnappliedSlashes`. These slashes are then applied in a future era as determined by
     * `SlashDeferDuration`.
     *
     * Any offences tied to an era older than `BondingDuration` are automatically dropped.
     * Processing always prioritizes the oldest era first.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<PalletStakingAsyncSlashingOffenceRecord | undefined> =} callback
     **/
    offenceQueue: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => PalletStakingAsyncSlashingOffenceRecord | undefined,
      [number, AccountId32]
    >;

    /**
     * Tracks the eras that contain offences in `OffenceQueue`, sorted from **earliest to latest**.
     *
     * - This ensures efficient retrieval of the oldest offence without iterating through
     * `OffenceQueue`.
     * - When a new offence is added to `OffenceQueue`, its era is **inserted in sorted order**
     * if not already present.
     * - When all offences for an era are processed, it is **removed** from this list.
     * - The maximum length of this vector is bounded by `BondingDuration`.
     *
     * This eliminates the need for expensive iteration and sorting when fetching the next offence
     * to process.
     *
     * @param {Callback<Array<number> | undefined> =} callback
     **/
    offenceQueueEras: GenericStorageQuery<Rv, () => Array<number> | undefined>;

    /**
     * Tracks the currently processed offence record from the `OffenceQueue`.
     *
     * - When processing offences, an offence record is **popped** from the oldest era in
     * `OffenceQueue` and stored here.
     * - The function `process_offence` reads from this storage, processing one page of exposure at
     * a time.
     * - After processing a page, the `exposure_page` count is **decremented** until it reaches
     * zero.
     * - Once fully processed, the offence record is removed from this storage.
     *
     * This ensures that offences are processed incrementally, preventing excessive computation
     * in a single block while maintaining correct slashing behavior.
     *
     * @param {Callback<[number, AccountId32, PalletStakingAsyncSlashingOffenceRecord] | undefined> =} callback
     **/
    processingOffence: GenericStorageQuery<
      Rv,
      () => [number, AccountId32, PalletStakingAsyncSlashingOffenceRecord] | undefined
    >;

    /**
     * All unapplied slashes that are queued for later.
     *
     * @param {[number, [AccountId32Like, Perbill, number]]} arg
     * @param {Callback<PalletStakingAsyncUnappliedSlash | undefined> =} callback
     **/
    unappliedSlashes: GenericStorageQuery<
      Rv,
      (arg: [number, [AccountId32Like, Perbill, number]]) => PalletStakingAsyncUnappliedSlash | undefined,
      [number, [AccountId32, Perbill, number]]
    >;

    /**
     * Cancelled slashes by era and validator with maximum slash fraction to be cancelled.
     *
     * When slashes are cancelled by governance, this stores the era and the validators
     * whose slashes should be cancelled, along with the maximum slash fraction that should
     * be cancelled for each validator.
     *
     * @param {number} arg
     * @param {Callback<Array<[AccountId32, Perbill]>> =} callback
     **/
    cancelledSlashes: GenericStorageQuery<Rv, (arg: number) => Array<[AccountId32, Perbill]>, number>;

    /**
     * All slashing events on validators, mapped by era to the highest slash proportion
     * and slash value of the era.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<[Perbill, bigint] | undefined> =} callback
     **/
    validatorSlashInEra: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => [Perbill, bigint] | undefined,
      [number, AccountId32]
    >;

    /**
     * The threshold for when users can start calling `chill_other` for other validators /
     * nominators. The threshold is compared to the actual number of validators / nominators
     * (`CountFor*`) in the system compared to the configured max (`Max*Count`).
     *
     * @param {Callback<Percent | undefined> =} callback
     **/
    chillThreshold: GenericStorageQuery<Rv, () => Percent | undefined>;

    /**
     * Voter snapshot progress status.
     *
     * If the status is `Ongoing`, it keeps a cursor of the last voter retrieved to proceed when
     * creating the next snapshot page.
     *
     * @param {Callback<PalletStakingAsyncSnapshotStatus> =} callback
     **/
    voterSnapshotStatus: GenericStorageQuery<Rv, () => PalletStakingAsyncSnapshotStatus>;

    /**
     * Keeps track of an ongoing multi-page election solution request.
     *
     * If `Some(_)``, it is the next page that we intend to elect. If `None`, we are not in the
     * election process.
     *
     * This is only set in multi-block elections. Should always be `None` otherwise.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    nextElectionPage: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * A bounded list of the "electable" stashes that resulted from a successful election.
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    electableStashes: GenericStorageQuery<Rv, () => Array<AccountId32>>;

    /**
     * Tracks the current step of era pruning process for each era being lazily pruned.
     *
     * @param {number} arg
     * @param {Callback<PalletStakingAsyncPalletPruningStep | undefined> =} callback
     **/
    eraPruningState: GenericStorageQuery<Rv, (arg: number) => PalletStakingAsyncPalletPruningStep | undefined, number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Treasury`'s storage queries
   **/
  treasury: {
    /**
     * DEPRECATED: associated with `spend_local` call and will be removed in May 2025.
     * Refer to <https://github.com/paritytech/polkadot-sdk/pull/5961> for migration to `spend`.
     *
     * Number of proposals that have been made.
     *
     * @param {Callback<number> =} callback
     **/
    proposalCount: GenericStorageQuery<Rv, () => number>;

    /**
     * DEPRECATED: associated with `spend_local` call and will be removed in May 2025.
     * Refer to <https://github.com/paritytech/polkadot-sdk/pull/5961> for migration to `spend`.
     *
     * Proposals that have been made.
     *
     * @param {number} arg
     * @param {Callback<PalletTreasuryProposal | undefined> =} callback
     **/
    proposals: GenericStorageQuery<Rv, (arg: number) => PalletTreasuryProposal | undefined, number>;

    /**
     * The amount which has been reported as inactive to Currency.
     *
     * @param {Callback<bigint> =} callback
     **/
    deactivated: GenericStorageQuery<Rv, () => bigint>;

    /**
     * DEPRECATED: associated with `spend_local` call and will be removed in May 2025.
     * Refer to <https://github.com/paritytech/polkadot-sdk/pull/5961> for migration to `spend`.
     *
     * Proposal indices that have been approved but not yet awarded.
     *
     * @param {Callback<Array<number>> =} callback
     **/
    approvals: GenericStorageQuery<Rv, () => Array<number>>;

    /**
     * The count of spends that have been made.
     *
     * @param {Callback<number> =} callback
     **/
    spendCount: GenericStorageQuery<Rv, () => number>;

    /**
     * Spends that have been approved and being processed.
     *
     * @param {number} arg
     * @param {Callback<PalletTreasurySpendStatus | undefined> =} callback
     **/
    spends: GenericStorageQuery<Rv, (arg: number) => PalletTreasurySpendStatus | undefined, number>;

    /**
     * The blocknumber for the last triggered spend period.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    lastSpendPeriod: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `ConvictionVoting`'s storage queries
   **/
  convictionVoting: {
    /**
     * All voting for a particular voter in a particular voting class. We store the balance for the
     * number of votes that we have recorded.
     *
     * @param {[AccountId32Like, number]} arg
     * @param {Callback<PalletConvictionVotingVoteVoting> =} callback
     **/
    votingFor: GenericStorageQuery<
      Rv,
      (arg: [AccountId32Like, number]) => PalletConvictionVotingVoteVoting,
      [AccountId32, number]
    >;

    /**
     * The voting classes which have a non-zero lock requirement and the lock amounts which they
     * require. The actual amount locked on behalf of this pallet should always be the maximum of
     * this list.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<[number, bigint]>> =} callback
     **/
    classLocksFor: GenericStorageQuery<Rv, (arg: AccountId32Like) => Array<[number, bigint]>, AccountId32>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Referenda`'s storage queries
   **/
  referenda: {
    /**
     * The next free referendum index, aka the number of referenda started so far.
     *
     * @param {Callback<number> =} callback
     **/
    referendumCount: GenericStorageQuery<Rv, () => number>;

    /**
     * Information concerning any given referendum.
     *
     * @param {number} arg
     * @param {Callback<PalletReferendaReferendumInfoOriginCaller | undefined> =} callback
     **/
    referendumInfoFor: GenericStorageQuery<
      Rv,
      (arg: number) => PalletReferendaReferendumInfoOriginCaller | undefined,
      number
    >;

    /**
     * The sorted list of referenda ready to be decided but not yet being decided, ordered by
     * conviction-weighted approvals.
     *
     * This should be empty if `DecidingCount` is less than `TrackInfo::max_deciding`.
     *
     * @param {number} arg
     * @param {Callback<Array<[number, bigint]>> =} callback
     **/
    trackQueue: GenericStorageQuery<Rv, (arg: number) => Array<[number, bigint]>, number>;

    /**
     * The number of referenda being decided currently.
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    decidingCount: GenericStorageQuery<Rv, (arg: number) => number, number>;

    /**
     * The metadata is a general information concerning the referendum.
     * The `Hash` refers to the preimage of the `Preimages` provider which can be a JSON
     * dump or IPFS hash of a JSON file.
     *
     * Consider a garbage collection for a metadata of finished referendums to `unrequest` (remove)
     * large preimages.
     *
     * @param {number} arg
     * @param {Callback<H256 | undefined> =} callback
     **/
    metadataOf: GenericStorageQuery<Rv, (arg: number) => H256 | undefined, number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Whitelist`'s storage queries
   **/
  whitelist: {
    /**
     *
     * @param {H256} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    whitelistedCall: GenericStorageQuery<Rv, (arg: H256) => [] | undefined, H256>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Bounties`'s storage queries
   **/
  bounties: {
    /**
     * Number of bounty proposals that have been made.
     *
     * @param {Callback<number> =} callback
     **/
    bountyCount: GenericStorageQuery<Rv, () => number>;

    /**
     * Bounties that have been made.
     *
     * @param {number} arg
     * @param {Callback<PalletBountiesBounty | undefined> =} callback
     **/
    bounties: GenericStorageQuery<Rv, (arg: number) => PalletBountiesBounty | undefined, number>;

    /**
     * The description of each bounty.
     *
     * @param {number} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    bountyDescriptions: GenericStorageQuery<Rv, (arg: number) => Bytes | undefined, number>;

    /**
     * Bounty indices that have been approved but not yet funded.
     *
     * @param {Callback<Array<number>> =} callback
     **/
    bountyApprovals: GenericStorageQuery<Rv, () => Array<number>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `ChildBounties`'s storage queries
   **/
  childBounties: {
    /**
     * DEPRECATED: Replaced with `ParentTotalChildBounties` storage item keeping dedicated counts
     * for each parent bounty. Number of total child bounties. Will be removed in May 2025.
     *
     * @param {Callback<number> =} callback
     **/
    childBountyCount: GenericStorageQuery<Rv, () => number>;

    /**
     * Number of active child bounties per parent bounty.
     * Map of parent bounty index to number of child bounties.
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    parentChildBounties: GenericStorageQuery<Rv, (arg: number) => number, number>;

    /**
     * Number of total child bounties per parent bounty, including completed bounties.
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    parentTotalChildBounties: GenericStorageQuery<Rv, (arg: number) => number, number>;

    /**
     * Child bounties that have been added.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletChildBountiesChildBounty | undefined> =} callback
     **/
    childBounties: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => PalletChildBountiesChildBounty | undefined,
      [number, number]
    >;

    /**
     * The description of each child-bounty. Indexed by `(parent_id, child_id)`.
     *
     * This item replaces the `ChildBountyDescriptions` storage item from the V0 storage version.
     *
     * @param {[number, number]} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    childBountyDescriptionsV1: GenericStorageQuery<Rv, (arg: [number, number]) => Bytes | undefined, [number, number]>;

    /**
     * The mapping of the child bounty ids from storage version `V0` to the new `V1` version.
     *
     * The `V0` ids based on total child bounty count [`ChildBountyCount`]`. The `V1` version ids
     * based on the child bounty count per parent bounty [`ParentTotalChildBounties`].
     * The item intended solely for client convenience and not used in the pallet's core logic.
     *
     * @param {number} arg
     * @param {Callback<[number, number] | undefined> =} callback
     **/
    v0ToV1ChildBountyIds: GenericStorageQuery<Rv, (arg: number) => [number, number] | undefined, number>;

    /**
     * The cumulative child-bounty curator fee for each parent bounty.
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    childrenCuratorFees: GenericStorageQuery<Rv, (arg: number) => bigint, number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `AssetRate`'s storage queries
   **/
  assetRate: {
    /**
     * Maps an asset to its fixed point representation in the native balance.
     *
     * E.g. `native_amount = asset_amount * ConversionRateToNative::<T>::get(asset_kind)`
     *
     * @param {PolkadotRuntimeCommonImplsVersionedLocatableAsset} arg
     * @param {Callback<FixedU128 | undefined> =} callback
     **/
    conversionRateToNative: GenericStorageQuery<
      Rv,
      (arg: PolkadotRuntimeCommonImplsVersionedLocatableAsset) => FixedU128 | undefined,
      PolkadotRuntimeCommonImplsVersionedLocatableAsset
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `AhOps`'s storage queries
   **/
  ahOps: {
    /**
     * Amount of balance that was reserved for winning a lease auction.
     *
     * `unreserve_lease_deposit` can be permissionlessly called once the block number passed to
     * unreserve the deposit. It is implicitly called by `withdraw_crowdloan_contribution`.
     *
     * The account here can either be a crowdloan account or a solo bidder. If it is a crowdloan
     * account, then the summed up contributions for it in the contributions map will equate the
     * reserved balance here.
     *
     * The keys are as follows:
     * - Block number after which the deposit can be unreserved.
     * - The para_id of the lease slot.
     * - The account that will have the balance unreserved.
     * - The balance to be unreserved.
     *
     * @param {[number, PolkadotParachainPrimitivesPrimitivesId, AccountId32Like]} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    rcLeaseReserve: GenericStorageQuery<
      Rv,
      (arg: [number, PolkadotParachainPrimitivesPrimitivesId, AccountId32Like]) => bigint | undefined,
      [number, PolkadotParachainPrimitivesPrimitivesId, AccountId32]
    >;

    /**
     * Amount of balance that a contributor made towards a crowdloan.
     *
     * `withdraw_crowdloan_contribution` can be permissionlessly called once the block number
     * passed to unlock the balance for a specific account.
     *
     * The keys are as follows:
     * - Block number after which the balance can be unlocked.
     * - The para_id of the crowdloan.
     * - The account that made the contribution.
     *
     * The value is (fund_pot, balance). The contribution pot is the second key in the
     * `RcCrowdloanContribution` storage.
     *
     * @param {[number, PolkadotParachainPrimitivesPrimitivesId, AccountId32Like]} arg
     * @param {Callback<[AccountId32, bigint] | undefined> =} callback
     **/
    rcCrowdloanContribution: GenericStorageQuery<
      Rv,
      (arg: [number, PolkadotParachainPrimitivesPrimitivesId, AccountId32Like]) => [AccountId32, bigint] | undefined,
      [number, PolkadotParachainPrimitivesPrimitivesId, AccountId32]
    >;

    /**
     * The reserve that was taken to create a crowdloan.
     *
     * This is normally 500 DOT and can be refunded as last step after all
     * `RcCrowdloanContribution`s of this loan have been withdrawn.
     *
     * Keys:
     * - Block number after which this can be unreserved
     * - The para_id of the crowdloan
     * - The account that will have the balance unreserved
     *
     * @param {[number, PolkadotParachainPrimitivesPrimitivesId, AccountId32Like]} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    rcCrowdloanReserve: GenericStorageQuery<
      Rv,
      (arg: [number, PolkadotParachainPrimitivesPrimitivesId, AccountId32Like]) => bigint | undefined,
      [number, PolkadotParachainPrimitivesPrimitivesId, AccountId32]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `AhMigrator`'s storage queries
   **/
  ahMigrator: {
    /**
     * RC accounts that failed to migrate when were received on the Asset Hub.
     *
     * This is unlikely to happen, since we dry run the migration, but we keep it for completeness.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletRcMigratorAccountsAccount | undefined> =} callback
     **/
    rcAccounts: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletRcMigratorAccountsAccount | undefined,
      AccountId32
    >;

    /**
     * The Asset Hub migration state.
     *
     * @param {Callback<PalletAhMigratorMigrationStage> =} callback
     **/
    ahMigrationStage: GenericStorageQuery<Rv, () => PalletAhMigratorMigrationStage>;

    /**
     * Helper storage item to store the total balance / total issuance of native token at the start
     * of the migration. Since teleports are disabled during migration, the total issuance will not
     * change for other reason than the migration itself.
     *
     * @param {Callback<PalletAhMigratorBalancesBefore> =} callback
     **/
    ahBalancesBefore: GenericStorageQuery<Rv, () => PalletAhMigratorBalancesBefore>;

    /**
     * The priority of the DMP queue during migration.
     *
     * Controls how the DMP (Downward Message Passing) queue is processed relative to other queues
     * during the migration process. This helps ensure timely processing of migration messages.
     * The default priority pattern is defined in the pallet configuration, but can be overridden
     * by a storage value of this type.
     *
     * @param {Callback<PalletRcMigratorQueuePriority> =} callback
     **/
    dmpQueuePriorityConfig: GenericStorageQuery<Rv, () => PalletRcMigratorQueuePriority>;

    /**
     * An optional account id of a manager.
     *
     * This account id has similar privileges to [`Config::AdminOrigin`] except that it
     * can not set the manager account id via `set_manager` call.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    manager: GenericStorageQuery<Rv, () => AccountId32 | undefined>;

    /**
     * The block number at which the migration began and the pallet's extrinsics were locked.
     *
     * This value is set when entering the `WaitingForAh` stage, i.e., when
     * `RcMigrationStage::is_ongoing()` becomes `true`.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    migrationStartBlock: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Block number when migration finished and extrinsics were unlocked.
     *
     * This is set when entering the `MigrationDone` stage hence when
     * `RcMigrationStage::is_finished()` becomes `true`.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    migrationEndBlock: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
}
