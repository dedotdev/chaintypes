// Generated by dedot cli

import type { GenericChainErrors, GenericPalletError } from 'dedot/types';

export interface ChainErrors extends GenericChainErrors {
  /**
   * Pallet `System`'s errors
   **/
  system: {
    /**
     * The name of specification does not match between the current runtime
     * and the new runtime.
     **/
    InvalidSpecName: GenericPalletError;

    /**
     * The specification version is not allowed to decrease between the current runtime
     * and the new runtime.
     **/
    SpecVersionNeedsToIncrease: GenericPalletError;

    /**
     * Failed to extract the runtime version from the new runtime.
     *
     * Either calling `Core_version` or decoding `RuntimeVersion` failed.
     **/
    FailedToExtractRuntimeVersion: GenericPalletError;

    /**
     * Suicide called when the account has non-default composite data.
     **/
    NonDefaultComposite: GenericPalletError;

    /**
     * There is a non-zero reference count preventing the account from being purged.
     **/
    NonZeroRefCount: GenericPalletError;

    /**
     * The origin filter prevent the call to be dispatched.
     **/
    CallFiltered: GenericPalletError;

    /**
     * A multi-block migration is ongoing and prevents the current code from being replaced.
     **/
    MultiBlockMigrationsOngoing: GenericPalletError;

    /**
     * No upgrade authorized.
     **/
    NothingAuthorized: GenericPalletError;

    /**
     * The submitted code is not authorized.
     **/
    Unauthorized: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Babe`'s errors
   **/
  babe: {
    /**
     * An equivocation proof provided as part of an equivocation report is invalid.
     **/
    InvalidEquivocationProof: GenericPalletError;

    /**
     * A key ownership proof provided as part of an equivocation report is invalid.
     **/
    InvalidKeyOwnershipProof: GenericPalletError;

    /**
     * A given equivocation report is valid but already previously reported.
     **/
    DuplicateOffenceReport: GenericPalletError;

    /**
     * Submitted configuration is invalid.
     **/
    InvalidConfiguration: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Indices`'s errors
   **/
  indices: {
    /**
     * The index was not already assigned.
     **/
    NotAssigned: GenericPalletError;

    /**
     * The index is assigned to another account.
     **/
    NotOwner: GenericPalletError;

    /**
     * The index was not available.
     **/
    InUse: GenericPalletError;

    /**
     * The source and destination accounts are identical.
     **/
    NotTransfer: GenericPalletError;

    /**
     * The index is permanent and may not be freed/changed.
     **/
    Permanent: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Balances`'s errors
   **/
  balances: {
    /**
     * Vesting balance too high to send value.
     **/
    VestingBalance: GenericPalletError;

    /**
     * Account liquidity restrictions prevent withdrawal.
     **/
    LiquidityRestrictions: GenericPalletError;

    /**
     * Balance too low to send value.
     **/
    InsufficientBalance: GenericPalletError;

    /**
     * Value too low to create account due to existential deposit.
     **/
    ExistentialDeposit: GenericPalletError;

    /**
     * Transfer/payment would kill account.
     **/
    Expendability: GenericPalletError;

    /**
     * A vesting schedule already exists for this account.
     **/
    ExistingVestingSchedule: GenericPalletError;

    /**
     * Beneficiary account must pre-exist.
     **/
    DeadAccount: GenericPalletError;

    /**
     * Number of named reserves exceed `MaxReserves`.
     **/
    TooManyReserves: GenericPalletError;

    /**
     * Number of holds exceed `VariantCountOf<T::RuntimeHoldReason>`.
     **/
    TooManyHolds: GenericPalletError;

    /**
     * Number of freezes exceed `MaxFreezes`.
     **/
    TooManyFreezes: GenericPalletError;

    /**
     * The issuance cannot be modified since it is already deactivated.
     **/
    IssuanceDeactivated: GenericPalletError;

    /**
     * The delta cannot be zero.
     **/
    DeltaZero: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Staking`'s errors
   **/
  staking: {
    /**
     * Not a controller account.
     **/
    NotController: GenericPalletError;

    /**
     * Not a stash account.
     **/
    NotStash: GenericPalletError;

    /**
     * Stash is already bonded.
     **/
    AlreadyBonded: GenericPalletError;

    /**
     * Controller is already paired.
     **/
    AlreadyPaired: GenericPalletError;

    /**
     * Targets cannot be empty.
     **/
    EmptyTargets: GenericPalletError;

    /**
     * Duplicate index.
     **/
    DuplicateIndex: GenericPalletError;

    /**
     * Slash record index out of bounds.
     **/
    InvalidSlashIndex: GenericPalletError;

    /**
     * Cannot have a validator or nominator role, with value less than the minimum defined by
     * governance (see `MinValidatorBond` and `MinNominatorBond`). If unbonding is the
     * intention, `chill` first to remove one's role as validator/nominator.
     **/
    InsufficientBond: GenericPalletError;

    /**
     * Can not schedule more unlock chunks.
     **/
    NoMoreChunks: GenericPalletError;

    /**
     * Can not rebond without unlocking chunks.
     **/
    NoUnlockChunk: GenericPalletError;

    /**
     * Attempting to target a stash that still has funds.
     **/
    FundedTarget: GenericPalletError;

    /**
     * Invalid era to reward.
     **/
    InvalidEraToReward: GenericPalletError;

    /**
     * Invalid number of nominations.
     **/
    InvalidNumberOfNominations: GenericPalletError;

    /**
     * Items are not sorted and unique.
     **/
    NotSortedAndUnique: GenericPalletError;

    /**
     * Rewards for this era have already been claimed for this validator.
     **/
    AlreadyClaimed: GenericPalletError;

    /**
     * No nominators exist on this page.
     **/
    InvalidPage: GenericPalletError;

    /**
     * Incorrect previous history depth input provided.
     **/
    IncorrectHistoryDepth: GenericPalletError;

    /**
     * Incorrect number of slashing spans provided.
     **/
    IncorrectSlashingSpans: GenericPalletError;

    /**
     * Internal state has become somehow corrupted and the operation cannot continue.
     **/
    BadState: GenericPalletError;

    /**
     * Too many nomination targets supplied.
     **/
    TooManyTargets: GenericPalletError;

    /**
     * A nomination target was supplied that was blocked or otherwise not a validator.
     **/
    BadTarget: GenericPalletError;

    /**
     * The user has enough bond and thus cannot be chilled forcefully by an external person.
     **/
    CannotChillOther: GenericPalletError;

    /**
     * There are too many nominators in the system. Governance needs to adjust the staking
     * settings to keep things safe for the runtime.
     **/
    TooManyNominators: GenericPalletError;

    /**
     * There are too many validator candidates in the system. Governance needs to adjust the
     * staking settings to keep things safe for the runtime.
     **/
    TooManyValidators: GenericPalletError;

    /**
     * Commission is too low. Must be at least `MinCommission`.
     **/
    CommissionTooLow: GenericPalletError;

    /**
     * Some bound is not met.
     **/
    BoundNotMet: GenericPalletError;

    /**
     * Used when attempting to use deprecated controller account logic.
     **/
    ControllerDeprecated: GenericPalletError;

    /**
     * Cannot reset a ledger.
     **/
    CannotRestoreLedger: GenericPalletError;

    /**
     * Provided reward destination is not allowed.
     **/
    RewardDestinationRestricted: GenericPalletError;

    /**
     * Not enough funds available to withdraw.
     **/
    NotEnoughFunds: GenericPalletError;

    /**
     * Operation not allowed for virtual stakers.
     **/
    VirtualStakerNotAllowed: GenericPalletError;

    /**
     * Stash could not be reaped as other pallet might depend on it.
     **/
    CannotReapStash: GenericPalletError;

    /**
     * The stake of this account is already migrated to `Fungible` holds.
     **/
    AlreadyMigrated: GenericPalletError;

    /**
     * Account is restricted from participation in staking. This may happen if the account is
     * staking in another way already, such as via pool.
     **/
    Restricted: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Session`'s errors
   **/
  session: {
    /**
     * Invalid ownership proof.
     **/
    InvalidProof: GenericPalletError;

    /**
     * No associated validator ID for account.
     **/
    NoAssociatedValidatorId: GenericPalletError;

    /**
     * Registered duplicate key.
     **/
    DuplicatedKey: GenericPalletError;

    /**
     * No keys are associated with this account.
     **/
    NoKeys: GenericPalletError;

    /**
     * Key setting account is not live, so it's impossible to associate keys.
     **/
    NoAccount: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Grandpa`'s errors
   **/
  grandpa: {
    /**
     * Attempt to signal GRANDPA pause when the authority set isn't live
     * (either paused or already pending pause).
     **/
    PauseFailed: GenericPalletError;

    /**
     * Attempt to signal GRANDPA resume when the authority set isn't paused
     * (either live or already pending resume).
     **/
    ResumeFailed: GenericPalletError;

    /**
     * Attempt to signal GRANDPA change with one already pending.
     **/
    ChangePending: GenericPalletError;

    /**
     * Cannot signal forced change so soon after last.
     **/
    TooSoon: GenericPalletError;

    /**
     * A key ownership proof provided as part of an equivocation report is invalid.
     **/
    InvalidKeyOwnershipProof: GenericPalletError;

    /**
     * An equivocation proof provided as part of an equivocation report is invalid.
     **/
    InvalidEquivocationProof: GenericPalletError;

    /**
     * A given equivocation report is valid but already previously reported.
     **/
    DuplicateOffenceReport: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Utility`'s errors
   **/
  utility: {
    /**
     * Too many calls batched.
     **/
    TooManyCalls: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Identity`'s errors
   **/
  identity: {
    /**
     * Too many subs-accounts.
     **/
    TooManySubAccounts: GenericPalletError;

    /**
     * Account isn't found.
     **/
    NotFound: GenericPalletError;

    /**
     * Account isn't named.
     **/
    NotNamed: GenericPalletError;

    /**
     * Empty index.
     **/
    EmptyIndex: GenericPalletError;

    /**
     * Fee is changed.
     **/
    FeeChanged: GenericPalletError;

    /**
     * No identity found.
     **/
    NoIdentity: GenericPalletError;

    /**
     * Sticky judgement.
     **/
    StickyJudgement: GenericPalletError;

    /**
     * Judgement given.
     **/
    JudgementGiven: GenericPalletError;

    /**
     * Invalid judgement.
     **/
    InvalidJudgement: GenericPalletError;

    /**
     * The index is invalid.
     **/
    InvalidIndex: GenericPalletError;

    /**
     * The target is invalid.
     **/
    InvalidTarget: GenericPalletError;

    /**
     * Maximum amount of registrars reached. Cannot add any more.
     **/
    TooManyRegistrars: GenericPalletError;

    /**
     * Account ID is already named.
     **/
    AlreadyClaimed: GenericPalletError;

    /**
     * Sender is not a sub-account.
     **/
    NotSub: GenericPalletError;

    /**
     * Sub-account isn't owned by sender.
     **/
    NotOwned: GenericPalletError;

    /**
     * The provided judgement was for a different identity.
     **/
    JudgementForDifferentIdentity: GenericPalletError;

    /**
     * Error that occurs when there is an issue paying for judgement.
     **/
    JudgementPaymentFailed: GenericPalletError;

    /**
     * The provided suffix is too long.
     **/
    InvalidSuffix: GenericPalletError;

    /**
     * The sender does not have permission to issue a username.
     **/
    NotUsernameAuthority: GenericPalletError;

    /**
     * The authority cannot allocate any more usernames.
     **/
    NoAllocation: GenericPalletError;

    /**
     * The signature on a username was not valid.
     **/
    InvalidSignature: GenericPalletError;

    /**
     * Setting this username requires a signature, but none was provided.
     **/
    RequiresSignature: GenericPalletError;

    /**
     * The username does not meet the requirements.
     **/
    InvalidUsername: GenericPalletError;

    /**
     * The username is already taken.
     **/
    UsernameTaken: GenericPalletError;

    /**
     * The requested username does not exist.
     **/
    NoUsername: GenericPalletError;

    /**
     * The username cannot be forcefully removed because it can still be accepted.
     **/
    NotExpired: GenericPalletError;

    /**
     * The username cannot be removed because it's still in the grace period.
     **/
    TooEarly: GenericPalletError;

    /**
     * The username cannot be removed because it is not unbinding.
     **/
    NotUnbinding: GenericPalletError;

    /**
     * The username cannot be unbound because it is already unbinding.
     **/
    AlreadyUnbinding: GenericPalletError;

    /**
     * The action cannot be performed because of insufficient privileges (e.g. authority
     * trying to unbind a username provided by the system).
     **/
    InsufficientPrivileges: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Recovery`'s errors
   **/
  recovery: {
    /**
     * User is not allowed to make a call on behalf of this account
     **/
    NotAllowed: GenericPalletError;

    /**
     * Threshold must be greater than zero
     **/
    ZeroThreshold: GenericPalletError;

    /**
     * Friends list must be greater than zero and threshold
     **/
    NotEnoughFriends: GenericPalletError;

    /**
     * Friends list must be less than max friends
     **/
    MaxFriends: GenericPalletError;

    /**
     * Friends list must be sorted and free of duplicates
     **/
    NotSorted: GenericPalletError;

    /**
     * This account is not set up for recovery
     **/
    NotRecoverable: GenericPalletError;

    /**
     * This account is already set up for recovery
     **/
    AlreadyRecoverable: GenericPalletError;

    /**
     * A recovery process has already started for this account
     **/
    AlreadyStarted: GenericPalletError;

    /**
     * A recovery process has not started for this rescuer
     **/
    NotStarted: GenericPalletError;

    /**
     * This account is not a friend who can vouch
     **/
    NotFriend: GenericPalletError;

    /**
     * The friend must wait until the delay period to vouch for this recovery
     **/
    DelayPeriod: GenericPalletError;

    /**
     * This user has already vouched for this recovery
     **/
    AlreadyVouched: GenericPalletError;

    /**
     * The threshold for recovering this account has not been met
     **/
    Threshold: GenericPalletError;

    /**
     * There are still active recovery attempts that need to be closed
     **/
    StillActive: GenericPalletError;

    /**
     * This account is already set up for recovery
     **/
    AlreadyProxy: GenericPalletError;

    /**
     * Some internal state is broken.
     **/
    BadState: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Vesting`'s errors
   **/
  vesting: {
    /**
     * The account given is not vesting.
     **/
    NotVesting: GenericPalletError;

    /**
     * The account already has `MaxVestingSchedules` count of schedules and thus
     * cannot add another one. Consider merging existing schedules in order to add another.
     **/
    AtMaxVestingSchedules: GenericPalletError;

    /**
     * Amount being transferred is too low to create a vesting schedule.
     **/
    AmountLow: GenericPalletError;

    /**
     * An index was out of bounds of the vesting schedules.
     **/
    ScheduleIndexOutOfBounds: GenericPalletError;

    /**
     * Failed to create a new schedule because some parameter was invalid.
     **/
    InvalidScheduleParams: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Scheduler`'s errors
   **/
  scheduler: {
    /**
     * Failed to schedule a call
     **/
    FailedToSchedule: GenericPalletError;

    /**
     * Cannot find the scheduled call.
     **/
    NotFound: GenericPalletError;

    /**
     * Given target block number is in the past.
     **/
    TargetBlockNumberInPast: GenericPalletError;

    /**
     * Reschedule failed because it does not change scheduled time.
     **/
    RescheduleNoChange: GenericPalletError;

    /**
     * Attempt to use a non-named function on a named task.
     **/
    Named: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Preimage`'s errors
   **/
  preimage: {
    /**
     * Preimage is too large to store on-chain.
     **/
    TooBig: GenericPalletError;

    /**
     * Preimage has already been noted on-chain.
     **/
    AlreadyNoted: GenericPalletError;

    /**
     * The user is not authorized to perform this action.
     **/
    NotAuthorized: GenericPalletError;

    /**
     * The preimage cannot be removed since it has not yet been noted.
     **/
    NotNoted: GenericPalletError;

    /**
     * A preimage may not be removed when there are outstanding requests.
     **/
    Requested: GenericPalletError;

    /**
     * The preimage request cannot be removed since no outstanding requests exist.
     **/
    NotRequested: GenericPalletError;

    /**
     * More than `MAX_HASH_UPGRADE_BULK_COUNT` hashes were requested to be upgraded at once.
     **/
    TooMany: GenericPalletError;

    /**
     * Too few hashes were requested to be upgraded (i.e. zero).
     **/
    TooFew: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Sudo`'s errors
   **/
  sudo: {
    /**
     * Sender must be the Sudo account.
     **/
    RequireSudo: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Proxy`'s errors
   **/
  proxy: {
    /**
     * There are too many proxies registered or too many announcements pending.
     **/
    TooMany: GenericPalletError;

    /**
     * Proxy registration not found.
     **/
    NotFound: GenericPalletError;

    /**
     * Sender is not a proxy of the account to be proxied.
     **/
    NotProxy: GenericPalletError;

    /**
     * A call which is incompatible with the proxy type's filter was attempted.
     **/
    Unproxyable: GenericPalletError;

    /**
     * Account is already a proxy.
     **/
    Duplicate: GenericPalletError;

    /**
     * Call may not be made by proxy because it may escalate its privileges.
     **/
    NoPermission: GenericPalletError;

    /**
     * Announcement, if made at all, was made too recently.
     **/
    Unannounced: GenericPalletError;

    /**
     * Cannot add self as proxy.
     **/
    NoSelfProxy: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Multisig`'s errors
   **/
  multisig: {
    /**
     * Threshold must be 2 or greater.
     **/
    MinimumThreshold: GenericPalletError;

    /**
     * Call is already approved by this signatory.
     **/
    AlreadyApproved: GenericPalletError;

    /**
     * Call doesn't need any (more) approvals.
     **/
    NoApprovalsNeeded: GenericPalletError;

    /**
     * There are too few signatories in the list.
     **/
    TooFewSignatories: GenericPalletError;

    /**
     * There are too many signatories in the list.
     **/
    TooManySignatories: GenericPalletError;

    /**
     * The signatories were provided out of order; they should be ordered.
     **/
    SignatoriesOutOfOrder: GenericPalletError;

    /**
     * The sender was contained in the other signatories; it shouldn't be.
     **/
    SenderInSignatories: GenericPalletError;

    /**
     * Multisig operation not found in storage.
     **/
    NotFound: GenericPalletError;

    /**
     * Only the account that originally created the multisig is able to cancel it or update
     * its deposits.
     **/
    NotOwner: GenericPalletError;

    /**
     * No timepoint was given, yet the multisig operation is already underway.
     **/
    NoTimepoint: GenericPalletError;

    /**
     * A different timepoint was given to the multisig operation that is underway.
     **/
    WrongTimepoint: GenericPalletError;

    /**
     * A timepoint was given, yet no multisig operation is underway.
     **/
    UnexpectedTimepoint: GenericPalletError;

    /**
     * The maximum weight information provided was too low.
     **/
    MaxWeightTooLow: GenericPalletError;

    /**
     * The data to be stored is already stored.
     **/
    AlreadyStored: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `ElectionProviderMultiPhase`'s errors
   **/
  electionProviderMultiPhase: {
    /**
     * Submission was too early.
     **/
    PreDispatchEarlySubmission: GenericPalletError;

    /**
     * Wrong number of winners presented.
     **/
    PreDispatchWrongWinnerCount: GenericPalletError;

    /**
     * Submission was too weak, score-wise.
     **/
    PreDispatchWeakSubmission: GenericPalletError;

    /**
     * The queue was full, and the solution was not better than any of the existing ones.
     **/
    SignedQueueFull: GenericPalletError;

    /**
     * The origin failed to pay the deposit.
     **/
    SignedCannotPayDeposit: GenericPalletError;

    /**
     * Witness data to dispatchable is invalid.
     **/
    SignedInvalidWitness: GenericPalletError;

    /**
     * The signed submission consumes too much weight
     **/
    SignedTooMuchWeight: GenericPalletError;

    /**
     * OCW submitted solution for wrong round
     **/
    OcwCallWrongEra: GenericPalletError;

    /**
     * Snapshot metadata should exist but didn't.
     **/
    MissingSnapshotMetadata: GenericPalletError;

    /**
     * `Self::insert_submission` returned an invalid index.
     **/
    InvalidSubmissionIndex: GenericPalletError;

    /**
     * The call is not allowed at this point.
     **/
    CallNotAllowed: GenericPalletError;

    /**
     * The fallback failed
     **/
    FallbackFailed: GenericPalletError;

    /**
     * Some bound not met
     **/
    BoundNotMet: GenericPalletError;

    /**
     * Submitted solution has too many winners
     **/
    TooManyWinners: GenericPalletError;

    /**
     * Submission was prepared for a different round.
     **/
    PreDispatchDifferentRound: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `VoterList`'s errors
   **/
  voterList: {
    /**
     * A error in the list interface implementation.
     **/
    List: GenericPalletError;

    /**
     * Could not update a node, because the pallet is locked.
     **/
    Locked: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `NominationPools`'s errors
   **/
  nominationPools: {
    /**
     * A (bonded) pool id does not exist.
     **/
    PoolNotFound: GenericPalletError;

    /**
     * An account is not a member.
     **/
    PoolMemberNotFound: GenericPalletError;

    /**
     * A reward pool does not exist. In all cases this is a system logic error.
     **/
    RewardPoolNotFound: GenericPalletError;

    /**
     * A sub pool does not exist.
     **/
    SubPoolsNotFound: GenericPalletError;

    /**
     * An account is already delegating in another pool. An account may only belong to one
     * pool at a time.
     **/
    AccountBelongsToOtherPool: GenericPalletError;

    /**
     * The member is fully unbonded (and thus cannot access the bonded and reward pool
     * anymore to, for example, collect rewards).
     **/
    FullyUnbonding: GenericPalletError;

    /**
     * The member cannot unbond further chunks due to reaching the limit.
     **/
    MaxUnbondingLimit: GenericPalletError;

    /**
     * None of the funds can be withdrawn yet because the bonding duration has not passed.
     **/
    CannotWithdrawAny: GenericPalletError;

    /**
     * The amount does not meet the minimum bond to either join or create a pool.
     *
     * The depositor can never unbond to a value less than `Pallet::depositor_min_bond`. The
     * caller does not have nominating permissions for the pool. Members can never unbond to a
     * value below `MinJoinBond`.
     **/
    MinimumBondNotMet: GenericPalletError;

    /**
     * The transaction could not be executed due to overflow risk for the pool.
     **/
    OverflowRisk: GenericPalletError;

    /**
     * A pool must be in [`PoolState::Destroying`] in order for the depositor to unbond or for
     * other members to be permissionlessly unbonded.
     **/
    NotDestroying: GenericPalletError;

    /**
     * The caller does not have nominating permissions for the pool.
     **/
    NotNominator: GenericPalletError;

    /**
     * Either a) the caller cannot make a valid kick or b) the pool is not destroying.
     **/
    NotKickerOrDestroying: GenericPalletError;

    /**
     * The pool is not open to join
     **/
    NotOpen: GenericPalletError;

    /**
     * The system is maxed out on pools.
     **/
    MaxPools: GenericPalletError;

    /**
     * Too many members in the pool or system.
     **/
    MaxPoolMembers: GenericPalletError;

    /**
     * The pools state cannot be changed.
     **/
    CanNotChangeState: GenericPalletError;

    /**
     * The caller does not have adequate permissions.
     **/
    DoesNotHavePermission: GenericPalletError;

    /**
     * Metadata exceeds [`Config::MaxMetadataLen`]
     **/
    MetadataExceedsMaxLen: GenericPalletError;

    /**
     * Some error occurred that should never happen. This should be reported to the
     * maintainers.
     **/
    Defensive: GenericPalletError;

    /**
     * Partial unbonding now allowed permissionlessly.
     **/
    PartialUnbondNotAllowedPermissionlessly: GenericPalletError;

    /**
     * The pool's max commission cannot be set higher than the existing value.
     **/
    MaxCommissionRestricted: GenericPalletError;

    /**
     * The supplied commission exceeds the max allowed commission.
     **/
    CommissionExceedsMaximum: GenericPalletError;

    /**
     * The supplied commission exceeds global maximum commission.
     **/
    CommissionExceedsGlobalMaximum: GenericPalletError;

    /**
     * Not enough blocks have surpassed since the last commission update.
     **/
    CommissionChangeThrottled: GenericPalletError;

    /**
     * The submitted changes to commission change rate are not allowed.
     **/
    CommissionChangeRateNotAllowed: GenericPalletError;

    /**
     * There is no pending commission to claim.
     **/
    NoPendingCommission: GenericPalletError;

    /**
     * No commission current has been set.
     **/
    NoCommissionCurrentSet: GenericPalletError;

    /**
     * Pool id currently in use.
     **/
    PoolIdInUse: GenericPalletError;

    /**
     * Pool id provided is not correct/usable.
     **/
    InvalidPoolId: GenericPalletError;

    /**
     * Bonding extra is restricted to the exact pending reward amount.
     **/
    BondExtraRestricted: GenericPalletError;

    /**
     * No imbalance in the ED deposit for the pool.
     **/
    NothingToAdjust: GenericPalletError;

    /**
     * No slash pending that can be applied to the member.
     **/
    NothingToSlash: GenericPalletError;

    /**
     * The slash amount is too low to be applied.
     **/
    SlashTooLow: GenericPalletError;

    /**
     * The pool or member delegation has already migrated to delegate stake.
     **/
    AlreadyMigrated: GenericPalletError;

    /**
     * The pool or member delegation has not migrated yet to delegate stake.
     **/
    NotMigrated: GenericPalletError;

    /**
     * This call is not allowed in the current state of the pallet.
     **/
    NotSupported: GenericPalletError;

    /**
     * Account is restricted from participation in pools. This may happen if the account is
     * staking in another way already.
     **/
    Restricted: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `FastUnstake`'s errors
   **/
  fastUnstake: {
    /**
     * The provided Controller account was not found.
     *
     * This means that the given account is not bonded.
     **/
    NotController: GenericPalletError;

    /**
     * The bonded account has already been queued.
     **/
    AlreadyQueued: GenericPalletError;

    /**
     * The bonded account has active unlocking chunks.
     **/
    NotFullyBonded: GenericPalletError;

    /**
     * The provided un-staker is not in the `Queue`.
     **/
    NotQueued: GenericPalletError;

    /**
     * The provided un-staker is already in Head, and cannot deregister.
     **/
    AlreadyHead: GenericPalletError;

    /**
     * The call is not allowed at this point because the pallet is not active.
     **/
    CallNotAllowed: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `ConvictionVoting`'s errors
   **/
  convictionVoting: {
    /**
     * Poll is not ongoing.
     **/
    NotOngoing: GenericPalletError;

    /**
     * The given account did not vote on the poll.
     **/
    NotVoter: GenericPalletError;

    /**
     * The actor has no permission to conduct the action.
     **/
    NoPermission: GenericPalletError;

    /**
     * The actor has no permission to conduct the action right now but will do in the future.
     **/
    NoPermissionYet: GenericPalletError;

    /**
     * The account is already delegating.
     **/
    AlreadyDelegating: GenericPalletError;

    /**
     * The account currently has votes attached to it and the operation cannot succeed until
     * these are removed through `remove_vote`.
     **/
    AlreadyVoting: GenericPalletError;

    /**
     * Too high a balance was provided that the account cannot afford.
     **/
    InsufficientFunds: GenericPalletError;

    /**
     * The account is not currently delegating.
     **/
    NotDelegating: GenericPalletError;

    /**
     * Delegation to oneself makes no sense.
     **/
    Nonsense: GenericPalletError;

    /**
     * Maximum number of votes reached.
     **/
    MaxVotesReached: GenericPalletError;

    /**
     * The class must be supplied since it is not easily determinable from the state.
     **/
    ClassNeeded: GenericPalletError;

    /**
     * The class ID supplied is invalid.
     **/
    BadClass: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Referenda`'s errors
   **/
  referenda: {
    /**
     * Referendum is not ongoing.
     **/
    NotOngoing: GenericPalletError;

    /**
     * Referendum's decision deposit is already paid.
     **/
    HasDeposit: GenericPalletError;

    /**
     * The track identifier given was invalid.
     **/
    BadTrack: GenericPalletError;

    /**
     * There are already a full complement of referenda in progress for this track.
     **/
    Full: GenericPalletError;

    /**
     * The queue of the track is empty.
     **/
    QueueEmpty: GenericPalletError;

    /**
     * The referendum index provided is invalid in this context.
     **/
    BadReferendum: GenericPalletError;

    /**
     * There was nothing to do in the advancement.
     **/
    NothingToDo: GenericPalletError;

    /**
     * No track exists for the proposal origin.
     **/
    NoTrack: GenericPalletError;

    /**
     * Any deposit cannot be refunded until after the decision is over.
     **/
    Unfinished: GenericPalletError;

    /**
     * The deposit refunder is not the depositor.
     **/
    NoPermission: GenericPalletError;

    /**
     * The deposit cannot be refunded since none was made.
     **/
    NoDeposit: GenericPalletError;

    /**
     * The referendum status is invalid for this operation.
     **/
    BadStatus: GenericPalletError;

    /**
     * The preimage does not exist.
     **/
    PreimageNotExist: GenericPalletError;

    /**
     * The preimage is stored with a different length than the one provided.
     **/
    PreimageStoredWithDifferentLength: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Whitelist`'s errors
   **/
  whitelist: {
    /**
     * The preimage of the call hash could not be loaded.
     **/
    UnavailablePreImage: GenericPalletError;

    /**
     * The call could not be decoded.
     **/
    UndecodableCall: GenericPalletError;

    /**
     * The weight of the decoded call was higher than the witness.
     **/
    InvalidCallWeightWitness: GenericPalletError;

    /**
     * The call was not whitelisted.
     **/
    CallIsNotWhitelisted: GenericPalletError;

    /**
     * The call was already whitelisted; No-Op.
     **/
    CallAlreadyWhitelisted: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Treasury`'s errors
   **/
  treasury: {
    /**
     * No proposal, bounty or spend at that index.
     **/
    InvalidIndex: GenericPalletError;

    /**
     * Too many approvals in the queue.
     **/
    TooManyApprovals: GenericPalletError;

    /**
     * The spend origin is valid but the amount it is allowed to spend is lower than the
     * amount to be spent.
     **/
    InsufficientPermission: GenericPalletError;

    /**
     * Proposal has not been approved.
     **/
    ProposalNotApproved: GenericPalletError;

    /**
     * The balance of the asset kind is not convertible to the balance of the native asset.
     **/
    FailedToConvertBalance: GenericPalletError;

    /**
     * The spend has expired and cannot be claimed.
     **/
    SpendExpired: GenericPalletError;

    /**
     * The spend is not yet eligible for payout.
     **/
    EarlyPayout: GenericPalletError;

    /**
     * The payment has already been attempted.
     **/
    AlreadyAttempted: GenericPalletError;

    /**
     * There was some issue with the mechanism of payment.
     **/
    PayoutError: GenericPalletError;

    /**
     * The payout was not yet attempted/claimed.
     **/
    NotAttempted: GenericPalletError;

    /**
     * The payment has neither failed nor succeeded yet.
     **/
    Inconclusive: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `DelegatedStaking`'s errors
   **/
  delegatedStaking: {
    /**
     * The account cannot perform this operation.
     **/
    NotAllowed: GenericPalletError;

    /**
     * An existing staker cannot perform this action.
     **/
    AlreadyStaking: GenericPalletError;

    /**
     * Reward Destination cannot be same as `Agent` account.
     **/
    InvalidRewardDestination: GenericPalletError;

    /**
     * Delegation conditions are not met.
     *
     * Possible issues are
     * 1) Cannot delegate to self,
     * 2) Cannot delegate to multiple delegates.
     **/
    InvalidDelegation: GenericPalletError;

    /**
     * The account does not have enough funds to perform the operation.
     **/
    NotEnoughFunds: GenericPalletError;

    /**
     * Not an existing `Agent` account.
     **/
    NotAgent: GenericPalletError;

    /**
     * Not a Delegator account.
     **/
    NotDelegator: GenericPalletError;

    /**
     * Some corruption in internal state.
     **/
    BadState: GenericPalletError;

    /**
     * Unapplied pending slash restricts operation on `Agent`.
     **/
    UnappliedSlash: GenericPalletError;

    /**
     * `Agent` has no pending slash to be applied.
     **/
    NothingToSlash: GenericPalletError;

    /**
     * Failed to withdraw amount from Core Staking.
     **/
    WithdrawFailed: GenericPalletError;

    /**
     * Operation not supported by this pallet.
     **/
    NotSupported: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Configuration`'s errors
   **/
  configuration: {
    /**
     * The new value for a configuration parameter is invalid.
     **/
    InvalidNewValue: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `ParaInclusion`'s errors
   **/
  paraInclusion: {
    /**
     * Validator index out of bounds.
     **/
    ValidatorIndexOutOfBounds: GenericPalletError;

    /**
     * Candidate submitted but para not scheduled.
     **/
    UnscheduledCandidate: GenericPalletError;

    /**
     * Head data exceeds the configured maximum.
     **/
    HeadDataTooLarge: GenericPalletError;

    /**
     * Code upgrade prematurely.
     **/
    PrematureCodeUpgrade: GenericPalletError;

    /**
     * Output code is too large
     **/
    NewCodeTooLarge: GenericPalletError;

    /**
     * The candidate's relay-parent was not allowed. Either it was
     * not recent enough or it didn't advance based on the last parachain block.
     **/
    DisallowedRelayParent: GenericPalletError;

    /**
     * Failed to compute group index for the core: either it's out of bounds
     * or the relay parent doesn't belong to the current session.
     **/
    InvalidAssignment: GenericPalletError;

    /**
     * Invalid group index in core assignment.
     **/
    InvalidGroupIndex: GenericPalletError;

    /**
     * Insufficient (non-majority) backing.
     **/
    InsufficientBacking: GenericPalletError;

    /**
     * Invalid (bad signature, unknown validator, etc.) backing.
     **/
    InvalidBacking: GenericPalletError;

    /**
     * The validation data hash does not match expected.
     **/
    ValidationDataHashMismatch: GenericPalletError;

    /**
     * The downward message queue is not processed correctly.
     **/
    IncorrectDownwardMessageHandling: GenericPalletError;

    /**
     * At least one upward message sent does not pass the acceptance criteria.
     **/
    InvalidUpwardMessages: GenericPalletError;

    /**
     * The candidate didn't follow the rules of HRMP watermark advancement.
     **/
    HrmpWatermarkMishandling: GenericPalletError;

    /**
     * The HRMP messages sent by the candidate is not valid.
     **/
    InvalidOutboundHrmp: GenericPalletError;

    /**
     * The validation code hash of the candidate is not valid.
     **/
    InvalidValidationCodeHash: GenericPalletError;

    /**
     * The `para_head` hash in the candidate descriptor doesn't match the hash of the actual
     * para head in the commitments.
     **/
    ParaHeadMismatch: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `ParaInherent`'s errors
   **/
  paraInherent: {
    /**
     * Inclusion inherent called more than once per block.
     **/
    TooManyInclusionInherents: GenericPalletError;

    /**
     * The hash of the submitted parent header doesn't correspond to the saved block hash of
     * the parent.
     **/
    InvalidParentHeader: GenericPalletError;

    /**
     * Inherent data was filtered during execution. This should have only been done
     * during creation.
     **/
    InherentDataFilteredDuringExecution: GenericPalletError;

    /**
     * Too many candidates supplied.
     **/
    UnscheduledCandidate: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Paras`'s errors
   **/
  paras: {
    /**
     * Para is not registered in our system.
     **/
    NotRegistered: GenericPalletError;

    /**
     * Para cannot be onboarded because it is already tracked by our system.
     **/
    CannotOnboard: GenericPalletError;

    /**
     * Para cannot be offboarded at this time.
     **/
    CannotOffboard: GenericPalletError;

    /**
     * Para cannot be upgraded to a lease holding parachain.
     **/
    CannotUpgrade: GenericPalletError;

    /**
     * Para cannot be downgraded to an on-demand parachain.
     **/
    CannotDowngrade: GenericPalletError;

    /**
     * The statement for PVF pre-checking is stale.
     **/
    PvfCheckStatementStale: GenericPalletError;

    /**
     * The statement for PVF pre-checking is for a future session.
     **/
    PvfCheckStatementFuture: GenericPalletError;

    /**
     * Claimed validator index is out of bounds.
     **/
    PvfCheckValidatorIndexOutOfBounds: GenericPalletError;

    /**
     * The signature for the PVF pre-checking is invalid.
     **/
    PvfCheckInvalidSignature: GenericPalletError;

    /**
     * The given validator already has cast a vote.
     **/
    PvfCheckDoubleVote: GenericPalletError;

    /**
     * The given PVF does not exist at the moment of process a vote.
     **/
    PvfCheckSubjectInvalid: GenericPalletError;

    /**
     * Parachain cannot currently schedule a code upgrade.
     **/
    CannotUpgradeCode: GenericPalletError;

    /**
     * Invalid validation code size.
     **/
    InvalidCode: GenericPalletError;

    /**
     * No upgrade authorized.
     **/
    NothingAuthorized: GenericPalletError;

    /**
     * The submitted code is not authorized.
     **/
    Unauthorized: GenericPalletError;

    /**
     * Invalid block number.
     **/
    InvalidBlockNumber: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Hrmp`'s errors
   **/
  hrmp: {
    /**
     * The sender tried to open a channel to themselves.
     **/
    OpenHrmpChannelToSelf: GenericPalletError;

    /**
     * The recipient is not a valid para.
     **/
    OpenHrmpChannelInvalidRecipient: GenericPalletError;

    /**
     * The requested capacity is zero.
     **/
    OpenHrmpChannelZeroCapacity: GenericPalletError;

    /**
     * The requested capacity exceeds the global limit.
     **/
    OpenHrmpChannelCapacityExceedsLimit: GenericPalletError;

    /**
     * The requested maximum message size is 0.
     **/
    OpenHrmpChannelZeroMessageSize: GenericPalletError;

    /**
     * The open request requested the message size that exceeds the global limit.
     **/
    OpenHrmpChannelMessageSizeExceedsLimit: GenericPalletError;

    /**
     * The channel already exists
     **/
    OpenHrmpChannelAlreadyExists: GenericPalletError;

    /**
     * There is already a request to open the same channel.
     **/
    OpenHrmpChannelAlreadyRequested: GenericPalletError;

    /**
     * The sender already has the maximum number of allowed outbound channels.
     **/
    OpenHrmpChannelLimitExceeded: GenericPalletError;

    /**
     * The channel from the sender to the origin doesn't exist.
     **/
    AcceptHrmpChannelDoesntExist: GenericPalletError;

    /**
     * The channel is already confirmed.
     **/
    AcceptHrmpChannelAlreadyConfirmed: GenericPalletError;

    /**
     * The recipient already has the maximum number of allowed inbound channels.
     **/
    AcceptHrmpChannelLimitExceeded: GenericPalletError;

    /**
     * The origin tries to close a channel where it is neither the sender nor the recipient.
     **/
    CloseHrmpChannelUnauthorized: GenericPalletError;

    /**
     * The channel to be closed doesn't exist.
     **/
    CloseHrmpChannelDoesntExist: GenericPalletError;

    /**
     * The channel close request is already requested.
     **/
    CloseHrmpChannelAlreadyUnderway: GenericPalletError;

    /**
     * Canceling is requested by neither the sender nor recipient of the open channel request.
     **/
    CancelHrmpOpenChannelUnauthorized: GenericPalletError;

    /**
     * The open request doesn't exist.
     **/
    OpenHrmpChannelDoesntExist: GenericPalletError;

    /**
     * Cannot cancel an HRMP open channel request because it is already confirmed.
     **/
    OpenHrmpChannelAlreadyConfirmed: GenericPalletError;

    /**
     * The provided witness data is wrong.
     **/
    WrongWitness: GenericPalletError;

    /**
     * The channel between these two chains cannot be authorized.
     **/
    ChannelCreationNotAuthorized: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `ParasDisputes`'s errors
   **/
  parasDisputes: {
    /**
     * Duplicate dispute statement sets provided.
     **/
    DuplicateDisputeStatementSets: GenericPalletError;

    /**
     * Ancient dispute statement provided.
     **/
    AncientDisputeStatement: GenericPalletError;

    /**
     * Validator index on statement is out of bounds for session.
     **/
    ValidatorIndexOutOfBounds: GenericPalletError;

    /**
     * Invalid signature on statement.
     **/
    InvalidSignature: GenericPalletError;

    /**
     * Validator vote submitted more than once to dispute.
     **/
    DuplicateStatement: GenericPalletError;

    /**
     * A dispute where there are only votes on one side.
     **/
    SingleSidedDispute: GenericPalletError;

    /**
     * A dispute vote from a malicious backer.
     **/
    MaliciousBacker: GenericPalletError;

    /**
     * No backing votes were provides along dispute statements.
     **/
    MissingBackingVotes: GenericPalletError;

    /**
     * Unconfirmed dispute statement sets provided.
     **/
    UnconfirmedDispute: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `ParasSlashing`'s errors
   **/
  parasSlashing: {
    /**
     * The key ownership proof is invalid.
     **/
    InvalidKeyOwnershipProof: GenericPalletError;

    /**
     * The session index is too old or invalid.
     **/
    InvalidSessionIndex: GenericPalletError;

    /**
     * The candidate hash is invalid.
     **/
    InvalidCandidateHash: GenericPalletError;

    /**
     * There is no pending slash for the given validator index and time
     * slot.
     **/
    InvalidValidatorIndex: GenericPalletError;

    /**
     * The validator index does not match the validator id.
     **/
    ValidatorIndexIdMismatch: GenericPalletError;

    /**
     * The given slashing report is valid but already previously reported.
     **/
    DuplicateSlashingReport: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `OnDemandAssignmentProvider`'s errors
   **/
  onDemandAssignmentProvider: {
    /**
     * The order queue is full, `place_order` will not continue.
     **/
    QueueFull: GenericPalletError;

    /**
     * The current spot price is higher than the max amount specified in the `place_order`
     * call, making it invalid.
     **/
    SpotPriceHigherThanMaxAmount: GenericPalletError;

    /**
     * The account doesn't have enough credits to purchase on-demand coretime.
     **/
    InsufficientCredits: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `CoretimeAssignmentProvider`'s errors
   **/
  coretimeAssignmentProvider: {
    AssignmentsEmpty: GenericPalletError;

    /**
     * assign_core is only allowed to append new assignments at the end of already existing
     * ones or update the last entry.
     **/
    DisallowedInsert: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Registrar`'s errors
   **/
  registrar: {
    /**
     * The ID is not registered.
     **/
    NotRegistered: GenericPalletError;

    /**
     * The ID is already registered.
     **/
    AlreadyRegistered: GenericPalletError;

    /**
     * The caller is not the owner of this Id.
     **/
    NotOwner: GenericPalletError;

    /**
     * Invalid para code size.
     **/
    CodeTooLarge: GenericPalletError;

    /**
     * Invalid para head data size.
     **/
    HeadDataTooLarge: GenericPalletError;

    /**
     * Para is not a Parachain.
     **/
    NotParachain: GenericPalletError;

    /**
     * Para is not a Parathread (on-demand parachain).
     **/
    NotParathread: GenericPalletError;

    /**
     * Cannot deregister para
     **/
    CannotDeregister: GenericPalletError;

    /**
     * Cannot schedule downgrade of lease holding parachain to on-demand parachain
     **/
    CannotDowngrade: GenericPalletError;

    /**
     * Cannot schedule upgrade of on-demand parachain to lease holding parachain
     **/
    CannotUpgrade: GenericPalletError;

    /**
     * Para is locked from manipulation by the manager. Must use parachain or relay chain
     * governance.
     **/
    ParaLocked: GenericPalletError;

    /**
     * The ID given for registration has not been reserved.
     **/
    NotReserved: GenericPalletError;

    /**
     * The validation code is invalid.
     **/
    InvalidCode: GenericPalletError;

    /**
     * Cannot perform a parachain slot / lifecycle swap. Check that the state of both paras
     * are correct for the swap to work.
     **/
    CannotSwap: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Slots`'s errors
   **/
  slots: {
    /**
     * The parachain ID is not onboarding.
     **/
    ParaNotOnboarding: GenericPalletError;

    /**
     * There was an error with the lease.
     **/
    LeaseError: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `ParasSudoWrapper`'s errors
   **/
  parasSudoWrapper: {
    /**
     * The specified parachain is not registered.
     **/
    ParaDoesntExist: GenericPalletError;

    /**
     * The specified parachain is already registered.
     **/
    ParaAlreadyExists: GenericPalletError;

    /**
     * A DMP message couldn't be sent because it exceeds the maximum size allowed for a
     * downward message.
     **/
    ExceedsMaxMessageSize: GenericPalletError;

    /**
     * A DMP message couldn't be sent because the destination is unreachable.
     **/
    Unroutable: GenericPalletError;

    /**
     * Could not schedule para cleanup.
     **/
    CouldntCleanup: GenericPalletError;

    /**
     * Not a parathread (on-demand parachain).
     **/
    NotParathread: GenericPalletError;

    /**
     * Not a lease holding parachain.
     **/
    NotParachain: GenericPalletError;

    /**
     * Cannot upgrade on-demand parachain to lease holding parachain.
     **/
    CannotUpgrade: GenericPalletError;

    /**
     * Cannot downgrade lease holding parachain to on-demand.
     **/
    CannotDowngrade: GenericPalletError;

    /**
     * There are more cores than supported by the runtime.
     **/
    TooManyCores: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Auctions`'s errors
   **/
  auctions: {
    /**
     * This auction is already in progress.
     **/
    AuctionInProgress: GenericPalletError;

    /**
     * The lease period is in the past.
     **/
    LeasePeriodInPast: GenericPalletError;

    /**
     * Para is not registered
     **/
    ParaNotRegistered: GenericPalletError;

    /**
     * Not a current auction.
     **/
    NotCurrentAuction: GenericPalletError;

    /**
     * Not an auction.
     **/
    NotAuction: GenericPalletError;

    /**
     * Auction has already ended.
     **/
    AuctionEnded: GenericPalletError;

    /**
     * The para is already leased out for part of this range.
     **/
    AlreadyLeasedOut: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Crowdloan`'s errors
   **/
  crowdloan: {
    /**
     * The current lease period is more than the first lease period.
     **/
    FirstPeriodInPast: GenericPalletError;

    /**
     * The first lease period needs to at least be less than 3 `max_value`.
     **/
    FirstPeriodTooFarInFuture: GenericPalletError;

    /**
     * Last lease period must be greater than first lease period.
     **/
    LastPeriodBeforeFirstPeriod: GenericPalletError;

    /**
     * The last lease period cannot be more than 3 periods after the first period.
     **/
    LastPeriodTooFarInFuture: GenericPalletError;

    /**
     * The campaign ends before the current block number. The end must be in the future.
     **/
    CannotEndInPast: GenericPalletError;

    /**
     * The end date for this crowdloan is not sensible.
     **/
    EndTooFarInFuture: GenericPalletError;

    /**
     * There was an overflow.
     **/
    Overflow: GenericPalletError;

    /**
     * The contribution was below the minimum, `MinContribution`.
     **/
    ContributionTooSmall: GenericPalletError;

    /**
     * Invalid fund index.
     **/
    InvalidParaId: GenericPalletError;

    /**
     * Contributions exceed maximum amount.
     **/
    CapExceeded: GenericPalletError;

    /**
     * The contribution period has already ended.
     **/
    ContributionPeriodOver: GenericPalletError;

    /**
     * The origin of this call is invalid.
     **/
    InvalidOrigin: GenericPalletError;

    /**
     * This crowdloan does not correspond to a parachain.
     **/
    NotParachain: GenericPalletError;

    /**
     * This parachain lease is still active and retirement cannot yet begin.
     **/
    LeaseActive: GenericPalletError;

    /**
     * This parachain's bid or lease is still active and withdraw cannot yet begin.
     **/
    BidOrLeaseActive: GenericPalletError;

    /**
     * The crowdloan has not yet ended.
     **/
    FundNotEnded: GenericPalletError;

    /**
     * There are no contributions stored in this crowdloan.
     **/
    NoContributions: GenericPalletError;

    /**
     * The crowdloan is not ready to dissolve. Potentially still has a slot or in retirement
     * period.
     **/
    NotReadyToDissolve: GenericPalletError;

    /**
     * Invalid signature.
     **/
    InvalidSignature: GenericPalletError;

    /**
     * The provided memo is too large.
     **/
    MemoTooLarge: GenericPalletError;

    /**
     * The fund is already in `NewRaise`
     **/
    AlreadyInNewRaise: GenericPalletError;

    /**
     * No contributions allowed during the VRF delay
     **/
    VrfDelayInProgress: GenericPalletError;

    /**
     * A lease period has not started yet, due to an offset in the starting block.
     **/
    NoLeasePeriod: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `AssignedSlots`'s errors
   **/
  assignedSlots: {
    /**
     * The specified parachain is not registered.
     **/
    ParaDoesntExist: GenericPalletError;

    /**
     * Not a parathread (on-demand parachain).
     **/
    NotParathread: GenericPalletError;

    /**
     * Cannot upgrade on-demand parachain to lease holding
     * parachain.
     **/
    CannotUpgrade: GenericPalletError;

    /**
     * Cannot downgrade lease holding parachain to
     * on-demand.
     **/
    CannotDowngrade: GenericPalletError;

    /**
     * Permanent or Temporary slot already assigned.
     **/
    SlotAlreadyAssigned: GenericPalletError;

    /**
     * Permanent or Temporary slot has not been assigned.
     **/
    SlotNotAssigned: GenericPalletError;

    /**
     * An ongoing lease already exists.
     **/
    OngoingLeaseExists: GenericPalletError;
    MaxPermanentSlotsExceeded: GenericPalletError;
    MaxTemporarySlotsExceeded: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Coretime`'s errors
   **/
  coretime: {
    /**
     * The paraid making the call is not the coretime brokerage system parachain.
     **/
    NotBroker: GenericPalletError;

    /**
     * Requested revenue information `when` parameter was in the future from the current
     * block height.
     **/
    RequestedFutureRevenue: GenericPalletError;

    /**
     * Failed to transfer assets to the coretime chain
     **/
    AssetTransferFailed: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `StakingAhClient`'s errors
   **/
  stakingAhClient: {
    /**
     * Could not process incoming message because incoming messages are blocked.
     **/
    Blocked: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `MultiBlockMigrations`'s errors
   **/
  multiBlockMigrations: {
    /**
     * The operation cannot complete since some MBMs are ongoing.
     **/
    Ongoing: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `XcmPallet`'s errors
   **/
  xcmPallet: {
    /**
     * The desired destination was unreachable, generally because there is a no way of routing
     * to it.
     **/
    Unreachable: GenericPalletError;

    /**
     * There was some other issue (i.e. not to do with routing) in sending the message.
     * Perhaps a lack of space for buffering the message.
     **/
    SendFailure: GenericPalletError;

    /**
     * The message execution fails the filter.
     **/
    Filtered: GenericPalletError;

    /**
     * The message's weight could not be determined.
     **/
    UnweighableMessage: GenericPalletError;

    /**
     * The destination `Location` provided cannot be inverted.
     **/
    DestinationNotInvertible: GenericPalletError;

    /**
     * The assets to be sent are empty.
     **/
    Empty: GenericPalletError;

    /**
     * Could not re-anchor the assets to declare the fees for the destination chain.
     **/
    CannotReanchor: GenericPalletError;

    /**
     * Too many assets have been attempted for transfer.
     **/
    TooManyAssets: GenericPalletError;

    /**
     * Origin is invalid for sending.
     **/
    InvalidOrigin: GenericPalletError;

    /**
     * The version of the `Versioned` value used is not able to be interpreted.
     **/
    BadVersion: GenericPalletError;

    /**
     * The given location could not be used (e.g. because it cannot be expressed in the
     * desired version of XCM).
     **/
    BadLocation: GenericPalletError;

    /**
     * The referenced subscription could not be found.
     **/
    NoSubscription: GenericPalletError;

    /**
     * The location is invalid since it already has a subscription from us.
     **/
    AlreadySubscribed: GenericPalletError;

    /**
     * Could not check-out the assets for teleportation to the destination chain.
     **/
    CannotCheckOutTeleport: GenericPalletError;

    /**
     * The owner does not own (all) of the asset that they wish to do the operation on.
     **/
    LowBalance: GenericPalletError;

    /**
     * The asset owner has too many locks on the asset.
     **/
    TooManyLocks: GenericPalletError;

    /**
     * The given account is not an identifiable sovereign account for any location.
     **/
    AccountNotSovereign: GenericPalletError;

    /**
     * The operation required fees to be paid which the initiator could not meet.
     **/
    FeesNotMet: GenericPalletError;

    /**
     * A remote lock with the corresponding data could not be found.
     **/
    LockNotFound: GenericPalletError;

    /**
     * The unlock operation cannot succeed because there are still consumers of the lock.
     **/
    InUse: GenericPalletError;

    /**
     * Invalid asset, reserve chain could not be determined for it.
     **/
    InvalidAssetUnknownReserve: GenericPalletError;

    /**
     * Invalid asset, do not support remote asset reserves with different fees reserves.
     **/
    InvalidAssetUnsupportedReserve: GenericPalletError;

    /**
     * Too many assets with different reserve locations have been attempted for transfer.
     **/
    TooManyReserves: GenericPalletError;

    /**
     * Local XCM execution incomplete.
     **/
    LocalExecutionIncomplete: GenericPalletError;

    /**
     * Too many locations authorized to alias origin.
     *
     * @deprecated Use `LocalExecutionIncompleteWithError` instead (since 20.0.0)
     **/
    TooManyAuthorizedAliases: GenericPalletError;

    /**
     * Expiry block number is in the past.
     **/
    ExpiresInPast: GenericPalletError;

    /**
     * The alias to remove authorization for was not found.
     **/
    AliasNotFound: GenericPalletError;

    /**
     * Local XCM execution incomplete with the actual XCM error and the index of the
     * instruction that caused the error.
     **/
    LocalExecutionIncompleteWithError: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `MessageQueue`'s errors
   **/
  messageQueue: {
    /**
     * Page is not reapable because it has items remaining to be processed and is not old
     * enough.
     **/
    NotReapable: GenericPalletError;

    /**
     * Page to be reaped does not exist.
     **/
    NoPage: GenericPalletError;

    /**
     * The referenced message could not be found.
     **/
    NoMessage: GenericPalletError;

    /**
     * The message was already processed and cannot be processed again.
     **/
    AlreadyProcessed: GenericPalletError;

    /**
     * The message is queued for future execution.
     **/
    Queued: GenericPalletError;

    /**
     * There is temporarily not enough weight to continue servicing messages.
     **/
    InsufficientWeight: GenericPalletError;

    /**
     * This message is temporarily unprocessable.
     *
     * Such errors are expected, but not guaranteed, to resolve themselves eventually through
     * retrying.
     **/
    TemporarilyUnprocessable: GenericPalletError;

    /**
     * The queue is paused and no message can be executed from it.
     *
     * This can change at any time and may resolve in the future by re-trying.
     **/
    QueuePaused: GenericPalletError;

    /**
     * Another call is in progress and needs to finish before this call can happen.
     **/
    RecursiveDisallowed: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `AssetRate`'s errors
   **/
  assetRate: {
    /**
     * The given asset ID is unknown.
     **/
    UnknownAssetKind: GenericPalletError;

    /**
     * The given asset ID already has an assigned conversion rate and cannot be re-created.
     **/
    AlreadyExists: GenericPalletError;

    /**
     * Overflow ocurred when calculating the inverse rate.
     **/
    Overflow: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `MetaTx`'s errors
   **/
  metaTx: {
    /**
     * Invalid proof (e.g. signature).
     **/
    BadProof: GenericPalletError;

    /**
     * The meta transaction is not yet valid (e.g. nonce too high).
     **/
    Future: GenericPalletError;

    /**
     * The meta transaction is outdated (e.g. nonce too low).
     **/
    Stale: GenericPalletError;

    /**
     * The meta transactions's birth block is ancient.
     **/
    AncientBirthBlock: GenericPalletError;

    /**
     * The transaction extension did not authorize any origin.
     **/
    UnknownOrigin: GenericPalletError;

    /**
     * The meta transaction is invalid.
     **/
    Invalid: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `RootOffences`'s errors
   **/
  rootOffences: {
    /**
     * Failed to get the active era from the staking pallet.
     **/
    FailedToGetActiveEra: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Beefy`'s errors
   **/
  beefy: {
    /**
     * A key ownership proof provided as part of an equivocation report is invalid.
     **/
    InvalidKeyOwnershipProof: GenericPalletError;

    /**
     * A double voting proof provided as part of an equivocation report is invalid.
     **/
    InvalidDoubleVotingProof: GenericPalletError;

    /**
     * A fork voting proof provided as part of an equivocation report is invalid.
     **/
    InvalidForkVotingProof: GenericPalletError;

    /**
     * A future block voting proof provided as part of an equivocation report is invalid.
     **/
    InvalidFutureBlockVotingProof: GenericPalletError;

    /**
     * The session of the equivocation proof is invalid
     **/
    InvalidEquivocationProofSession: GenericPalletError;

    /**
     * The session of the equivocation proof is not in the mapping (anymore)
     **/
    InvalidEquivocationProofSessionMember: GenericPalletError;

    /**
     * A given equivocation report is valid but already previously reported.
     **/
    DuplicateOffenceReport: GenericPalletError;

    /**
     * Submitted configuration is invalid.
     **/
    InvalidConfiguration: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
}
