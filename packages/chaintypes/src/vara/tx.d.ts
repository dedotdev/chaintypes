// Generated by dedot cli

import type {
  GenericChainTx,
  GenericTxCall,
  ISubmittableExtrinsic,
  ISubmittableResult,
  IRuntimeTxCall,
  RpcVersion,
  RpcV2,
  ISubmittableExtrinsicLegacy,
} from 'dedot/types';
import type {
  MultiAddressLike,
  Extrinsic,
  BytesLike,
  H256,
  AccountId32Like,
  Percent,
  Perbill,
  FixedBytes,
  Data,
  H160,
} from 'dedot/codecs';
import type {
  VaraRuntimeRuntimeCallLike,
  SpRuntimeMultiSignature,
  FrameSystemEventRecord,
  SpConsensusSlotsEquivocationProof,
  SpSessionMembershipProof,
  SpConsensusBabeDigestsNextConfigDescriptor,
  SpConsensusGrandpaEquivocationProof,
  PalletBalancesAdjustmentDirection,
  VaraRuntimeSessionKeys,
  VaraRuntimeOriginCaller,
  SpWeightsWeightV2Weight,
  PalletVestingVestingInfo,
  PalletImOnlineHeartbeat,
  PalletImOnlineSr25519AppSr25519Signature,
  PalletStakingRewardDestination,
  PalletStakingValidatorPrefs,
  PalletStakingPalletConfigOp,
  PalletStakingPalletConfigOpU32,
  PalletStakingPalletConfigOpPercent,
  PalletStakingPalletConfigOpPerbill,
  PalletStakingUnlockChunk,
  PalletConvictionVotingVoteAccountVote,
  PalletConvictionVotingConviction,
  FrameSupportPreimagesBounded,
  FrameSupportScheduleDispatchTime,
  PalletIdentityLegacyIdentityInfo,
  PalletIdentityJudgement,
  VaraRuntimeProxyType,
  PalletMultisigTimepoint,
  PalletElectionProviderMultiPhaseRawSolution,
  PalletElectionProviderMultiPhaseSolutionOrSnapshotSize,
  SpNposElectionsElectionScore,
  SpNposElectionsSupport,
  PalletNominationPoolsBondExtra,
  PalletNominationPoolsPoolState,
  PalletNominationPoolsConfigOp,
  PalletNominationPoolsConfigOpU32,
  PalletNominationPoolsConfigOpPerbill,
  PalletNominationPoolsConfigOp004,
  PalletNominationPoolsClaimPermission,
  PalletNominationPoolsCommissionChangeRate,
  PalletNominationPoolsCommissionClaimPermission,
  GprimitivesCodeId,
  GprimitivesActorId,
  GprimitivesMessageId,
  NonZeroU32,
  PalletGearVoucherInternalVoucherId,
  PalletGearVoucherInternalPrepaidCall,
} from './types.js';

export type ChainSubmittableExtrinsic<
  Rv extends RpcVersion,
  T extends IRuntimeTxCall = VaraRuntimeRuntimeCallLike,
> = Extrinsic<MultiAddressLike, T, SpRuntimeMultiSignature, any[]> &
  (Rv extends RpcV2
    ? ISubmittableExtrinsic<ISubmittableResult<FrameSystemEventRecord>>
    : ISubmittableExtrinsicLegacy<ISubmittableResult<FrameSystemEventRecord>>);

export type TxCall<Rv extends RpcVersion> = (...args: any[]) => ChainSubmittableExtrinsic<Rv>;

export interface ChainTx<Rv extends RpcVersion> extends GenericChainTx<Rv, TxCall<Rv>> {
  /**
   * Pallet `System`'s transaction calls
   **/
  system: {
    /**
     * Make some on-chain remark.
     *
     * Can be executed by every `origin`.
     *
     * @param {BytesLike} remark
     **/
    remark: GenericTxCall<
      Rv,
      (remark: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'Remark';
            params: { remark: BytesLike };
          };
        }
      >
    >;

    /**
     * Set the number of pages in the WebAssembly environment's heap.
     *
     * @param {bigint} pages
     **/
    setHeapPages: GenericTxCall<
      Rv,
      (pages: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'SetHeapPages';
            params: { pages: bigint };
          };
        }
      >
    >;

    /**
     * Set the new runtime code.
     *
     * @param {BytesLike} code
     **/
    setCode: GenericTxCall<
      Rv,
      (code: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'SetCode';
            params: { code: BytesLike };
          };
        }
      >
    >;

    /**
     * Set the new runtime code without doing any checks of the given `code`.
     *
     * Note that runtime upgrades will not run if this is called with a not-increasing spec
     * version!
     *
     * @param {BytesLike} code
     **/
    setCodeWithoutChecks: GenericTxCall<
      Rv,
      (code: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'SetCodeWithoutChecks';
            params: { code: BytesLike };
          };
        }
      >
    >;

    /**
     * Set some items of storage.
     *
     * @param {Array<[BytesLike, BytesLike]>} items
     **/
    setStorage: GenericTxCall<
      Rv,
      (items: Array<[BytesLike, BytesLike]>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'SetStorage';
            params: { items: Array<[BytesLike, BytesLike]> };
          };
        }
      >
    >;

    /**
     * Kill some items from storage.
     *
     * @param {Array<BytesLike>} keys
     **/
    killStorage: GenericTxCall<
      Rv,
      (keys: Array<BytesLike>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'KillStorage';
            params: { keys: Array<BytesLike> };
          };
        }
      >
    >;

    /**
     * Kill all storage items with a key that starts with the given prefix.
     *
     * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
     * the prefix we are removing to accurately calculate the weight of this function.
     *
     * @param {BytesLike} prefix
     * @param {number} subkeys
     **/
    killPrefix: GenericTxCall<
      Rv,
      (
        prefix: BytesLike,
        subkeys: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'KillPrefix';
            params: { prefix: BytesLike; subkeys: number };
          };
        }
      >
    >;

    /**
     * Make some on-chain remark and emit event.
     *
     * @param {BytesLike} remark
     **/
    remarkWithEvent: GenericTxCall<
      Rv,
      (remark: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'RemarkWithEvent';
            params: { remark: BytesLike };
          };
        }
      >
    >;

    /**
     * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
     * later.
     *
     * This call requires Root origin.
     *
     * @param {H256} codeHash
     **/
    authorizeUpgrade: GenericTxCall<
      Rv,
      (codeHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'AuthorizeUpgrade';
            params: { codeHash: H256 };
          };
        }
      >
    >;

    /**
     * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
     * later.
     *
     * WARNING: This authorizes an upgrade that will take place without any safety checks, for
     * example that the spec name remains the same and that the version number increases. Not
     * recommended for normal use. Use `authorize_upgrade` instead.
     *
     * This call requires Root origin.
     *
     * @param {H256} codeHash
     **/
    authorizeUpgradeWithoutChecks: GenericTxCall<
      Rv,
      (codeHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'AuthorizeUpgradeWithoutChecks';
            params: { codeHash: H256 };
          };
        }
      >
    >;

    /**
     * Provide the preimage (runtime binary) `code` for an upgrade that has been authorized.
     *
     * If the authorization required a version check, this call will ensure the spec name
     * remains unchanged and that the spec version has increased.
     *
     * Depending on the runtime's `OnSetCode` configuration, this function may directly apply
     * the new `code` in the same block or attempt to schedule the upgrade.
     *
     * All origins are allowed.
     *
     * @param {BytesLike} code
     **/
    applyAuthorizedUpgrade: GenericTxCall<
      Rv,
      (code: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'ApplyAuthorizedUpgrade';
            params: { code: BytesLike };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Timestamp`'s transaction calls
   **/
  timestamp: {
    /**
     * Set the current time.
     *
     * This call should be invoked exactly once per block. It will panic at the finalization
     * phase, if this call hasn't been invoked by that time.
     *
     * The timestamp should be greater than the previous one by the amount specified by
     * [`Config::MinimumPeriod`].
     *
     * The dispatch origin for this call must be _None_.
     *
     * This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware
     * that changing the complexity of this call could result exhausting the resources in a
     * block to execute any other calls.
     *
     * ## Complexity
     * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
     * - 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in
     * `on_finalize`)
     * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
     *
     * @param {bigint} now
     **/
    set: GenericTxCall<
      Rv,
      (now: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Timestamp';
          palletCall: {
            name: 'Set';
            params: { now: bigint };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Babe`'s transaction calls
   **/
  babe: {
    /**
     * Report authority equivocation/misbehavior. This method will verify
     * the equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence will
     * be reported.
     *
     * @param {SpConsensusSlotsEquivocationProof} equivocationProof
     * @param {SpSessionMembershipProof} keyOwnerProof
     **/
    reportEquivocation: GenericTxCall<
      Rv,
      (
        equivocationProof: SpConsensusSlotsEquivocationProof,
        keyOwnerProof: SpSessionMembershipProof,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Babe';
          palletCall: {
            name: 'ReportEquivocation';
            params: { equivocationProof: SpConsensusSlotsEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
          };
        }
      >
    >;

    /**
     * Report authority equivocation/misbehavior. This method will verify
     * the equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence will
     * be reported.
     * This extrinsic must be called unsigned and it is expected that only
     * block authors will call it (validated in `ValidateUnsigned`), as such
     * if the block author is defined it will be defined as the equivocation
     * reporter.
     *
     * @param {SpConsensusSlotsEquivocationProof} equivocationProof
     * @param {SpSessionMembershipProof} keyOwnerProof
     **/
    reportEquivocationUnsigned: GenericTxCall<
      Rv,
      (
        equivocationProof: SpConsensusSlotsEquivocationProof,
        keyOwnerProof: SpSessionMembershipProof,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Babe';
          palletCall: {
            name: 'ReportEquivocationUnsigned';
            params: { equivocationProof: SpConsensusSlotsEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
          };
        }
      >
    >;

    /**
     * Plan an epoch config change. The epoch config change is recorded and will be enacted on
     * the next call to `enact_epoch_change`. The config will be activated one epoch after.
     * Multiple calls to this method will replace any existing planned config change that had
     * not been enacted yet.
     *
     * @param {SpConsensusBabeDigestsNextConfigDescriptor} config
     **/
    planConfigChange: GenericTxCall<
      Rv,
      (config: SpConsensusBabeDigestsNextConfigDescriptor) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Babe';
          palletCall: {
            name: 'PlanConfigChange';
            params: { config: SpConsensusBabeDigestsNextConfigDescriptor };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Grandpa`'s transaction calls
   **/
  grandpa: {
    /**
     * Report voter equivocation/misbehavior. This method will verify the
     * equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence
     * will be reported.
     *
     * @param {SpConsensusGrandpaEquivocationProof} equivocationProof
     * @param {SpSessionMembershipProof} keyOwnerProof
     **/
    reportEquivocation: GenericTxCall<
      Rv,
      (
        equivocationProof: SpConsensusGrandpaEquivocationProof,
        keyOwnerProof: SpSessionMembershipProof,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Grandpa';
          palletCall: {
            name: 'ReportEquivocation';
            params: { equivocationProof: SpConsensusGrandpaEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
          };
        }
      >
    >;

    /**
     * Report voter equivocation/misbehavior. This method will verify the
     * equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence
     * will be reported.
     *
     * This extrinsic must be called unsigned and it is expected that only
     * block authors will call it (validated in `ValidateUnsigned`), as such
     * if the block author is defined it will be defined as the equivocation
     * reporter.
     *
     * @param {SpConsensusGrandpaEquivocationProof} equivocationProof
     * @param {SpSessionMembershipProof} keyOwnerProof
     **/
    reportEquivocationUnsigned: GenericTxCall<
      Rv,
      (
        equivocationProof: SpConsensusGrandpaEquivocationProof,
        keyOwnerProof: SpSessionMembershipProof,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Grandpa';
          palletCall: {
            name: 'ReportEquivocationUnsigned';
            params: { equivocationProof: SpConsensusGrandpaEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
          };
        }
      >
    >;

    /**
     * Note that the current authority set of the GRANDPA finality gadget has stalled.
     *
     * This will trigger a forced authority set change at the beginning of the next session, to
     * be enacted `delay` blocks after that. The `delay` should be high enough to safely assume
     * that the block signalling the forced change will not be re-orged e.g. 1000 blocks.
     * The block production rate (which may be slowed down because of finality lagging) should
     * be taken into account when choosing the `delay`. The GRANDPA voters based on the new
     * authority will start voting on top of `best_finalized_block_number` for new finalized
     * blocks. `best_finalized_block_number` should be the highest of the latest finalized
     * block of all validators of the new authority set.
     *
     * Only callable by root.
     *
     * @param {number} delay
     * @param {number} bestFinalizedBlockNumber
     **/
    noteStalled: GenericTxCall<
      Rv,
      (
        delay: number,
        bestFinalizedBlockNumber: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Grandpa';
          palletCall: {
            name: 'NoteStalled';
            params: { delay: number; bestFinalizedBlockNumber: number };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Balances`'s transaction calls
   **/
  balances: {
    /**
     * Transfer some liquid free balance to another account.
     *
     * `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
     * If the sender's account is below the existential deposit as a result
     * of the transfer, the account will be reaped.
     *
     * The dispatch origin for this call must be `Signed` by the transactor.
     *
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     **/
    transferAllowDeath: GenericTxCall<
      Rv,
      (
        dest: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'TransferAllowDeath';
            params: { dest: MultiAddressLike; value: bigint };
          };
        }
      >
    >;

    /**
     * Exactly as `transfer_allow_death`, except the origin must be root and the source account
     * may be specified.
     *
     * @param {MultiAddressLike} source
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     **/
    forceTransfer: GenericTxCall<
      Rv,
      (
        source: MultiAddressLike,
        dest: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'ForceTransfer';
            params: { source: MultiAddressLike; dest: MultiAddressLike; value: bigint };
          };
        }
      >
    >;

    /**
     * Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
     * kill the origin account.
     *
     * 99% of the time you want [`transfer_allow_death`] instead.
     *
     * [`transfer_allow_death`]: struct.Pallet.html#method.transfer
     *
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     **/
    transferKeepAlive: GenericTxCall<
      Rv,
      (
        dest: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'TransferKeepAlive';
            params: { dest: MultiAddressLike; value: bigint };
          };
        }
      >
    >;

    /**
     * Transfer the entire transferable balance from the caller account.
     *
     * NOTE: This function only attempts to transfer _transferable_ balances. This means that
     * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
     * transferred by this function. To ensure that this function results in a killed account,
     * you might need to prepare the account by removing any reference counters, storage
     * deposits, etc...
     *
     * The dispatch origin of this call must be Signed.
     *
     * - `dest`: The recipient of the transfer.
     * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
     * of the funds the account has, causing the sender account to be killed (false), or
     * transfer everything except at least the existential deposit, which will guarantee to
     * keep the sender account alive (true).
     *
     * @param {MultiAddressLike} dest
     * @param {boolean} keepAlive
     **/
    transferAll: GenericTxCall<
      Rv,
      (
        dest: MultiAddressLike,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'TransferAll';
            params: { dest: MultiAddressLike; keepAlive: boolean };
          };
        }
      >
    >;

    /**
     * Unreserve some balance from a user by force.
     *
     * Can only be called by ROOT.
     *
     * @param {MultiAddressLike} who
     * @param {bigint} amount
     **/
    forceUnreserve: GenericTxCall<
      Rv,
      (
        who: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'ForceUnreserve';
            params: { who: MultiAddressLike; amount: bigint };
          };
        }
      >
    >;

    /**
     * Upgrade a specified account.
     *
     * - `origin`: Must be `Signed`.
     * - `who`: The account to be upgraded.
     *
     * This will waive the transaction fee if at least all but 10% of the accounts needed to
     * be upgraded. (We let some not have to be upgraded just in order to allow for the
     * possibility of churn).
     *
     * @param {Array<AccountId32Like>} who
     **/
    upgradeAccounts: GenericTxCall<
      Rv,
      (who: Array<AccountId32Like>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'UpgradeAccounts';
            params: { who: Array<AccountId32Like> };
          };
        }
      >
    >;

    /**
     * Set the regular balance of a given account.
     *
     * The dispatch origin for this call is `root`.
     *
     * @param {MultiAddressLike} who
     * @param {bigint} newFree
     **/
    forceSetBalance: GenericTxCall<
      Rv,
      (
        who: MultiAddressLike,
        newFree: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'ForceSetBalance';
            params: { who: MultiAddressLike; newFree: bigint };
          };
        }
      >
    >;

    /**
     * Adjust the total issuance in a saturating way.
     *
     * Can only be called by root and always needs a positive `delta`.
     *
     * # Example
     *
     * @param {PalletBalancesAdjustmentDirection} direction
     * @param {bigint} delta
     **/
    forceAdjustTotalIssuance: GenericTxCall<
      Rv,
      (
        direction: PalletBalancesAdjustmentDirection,
        delta: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'ForceAdjustTotalIssuance';
            params: { direction: PalletBalancesAdjustmentDirection; delta: bigint };
          };
        }
      >
    >;

    /**
     * Burn the specified liquid free balance from the origin account.
     *
     * If the origin's account ends up below the existential deposit as a result
     * of the burn and `keep_alive` is false, the account will be reaped.
     *
     * Unlike sending funds to a _burn_ address, which merely makes the funds inaccessible,
     * this `burn` operation will reduce total issuance by the amount _burned_.
     *
     * @param {bigint} value
     * @param {boolean} keepAlive
     **/
    burn: GenericTxCall<
      Rv,
      (
        value: bigint,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'Burn';
            params: { value: bigint; keepAlive: boolean };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Session`'s transaction calls
   **/
  session: {
    /**
     * Sets the session key(s) of the function caller to `keys`.
     * Allows an account to set its session key prior to becoming a validator.
     * This doesn't take effect until the next session.
     *
     * The dispatch origin of this function must be signed.
     *
     * ## Complexity
     * - `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is
     * fixed.
     *
     * @param {VaraRuntimeSessionKeys} keys
     * @param {BytesLike} proof
     **/
    setKeys: GenericTxCall<
      Rv,
      (
        keys: VaraRuntimeSessionKeys,
        proof: BytesLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Session';
          palletCall: {
            name: 'SetKeys';
            params: { keys: VaraRuntimeSessionKeys; proof: BytesLike };
          };
        }
      >
    >;

    /**
     * Removes any session key(s) of the function caller.
     *
     * This doesn't take effect until the next session.
     *
     * The dispatch origin of this function must be Signed and the account must be either be
     * convertible to a validator ID using the chain's typical addressing system (this usually
     * means being a controller account) or directly convertible into a validator ID (which
     * usually means being a stash account).
     *
     * ## Complexity
     * - `O(1)` in number of key types. Actual cost depends on the number of length of
     * `T::Keys::key_ids()` which is fixed.
     *
     **/
    purgeKeys: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Session';
          palletCall: {
            name: 'PurgeKeys';
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Utility`'s transaction calls
   **/
  utility: {
    /**
     * Send a batch of dispatch calls.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     *
     * @param {Array<VaraRuntimeRuntimeCallLike>} calls
     **/
    batch: GenericTxCall<
      Rv,
      (calls: Array<VaraRuntimeRuntimeCallLike>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'Batch';
            params: { calls: Array<VaraRuntimeRuntimeCallLike> };
          };
        }
      >
    >;

    /**
     * Send a call through an indexed pseudonym of the sender.
     *
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     *
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     *
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * @param {number} index
     * @param {VaraRuntimeRuntimeCallLike} call
     **/
    asDerivative: GenericTxCall<
      Rv,
      (
        index: number,
        call: VaraRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'AsDerivative';
            params: { index: number; call: VaraRuntimeRuntimeCallLike };
          };
        }
      >
    >;

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * @param {Array<VaraRuntimeRuntimeCallLike>} calls
     **/
    batchAll: GenericTxCall<
      Rv,
      (calls: Array<VaraRuntimeRuntimeCallLike>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'BatchAll';
            params: { calls: Array<VaraRuntimeRuntimeCallLike> };
          };
        }
      >
    >;

    /**
     * Dispatches a function call with a provided origin.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {VaraRuntimeOriginCaller} asOrigin
     * @param {VaraRuntimeRuntimeCallLike} call
     **/
    dispatchAs: GenericTxCall<
      Rv,
      (
        asOrigin: VaraRuntimeOriginCaller,
        call: VaraRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'DispatchAs';
            params: { asOrigin: VaraRuntimeOriginCaller; call: VaraRuntimeRuntimeCallLike };
          };
        }
      >
    >;

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * @param {Array<VaraRuntimeRuntimeCallLike>} calls
     **/
    forceBatch: GenericTxCall<
      Rv,
      (calls: Array<VaraRuntimeRuntimeCallLike>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'ForceBatch';
            params: { calls: Array<VaraRuntimeRuntimeCallLike> };
          };
        }
      >
    >;

    /**
     * Dispatch a function call with a specified weight.
     *
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * @param {VaraRuntimeRuntimeCallLike} call
     * @param {SpWeightsWeightV2Weight} weight
     **/
    withWeight: GenericTxCall<
      Rv,
      (
        call: VaraRuntimeRuntimeCallLike,
        weight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'WithWeight';
            params: { call: VaraRuntimeRuntimeCallLike; weight: SpWeightsWeightV2Weight };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Vesting`'s transaction calls
   **/
  vesting: {
    /**
     * Unlock any vested funds of the sender account.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have funds still
     * locked under this pallet.
     *
     * Emits either `VestingCompleted` or `VestingUpdated`.
     *
     * ## Complexity
     * - `O(1)`.
     *
     **/
    vest: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Vesting';
          palletCall: {
            name: 'Vest';
          };
        }
      >
    >;

    /**
     * Unlock any vested funds of a `target` account.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `target`: The account whose vested funds should be unlocked. Must have funds still
     * locked under this pallet.
     *
     * Emits either `VestingCompleted` or `VestingUpdated`.
     *
     * ## Complexity
     * - `O(1)`.
     *
     * @param {MultiAddressLike} target
     **/
    vestOther: GenericTxCall<
      Rv,
      (target: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Vesting';
          palletCall: {
            name: 'VestOther';
            params: { target: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Create a vested transfer.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `target`: The account receiving the vested funds.
     * - `schedule`: The vesting schedule attached to the transfer.
     *
     * Emits `VestingCreated`.
     *
     * NOTE: This will unlock all schedules through the current block.
     *
     * ## Complexity
     * - `O(1)`.
     *
     * @param {MultiAddressLike} target
     * @param {PalletVestingVestingInfo} schedule
     **/
    vestedTransfer: GenericTxCall<
      Rv,
      (
        target: MultiAddressLike,
        schedule: PalletVestingVestingInfo,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Vesting';
          palletCall: {
            name: 'VestedTransfer';
            params: { target: MultiAddressLike; schedule: PalletVestingVestingInfo };
          };
        }
      >
    >;

    /**
     * Force a vested transfer.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * - `source`: The account whose funds should be transferred.
     * - `target`: The account that should be transferred the vested funds.
     * - `schedule`: The vesting schedule attached to the transfer.
     *
     * Emits `VestingCreated`.
     *
     * NOTE: This will unlock all schedules through the current block.
     *
     * ## Complexity
     * - `O(1)`.
     *
     * @param {MultiAddressLike} source
     * @param {MultiAddressLike} target
     * @param {PalletVestingVestingInfo} schedule
     **/
    forceVestedTransfer: GenericTxCall<
      Rv,
      (
        source: MultiAddressLike,
        target: MultiAddressLike,
        schedule: PalletVestingVestingInfo,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Vesting';
          palletCall: {
            name: 'ForceVestedTransfer';
            params: { source: MultiAddressLike; target: MultiAddressLike; schedule: PalletVestingVestingInfo };
          };
        }
      >
    >;

    /**
     * Merge two vesting schedules together, creating a new vesting schedule that unlocks over
     * the highest possible start and end blocks. If both schedules have already started the
     * current block will be used as the schedule start; with the caveat that if one schedule
     * is finished by the current block, the other will be treated as the new merged schedule,
     * unmodified.
     *
     * NOTE: If `schedule1_index == schedule2_index` this is a no-op.
     * NOTE: This will unlock all schedules through the current block prior to merging.
     * NOTE: If both schedules have ended by the current block, no new schedule will be created
     * and both will be removed.
     *
     * Merged schedule attributes:
     * - `starting_block`: `MAX(schedule1.starting_block, scheduled2.starting_block,
     * current_block)`.
     * - `ending_block`: `MAX(schedule1.ending_block, schedule2.ending_block)`.
     * - `locked`: `schedule1.locked_at(current_block) + schedule2.locked_at(current_block)`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `schedule1_index`: index of the first schedule to merge.
     * - `schedule2_index`: index of the second schedule to merge.
     *
     * @param {number} schedule1Index
     * @param {number} schedule2Index
     **/
    mergeSchedules: GenericTxCall<
      Rv,
      (
        schedule1Index: number,
        schedule2Index: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Vesting';
          palletCall: {
            name: 'MergeSchedules';
            params: { schedule1Index: number; schedule2Index: number };
          };
        }
      >
    >;

    /**
     * Force remove a vesting schedule
     *
     * The dispatch origin for this call must be _Root_.
     *
     * - `target`: An account that has a vesting schedule
     * - `schedule_index`: The vesting schedule index that should be removed
     *
     * @param {MultiAddressLike} target
     * @param {number} scheduleIndex
     **/
    forceRemoveVestingSchedule: GenericTxCall<
      Rv,
      (
        target: MultiAddressLike,
        scheduleIndex: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Vesting';
          palletCall: {
            name: 'ForceRemoveVestingSchedule';
            params: { target: MultiAddressLike; scheduleIndex: number };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `BagsList`'s transaction calls
   **/
  bagsList: {
    /**
     * Declare that some `dislocated` account has, through rewards or penalties, sufficiently
     * changed its score that it should properly fall into a different bag than its current
     * one.
     *
     * Anyone can call this function about any potentially dislocated account.
     *
     * Will always update the stored score of `dislocated` to the correct score, based on
     * `ScoreProvider`.
     *
     * If `dislocated` does not exists, it returns an error.
     *
     * @param {MultiAddressLike} dislocated
     **/
    rebag: GenericTxCall<
      Rv,
      (dislocated: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'BagsList';
          palletCall: {
            name: 'Rebag';
            params: { dislocated: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Move the caller's Id directly in front of `lighter`.
     *
     * The dispatch origin for this call must be _Signed_ and can only be called by the Id of
     * the account going in front of `lighter`. Fee is payed by the origin under all
     * circumstances.
     *
     * Only works if:
     *
     * - both nodes are within the same bag,
     * - and `origin` has a greater `Score` than `lighter`.
     *
     * @param {MultiAddressLike} lighter
     **/
    putInFrontOf: GenericTxCall<
      Rv,
      (lighter: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'BagsList';
          palletCall: {
            name: 'PutInFrontOf';
            params: { lighter: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Same as [`Pallet::put_in_front_of`], but it can be called by anyone.
     *
     * Fee is paid by the origin under all circumstances.
     *
     * @param {MultiAddressLike} heavier
     * @param {MultiAddressLike} lighter
     **/
    putInFrontOfOther: GenericTxCall<
      Rv,
      (
        heavier: MultiAddressLike,
        lighter: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'BagsList';
          palletCall: {
            name: 'PutInFrontOfOther';
            params: { heavier: MultiAddressLike; lighter: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `ImOnline`'s transaction calls
   **/
  imOnline: {
    /**
     * ## Complexity:
     * - `O(K)` where K is length of `Keys` (heartbeat.validators_len)
     * - `O(K)`: decoding of length `K`
     *
     * @param {PalletImOnlineHeartbeat} heartbeat
     * @param {PalletImOnlineSr25519AppSr25519Signature} signature
     **/
    heartbeat: GenericTxCall<
      Rv,
      (
        heartbeat: PalletImOnlineHeartbeat,
        signature: PalletImOnlineSr25519AppSr25519Signature,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ImOnline';
          palletCall: {
            name: 'Heartbeat';
            params: { heartbeat: PalletImOnlineHeartbeat; signature: PalletImOnlineSr25519AppSr25519Signature };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Staking`'s transaction calls
   **/
  staking: {
    /**
     * Take the origin account as a stash and lock up `value` of its balance. `controller` will
     * be the account that controls it.
     *
     * `value` must be more than the `minimum_balance` specified by `T::Currency`.
     *
     * The dispatch origin for this call must be _Signed_ by the stash account.
     *
     * Emits `Bonded`.
     * ## Complexity
     * - Independent of the arguments. Moderate complexity.
     * - O(1).
     * - Three extra DB entries.
     *
     * NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned
     * unless the `origin` falls below _existential deposit_ (or equal to 0) and gets removed
     * as dust.
     *
     * @param {bigint} value
     * @param {PalletStakingRewardDestination} payee
     **/
    bond: GenericTxCall<
      Rv,
      (
        value: bigint,
        payee: PalletStakingRewardDestination,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Staking';
          palletCall: {
            name: 'Bond';
            params: { value: bigint; payee: PalletStakingRewardDestination };
          };
        }
      >
    >;

    /**
     * Add some extra amount that have appeared in the stash `free_balance` into the balance up
     * for staking.
     *
     * The dispatch origin for this call must be _Signed_ by the stash, not the controller.
     *
     * Use this if there are additional funds in your stash account that you wish to bond.
     * Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose
     * any limitation on the amount that can be added.
     *
     * Emits `Bonded`.
     *
     * ## Complexity
     * - Independent of the arguments. Insignificant complexity.
     * - O(1).
     *
     * @param {bigint} maxAdditional
     **/
    bondExtra: GenericTxCall<
      Rv,
      (maxAdditional: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Staking';
          palletCall: {
            name: 'BondExtra';
            params: { maxAdditional: bigint };
          };
        }
      >
    >;

    /**
     * Schedule a portion of the stash to be unlocked ready for transfer out after the bond
     * period ends. If this leaves an amount actively bonded less than
     * T::Currency::minimum_balance(), then it is increased to the full amount.
     *
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     *
     * Once the unlock period is done, you can call `withdraw_unbonded` to actually move
     * the funds out of management ready for transfer.
     *
     * No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)
     * can co-exists at the same time. If there are no unlocking chunks slots available
     * [`Call::withdraw_unbonded`] is called to remove some of the chunks (if possible).
     *
     * If a user encounters the `InsufficientBond` error when calling this extrinsic,
     * they should call `chill` first in order to free up their bonded funds.
     *
     * Emits `Unbonded`.
     *
     * See also [`Call::withdraw_unbonded`].
     *
     * @param {bigint} value
     **/
    unbond: GenericTxCall<
      Rv,
      (value: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Staking';
          palletCall: {
            name: 'Unbond';
            params: { value: bigint };
          };
        }
      >
    >;

    /**
     * Remove any unlocked chunks from the `unlocking` queue from our management.
     *
     * This essentially frees up that balance to be used by the stash account to do whatever
     * it wants.
     *
     * The dispatch origin for this call must be _Signed_ by the controller.
     *
     * Emits `Withdrawn`.
     *
     * See also [`Call::unbond`].
     *
     * ## Parameters
     *
     * - `num_slashing_spans` indicates the number of metadata slashing spans to clear when
     * this call results in a complete removal of all the data related to the stash account.
     * In this case, the `num_slashing_spans` must be larger or equal to the number of
     * slashing spans associated with the stash account in the [`SlashingSpans`] storage type,
     * otherwise the call will fail. The call weight is directly proportional to
     * `num_slashing_spans`.
     *
     * ## Complexity
     * O(S) where S is the number of slashing spans to remove
     * NOTE: Weight annotation is the kill scenario, we refund otherwise.
     *
     * @param {number} numSlashingSpans
     **/
    withdrawUnbonded: GenericTxCall<
      Rv,
      (numSlashingSpans: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Staking';
          palletCall: {
            name: 'WithdrawUnbonded';
            params: { numSlashingSpans: number };
          };
        }
      >
    >;

    /**
     * Declare the desire to validate for the origin controller.
     *
     * Effects will be felt at the beginning of the next era.
     *
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     *
     * @param {PalletStakingValidatorPrefs} prefs
     **/
    validate: GenericTxCall<
      Rv,
      (prefs: PalletStakingValidatorPrefs) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Staking';
          palletCall: {
            name: 'Validate';
            params: { prefs: PalletStakingValidatorPrefs };
          };
        }
      >
    >;

    /**
     * Declare the desire to nominate `targets` for the origin controller.
     *
     * Effects will be felt at the beginning of the next era.
     *
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     *
     * ## Complexity
     * - The transaction's complexity is proportional to the size of `targets` (N)
     * which is capped at CompactAssignments::LIMIT (T::MaxNominations).
     * - Both the reads and writes follow a similar pattern.
     *
     * @param {Array<MultiAddressLike>} targets
     **/
    nominate: GenericTxCall<
      Rv,
      (targets: Array<MultiAddressLike>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Staking';
          palletCall: {
            name: 'Nominate';
            params: { targets: Array<MultiAddressLike> };
          };
        }
      >
    >;

    /**
     * Declare no desire to either validate or nominate.
     *
     * Effects will be felt at the beginning of the next era.
     *
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     *
     * ## Complexity
     * - Independent of the arguments. Insignificant complexity.
     * - Contains one read.
     * - Writes are limited to the `origin` account key.
     *
     **/
    chill: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Staking';
          palletCall: {
            name: 'Chill';
          };
        }
      >
    >;

    /**
     * (Re-)set the payment target for a controller.
     *
     * Effects will be felt instantly (as soon as this function is completed successfully).
     *
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     *
     * ## Complexity
     * - O(1)
     * - Independent of the arguments. Insignificant complexity.
     * - Contains a limited number of reads.
     * - Writes are limited to the `origin` account key.
     * ---------
     *
     * @param {PalletStakingRewardDestination} payee
     **/
    setPayee: GenericTxCall<
      Rv,
      (payee: PalletStakingRewardDestination) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Staking';
          palletCall: {
            name: 'SetPayee';
            params: { payee: PalletStakingRewardDestination };
          };
        }
      >
    >;

    /**
     * (Re-)sets the controller of a stash to the stash itself. This function previously
     * accepted a `controller` argument to set the controller to an account other than the
     * stash itself. This functionality has now been removed, now only setting the controller
     * to the stash, if it is not already.
     *
     * Effects will be felt instantly (as soon as this function is completed successfully).
     *
     * The dispatch origin for this call must be _Signed_ by the stash, not the controller.
     *
     * ## Complexity
     * O(1)
     * - Independent of the arguments. Insignificant complexity.
     * - Contains a limited number of reads.
     * - Writes are limited to the `origin` account key.
     *
     **/
    setController: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Staking';
          palletCall: {
            name: 'SetController';
          };
        }
      >
    >;

    /**
     * Sets the ideal number of validators.
     *
     * The dispatch origin must be Root.
     *
     * ## Complexity
     * O(1)
     *
     * @param {number} new_
     **/
    setValidatorCount: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Staking';
          palletCall: {
            name: 'SetValidatorCount';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Increments the ideal number of validators up to maximum of
     * `ElectionProviderBase::MaxWinners`.
     *
     * The dispatch origin must be Root.
     *
     * ## Complexity
     * Same as [`Self::set_validator_count`].
     *
     * @param {number} additional
     **/
    increaseValidatorCount: GenericTxCall<
      Rv,
      (additional: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Staking';
          palletCall: {
            name: 'IncreaseValidatorCount';
            params: { additional: number };
          };
        }
      >
    >;

    /**
     * Scale up the ideal number of validators by a factor up to maximum of
     * `ElectionProviderBase::MaxWinners`.
     *
     * The dispatch origin must be Root.
     *
     * ## Complexity
     * Same as [`Self::set_validator_count`].
     *
     * @param {Percent} factor
     **/
    scaleValidatorCount: GenericTxCall<
      Rv,
      (factor: Percent) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Staking';
          palletCall: {
            name: 'ScaleValidatorCount';
            params: { factor: Percent };
          };
        }
      >
    >;

    /**
     * Force there to be no new eras indefinitely.
     *
     * The dispatch origin must be Root.
     *
     * # Warning
     *
     * The election process starts multiple blocks before the end of the era.
     * Thus the election process may be ongoing when this is called. In this case the
     * election will continue until the next era is triggered.
     *
     * ## Complexity
     * - No arguments.
     * - Weight: O(1)
     *
     **/
    forceNoEras: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Staking';
          palletCall: {
            name: 'ForceNoEras';
          };
        }
      >
    >;

    /**
     * Force there to be a new era at the end of the next session. After this, it will be
     * reset to normal (non-forced) behaviour.
     *
     * The dispatch origin must be Root.
     *
     * # Warning
     *
     * The election process starts multiple blocks before the end of the era.
     * If this is called just before a new era is triggered, the election process may not
     * have enough blocks to get a result.
     *
     * ## Complexity
     * - No arguments.
     * - Weight: O(1)
     *
     **/
    forceNewEra: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Staking';
          palletCall: {
            name: 'ForceNewEra';
          };
        }
      >
    >;

    /**
     * Set the validators who cannot be slashed (if any).
     *
     * The dispatch origin must be Root.
     *
     * @param {Array<AccountId32Like>} invulnerables
     **/
    setInvulnerables: GenericTxCall<
      Rv,
      (invulnerables: Array<AccountId32Like>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Staking';
          palletCall: {
            name: 'SetInvulnerables';
            params: { invulnerables: Array<AccountId32Like> };
          };
        }
      >
    >;

    /**
     * Force a current staker to become completely unstaked, immediately.
     *
     * The dispatch origin must be Root.
     *
     * ## Parameters
     *
     * - `num_slashing_spans`: Refer to comments on [`Call::withdraw_unbonded`] for more
     * details.
     *
     * @param {AccountId32Like} stash
     * @param {number} numSlashingSpans
     **/
    forceUnstake: GenericTxCall<
      Rv,
      (
        stash: AccountId32Like,
        numSlashingSpans: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Staking';
          palletCall: {
            name: 'ForceUnstake';
            params: { stash: AccountId32Like; numSlashingSpans: number };
          };
        }
      >
    >;

    /**
     * Force there to be a new era at the end of sessions indefinitely.
     *
     * The dispatch origin must be Root.
     *
     * # Warning
     *
     * The election process starts multiple blocks before the end of the era.
     * If this is called just before a new era is triggered, the election process may not
     * have enough blocks to get a result.
     *
     **/
    forceNewEraAlways: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Staking';
          palletCall: {
            name: 'ForceNewEraAlways';
          };
        }
      >
    >;

    /**
     * Cancel enactment of a deferred slash.
     *
     * Can be called by the `T::AdminOrigin`.
     *
     * Parameters: era and indices of the slashes for that era to kill.
     *
     * @param {number} era
     * @param {Array<number>} slashIndices
     **/
    cancelDeferredSlash: GenericTxCall<
      Rv,
      (
        era: number,
        slashIndices: Array<number>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Staking';
          palletCall: {
            name: 'CancelDeferredSlash';
            params: { era: number; slashIndices: Array<number> };
          };
        }
      >
    >;

    /**
     * Pay out next page of the stakers behind a validator for the given era.
     *
     * - `validator_stash` is the stash account of the validator.
     * - `era` may be any era between `[current_era - history_depth; current_era]`.
     *
     * The origin of this call must be _Signed_. Any account can call this function, even if
     * it is not one of the stakers.
     *
     * The reward payout could be paged in case there are too many nominators backing the
     * `validator_stash`. This call will payout unpaid pages in an ascending order. To claim a
     * specific page, use `payout_stakers_by_page`.`
     *
     * If all pages are claimed, it returns an error `InvalidPage`.
     *
     * @param {AccountId32Like} validatorStash
     * @param {number} era
     **/
    payoutStakers: GenericTxCall<
      Rv,
      (
        validatorStash: AccountId32Like,
        era: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Staking';
          palletCall: {
            name: 'PayoutStakers';
            params: { validatorStash: AccountId32Like; era: number };
          };
        }
      >
    >;

    /**
     * Rebond a portion of the stash scheduled to be unlocked.
     *
     * The dispatch origin must be signed by the controller.
     *
     * ## Complexity
     * - Time complexity: O(L), where L is unlocking chunks
     * - Bounded by `MaxUnlockingChunks`.
     *
     * @param {bigint} value
     **/
    rebond: GenericTxCall<
      Rv,
      (value: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Staking';
          palletCall: {
            name: 'Rebond';
            params: { value: bigint };
          };
        }
      >
    >;

    /**
     * Remove all data structures concerning a staker/stash once it is at a state where it can
     * be considered `dust` in the staking system. The requirements are:
     *
     * 1. the `total_balance` of the stash is below existential deposit.
     * 2. or, the `ledger.total` of the stash is below existential deposit.
     * 3. or, existential deposit is zero and either `total_balance` or `ledger.total` is zero.
     *
     * The former can happen in cases like a slash; the latter when a fully unbonded account
     * is still receiving staking rewards in `RewardDestination::Staked`.
     *
     * It can be called by anyone, as long as `stash` meets the above requirements.
     *
     * Refunds the transaction fees upon successful execution.
     *
     * ## Parameters
     *
     * - `num_slashing_spans`: Refer to comments on [`Call::withdraw_unbonded`] for more
     * details.
     *
     * @param {AccountId32Like} stash
     * @param {number} numSlashingSpans
     **/
    reapStash: GenericTxCall<
      Rv,
      (
        stash: AccountId32Like,
        numSlashingSpans: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Staking';
          palletCall: {
            name: 'ReapStash';
            params: { stash: AccountId32Like; numSlashingSpans: number };
          };
        }
      >
    >;

    /**
     * Remove the given nominations from the calling validator.
     *
     * Effects will be felt at the beginning of the next era.
     *
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     *
     * - `who`: A list of nominator stash accounts who are nominating this validator which
     * should no longer be nominating this validator.
     *
     * Note: Making this call only makes sense if you first set the validator preferences to
     * block any further nominations.
     *
     * @param {Array<MultiAddressLike>} who
     **/
    kick: GenericTxCall<
      Rv,
      (who: Array<MultiAddressLike>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Staking';
          palletCall: {
            name: 'Kick';
            params: { who: Array<MultiAddressLike> };
          };
        }
      >
    >;

    /**
     * Update the various staking configurations .
     *
     * * `min_nominator_bond`: The minimum active bond needed to be a nominator.
     * * `min_validator_bond`: The minimum active bond needed to be a validator.
     * * `max_nominator_count`: The max number of users who can be a nominator at once. When
     * set to `None`, no limit is enforced.
     * * `max_validator_count`: The max number of users who can be a validator at once. When
     * set to `None`, no limit is enforced.
     * * `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which
     * should be filled in order for the `chill_other` transaction to work.
     * * `min_commission`: The minimum amount of commission that each validators must maintain.
     * This is checked only upon calling `validate`. Existing validators are not affected.
     *
     * RuntimeOrigin must be Root to call this function.
     *
     * NOTE: Existing nominators and validators will not be affected by this update.
     * to kick people under the new limits, `chill_other` should be called.
     *
     * @param {PalletStakingPalletConfigOp} minNominatorBond
     * @param {PalletStakingPalletConfigOp} minValidatorBond
     * @param {PalletStakingPalletConfigOpU32} maxNominatorCount
     * @param {PalletStakingPalletConfigOpU32} maxValidatorCount
     * @param {PalletStakingPalletConfigOpPercent} chillThreshold
     * @param {PalletStakingPalletConfigOpPerbill} minCommission
     * @param {PalletStakingPalletConfigOpPercent} maxStakedRewards
     **/
    setStakingConfigs: GenericTxCall<
      Rv,
      (
        minNominatorBond: PalletStakingPalletConfigOp,
        minValidatorBond: PalletStakingPalletConfigOp,
        maxNominatorCount: PalletStakingPalletConfigOpU32,
        maxValidatorCount: PalletStakingPalletConfigOpU32,
        chillThreshold: PalletStakingPalletConfigOpPercent,
        minCommission: PalletStakingPalletConfigOpPerbill,
        maxStakedRewards: PalletStakingPalletConfigOpPercent,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Staking';
          palletCall: {
            name: 'SetStakingConfigs';
            params: {
              minNominatorBond: PalletStakingPalletConfigOp;
              minValidatorBond: PalletStakingPalletConfigOp;
              maxNominatorCount: PalletStakingPalletConfigOpU32;
              maxValidatorCount: PalletStakingPalletConfigOpU32;
              chillThreshold: PalletStakingPalletConfigOpPercent;
              minCommission: PalletStakingPalletConfigOpPerbill;
              maxStakedRewards: PalletStakingPalletConfigOpPercent;
            };
          };
        }
      >
    >;

    /**
     * Declare a `controller` to stop participating as either a validator or nominator.
     *
     * Effects will be felt at the beginning of the next era.
     *
     * The dispatch origin for this call must be _Signed_, but can be called by anyone.
     *
     * If the caller is the same as the controller being targeted, then no further checks are
     * enforced, and this function behaves just like `chill`.
     *
     * If the caller is different than the controller being targeted, the following conditions
     * must be met:
     *
     * * `controller` must belong to a nominator who has become non-decodable,
     *
     * Or:
     *
     * * A `ChillThreshold` must be set and checked which defines how close to the max
     * nominators or validators we must reach before users can start chilling one-another.
     * * A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine
     * how close we are to the threshold.
     * * A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines
     * if this is a person that should be chilled because they have not met the threshold
     * bond required.
     *
     * This can be helpful if bond requirements are updated, and we need to remove old users
     * who do not satisfy these requirements.
     *
     * @param {AccountId32Like} stash
     **/
    chillOther: GenericTxCall<
      Rv,
      (stash: AccountId32Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Staking';
          palletCall: {
            name: 'ChillOther';
            params: { stash: AccountId32Like };
          };
        }
      >
    >;

    /**
     * Force a validator to have at least the minimum commission. This will not affect a
     * validator who already has a commission greater than or equal to the minimum. Any account
     * can call this.
     *
     * @param {AccountId32Like} validatorStash
     **/
    forceApplyMinCommission: GenericTxCall<
      Rv,
      (validatorStash: AccountId32Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Staking';
          palletCall: {
            name: 'ForceApplyMinCommission';
            params: { validatorStash: AccountId32Like };
          };
        }
      >
    >;

    /**
     * Sets the minimum amount of commission that each validators must maintain.
     *
     * This call has lower privilege requirements than `set_staking_config` and can be called
     * by the `T::AdminOrigin`. Root can always call this.
     *
     * @param {Perbill} new_
     **/
    setMinCommission: GenericTxCall<
      Rv,
      (new_: Perbill) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Staking';
          palletCall: {
            name: 'SetMinCommission';
            params: { new: Perbill };
          };
        }
      >
    >;

    /**
     * Pay out a page of the stakers behind a validator for the given era and page.
     *
     * - `validator_stash` is the stash account of the validator.
     * - `era` may be any era between `[current_era - history_depth; current_era]`.
     * - `page` is the page index of nominators to pay out with value between 0 and
     * `num_nominators / T::MaxExposurePageSize`.
     *
     * The origin of this call must be _Signed_. Any account can call this function, even if
     * it is not one of the stakers.
     *
     * If a validator has more than [`Config::MaxExposurePageSize`] nominators backing
     * them, then the list of nominators is paged, with each page being capped at
     * [`Config::MaxExposurePageSize`.] If a validator has more than one page of nominators,
     * the call needs to be made for each page separately in order for all the nominators
     * backing a validator to receive the reward. The nominators are not sorted across pages
     * and so it should not be assumed the highest staker would be on the topmost page and vice
     * versa. If rewards are not claimed in [`Config::HistoryDepth`] eras, they are lost.
     *
     * @param {AccountId32Like} validatorStash
     * @param {number} era
     * @param {number} page
     **/
    payoutStakersByPage: GenericTxCall<
      Rv,
      (
        validatorStash: AccountId32Like,
        era: number,
        page: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Staking';
          palletCall: {
            name: 'PayoutStakersByPage';
            params: { validatorStash: AccountId32Like; era: number; page: number };
          };
        }
      >
    >;

    /**
     * Migrates an account's `RewardDestination::Controller` to
     * `RewardDestination::Account(controller)`.
     *
     * Effects will be felt instantly (as soon as this function is completed successfully).
     *
     * This will waive the transaction fee if the `payee` is successfully migrated.
     *
     * @param {AccountId32Like} controller
     **/
    updatePayee: GenericTxCall<
      Rv,
      (controller: AccountId32Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Staking';
          palletCall: {
            name: 'UpdatePayee';
            params: { controller: AccountId32Like };
          };
        }
      >
    >;

    /**
     * Updates a batch of controller accounts to their corresponding stash account if they are
     * not the same. Ignores any controller accounts that do not exist, and does not operate if
     * the stash and controller are already the same.
     *
     * Effects will be felt instantly (as soon as this function is completed successfully).
     *
     * The dispatch origin must be `T::AdminOrigin`.
     *
     * @param {Array<AccountId32Like>} controllers
     **/
    deprecateControllerBatch: GenericTxCall<
      Rv,
      (controllers: Array<AccountId32Like>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Staking';
          palletCall: {
            name: 'DeprecateControllerBatch';
            params: { controllers: Array<AccountId32Like> };
          };
        }
      >
    >;

    /**
     * Restores the state of a ledger which is in an inconsistent state.
     *
     * The requirements to restore a ledger are the following:
     * * The stash is bonded; or
     * * The stash is not bonded but it has a staking lock left behind; or
     * * If the stash has an associated ledger and its state is inconsistent; or
     * * If the ledger is not corrupted *but* its staking lock is out of sync.
     *
     * The `maybe_*` input parameters will overwrite the corresponding data and metadata of the
     * ledger associated with the stash. If the input parameters are not set, the ledger will
     * be reset values from on-chain state.
     *
     * @param {AccountId32Like} stash
     * @param {AccountId32Like | undefined} maybeController
     * @param {bigint | undefined} maybeTotal
     * @param {Array<PalletStakingUnlockChunk> | undefined} maybeUnlocking
     **/
    restoreLedger: GenericTxCall<
      Rv,
      (
        stash: AccountId32Like,
        maybeController: AccountId32Like | undefined,
        maybeTotal: bigint | undefined,
        maybeUnlocking: Array<PalletStakingUnlockChunk> | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Staking';
          palletCall: {
            name: 'RestoreLedger';
            params: {
              stash: AccountId32Like;
              maybeController: AccountId32Like | undefined;
              maybeTotal: bigint | undefined;
              maybeUnlocking: Array<PalletStakingUnlockChunk> | undefined;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Treasury`'s transaction calls
   **/
  treasury: {
    /**
     * Propose and approve a spend of treasury funds.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::SpendOrigin`] with the `Success` value being at least `amount`.
     *
     * ### Details
     * NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
     * beneficiary.
     *
     * ### Parameters
     * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
     * - `beneficiary`: The destination account for the transfer.
     *
     * ## Events
     *
     * Emits [`Event::SpendApproved`] if successful.
     *
     * @param {bigint} amount
     * @param {MultiAddressLike} beneficiary
     **/
    spendLocal: GenericTxCall<
      Rv,
      (
        amount: bigint,
        beneficiary: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Treasury';
          palletCall: {
            name: 'SpendLocal';
            params: { amount: bigint; beneficiary: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Force a previously approved proposal to be removed from the approval queue.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::RejectOrigin`].
     *
     * ## Details
     *
     * The original deposit will no longer be returned.
     *
     * ### Parameters
     * - `proposal_id`: The index of a proposal
     *
     * ### Complexity
     * - O(A) where `A` is the number of approvals
     *
     * ### Errors
     * - [`Error::ProposalNotApproved`]: The `proposal_id` supplied was not found in the
     * approval queue, i.e., the proposal has not been approved. This could also mean the
     * proposal does not exist altogether, thus there is no way it would have been approved
     * in the first place.
     *
     * @param {number} proposalId
     **/
    removeApproval: GenericTxCall<
      Rv,
      (proposalId: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Treasury';
          palletCall: {
            name: 'RemoveApproval';
            params: { proposalId: number };
          };
        }
      >
    >;

    /**
     * Propose and approve a spend of treasury funds.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::SpendOrigin`] with the `Success` value being at least
     * `amount` of `asset_kind` in the native asset. The amount of `asset_kind` is converted
     * for assertion using the [`Config::BalanceConverter`].
     *
     * ## Details
     *
     * Create an approved spend for transferring a specific `amount` of `asset_kind` to a
     * designated beneficiary. The spend must be claimed using the `payout` dispatchable within
     * the [`Config::PayoutPeriod`].
     *
     * ### Parameters
     * - `asset_kind`: An indicator of the specific asset class to be spent.
     * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
     * - `beneficiary`: The beneficiary of the spend.
     * - `valid_from`: The block number from which the spend can be claimed. It can refer to
     * the past if the resulting spend has not yet expired according to the
     * [`Config::PayoutPeriod`]. If `None`, the spend can be claimed immediately after
     * approval.
     *
     * ## Events
     *
     * Emits [`Event::AssetSpendApproved`] if successful.
     *
     * @param {[]} assetKind
     * @param {bigint} amount
     * @param {AccountId32Like} beneficiary
     * @param {number | undefined} validFrom
     **/
    spend: GenericTxCall<
      Rv,
      (
        assetKind: [],
        amount: bigint,
        beneficiary: AccountId32Like,
        validFrom: number | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Treasury';
          palletCall: {
            name: 'Spend';
            params: { assetKind: []; amount: bigint; beneficiary: AccountId32Like; validFrom: number | undefined };
          };
        }
      >
    >;

    /**
     * Claim a spend.
     *
     * ## Dispatch Origin
     *
     * Must be signed
     *
     * ## Details
     *
     * Spends must be claimed within some temporal bounds. A spend may be claimed within one
     * [`Config::PayoutPeriod`] from the `valid_from` block.
     * In case of a payout failure, the spend status must be updated with the `check_status`
     * dispatchable before retrying with the current function.
     *
     * ### Parameters
     * - `index`: The spend index.
     *
     * ## Events
     *
     * Emits [`Event::Paid`] if successful.
     *
     * @param {number} index
     **/
    payout: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Treasury';
          palletCall: {
            name: 'Payout';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Check the status of the spend and remove it from the storage if processed.
     *
     * ## Dispatch Origin
     *
     * Must be signed.
     *
     * ## Details
     *
     * The status check is a prerequisite for retrying a failed payout.
     * If a spend has either succeeded or expired, it is removed from the storage by this
     * function. In such instances, transaction fees are refunded.
     *
     * ### Parameters
     * - `index`: The spend index.
     *
     * ## Events
     *
     * Emits [`Event::PaymentFailed`] if the spend payout has failed.
     * Emits [`Event::SpendProcessed`] if the spend payout has succeed.
     *
     * @param {number} index
     **/
    checkStatus: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Treasury';
          palletCall: {
            name: 'CheckStatus';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Void previously approved spend.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::RejectOrigin`].
     *
     * ## Details
     *
     * A spend void is only possible if the payout has not been attempted yet.
     *
     * ### Parameters
     * - `index`: The spend index.
     *
     * ## Events
     *
     * Emits [`Event::AssetSpendVoided`] if successful.
     *
     * @param {number} index
     **/
    voidSpend: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Treasury';
          palletCall: {
            name: 'VoidSpend';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `ConvictionVoting`'s transaction calls
   **/
  convictionVoting: {
    /**
     * Vote in a poll. If `vote.is_aye()`, the vote is to enact the proposal;
     * otherwise it is a vote to keep the status quo.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `poll_index`: The index of the poll to vote for.
     * - `vote`: The vote configuration.
     *
     * Weight: `O(R)` where R is the number of polls the voter has voted on.
     *
     * @param {number} pollIndex
     * @param {PalletConvictionVotingVoteAccountVote} vote
     **/
    vote: GenericTxCall<
      Rv,
      (
        pollIndex: number,
        vote: PalletConvictionVotingVoteAccountVote,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ConvictionVoting';
          palletCall: {
            name: 'Vote';
            params: { pollIndex: number; vote: PalletConvictionVotingVoteAccountVote };
          };
        }
      >
    >;

    /**
     * Delegate the voting power (with some given conviction) of the sending account for a
     * particular class of polls.
     *
     * The balance delegated is locked for as long as it's delegated, and thereafter for the
     * time appropriate for the conviction's lock period.
     *
     * The dispatch origin of this call must be _Signed_, and the signing account must either:
     * - be delegating already; or
     * - have no voting activity (if there is, then it will need to be removed through
     * `remove_vote`).
     *
     * - `to`: The account whose voting the `target` account's voting power will follow.
     * - `class`: The class of polls to delegate. To delegate multiple classes, multiple calls
     * to this function are required.
     * - `conviction`: The conviction that will be attached to the delegated votes. When the
     * account is undelegated, the funds will be locked for the corresponding period.
     * - `balance`: The amount of the account's balance to be used in delegating. This must not
     * be more than the account's current balance.
     *
     * Emits `Delegated`.
     *
     * Weight: `O(R)` where R is the number of polls the voter delegating to has
     * voted on. Weight is initially charged as if maximum votes, but is refunded later.
     *
     * @param {number} class_
     * @param {MultiAddressLike} to
     * @param {PalletConvictionVotingConviction} conviction
     * @param {bigint} balance
     **/
    delegate: GenericTxCall<
      Rv,
      (
        class_: number,
        to: MultiAddressLike,
        conviction: PalletConvictionVotingConviction,
        balance: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ConvictionVoting';
          palletCall: {
            name: 'Delegate';
            params: {
              class: number;
              to: MultiAddressLike;
              conviction: PalletConvictionVotingConviction;
              balance: bigint;
            };
          };
        }
      >
    >;

    /**
     * Undelegate the voting power of the sending account for a particular class of polls.
     *
     * Tokens may be unlocked following once an amount of time consistent with the lock period
     * of the conviction with which the delegation was issued has passed.
     *
     * The dispatch origin of this call must be _Signed_ and the signing account must be
     * currently delegating.
     *
     * - `class`: The class of polls to remove the delegation from.
     *
     * Emits `Undelegated`.
     *
     * Weight: `O(R)` where R is the number of polls the voter delegating to has
     * voted on. Weight is initially charged as if maximum votes, but is refunded later.
     *
     * @param {number} class_
     **/
    undelegate: GenericTxCall<
      Rv,
      (class_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ConvictionVoting';
          palletCall: {
            name: 'Undelegate';
            params: { class: number };
          };
        }
      >
    >;

    /**
     * Remove the lock caused by prior voting/delegating which has expired within a particular
     * class.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `class`: The class of polls to unlock.
     * - `target`: The account to remove the lock on.
     *
     * Weight: `O(R)` with R number of vote of target.
     *
     * @param {number} class_
     * @param {MultiAddressLike} target
     **/
    unlock: GenericTxCall<
      Rv,
      (
        class_: number,
        target: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ConvictionVoting';
          palletCall: {
            name: 'Unlock';
            params: { class: number; target: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Remove a vote for a poll.
     *
     * If:
     * - the poll was cancelled, or
     * - the poll is ongoing, or
     * - the poll has ended such that
     * - the vote of the account was in opposition to the result; or
     * - there was no conviction to the account's vote; or
     * - the account made a split vote
     * ...then the vote is removed cleanly and a following call to `unlock` may result in more
     * funds being available.
     *
     * If, however, the poll has ended and:
     * - it finished corresponding to the vote of the account, and
     * - the account made a standard vote with conviction, and
     * - the lock period of the conviction is not over
     * ...then the lock will be aggregated into the overall account's lock, which may involve
     * *overlocking* (where the two locks are combined into a single lock that is the maximum
     * of both the amount locked and the time is it locked for).
     *
     * The dispatch origin of this call must be _Signed_, and the signer must have a vote
     * registered for poll `index`.
     *
     * - `index`: The index of poll of the vote to be removed.
     * - `class`: Optional parameter, if given it indicates the class of the poll. For polls
     * which have finished or are cancelled, this must be `Some`.
     *
     * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
     * Weight is calculated for the maximum number of vote.
     *
     * @param {number | undefined} class_
     * @param {number} index
     **/
    removeVote: GenericTxCall<
      Rv,
      (
        class_: number | undefined,
        index: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ConvictionVoting';
          palletCall: {
            name: 'RemoveVote';
            params: { class: number | undefined; index: number };
          };
        }
      >
    >;

    /**
     * Remove a vote for a poll.
     *
     * If the `target` is equal to the signer, then this function is exactly equivalent to
     * `remove_vote`. If not equal to the signer, then the vote must have expired,
     * either because the poll was cancelled, because the voter lost the poll or
     * because the conviction period is over.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `target`: The account of the vote to be removed; this account must have voted for poll
     * `index`.
     * - `index`: The index of poll of the vote to be removed.
     * - `class`: The class of the poll.
     *
     * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
     * Weight is calculated for the maximum number of vote.
     *
     * @param {MultiAddressLike} target
     * @param {number} class_
     * @param {number} index
     **/
    removeOtherVote: GenericTxCall<
      Rv,
      (
        target: MultiAddressLike,
        class_: number,
        index: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ConvictionVoting';
          palletCall: {
            name: 'RemoveOtherVote';
            params: { target: MultiAddressLike; class: number; index: number };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Referenda`'s transaction calls
   **/
  referenda: {
    /**
     * Propose a referendum on a privileged action.
     *
     * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
     * available.
     * - `proposal_origin`: The origin from which the proposal should be executed.
     * - `proposal`: The proposal.
     * - `enactment_moment`: The moment that the proposal should be enacted.
     *
     * Emits `Submitted`.
     *
     * @param {VaraRuntimeOriginCaller} proposalOrigin
     * @param {FrameSupportPreimagesBounded} proposal
     * @param {FrameSupportScheduleDispatchTime} enactmentMoment
     **/
    submit: GenericTxCall<
      Rv,
      (
        proposalOrigin: VaraRuntimeOriginCaller,
        proposal: FrameSupportPreimagesBounded,
        enactmentMoment: FrameSupportScheduleDispatchTime,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'Submit';
            params: {
              proposalOrigin: VaraRuntimeOriginCaller;
              proposal: FrameSupportPreimagesBounded;
              enactmentMoment: FrameSupportScheduleDispatchTime;
            };
          };
        }
      >
    >;

    /**
     * Post the Decision Deposit for a referendum.
     *
     * - `origin`: must be `Signed` and the account must have funds available for the
     * referendum's track's Decision Deposit.
     * - `index`: The index of the submitted referendum whose Decision Deposit is yet to be
     * posted.
     *
     * Emits `DecisionDepositPlaced`.
     *
     * @param {number} index
     **/
    placeDecisionDeposit: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'PlaceDecisionDeposit';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Refund the Decision Deposit for a closed referendum back to the depositor.
     *
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Decision Deposit has not yet been
     * refunded.
     *
     * Emits `DecisionDepositRefunded`.
     *
     * @param {number} index
     **/
    refundDecisionDeposit: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'RefundDecisionDeposit';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Cancel an ongoing referendum.
     *
     * - `origin`: must be the `CancelOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     *
     * Emits `Cancelled`.
     *
     * @param {number} index
     **/
    cancel: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'Cancel';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Cancel an ongoing referendum and slash the deposits.
     *
     * - `origin`: must be the `KillOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     *
     * Emits `Killed` and `DepositSlashed`.
     *
     * @param {number} index
     **/
    kill: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'Kill';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Advance a referendum onto its next logical state. Only used internally.
     *
     * - `origin`: must be `Root`.
     * - `index`: the referendum to be advanced.
     *
     * @param {number} index
     **/
    nudgeReferendum: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'NudgeReferendum';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Advance a track onto its next logical state. Only used internally.
     *
     * - `origin`: must be `Root`.
     * - `track`: the track to be advanced.
     *
     * Action item for when there is now one fewer referendum in the deciding phase and the
     * `DecidingCount` is not yet updated. This means that we should either:
     * - begin deciding another referendum (and leave `DecidingCount` alone); or
     * - decrement `DecidingCount`.
     *
     * @param {number} track
     **/
    oneFewerDeciding: GenericTxCall<
      Rv,
      (track: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'OneFewerDeciding';
            params: { track: number };
          };
        }
      >
    >;

    /**
     * Refund the Submission Deposit for a closed referendum back to the depositor.
     *
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Submission Deposit has not yet been
     * refunded.
     *
     * Emits `SubmissionDepositRefunded`.
     *
     * @param {number} index
     **/
    refundSubmissionDeposit: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'RefundSubmissionDeposit';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Set or clear metadata of a referendum.
     *
     * Parameters:
     * - `origin`: Must be `Signed` by a creator of a referendum or by anyone to clear a
     * metadata of a finished referendum.
     * - `index`: The index of a referendum to set or clear metadata for.
     * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
     *
     * @param {number} index
     * @param {H256 | undefined} maybeHash
     **/
    setMetadata: GenericTxCall<
      Rv,
      (
        index: number,
        maybeHash: H256 | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'SetMetadata';
            params: { index: number; maybeHash: H256 | undefined };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `FellowshipCollective`'s transaction calls
   **/
  fellowshipCollective: {
    /**
     * Introduce a new member.
     *
     * - `origin`: Must be the `AddOrigin`.
     * - `who`: Account of non-member which will become a member.
     *
     * Weight: `O(1)`
     *
     * @param {MultiAddressLike} who
     **/
    addMember: GenericTxCall<
      Rv,
      (who: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'FellowshipCollective';
          palletCall: {
            name: 'AddMember';
            params: { who: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Increment the rank of an existing member by one.
     *
     * - `origin`: Must be the `PromoteOrigin`.
     * - `who`: Account of existing member.
     *
     * Weight: `O(1)`
     *
     * @param {MultiAddressLike} who
     **/
    promoteMember: GenericTxCall<
      Rv,
      (who: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'FellowshipCollective';
          palletCall: {
            name: 'PromoteMember';
            params: { who: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Decrement the rank of an existing member by one. If the member is already at rank zero,
     * then they are removed entirely.
     *
     * - `origin`: Must be the `DemoteOrigin`.
     * - `who`: Account of existing member of rank greater than zero.
     *
     * Weight: `O(1)`, less if the member's index is highest in its rank.
     *
     * @param {MultiAddressLike} who
     **/
    demoteMember: GenericTxCall<
      Rv,
      (who: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'FellowshipCollective';
          palletCall: {
            name: 'DemoteMember';
            params: { who: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Remove the member entirely.
     *
     * - `origin`: Must be the `RemoveOrigin`.
     * - `who`: Account of existing member of rank greater than zero.
     * - `min_rank`: The rank of the member or greater.
     *
     * Weight: `O(min_rank)`.
     *
     * @param {MultiAddressLike} who
     * @param {number} minRank
     **/
    removeMember: GenericTxCall<
      Rv,
      (
        who: MultiAddressLike,
        minRank: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'FellowshipCollective';
          palletCall: {
            name: 'RemoveMember';
            params: { who: MultiAddressLike; minRank: number };
          };
        }
      >
    >;

    /**
     * Add an aye or nay vote for the sender to the given proposal.
     *
     * - `origin`: Must be `Signed` by a member account.
     * - `poll`: Index of a poll which is ongoing.
     * - `aye`: `true` if the vote is to approve the proposal, `false` otherwise.
     *
     * Transaction fees are be waived if the member is voting on any particular proposal
     * for the first time and the call is successful. Subsequent vote changes will charge a
     * fee.
     *
     * Weight: `O(1)`, less if there was no previous vote on the poll by the member.
     *
     * @param {number} poll
     * @param {boolean} aye
     **/
    vote: GenericTxCall<
      Rv,
      (
        poll: number,
        aye: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'FellowshipCollective';
          palletCall: {
            name: 'Vote';
            params: { poll: number; aye: boolean };
          };
        }
      >
    >;

    /**
     * Remove votes from the given poll. It must have ended.
     *
     * - `origin`: Must be `Signed` by any account.
     * - `poll_index`: Index of a poll which is completed and for which votes continue to
     * exist.
     * - `max`: Maximum number of vote items from remove in this call.
     *
     * Transaction fees are waived if the operation is successful.
     *
     * Weight `O(max)` (less if there are fewer items to remove than `max`).
     *
     * @param {number} pollIndex
     * @param {number} max
     **/
    cleanupPoll: GenericTxCall<
      Rv,
      (
        pollIndex: number,
        max: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'FellowshipCollective';
          palletCall: {
            name: 'CleanupPoll';
            params: { pollIndex: number; max: number };
          };
        }
      >
    >;

    /**
     * Exchanges a member with a new account and the same existing rank.
     *
     * - `origin`: Must be the `ExchangeOrigin`.
     * - `who`: Account of existing member of rank greater than zero to be exchanged.
     * - `new_who`: New Account of existing member of rank greater than zero to exchanged to.
     *
     * @param {MultiAddressLike} who
     * @param {MultiAddressLike} newWho
     **/
    exchangeMember: GenericTxCall<
      Rv,
      (
        who: MultiAddressLike,
        newWho: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'FellowshipCollective';
          palletCall: {
            name: 'ExchangeMember';
            params: { who: MultiAddressLike; newWho: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `FellowshipReferenda`'s transaction calls
   **/
  fellowshipReferenda: {
    /**
     * Propose a referendum on a privileged action.
     *
     * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
     * available.
     * - `proposal_origin`: The origin from which the proposal should be executed.
     * - `proposal`: The proposal.
     * - `enactment_moment`: The moment that the proposal should be enacted.
     *
     * Emits `Submitted`.
     *
     * @param {VaraRuntimeOriginCaller} proposalOrigin
     * @param {FrameSupportPreimagesBounded} proposal
     * @param {FrameSupportScheduleDispatchTime} enactmentMoment
     **/
    submit: GenericTxCall<
      Rv,
      (
        proposalOrigin: VaraRuntimeOriginCaller,
        proposal: FrameSupportPreimagesBounded,
        enactmentMoment: FrameSupportScheduleDispatchTime,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'FellowshipReferenda';
          palletCall: {
            name: 'Submit';
            params: {
              proposalOrigin: VaraRuntimeOriginCaller;
              proposal: FrameSupportPreimagesBounded;
              enactmentMoment: FrameSupportScheduleDispatchTime;
            };
          };
        }
      >
    >;

    /**
     * Post the Decision Deposit for a referendum.
     *
     * - `origin`: must be `Signed` and the account must have funds available for the
     * referendum's track's Decision Deposit.
     * - `index`: The index of the submitted referendum whose Decision Deposit is yet to be
     * posted.
     *
     * Emits `DecisionDepositPlaced`.
     *
     * @param {number} index
     **/
    placeDecisionDeposit: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'FellowshipReferenda';
          palletCall: {
            name: 'PlaceDecisionDeposit';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Refund the Decision Deposit for a closed referendum back to the depositor.
     *
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Decision Deposit has not yet been
     * refunded.
     *
     * Emits `DecisionDepositRefunded`.
     *
     * @param {number} index
     **/
    refundDecisionDeposit: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'FellowshipReferenda';
          palletCall: {
            name: 'RefundDecisionDeposit';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Cancel an ongoing referendum.
     *
     * - `origin`: must be the `CancelOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     *
     * Emits `Cancelled`.
     *
     * @param {number} index
     **/
    cancel: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'FellowshipReferenda';
          palletCall: {
            name: 'Cancel';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Cancel an ongoing referendum and slash the deposits.
     *
     * - `origin`: must be the `KillOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     *
     * Emits `Killed` and `DepositSlashed`.
     *
     * @param {number} index
     **/
    kill: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'FellowshipReferenda';
          palletCall: {
            name: 'Kill';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Advance a referendum onto its next logical state. Only used internally.
     *
     * - `origin`: must be `Root`.
     * - `index`: the referendum to be advanced.
     *
     * @param {number} index
     **/
    nudgeReferendum: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'FellowshipReferenda';
          palletCall: {
            name: 'NudgeReferendum';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Advance a track onto its next logical state. Only used internally.
     *
     * - `origin`: must be `Root`.
     * - `track`: the track to be advanced.
     *
     * Action item for when there is now one fewer referendum in the deciding phase and the
     * `DecidingCount` is not yet updated. This means that we should either:
     * - begin deciding another referendum (and leave `DecidingCount` alone); or
     * - decrement `DecidingCount`.
     *
     * @param {number} track
     **/
    oneFewerDeciding: GenericTxCall<
      Rv,
      (track: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'FellowshipReferenda';
          palletCall: {
            name: 'OneFewerDeciding';
            params: { track: number };
          };
        }
      >
    >;

    /**
     * Refund the Submission Deposit for a closed referendum back to the depositor.
     *
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Submission Deposit has not yet been
     * refunded.
     *
     * Emits `SubmissionDepositRefunded`.
     *
     * @param {number} index
     **/
    refundSubmissionDeposit: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'FellowshipReferenda';
          palletCall: {
            name: 'RefundSubmissionDeposit';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Set or clear metadata of a referendum.
     *
     * Parameters:
     * - `origin`: Must be `Signed` by a creator of a referendum or by anyone to clear a
     * metadata of a finished referendum.
     * - `index`: The index of a referendum to set or clear metadata for.
     * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
     *
     * @param {number} index
     * @param {H256 | undefined} maybeHash
     **/
    setMetadata: GenericTxCall<
      Rv,
      (
        index: number,
        maybeHash: H256 | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'FellowshipReferenda';
          palletCall: {
            name: 'SetMetadata';
            params: { index: number; maybeHash: H256 | undefined };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Whitelist`'s transaction calls
   **/
  whitelist: {
    /**
     *
     * @param {H256} callHash
     **/
    whitelistCall: GenericTxCall<
      Rv,
      (callHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Whitelist';
          palletCall: {
            name: 'WhitelistCall';
            params: { callHash: H256 };
          };
        }
      >
    >;

    /**
     *
     * @param {H256} callHash
     **/
    removeWhitelistedCall: GenericTxCall<
      Rv,
      (callHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Whitelist';
          palletCall: {
            name: 'RemoveWhitelistedCall';
            params: { callHash: H256 };
          };
        }
      >
    >;

    /**
     *
     * @param {H256} callHash
     * @param {number} callEncodedLen
     * @param {SpWeightsWeightV2Weight} callWeightWitness
     **/
    dispatchWhitelistedCall: GenericTxCall<
      Rv,
      (
        callHash: H256,
        callEncodedLen: number,
        callWeightWitness: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Whitelist';
          palletCall: {
            name: 'DispatchWhitelistedCall';
            params: { callHash: H256; callEncodedLen: number; callWeightWitness: SpWeightsWeightV2Weight };
          };
        }
      >
    >;

    /**
     *
     * @param {VaraRuntimeRuntimeCallLike} call
     **/
    dispatchWhitelistedCallWithPreimage: GenericTxCall<
      Rv,
      (call: VaraRuntimeRuntimeCallLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Whitelist';
          palletCall: {
            name: 'DispatchWhitelistedCallWithPreimage';
            params: { call: VaraRuntimeRuntimeCallLike };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Scheduler`'s transaction calls
   **/
  scheduler: {
    /**
     * Anonymously schedule a task.
     *
     * @param {number} when
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {VaraRuntimeRuntimeCallLike} call
     **/
    schedule: GenericTxCall<
      Rv,
      (
        when: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: VaraRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'Schedule';
            params: {
              when: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: VaraRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Cancel an anonymously scheduled task.
     *
     * @param {number} when
     * @param {number} index
     **/
    cancel: GenericTxCall<
      Rv,
      (
        when: number,
        index: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'Cancel';
            params: { when: number; index: number };
          };
        }
      >
    >;

    /**
     * Schedule a named task.
     *
     * @param {FixedBytes<32>} id
     * @param {number} when
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {VaraRuntimeRuntimeCallLike} call
     **/
    scheduleNamed: GenericTxCall<
      Rv,
      (
        id: FixedBytes<32>,
        when: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: VaraRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'ScheduleNamed';
            params: {
              id: FixedBytes<32>;
              when: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: VaraRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Cancel a named scheduled task.
     *
     * @param {FixedBytes<32>} id
     **/
    cancelNamed: GenericTxCall<
      Rv,
      (id: FixedBytes<32>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'CancelNamed';
            params: { id: FixedBytes<32> };
          };
        }
      >
    >;

    /**
     * Anonymously schedule a task after a delay.
     *
     * @param {number} after
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {VaraRuntimeRuntimeCallLike} call
     **/
    scheduleAfter: GenericTxCall<
      Rv,
      (
        after: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: VaraRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'ScheduleAfter';
            params: {
              after: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: VaraRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Schedule a named task after a delay.
     *
     * @param {FixedBytes<32>} id
     * @param {number} after
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {VaraRuntimeRuntimeCallLike} call
     **/
    scheduleNamedAfter: GenericTxCall<
      Rv,
      (
        id: FixedBytes<32>,
        after: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: VaraRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'ScheduleNamedAfter';
            params: {
              id: FixedBytes<32>;
              after: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: VaraRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Set a retry configuration for a task so that, in case its scheduled run fails, it will
     * be retried after `period` blocks, for a total amount of `retries` retries or until it
     * succeeds.
     *
     * Tasks which need to be scheduled for a retry are still subject to weight metering and
     * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
     * normally while the task is retrying.
     *
     * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
     * clones of the original task. Their retry configuration will be derived from the
     * original task's configuration, but will have a lower value for `remaining` than the
     * original `total_retries`.
     *
     * @param {[number, number]} task
     * @param {number} retries
     * @param {number} period
     **/
    setRetry: GenericTxCall<
      Rv,
      (
        task: [number, number],
        retries: number,
        period: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'SetRetry';
            params: { task: [number, number]; retries: number; period: number };
          };
        }
      >
    >;

    /**
     * Set a retry configuration for a named task so that, in case its scheduled run fails, it
     * will be retried after `period` blocks, for a total amount of `retries` retries or until
     * it succeeds.
     *
     * Tasks which need to be scheduled for a retry are still subject to weight metering and
     * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
     * normally while the task is retrying.
     *
     * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
     * clones of the original task. Their retry configuration will be derived from the
     * original task's configuration, but will have a lower value for `remaining` than the
     * original `total_retries`.
     *
     * @param {FixedBytes<32>} id
     * @param {number} retries
     * @param {number} period
     **/
    setRetryNamed: GenericTxCall<
      Rv,
      (
        id: FixedBytes<32>,
        retries: number,
        period: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'SetRetryNamed';
            params: { id: FixedBytes<32>; retries: number; period: number };
          };
        }
      >
    >;

    /**
     * Removes the retry configuration of a task.
     *
     * @param {[number, number]} task
     **/
    cancelRetry: GenericTxCall<
      Rv,
      (task: [number, number]) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'CancelRetry';
            params: { task: [number, number] };
          };
        }
      >
    >;

    /**
     * Cancel the retry configuration of a named task.
     *
     * @param {FixedBytes<32>} id
     **/
    cancelRetryNamed: GenericTxCall<
      Rv,
      (id: FixedBytes<32>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'CancelRetryNamed';
            params: { id: FixedBytes<32> };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Preimage`'s transaction calls
   **/
  preimage: {
    /**
     * Register a preimage on-chain.
     *
     * If the preimage was previously requested, no fees or deposits are taken for providing
     * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
     *
     * @param {BytesLike} bytes
     **/
    notePreimage: GenericTxCall<
      Rv,
      (bytes: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'NotePreimage';
            params: { bytes: BytesLike };
          };
        }
      >
    >;

    /**
     * Clear an unrequested preimage from the runtime storage.
     *
     * If `len` is provided, then it will be a much cheaper operation.
     *
     * - `hash`: The hash of the preimage to be removed from the store.
     * - `len`: The length of the preimage of `hash`.
     *
     * @param {H256} hash
     **/
    unnotePreimage: GenericTxCall<
      Rv,
      (hash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'UnnotePreimage';
            params: { hash: H256 };
          };
        }
      >
    >;

    /**
     * Request a preimage be uploaded to the chain without paying any fees or deposits.
     *
     * If the preimage requests has already been provided on-chain, we unreserve any deposit
     * a user may have paid, and take the control of the preimage out of their hands.
     *
     * @param {H256} hash
     **/
    requestPreimage: GenericTxCall<
      Rv,
      (hash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'RequestPreimage';
            params: { hash: H256 };
          };
        }
      >
    >;

    /**
     * Clear a previously made request for a preimage.
     *
     * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
     *
     * @param {H256} hash
     **/
    unrequestPreimage: GenericTxCall<
      Rv,
      (hash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'UnrequestPreimage';
            params: { hash: H256 };
          };
        }
      >
    >;

    /**
     * Ensure that the a bulk of pre-images is upgraded.
     *
     * The caller pays no fee if at least 90% of pre-images were successfully updated.
     *
     * @param {Array<H256>} hashes
     **/
    ensureUpdated: GenericTxCall<
      Rv,
      (hashes: Array<H256>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'EnsureUpdated';
            params: { hashes: Array<H256> };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Identity`'s transaction calls
   **/
  identity: {
    /**
     * Add a registrar to the system.
     *
     * The dispatch origin for this call must be `T::RegistrarOrigin`.
     *
     * - `account`: the account of the registrar.
     *
     * Emits `RegistrarAdded` if successful.
     *
     * @param {MultiAddressLike} account
     **/
    addRegistrar: GenericTxCall<
      Rv,
      (account: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'AddRegistrar';
            params: { account: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Set an account's identity information and reserve the appropriate deposit.
     *
     * If the account already has identity information, the deposit is taken as part payment
     * for the new deposit.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `info`: The identity information.
     *
     * Emits `IdentitySet` if successful.
     *
     * @param {PalletIdentityLegacyIdentityInfo} info
     **/
    setIdentity: GenericTxCall<
      Rv,
      (info: PalletIdentityLegacyIdentityInfo) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetIdentity';
            params: { info: PalletIdentityLegacyIdentityInfo };
          };
        }
      >
    >;

    /**
     * Set the sub-accounts of the sender.
     *
     * Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
     * and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * identity.
     *
     * - `subs`: The identity's (new) sub-accounts.
     *
     * @param {Array<[AccountId32Like, Data]>} subs
     **/
    setSubs: GenericTxCall<
      Rv,
      (subs: Array<[AccountId32Like, Data]>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetSubs';
            params: { subs: Array<[AccountId32Like, Data]> };
          };
        }
      >
    >;

    /**
     * Clear an account's identity info and all sub-accounts and return all deposits.
     *
     * Payment: All reserved balances on the account are returned.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * identity.
     *
     * Emits `IdentityCleared` if successful.
     *
     **/
    clearIdentity: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'ClearIdentity';
          };
        }
      >
    >;

    /**
     * Request a judgement from a registrar.
     *
     * Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
     * given.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a
     * registered identity.
     *
     * - `reg_index`: The index of the registrar whose judgement is requested.
     * - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
     *
     * ```nocompile
     * Registrars::<T>::get().get(reg_index).unwrap().fee
     * ```
     *
     * Emits `JudgementRequested` if successful.
     *
     * @param {number} regIndex
     * @param {bigint} maxFee
     **/
    requestJudgement: GenericTxCall<
      Rv,
      (
        regIndex: number,
        maxFee: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RequestJudgement';
            params: { regIndex: number; maxFee: bigint };
          };
        }
      >
    >;

    /**
     * Cancel a previous request.
     *
     * Payment: A previously reserved deposit is returned on success.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a
     * registered identity.
     *
     * - `reg_index`: The index of the registrar whose judgement is no longer requested.
     *
     * Emits `JudgementUnrequested` if successful.
     *
     * @param {number} regIndex
     **/
    cancelRequest: GenericTxCall<
      Rv,
      (regIndex: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'CancelRequest';
            params: { regIndex: number };
          };
        }
      >
    >;

    /**
     * Set the fee required for a judgement to be requested from a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `fee`: the new fee.
     *
     * @param {number} index
     * @param {bigint} fee
     **/
    setFee: GenericTxCall<
      Rv,
      (
        index: number,
        fee: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetFee';
            params: { index: number; fee: bigint };
          };
        }
      >
    >;

    /**
     * Change the account associated with a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `new`: the new account ID.
     *
     * @param {number} index
     * @param {MultiAddressLike} new_
     **/
    setAccountId: GenericTxCall<
      Rv,
      (
        index: number,
        new_: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetAccountId';
            params: { index: number; new: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Set the field information for a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `fields`: the fields that the registrar concerns themselves with.
     *
     * @param {number} index
     * @param {bigint} fields
     **/
    setFields: GenericTxCall<
      Rv,
      (
        index: number,
        fields: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetFields';
            params: { index: number; fields: bigint };
          };
        }
      >
    >;

    /**
     * Provide a judgement for an account's identity.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `reg_index`.
     *
     * - `reg_index`: the index of the registrar whose judgement is being made.
     * - `target`: the account whose identity the judgement is upon. This must be an account
     * with a registered identity.
     * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
     * - `identity`: The hash of the [`IdentityInformationProvider`] for that the judgement is
     * provided.
     *
     * Note: Judgements do not apply to a username.
     *
     * Emits `JudgementGiven` if successful.
     *
     * @param {number} regIndex
     * @param {MultiAddressLike} target
     * @param {PalletIdentityJudgement} judgement
     * @param {H256} identity
     **/
    provideJudgement: GenericTxCall<
      Rv,
      (
        regIndex: number,
        target: MultiAddressLike,
        judgement: PalletIdentityJudgement,
        identity: H256,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'ProvideJudgement';
            params: { regIndex: number; target: MultiAddressLike; judgement: PalletIdentityJudgement; identity: H256 };
          };
        }
      >
    >;

    /**
     * Remove an account's identity and sub-account information and slash the deposits.
     *
     * Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
     * `Slash`. Verification request deposits are not returned; they should be cancelled
     * manually using `cancel_request`.
     *
     * The dispatch origin for this call must match `T::ForceOrigin`.
     *
     * - `target`: the account whose identity the judgement is upon. This must be an account
     * with a registered identity.
     *
     * Emits `IdentityKilled` if successful.
     *
     * @param {MultiAddressLike} target
     **/
    killIdentity: GenericTxCall<
      Rv,
      (target: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'KillIdentity';
            params: { target: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Add the given account to the sender's subs.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     *
     * @param {MultiAddressLike} sub
     * @param {Data} data
     **/
    addSub: GenericTxCall<
      Rv,
      (
        sub: MultiAddressLike,
        data: Data,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'AddSub';
            params: { sub: MultiAddressLike; data: Data };
          };
        }
      >
    >;

    /**
     * Alter the associated name of the given sub-account.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     *
     * @param {MultiAddressLike} sub
     * @param {Data} data
     **/
    renameSub: GenericTxCall<
      Rv,
      (
        sub: MultiAddressLike,
        data: Data,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RenameSub';
            params: { sub: MultiAddressLike; data: Data };
          };
        }
      >
    >;

    /**
     * Remove the given account from the sender's subs.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     *
     * @param {MultiAddressLike} sub
     **/
    removeSub: GenericTxCall<
      Rv,
      (sub: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RemoveSub';
            params: { sub: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Remove the sender as a sub-account.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender (*not* the original depositor).
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * super-identity.
     *
     * NOTE: This should not normally be used, but is provided in the case that the non-
     * controller of an account is maliciously registered as a sub-account.
     *
     **/
    quitSub: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'QuitSub';
          };
        }
      >
    >;

    /**
     * Add an `AccountId` with permission to grant usernames with a given `suffix` appended.
     *
     * The authority can grant up to `allocation` usernames. To top up their allocation, they
     * should just issue (or request via governance) a new `add_username_authority` call.
     *
     * @param {MultiAddressLike} authority
     * @param {BytesLike} suffix
     * @param {number} allocation
     **/
    addUsernameAuthority: GenericTxCall<
      Rv,
      (
        authority: MultiAddressLike,
        suffix: BytesLike,
        allocation: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'AddUsernameAuthority';
            params: { authority: MultiAddressLike; suffix: BytesLike; allocation: number };
          };
        }
      >
    >;

    /**
     * Remove `authority` from the username authorities.
     *
     * @param {MultiAddressLike} authority
     **/
    removeUsernameAuthority: GenericTxCall<
      Rv,
      (authority: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RemoveUsernameAuthority';
            params: { authority: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Set the username for `who`. Must be called by a username authority.
     *
     * The authority must have an `allocation`. Users can either pre-sign their usernames or
     * accept them later.
     *
     * Usernames must:
     * - Only contain lowercase ASCII characters or digits.
     * - When combined with the suffix of the issuing authority be _less than_ the
     * `MaxUsernameLength`.
     *
     * @param {MultiAddressLike} who
     * @param {BytesLike} username
     * @param {SpRuntimeMultiSignature | undefined} signature
     **/
    setUsernameFor: GenericTxCall<
      Rv,
      (
        who: MultiAddressLike,
        username: BytesLike,
        signature: SpRuntimeMultiSignature | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetUsernameFor';
            params: { who: MultiAddressLike; username: BytesLike; signature: SpRuntimeMultiSignature | undefined };
          };
        }
      >
    >;

    /**
     * Accept a given username that an `authority` granted. The call must include the full
     * username, as in `username.suffix`.
     *
     * @param {BytesLike} username
     **/
    acceptUsername: GenericTxCall<
      Rv,
      (username: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'AcceptUsername';
            params: { username: BytesLike };
          };
        }
      >
    >;

    /**
     * Remove an expired username approval. The username was approved by an authority but never
     * accepted by the user and must now be beyond its expiration. The call must include the
     * full username, as in `username.suffix`.
     *
     * @param {BytesLike} username
     **/
    removeExpiredApproval: GenericTxCall<
      Rv,
      (username: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RemoveExpiredApproval';
            params: { username: BytesLike };
          };
        }
      >
    >;

    /**
     * Set a given username as the primary. The username should include the suffix.
     *
     * @param {BytesLike} username
     **/
    setPrimaryUsername: GenericTxCall<
      Rv,
      (username: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetPrimaryUsername';
            params: { username: BytesLike };
          };
        }
      >
    >;

    /**
     * Remove a username that corresponds to an account with no identity. Exists when a user
     * gets a username but then calls `clear_identity`.
     *
     * @param {BytesLike} username
     **/
    removeDanglingUsername: GenericTxCall<
      Rv,
      (username: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RemoveDanglingUsername';
            params: { username: BytesLike };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Proxy`'s transaction calls
   **/
  proxy: {
    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     *
     * @param {MultiAddressLike} real
     * @param {VaraRuntimeProxyType | undefined} forceProxyType
     * @param {VaraRuntimeRuntimeCallLike} call
     **/
    proxy: GenericTxCall<
      Rv,
      (
        real: MultiAddressLike,
        forceProxyType: VaraRuntimeProxyType | undefined,
        call: VaraRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'Proxy';
            params: {
              real: MultiAddressLike;
              forceProxyType: VaraRuntimeProxyType | undefined;
              call: VaraRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Register a proxy account for the sender that is able to make calls on its behalf.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `proxy`: The account that the `caller` would like to make a proxy.
     * - `proxy_type`: The permissions allowed for this proxy account.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     *
     * @param {MultiAddressLike} delegate
     * @param {VaraRuntimeProxyType} proxyType
     * @param {number} delay
     **/
    addProxy: GenericTxCall<
      Rv,
      (
        delegate: MultiAddressLike,
        proxyType: VaraRuntimeProxyType,
        delay: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'AddProxy';
            params: { delegate: MultiAddressLike; proxyType: VaraRuntimeProxyType; delay: number };
          };
        }
      >
    >;

    /**
     * Unregister a proxy account for the sender.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `proxy`: The account that the `caller` would like to remove as a proxy.
     * - `proxy_type`: The permissions currently enabled for the removed proxy account.
     *
     * @param {MultiAddressLike} delegate
     * @param {VaraRuntimeProxyType} proxyType
     * @param {number} delay
     **/
    removeProxy: GenericTxCall<
      Rv,
      (
        delegate: MultiAddressLike,
        proxyType: VaraRuntimeProxyType,
        delay: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'RemoveProxy';
            params: { delegate: MultiAddressLike; proxyType: VaraRuntimeProxyType; delay: number };
          };
        }
      >
    >;

    /**
     * Unregister all proxy accounts for the sender.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * WARNING: This may be called on accounts created by `pure`, however if done, then
     * the unreserved fees will be inaccessible. **All access to this account will be lost.**
     *
     **/
    removeProxies: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'RemoveProxies';
          };
        }
      >
    >;

    /**
     * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
     * initialize it with a proxy of `proxy_type` for `origin` sender.
     *
     * Requires a `Signed` origin.
     *
     * - `proxy_type`: The type of the proxy that the sender will be registered as over the
     * new account. This will almost always be the most permissive `ProxyType` possible to
     * allow for maximum flexibility.
     * - `index`: A disambiguation index, in case this is called multiple times in the same
     * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
     * want to use `0`.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     *
     * Fails with `Duplicate` if this has already been called in this transaction, from the
     * same sender, with the same parameters.
     *
     * Fails if there are insufficient funds to pay for deposit.
     *
     * @param {VaraRuntimeProxyType} proxyType
     * @param {number} delay
     * @param {number} index
     **/
    createPure: GenericTxCall<
      Rv,
      (
        proxyType: VaraRuntimeProxyType,
        delay: number,
        index: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'CreatePure';
            params: { proxyType: VaraRuntimeProxyType; delay: number; index: number };
          };
        }
      >
    >;

    /**
     * Removes a previously spawned pure proxy.
     *
     * WARNING: **All access to this account will be lost.** Any funds held in it will be
     * inaccessible.
     *
     * Requires a `Signed` origin, and the sender account must have been created by a call to
     * `pure` with corresponding parameters.
     *
     * - `spawner`: The account that originally called `pure` to create this account.
     * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
     * - `proxy_type`: The proxy type originally passed to `pure`.
     * - `height`: The height of the chain when the call to `pure` was processed.
     * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
     *
     * Fails with `NoPermission` in case the caller is not a previously created pure
     * account whose `pure` call has corresponding parameters.
     *
     * @param {MultiAddressLike} spawner
     * @param {VaraRuntimeProxyType} proxyType
     * @param {number} index
     * @param {number} height
     * @param {number} extIndex
     **/
    killPure: GenericTxCall<
      Rv,
      (
        spawner: MultiAddressLike,
        proxyType: VaraRuntimeProxyType,
        index: number,
        height: number,
        extIndex: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'KillPure';
            params: {
              spawner: MultiAddressLike;
              proxyType: VaraRuntimeProxyType;
              index: number;
              height: number;
              extIndex: number;
            };
          };
        }
      >
    >;

    /**
     * Publish the hash of a proxy-call that will be made in the future.
     *
     * This must be called some number of blocks before the corresponding `proxy` is attempted
     * if the delay associated with the proxy relationship is greater than zero.
     *
     * No more than `MaxPending` announcements may be made at any one time.
     *
     * This will take a deposit of `AnnouncementDepositFactor` as well as
     * `AnnouncementDepositBase` if there are no other pending announcements.
     *
     * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     *
     * @param {MultiAddressLike} real
     * @param {H256} callHash
     **/
    announce: GenericTxCall<
      Rv,
      (
        real: MultiAddressLike,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'Announce';
            params: { real: MultiAddressLike; callHash: H256 };
          };
        }
      >
    >;

    /**
     * Remove a given announcement.
     *
     * May be called by a proxy account to remove a call they previously announced and return
     * the deposit.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     *
     * @param {MultiAddressLike} real
     * @param {H256} callHash
     **/
    removeAnnouncement: GenericTxCall<
      Rv,
      (
        real: MultiAddressLike,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'RemoveAnnouncement';
            params: { real: MultiAddressLike; callHash: H256 };
          };
        }
      >
    >;

    /**
     * Remove the given announcement of a delegate.
     *
     * May be called by a target (proxied) account to remove a call that one of their delegates
     * (`delegate`) has announced they want to execute. The deposit is returned.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `delegate`: The account that previously announced the call.
     * - `call_hash`: The hash of the call to be made.
     *
     * @param {MultiAddressLike} delegate
     * @param {H256} callHash
     **/
    rejectAnnouncement: GenericTxCall<
      Rv,
      (
        delegate: MultiAddressLike,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'RejectAnnouncement';
            params: { delegate: MultiAddressLike; callHash: H256 };
          };
        }
      >
    >;

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     *
     * Removes any corresponding announcement(s).
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     *
     * @param {MultiAddressLike} delegate
     * @param {MultiAddressLike} real
     * @param {VaraRuntimeProxyType | undefined} forceProxyType
     * @param {VaraRuntimeRuntimeCallLike} call
     **/
    proxyAnnounced: GenericTxCall<
      Rv,
      (
        delegate: MultiAddressLike,
        real: MultiAddressLike,
        forceProxyType: VaraRuntimeProxyType | undefined,
        call: VaraRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'ProxyAnnounced';
            params: {
              delegate: MultiAddressLike;
              real: MultiAddressLike;
              forceProxyType: VaraRuntimeProxyType | undefined;
              call: VaraRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Multisig`'s transaction calls
   **/
  multisig: {
    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     *
     * Result is equivalent to the dispatched result.
     *
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     *
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {VaraRuntimeRuntimeCallLike} call
     **/
    asMultiThreshold1: GenericTxCall<
      Rv,
      (
        otherSignatories: Array<AccountId32Like>,
        call: VaraRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'AsMultiThreshold1';
            params: { otherSignatories: Array<AccountId32Like>; call: VaraRuntimeRuntimeCallLike };
          };
        }
      >
    >;

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     *
     * If there are enough, then dispatch the call.
     *
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     *
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     *
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     *
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     *
     * @param {number} threshold
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {PalletMultisigTimepoint | undefined} maybeTimepoint
     * @param {VaraRuntimeRuntimeCallLike} call
     * @param {SpWeightsWeightV2Weight} maxWeight
     **/
    asMulti: GenericTxCall<
      Rv,
      (
        threshold: number,
        otherSignatories: Array<AccountId32Like>,
        maybeTimepoint: PalletMultisigTimepoint | undefined,
        call: VaraRuntimeRuntimeCallLike,
        maxWeight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'AsMulti';
            params: {
              threshold: number;
              otherSignatories: Array<AccountId32Like>;
              maybeTimepoint: PalletMultisigTimepoint | undefined;
              call: VaraRuntimeRuntimeCallLike;
              maxWeight: SpWeightsWeightV2Weight;
            };
          };
        }
      >
    >;

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     *
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call_hash`: The hash of the call to be executed.
     *
     * NOTE: If this is the final approval, you will want to use `as_multi` instead.
     *
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     *
     * @param {number} threshold
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {PalletMultisigTimepoint | undefined} maybeTimepoint
     * @param {FixedBytes<32>} callHash
     * @param {SpWeightsWeightV2Weight} maxWeight
     **/
    approveAsMulti: GenericTxCall<
      Rv,
      (
        threshold: number,
        otherSignatories: Array<AccountId32Like>,
        maybeTimepoint: PalletMultisigTimepoint | undefined,
        callHash: FixedBytes<32>,
        maxWeight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'ApproveAsMulti';
            params: {
              threshold: number;
              otherSignatories: Array<AccountId32Like>;
              maybeTimepoint: PalletMultisigTimepoint | undefined;
              callHash: FixedBytes<32>;
              maxWeight: SpWeightsWeightV2Weight;
            };
          };
        }
      >
    >;

    /**
     * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
     * for this operation will be unreserved on success.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `timepoint`: The timepoint (block number and transaction index) of the first approval
     * transaction for this dispatch.
     * - `call_hash`: The hash of the call to be executed.
     *
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - One event.
     * - I/O: 1 read `O(S)`, one remove.
     * - Storage: removes one item.
     *
     * @param {number} threshold
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {PalletMultisigTimepoint} timepoint
     * @param {FixedBytes<32>} callHash
     **/
    cancelAsMulti: GenericTxCall<
      Rv,
      (
        threshold: number,
        otherSignatories: Array<AccountId32Like>,
        timepoint: PalletMultisigTimepoint,
        callHash: FixedBytes<32>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'CancelAsMulti';
            params: {
              threshold: number;
              otherSignatories: Array<AccountId32Like>;
              timepoint: PalletMultisigTimepoint;
              callHash: FixedBytes<32>;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `ElectionProviderMultiPhase`'s transaction calls
   **/
  electionProviderMultiPhase: {
    /**
     * Submit a solution for the unsigned phase.
     *
     * The dispatch origin fo this call must be __none__.
     *
     * This submission is checked on the fly. Moreover, this unsigned solution is only
     * validated when submitted to the pool from the **local** node. Effectively, this means
     * that only active validators can submit this transaction when authoring a block (similar
     * to an inherent).
     *
     * To prevent any incorrect solution (and thus wasted time/weight), this transaction will
     * panic if the solution submitted by the validator is invalid in any way, effectively
     * putting their authoring reward at risk.
     *
     * No deposit or reward is associated with this submission.
     *
     * @param {PalletElectionProviderMultiPhaseRawSolution} rawSolution
     * @param {PalletElectionProviderMultiPhaseSolutionOrSnapshotSize} witness
     **/
    submitUnsigned: GenericTxCall<
      Rv,
      (
        rawSolution: PalletElectionProviderMultiPhaseRawSolution,
        witness: PalletElectionProviderMultiPhaseSolutionOrSnapshotSize,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ElectionProviderMultiPhase';
          palletCall: {
            name: 'SubmitUnsigned';
            params: {
              rawSolution: PalletElectionProviderMultiPhaseRawSolution;
              witness: PalletElectionProviderMultiPhaseSolutionOrSnapshotSize;
            };
          };
        }
      >
    >;

    /**
     * Set a new value for `MinimumUntrustedScore`.
     *
     * Dispatch origin must be aligned with `T::ForceOrigin`.
     *
     * This check can be turned off by setting the value to `None`.
     *
     * @param {SpNposElectionsElectionScore | undefined} maybeNextScore
     **/
    setMinimumUntrustedScore: GenericTxCall<
      Rv,
      (maybeNextScore: SpNposElectionsElectionScore | undefined) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ElectionProviderMultiPhase';
          palletCall: {
            name: 'SetMinimumUntrustedScore';
            params: { maybeNextScore: SpNposElectionsElectionScore | undefined };
          };
        }
      >
    >;

    /**
     * Set a solution in the queue, to be handed out to the client of this pallet in the next
     * call to `ElectionProvider::elect`.
     *
     * This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`.
     *
     * The solution is not checked for any feasibility and is assumed to be trustworthy, as any
     * feasibility check itself can in principle cause the election process to fail (due to
     * memory/weight constrains).
     *
     * @param {Array<[AccountId32Like, SpNposElectionsSupport]>} supports
     **/
    setEmergencyElectionResult: GenericTxCall<
      Rv,
      (supports: Array<[AccountId32Like, SpNposElectionsSupport]>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ElectionProviderMultiPhase';
          palletCall: {
            name: 'SetEmergencyElectionResult';
            params: { supports: Array<[AccountId32Like, SpNposElectionsSupport]> };
          };
        }
      >
    >;

    /**
     * Submit a solution for the signed phase.
     *
     * The dispatch origin fo this call must be __signed__.
     *
     * The solution is potentially queued, based on the claimed score and processed at the end
     * of the signed phase.
     *
     * A deposit is reserved and recorded for the solution. Based on the outcome, the solution
     * might be rewarded, slashed, or get all or a part of the deposit back.
     *
     * @param {PalletElectionProviderMultiPhaseRawSolution} rawSolution
     **/
    submit: GenericTxCall<
      Rv,
      (rawSolution: PalletElectionProviderMultiPhaseRawSolution) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ElectionProviderMultiPhase';
          palletCall: {
            name: 'Submit';
            params: { rawSolution: PalletElectionProviderMultiPhaseRawSolution };
          };
        }
      >
    >;

    /**
     * Trigger the governance fallback.
     *
     * This can only be called when [`Phase::Emergency`] is enabled, as an alternative to
     * calling [`Call::set_emergency_election_result`].
     *
     * @param {number | undefined} maybeMaxVoters
     * @param {number | undefined} maybeMaxTargets
     **/
    governanceFallback: GenericTxCall<
      Rv,
      (
        maybeMaxVoters: number | undefined,
        maybeMaxTargets: number | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ElectionProviderMultiPhase';
          palletCall: {
            name: 'GovernanceFallback';
            params: { maybeMaxVoters: number | undefined; maybeMaxTargets: number | undefined };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Bounties`'s transaction calls
   **/
  bounties: {
    /**
     * Propose a new bounty.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
     * `DataDepositPerByte` for each byte in `reason`. It will be unreserved upon approval,
     * or slashed when rejected.
     *
     * - `curator`: The curator account whom will manage this bounty.
     * - `fee`: The curator fee.
     * - `value`: The total payment amount of this bounty, curator fee included.
     * - `description`: The description of this bounty.
     *
     * @param {bigint} value
     * @param {BytesLike} description
     **/
    proposeBounty: GenericTxCall<
      Rv,
      (
        value: bigint,
        description: BytesLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Bounties';
          palletCall: {
            name: 'ProposeBounty';
            params: { value: bigint; description: BytesLike };
          };
        }
      >
    >;

    /**
     * Approve a bounty proposal. At a later time, the bounty will be funded and become active
     * and the original deposit will be returned.
     *
     * May only be called from `T::SpendOrigin`.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {number} bountyId
     **/
    approveBounty: GenericTxCall<
      Rv,
      (bountyId: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Bounties';
          palletCall: {
            name: 'ApproveBounty';
            params: { bountyId: number };
          };
        }
      >
    >;

    /**
     * Propose a curator to a funded bounty.
     *
     * May only be called from `T::SpendOrigin`.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {number} bountyId
     * @param {MultiAddressLike} curator
     * @param {bigint} fee
     **/
    proposeCurator: GenericTxCall<
      Rv,
      (
        bountyId: number,
        curator: MultiAddressLike,
        fee: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Bounties';
          palletCall: {
            name: 'ProposeCurator';
            params: { bountyId: number; curator: MultiAddressLike; fee: bigint };
          };
        }
      >
    >;

    /**
     * Unassign curator from a bounty.
     *
     * This function can only be called by the `RejectOrigin` a signed origin.
     *
     * If this function is called by the `RejectOrigin`, we assume that the curator is
     * malicious or inactive. As a result, we will slash the curator when possible.
     *
     * If the origin is the curator, we take this as a sign they are unable to do their job and
     * they willingly give up. We could slash them, but for now we allow them to recover their
     * deposit and exit without issue. (We may want to change this if it is abused.)
     *
     * Finally, the origin can be anyone if and only if the curator is "inactive". This allows
     * anyone in the community to call out that a curator is not doing their due diligence, and
     * we should pick a new curator. In this case the curator should also be slashed.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {number} bountyId
     **/
    unassignCurator: GenericTxCall<
      Rv,
      (bountyId: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Bounties';
          palletCall: {
            name: 'UnassignCurator';
            params: { bountyId: number };
          };
        }
      >
    >;

    /**
     * Accept the curator role for a bounty.
     * A deposit will be reserved from curator and refund upon successful payout.
     *
     * May only be called from the curator.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {number} bountyId
     **/
    acceptCurator: GenericTxCall<
      Rv,
      (bountyId: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Bounties';
          palletCall: {
            name: 'AcceptCurator';
            params: { bountyId: number };
          };
        }
      >
    >;

    /**
     * Award bounty to a beneficiary account. The beneficiary will be able to claim the funds
     * after a delay.
     *
     * The dispatch origin for this call must be the curator of this bounty.
     *
     * - `bounty_id`: Bounty ID to award.
     * - `beneficiary`: The beneficiary account whom will receive the payout.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {number} bountyId
     * @param {MultiAddressLike} beneficiary
     **/
    awardBounty: GenericTxCall<
      Rv,
      (
        bountyId: number,
        beneficiary: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Bounties';
          palletCall: {
            name: 'AwardBounty';
            params: { bountyId: number; beneficiary: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Claim the payout from an awarded bounty after payout delay.
     *
     * The dispatch origin for this call must be the beneficiary of this bounty.
     *
     * - `bounty_id`: Bounty ID to claim.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {number} bountyId
     **/
    claimBounty: GenericTxCall<
      Rv,
      (bountyId: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Bounties';
          palletCall: {
            name: 'ClaimBounty';
            params: { bountyId: number };
          };
        }
      >
    >;

    /**
     * Cancel a proposed or active bounty. All the funds will be sent to treasury and
     * the curator deposit will be unreserved if possible.
     *
     * Only `T::RejectOrigin` is able to cancel a bounty.
     *
     * - `bounty_id`: Bounty ID to cancel.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {number} bountyId
     **/
    closeBounty: GenericTxCall<
      Rv,
      (bountyId: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Bounties';
          palletCall: {
            name: 'CloseBounty';
            params: { bountyId: number };
          };
        }
      >
    >;

    /**
     * Extend the expiry time of an active bounty.
     *
     * The dispatch origin for this call must be the curator of this bounty.
     *
     * - `bounty_id`: Bounty ID to extend.
     * - `remark`: additional information.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {number} bountyId
     * @param {BytesLike} remark
     **/
    extendBountyExpiry: GenericTxCall<
      Rv,
      (
        bountyId: number,
        remark: BytesLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Bounties';
          palletCall: {
            name: 'ExtendBountyExpiry';
            params: { bountyId: number; remark: BytesLike };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `ChildBounties`'s transaction calls
   **/
  childBounties: {
    /**
     * Add a new child-bounty.
     *
     * The dispatch origin for this call must be the curator of parent
     * bounty and the parent bounty must be in "active" state.
     *
     * Child-bounty gets added successfully & fund gets transferred from
     * parent bounty to child-bounty account, if parent bounty has enough
     * funds, else the call fails.
     *
     * Upper bound to maximum number of active child bounties that can be
     * added are managed via runtime trait config
     * [`Config::MaxActiveChildBountyCount`].
     *
     * If the call is success, the status of child-bounty is updated to
     * "Added".
     *
     * - `parent_bounty_id`: Index of parent bounty for which child-bounty is being added.
     * - `value`: Value for executing the proposal.
     * - `description`: Text description for the child-bounty.
     *
     * @param {number} parentBountyId
     * @param {bigint} value
     * @param {BytesLike} description
     **/
    addChildBounty: GenericTxCall<
      Rv,
      (
        parentBountyId: number,
        value: bigint,
        description: BytesLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ChildBounties';
          palletCall: {
            name: 'AddChildBounty';
            params: { parentBountyId: number; value: bigint; description: BytesLike };
          };
        }
      >
    >;

    /**
     * Propose curator for funded child-bounty.
     *
     * The dispatch origin for this call must be curator of parent bounty.
     *
     * Parent bounty must be in active state, for this child-bounty call to
     * work.
     *
     * Child-bounty must be in "Added" state, for processing the call. And
     * state of child-bounty is moved to "CuratorProposed" on successful
     * call completion.
     *
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     * - `curator`: Address of child-bounty curator.
     * - `fee`: payment fee to child-bounty curator for execution.
     *
     * @param {number} parentBountyId
     * @param {number} childBountyId
     * @param {MultiAddressLike} curator
     * @param {bigint} fee
     **/
    proposeCurator: GenericTxCall<
      Rv,
      (
        parentBountyId: number,
        childBountyId: number,
        curator: MultiAddressLike,
        fee: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ChildBounties';
          palletCall: {
            name: 'ProposeCurator';
            params: { parentBountyId: number; childBountyId: number; curator: MultiAddressLike; fee: bigint };
          };
        }
      >
    >;

    /**
     * Accept the curator role for the child-bounty.
     *
     * The dispatch origin for this call must be the curator of this
     * child-bounty.
     *
     * A deposit will be reserved from the curator and refund upon
     * successful payout or cancellation.
     *
     * Fee for curator is deducted from curator fee of parent bounty.
     *
     * Parent bounty must be in active state, for this child-bounty call to
     * work.
     *
     * Child-bounty must be in "CuratorProposed" state, for processing the
     * call. And state of child-bounty is moved to "Active" on successful
     * call completion.
     *
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     *
     * @param {number} parentBountyId
     * @param {number} childBountyId
     **/
    acceptCurator: GenericTxCall<
      Rv,
      (
        parentBountyId: number,
        childBountyId: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ChildBounties';
          palletCall: {
            name: 'AcceptCurator';
            params: { parentBountyId: number; childBountyId: number };
          };
        }
      >
    >;

    /**
     * Unassign curator from a child-bounty.
     *
     * The dispatch origin for this call can be either `RejectOrigin`, or
     * the curator of the parent bounty, or any signed origin.
     *
     * For the origin other than T::RejectOrigin and the child-bounty
     * curator, parent bounty must be in active state, for this call to
     * work. We allow child-bounty curator and T::RejectOrigin to execute
     * this call irrespective of the parent bounty state.
     *
     * If this function is called by the `RejectOrigin` or the
     * parent bounty curator, we assume that the child-bounty curator is
     * malicious or inactive. As a result, child-bounty curator deposit is
     * slashed.
     *
     * If the origin is the child-bounty curator, we take this as a sign
     * that they are unable to do their job, and are willingly giving up.
     * We could slash the deposit, but for now we allow them to unreserve
     * their deposit and exit without issue. (We may want to change this if
     * it is abused.)
     *
     * Finally, the origin can be anyone iff the child-bounty curator is
     * "inactive". Expiry update due of parent bounty is used to estimate
     * inactive state of child-bounty curator.
     *
     * This allows anyone in the community to call out that a child-bounty
     * curator is not doing their due diligence, and we should pick a new
     * one. In this case the child-bounty curator deposit is slashed.
     *
     * State of child-bounty is moved to Added state on successful call
     * completion.
     *
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     *
     * @param {number} parentBountyId
     * @param {number} childBountyId
     **/
    unassignCurator: GenericTxCall<
      Rv,
      (
        parentBountyId: number,
        childBountyId: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ChildBounties';
          palletCall: {
            name: 'UnassignCurator';
            params: { parentBountyId: number; childBountyId: number };
          };
        }
      >
    >;

    /**
     * Award child-bounty to a beneficiary.
     *
     * The beneficiary will be able to claim the funds after a delay.
     *
     * The dispatch origin for this call must be the parent curator or
     * curator of this child-bounty.
     *
     * Parent bounty must be in active state, for this child-bounty call to
     * work.
     *
     * Child-bounty must be in active state, for processing the call. And
     * state of child-bounty is moved to "PendingPayout" on successful call
     * completion.
     *
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     * - `beneficiary`: Beneficiary account.
     *
     * @param {number} parentBountyId
     * @param {number} childBountyId
     * @param {MultiAddressLike} beneficiary
     **/
    awardChildBounty: GenericTxCall<
      Rv,
      (
        parentBountyId: number,
        childBountyId: number,
        beneficiary: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ChildBounties';
          palletCall: {
            name: 'AwardChildBounty';
            params: { parentBountyId: number; childBountyId: number; beneficiary: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Claim the payout from an awarded child-bounty after payout delay.
     *
     * The dispatch origin for this call may be any signed origin.
     *
     * Call works independent of parent bounty state, No need for parent
     * bounty to be in active state.
     *
     * The Beneficiary is paid out with agreed bounty value. Curator fee is
     * paid & curator deposit is unreserved.
     *
     * Child-bounty must be in "PendingPayout" state, for processing the
     * call. And instance of child-bounty is removed from the state on
     * successful call completion.
     *
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     *
     * @param {number} parentBountyId
     * @param {number} childBountyId
     **/
    claimChildBounty: GenericTxCall<
      Rv,
      (
        parentBountyId: number,
        childBountyId: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ChildBounties';
          palletCall: {
            name: 'ClaimChildBounty';
            params: { parentBountyId: number; childBountyId: number };
          };
        }
      >
    >;

    /**
     * Cancel a proposed or active child-bounty. Child-bounty account funds
     * are transferred to parent bounty account. The child-bounty curator
     * deposit may be unreserved if possible.
     *
     * The dispatch origin for this call must be either parent curator or
     * `T::RejectOrigin`.
     *
     * If the state of child-bounty is `Active`, curator deposit is
     * unreserved.
     *
     * If the state of child-bounty is `PendingPayout`, call fails &
     * returns `PendingPayout` error.
     *
     * For the origin other than T::RejectOrigin, parent bounty must be in
     * active state, for this child-bounty call to work. For origin
     * T::RejectOrigin execution is forced.
     *
     * Instance of child-bounty is removed from the state on successful
     * call completion.
     *
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     *
     * @param {number} parentBountyId
     * @param {number} childBountyId
     **/
    closeChildBounty: GenericTxCall<
      Rv,
      (
        parentBountyId: number,
        childBountyId: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ChildBounties';
          palletCall: {
            name: 'CloseChildBounty';
            params: { parentBountyId: number; childBountyId: number };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `NominationPools`'s transaction calls
   **/
  nominationPools: {
    /**
     * Stake funds with a pool. The amount to bond is transferred from the member to the pool
     * account and immediately increases the pools bond.
     *
     * The method of transferring the amount to the pool account is determined by
     * [`adapter::StakeStrategyType`]. If the pool is configured to use
     * [`adapter::StakeStrategyType::Delegate`], the funds remain in the account of
     * the `origin`, while the pool gains the right to use these funds for staking.
     *
     * # Note
     *
     * * An account can only be a member of a single pool.
     * * An account cannot join the same pool multiple times.
     * * This call will *not* dust the member account, so the member must have at least
     * `existential deposit + amount` in their account.
     * * Only a pool with [`PoolState::Open`] can be joined
     *
     * @param {bigint} amount
     * @param {number} poolId
     **/
    join: GenericTxCall<
      Rv,
      (
        amount: bigint,
        poolId: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'Join';
            params: { amount: bigint; poolId: number };
          };
        }
      >
    >;

    /**
     * Bond `extra` more funds from `origin` into the pool to which they already belong.
     *
     * Additional funds can come from either the free balance of the account, of from the
     * accumulated rewards, see [`BondExtra`].
     *
     * Bonding extra funds implies an automatic payout of all pending rewards as well.
     * See `bond_extra_other` to bond pending rewards of `other` members.
     *
     * @param {PalletNominationPoolsBondExtra} extra
     **/
    bondExtra: GenericTxCall<
      Rv,
      (extra: PalletNominationPoolsBondExtra) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'BondExtra';
            params: { extra: PalletNominationPoolsBondExtra };
          };
        }
      >
    >;

    /**
     * A bonded member can use this to claim their payout based on the rewards that the pool
     * has accumulated since their last claimed payout (OR since joining if this is their first
     * time claiming rewards). The payout will be transferred to the member's account.
     *
     * The member will earn rewards pro rata based on the members stake vs the sum of the
     * members in the pools stake. Rewards do not "expire".
     *
     * See `claim_payout_other` to claim rewards on behalf of some `other` pool member.
     *
     **/
    claimPayout: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'ClaimPayout';
          };
        }
      >
    >;

    /**
     * Unbond up to `unbonding_points` of the `member_account`'s funds from the pool. It
     * implicitly collects the rewards one last time, since not doing so would mean some
     * rewards would be forfeited.
     *
     * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
     * account).
     *
     * # Conditions for a permissionless dispatch.
     *
     * * The pool is blocked and the caller is either the root or bouncer. This is refereed to
     * as a kick.
     * * The pool is destroying and the member is not the depositor.
     * * The pool is destroying, the member is the depositor and no other members are in the
     * pool.
     *
     * ## Conditions for permissioned dispatch (i.e. the caller is also the
     * `member_account`):
     *
     * * The caller is not the depositor.
     * * The caller is the depositor, the pool is destroying and no other members are in the
     * pool.
     *
     * # Note
     *
     * If there are too many unlocking chunks to unbond with the pool account,
     * [`Call::pool_withdraw_unbonded`] can be called to try and minimize unlocking chunks.
     * The [`StakingInterface::unbond`] will implicitly call [`Call::pool_withdraw_unbonded`]
     * to try to free chunks if necessary (ie. if unbound was called and no unlocking chunks
     * are available). However, it may not be possible to release the current unlocking chunks,
     * in which case, the result of this call will likely be the `NoMoreChunks` error from the
     * staking system.
     *
     * @param {MultiAddressLike} memberAccount
     * @param {bigint} unbondingPoints
     **/
    unbond: GenericTxCall<
      Rv,
      (
        memberAccount: MultiAddressLike,
        unbondingPoints: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'Unbond';
            params: { memberAccount: MultiAddressLike; unbondingPoints: bigint };
          };
        }
      >
    >;

    /**
     * Call `withdraw_unbonded` for the pools account. This call can be made by any account.
     *
     * This is useful if there are too many unlocking chunks to call `unbond`, and some
     * can be cleared by withdrawing. In the case there are too many unlocking chunks, the user
     * would probably see an error like `NoMoreChunks` emitted from the staking system when
     * they attempt to unbond.
     *
     * @param {number} poolId
     * @param {number} numSlashingSpans
     **/
    poolWithdrawUnbonded: GenericTxCall<
      Rv,
      (
        poolId: number,
        numSlashingSpans: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'PoolWithdrawUnbonded';
            params: { poolId: number; numSlashingSpans: number };
          };
        }
      >
    >;

    /**
     * Withdraw unbonded funds from `member_account`. If no bonded funds can be unbonded, an
     * error is returned.
     *
     * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
     * account).
     *
     * # Conditions for a permissionless dispatch
     *
     * * The pool is in destroy mode and the target is not the depositor.
     * * The target is the depositor and they are the only member in the sub pools.
     * * The pool is blocked and the caller is either the root or bouncer.
     *
     * # Conditions for permissioned dispatch
     *
     * * The caller is the target and they are not the depositor.
     *
     * # Note
     *
     * - If the target is the depositor, the pool will be destroyed.
     * - If the pool has any pending slash, we also try to slash the member before letting them
     * withdraw. This calculation adds some weight overhead and is only defensive. In reality,
     * pool slashes must have been already applied via permissionless [`Call::apply_slash`].
     *
     * @param {MultiAddressLike} memberAccount
     * @param {number} numSlashingSpans
     **/
    withdrawUnbonded: GenericTxCall<
      Rv,
      (
        memberAccount: MultiAddressLike,
        numSlashingSpans: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'WithdrawUnbonded';
            params: { memberAccount: MultiAddressLike; numSlashingSpans: number };
          };
        }
      >
    >;

    /**
     * Create a new delegation pool.
     *
     * # Arguments
     *
     * * `amount` - The amount of funds to delegate to the pool. This also acts of a sort of
     * deposit since the pools creator cannot fully unbond funds until the pool is being
     * destroyed.
     * * `index` - A disambiguation index for creating the account. Likely only useful when
     * creating multiple pools in the same extrinsic.
     * * `root` - The account to set as [`PoolRoles::root`].
     * * `nominator` - The account to set as the [`PoolRoles::nominator`].
     * * `bouncer` - The account to set as the [`PoolRoles::bouncer`].
     *
     * # Note
     *
     * In addition to `amount`, the caller will transfer the existential deposit; so the caller
     * needs at have at least `amount + existential_deposit` transferable.
     *
     * @param {bigint} amount
     * @param {MultiAddressLike} root
     * @param {MultiAddressLike} nominator
     * @param {MultiAddressLike} bouncer
     **/
    create: GenericTxCall<
      Rv,
      (
        amount: bigint,
        root: MultiAddressLike,
        nominator: MultiAddressLike,
        bouncer: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'Create';
            params: { amount: bigint; root: MultiAddressLike; nominator: MultiAddressLike; bouncer: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Create a new delegation pool with a previously used pool id
     *
     * # Arguments
     *
     * same as `create` with the inclusion of
     * * `pool_id` - `A valid PoolId.
     *
     * @param {bigint} amount
     * @param {MultiAddressLike} root
     * @param {MultiAddressLike} nominator
     * @param {MultiAddressLike} bouncer
     * @param {number} poolId
     **/
    createWithPoolId: GenericTxCall<
      Rv,
      (
        amount: bigint,
        root: MultiAddressLike,
        nominator: MultiAddressLike,
        bouncer: MultiAddressLike,
        poolId: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'CreateWithPoolId';
            params: {
              amount: bigint;
              root: MultiAddressLike;
              nominator: MultiAddressLike;
              bouncer: MultiAddressLike;
              poolId: number;
            };
          };
        }
      >
    >;

    /**
     * Nominate on behalf of the pool.
     *
     * The dispatch origin of this call must be signed by the pool nominator or the pool
     * root role.
     *
     * This directly forward the call to the staking pallet, on behalf of the pool bonded
     * account.
     *
     * # Note
     *
     * In addition to a `root` or `nominator` role of `origin`, pool's depositor needs to have
     * at least `depositor_min_bond` in the pool to start nominating.
     *
     * @param {number} poolId
     * @param {Array<AccountId32Like>} validators
     **/
    nominate: GenericTxCall<
      Rv,
      (
        poolId: number,
        validators: Array<AccountId32Like>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'Nominate';
            params: { poolId: number; validators: Array<AccountId32Like> };
          };
        }
      >
    >;

    /**
     * Set a new state for the pool.
     *
     * If a pool is already in the `Destroying` state, then under no condition can its state
     * change again.
     *
     * The dispatch origin of this call must be either:
     *
     * 1. signed by the bouncer, or the root role of the pool,
     * 2. if the pool conditions to be open are NOT met (as described by `ok_to_be_open`), and
     * then the state of the pool can be permissionlessly changed to `Destroying`.
     *
     * @param {number} poolId
     * @param {PalletNominationPoolsPoolState} state
     **/
    setState: GenericTxCall<
      Rv,
      (
        poolId: number,
        state: PalletNominationPoolsPoolState,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'SetState';
            params: { poolId: number; state: PalletNominationPoolsPoolState };
          };
        }
      >
    >;

    /**
     * Set a new metadata for the pool.
     *
     * The dispatch origin of this call must be signed by the bouncer, or the root role of the
     * pool.
     *
     * @param {number} poolId
     * @param {BytesLike} metadata
     **/
    setMetadata: GenericTxCall<
      Rv,
      (
        poolId: number,
        metadata: BytesLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'SetMetadata';
            params: { poolId: number; metadata: BytesLike };
          };
        }
      >
    >;

    /**
     * Update configurations for the nomination pools. The origin for this call must be
     * [`Config::AdminOrigin`].
     *
     * # Arguments
     *
     * * `min_join_bond` - Set [`MinJoinBond`].
     * * `min_create_bond` - Set [`MinCreateBond`].
     * * `max_pools` - Set [`MaxPools`].
     * * `max_members` - Set [`MaxPoolMembers`].
     * * `max_members_per_pool` - Set [`MaxPoolMembersPerPool`].
     * * `global_max_commission` - Set [`GlobalMaxCommission`].
     *
     * @param {PalletNominationPoolsConfigOp} minJoinBond
     * @param {PalletNominationPoolsConfigOp} minCreateBond
     * @param {PalletNominationPoolsConfigOpU32} maxPools
     * @param {PalletNominationPoolsConfigOpU32} maxMembers
     * @param {PalletNominationPoolsConfigOpU32} maxMembersPerPool
     * @param {PalletNominationPoolsConfigOpPerbill} globalMaxCommission
     **/
    setConfigs: GenericTxCall<
      Rv,
      (
        minJoinBond: PalletNominationPoolsConfigOp,
        minCreateBond: PalletNominationPoolsConfigOp,
        maxPools: PalletNominationPoolsConfigOpU32,
        maxMembers: PalletNominationPoolsConfigOpU32,
        maxMembersPerPool: PalletNominationPoolsConfigOpU32,
        globalMaxCommission: PalletNominationPoolsConfigOpPerbill,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'SetConfigs';
            params: {
              minJoinBond: PalletNominationPoolsConfigOp;
              minCreateBond: PalletNominationPoolsConfigOp;
              maxPools: PalletNominationPoolsConfigOpU32;
              maxMembers: PalletNominationPoolsConfigOpU32;
              maxMembersPerPool: PalletNominationPoolsConfigOpU32;
              globalMaxCommission: PalletNominationPoolsConfigOpPerbill;
            };
          };
        }
      >
    >;

    /**
     * Update the roles of the pool.
     *
     * The root is the only entity that can change any of the roles, including itself,
     * excluding the depositor, who can never change.
     *
     * It emits an event, notifying UIs of the role change. This event is quite relevant to
     * most pool members and they should be informed of changes to pool roles.
     *
     * @param {number} poolId
     * @param {PalletNominationPoolsConfigOp004} newRoot
     * @param {PalletNominationPoolsConfigOp004} newNominator
     * @param {PalletNominationPoolsConfigOp004} newBouncer
     **/
    updateRoles: GenericTxCall<
      Rv,
      (
        poolId: number,
        newRoot: PalletNominationPoolsConfigOp004,
        newNominator: PalletNominationPoolsConfigOp004,
        newBouncer: PalletNominationPoolsConfigOp004,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'UpdateRoles';
            params: {
              poolId: number;
              newRoot: PalletNominationPoolsConfigOp004;
              newNominator: PalletNominationPoolsConfigOp004;
              newBouncer: PalletNominationPoolsConfigOp004;
            };
          };
        }
      >
    >;

    /**
     * Chill on behalf of the pool.
     *
     * The dispatch origin of this call can be signed by the pool nominator or the pool
     * root role, same as [`Pallet::nominate`].
     *
     * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
     * account).
     *
     * # Conditions for a permissionless dispatch:
     * * When pool depositor has less than `MinNominatorBond` staked, otherwise pool members
     * are unable to unbond.
     *
     * # Conditions for permissioned dispatch:
     * * The caller has a nominator or root role of the pool.
     * This directly forward the call to the staking pallet, on behalf of the pool bonded
     * account.
     *
     * @param {number} poolId
     **/
    chill: GenericTxCall<
      Rv,
      (poolId: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'Chill';
            params: { poolId: number };
          };
        }
      >
    >;

    /**
     * `origin` bonds funds from `extra` for some pool member `member` into their respective
     * pools.
     *
     * `origin` can bond extra funds from free balance or pending rewards when `origin ==
     * other`.
     *
     * In the case of `origin != other`, `origin` can only bond extra pending rewards of
     * `other` members assuming set_claim_permission for the given member is
     * `PermissionlessCompound` or `PermissionlessAll`.
     *
     * @param {MultiAddressLike} member
     * @param {PalletNominationPoolsBondExtra} extra
     **/
    bondExtraOther: GenericTxCall<
      Rv,
      (
        member: MultiAddressLike,
        extra: PalletNominationPoolsBondExtra,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'BondExtraOther';
            params: { member: MultiAddressLike; extra: PalletNominationPoolsBondExtra };
          };
        }
      >
    >;

    /**
     * Allows a pool member to set a claim permission to allow or disallow permissionless
     * bonding and withdrawing.
     *
     * # Arguments
     *
     * * `origin` - Member of a pool.
     * * `permission` - The permission to be applied.
     *
     * @param {PalletNominationPoolsClaimPermission} permission
     **/
    setClaimPermission: GenericTxCall<
      Rv,
      (permission: PalletNominationPoolsClaimPermission) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'SetClaimPermission';
            params: { permission: PalletNominationPoolsClaimPermission };
          };
        }
      >
    >;

    /**
     * `origin` can claim payouts on some pool member `other`'s behalf.
     *
     * Pool member `other` must have a `PermissionlessWithdraw` or `PermissionlessAll` claim
     * permission for this call to be successful.
     *
     * @param {AccountId32Like} other
     **/
    claimPayoutOther: GenericTxCall<
      Rv,
      (other: AccountId32Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'ClaimPayoutOther';
            params: { other: AccountId32Like };
          };
        }
      >
    >;

    /**
     * Set the commission of a pool.
     * Both a commission percentage and a commission payee must be provided in the `current`
     * tuple. Where a `current` of `None` is provided, any current commission will be removed.
     *
     * - If a `None` is supplied to `new_commission`, existing commission will be removed.
     *
     * @param {number} poolId
     * @param {[Perbill, AccountId32Like] | undefined} newCommission
     **/
    setCommission: GenericTxCall<
      Rv,
      (
        poolId: number,
        newCommission: [Perbill, AccountId32Like] | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'SetCommission';
            params: { poolId: number; newCommission: [Perbill, AccountId32Like] | undefined };
          };
        }
      >
    >;

    /**
     * Set the maximum commission of a pool.
     *
     * - Initial max can be set to any `Perbill`, and only smaller values thereafter.
     * - Current commission will be lowered in the event it is higher than a new max
     * commission.
     *
     * @param {number} poolId
     * @param {Perbill} maxCommission
     **/
    setCommissionMax: GenericTxCall<
      Rv,
      (
        poolId: number,
        maxCommission: Perbill,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'SetCommissionMax';
            params: { poolId: number; maxCommission: Perbill };
          };
        }
      >
    >;

    /**
     * Set the commission change rate for a pool.
     *
     * Initial change rate is not bounded, whereas subsequent updates can only be more
     * restrictive than the current.
     *
     * @param {number} poolId
     * @param {PalletNominationPoolsCommissionChangeRate} changeRate
     **/
    setCommissionChangeRate: GenericTxCall<
      Rv,
      (
        poolId: number,
        changeRate: PalletNominationPoolsCommissionChangeRate,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'SetCommissionChangeRate';
            params: { poolId: number; changeRate: PalletNominationPoolsCommissionChangeRate };
          };
        }
      >
    >;

    /**
     * Claim pending commission.
     *
     * The dispatch origin of this call must be signed by the `root` role of the pool. Pending
     * commission is paid out and added to total claimed commission`. Total pending commission
     * is reset to zero. the current.
     *
     * @param {number} poolId
     **/
    claimCommission: GenericTxCall<
      Rv,
      (poolId: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'ClaimCommission';
            params: { poolId: number };
          };
        }
      >
    >;

    /**
     * Top up the deficit or withdraw the excess ED from the pool.
     *
     * When a pool is created, the pool depositor transfers ED to the reward account of the
     * pool. ED is subject to change and over time, the deposit in the reward account may be
     * insufficient to cover the ED deficit of the pool or vice-versa where there is excess
     * deposit to the pool. This call allows anyone to adjust the ED deposit of the
     * pool by either topping up the deficit or claiming the excess.
     *
     * @param {number} poolId
     **/
    adjustPoolDeposit: GenericTxCall<
      Rv,
      (poolId: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'AdjustPoolDeposit';
            params: { poolId: number };
          };
        }
      >
    >;

    /**
     * Set or remove a pool's commission claim permission.
     *
     * Determines who can claim the pool's pending commission. Only the `Root` role of the pool
     * is able to configure commission claim permissions.
     *
     * @param {number} poolId
     * @param {PalletNominationPoolsCommissionClaimPermission | undefined} permission
     **/
    setCommissionClaimPermission: GenericTxCall<
      Rv,
      (
        poolId: number,
        permission: PalletNominationPoolsCommissionClaimPermission | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'SetCommissionClaimPermission';
            params: { poolId: number; permission: PalletNominationPoolsCommissionClaimPermission | undefined };
          };
        }
      >
    >;

    /**
     * Apply a pending slash on a member.
     *
     * Fails unless [`crate::pallet::Config::StakeAdapter`] is of strategy type:
     * [`adapter::StakeStrategyType::Delegate`].
     *
     * This call can be dispatched permissionlessly (i.e. by any account). If the member has
     * slash to be applied, caller may be rewarded with the part of the slash.
     *
     * @param {MultiAddressLike} memberAccount
     **/
    applySlash: GenericTxCall<
      Rv,
      (memberAccount: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'ApplySlash';
            params: { memberAccount: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Migrates delegated funds from the pool account to the `member_account`.
     *
     * Fails unless [`crate::pallet::Config::StakeAdapter`] is of strategy type:
     * [`adapter::StakeStrategyType::Delegate`].
     *
     * This is a permission-less call and refunds any fee if claim is successful.
     *
     * If the pool has migrated to delegation based staking, the staked tokens of pool members
     * can be moved and held in their own account. See [`adapter::DelegateStake`]
     *
     * @param {MultiAddressLike} memberAccount
     **/
    migrateDelegation: GenericTxCall<
      Rv,
      (memberAccount: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'MigrateDelegation';
            params: { memberAccount: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Migrate pool from [`adapter::StakeStrategyType::Transfer`] to
     * [`adapter::StakeStrategyType::Delegate`].
     *
     * Fails unless [`crate::pallet::Config::StakeAdapter`] is of strategy type:
     * [`adapter::StakeStrategyType::Delegate`].
     *
     * This call can be dispatched permissionlessly, and refunds any fee if successful.
     *
     * If the pool has already migrated to delegation based staking, this call will fail.
     *
     * @param {number} poolId
     **/
    migratePoolToDelegateStake: GenericTxCall<
      Rv,
      (poolId: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'NominationPools';
          palletCall: {
            name: 'MigratePoolToDelegateStake';
            params: { poolId: number };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Gear`'s transaction calls
   **/
  gear: {
    /**
     * Saves program `code` in storage.
     *
     * The extrinsic was created to provide _deploy program from program_ functionality.
     * Anyone who wants to define a "factory" logic in program should first store the code and metadata for the "child"
     * program in storage. So the code for the child will be initialized by program initialization request only if it exists in storage.
     *
     * More precisely, the code and its metadata are actually saved in the storage under the hash of the `code`. The code hash is computed
     * as Blake256 hash. At the time of the call the `code` hash should not be in the storage. If it was stored previously, call will end up
     * with an `CodeAlreadyExists` error. In this case user can be sure, that he can actually use the hash of his program's code bytes to define
     * "program factory" logic in his program.
     *
     * Parameters
     * - `code`: wasm code of a program as a byte vector.
     *
     * Emits the following events:
     * - `SavedCode(H256)` - when the code is saved in storage.
     *
     * @param {BytesLike} code
     **/
    uploadCode: GenericTxCall<
      Rv,
      (code: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Gear';
          palletCall: {
            name: 'UploadCode';
            params: { code: BytesLike };
          };
        }
      >
    >;

    /**
     * Creates program initialization request (message), that is scheduled to be run in the same block.
     *
     * There are no guarantees that initialization message will be run in the same block due to block
     * gas limit restrictions. For example, when it will be the message's turn, required gas limit for it
     * could be more than remaining block gas limit. Therefore, the message processing will be postponed
     * until the next block.
     *
     * `ActorId` is computed as Blake256 hash of concatenated bytes of `code` + `salt`. (todo #512 `code_hash` + `salt`)
     * Such `ActorId` must not exist in the Program Storage at the time of this call.
     *
     * There is the same guarantee here as in `upload_code`. That is, future program's
     * `code` and metadata are stored before message was added to the queue and processed.
     *
     * The origin must be Signed and the sender must have sufficient funds to pay
     * for `gas` and `value` (in case the latter is being transferred).
     *
     * Gear runtime guarantees that an active program always has an account to store value.
     * If the underlying account management platform (e.g. Substrate's System pallet) requires
     * an existential deposit to keep an account alive, the related overhead is considered an
     * extra cost related with a program instantiation and is charged to the program's creator
     * and is released back to the creator when the program is removed.
     * In context of the above, the `value` parameter represents the so-called `reducible` balance
     * a program should have at its disposal upon instantiation. It is not used to offset the
     * existential deposit required for an account creation.
     *
     * Parameters:
     * - `code`: wasm code of a program as a byte vector.
     * - `salt`: randomness term (a seed) to allow programs with identical code
     * to be created independently.
     * - `init_payload`: encoded parameters of the wasm module `init` function.
     * - `gas_limit`: maximum amount of gas the program can spend before it is halted.
     * - `value`: balance to be transferred to the program once it's been created.
     *
     * Emits the following events:
     * - `InitMessageEnqueued(MessageInfo)` when init message is placed in the queue.
     *
     * # Note
     * Faulty (uninitialized) programs still have a valid addresses (program ids) that can deterministically be derived on the
     * caller's side upfront. It means that if messages are sent to such an address, they might still linger in the queue.
     *
     * In order to mitigate the risk of users' funds being sent to an address,
     * where a valid program should have resided, while it's not,
     * such "failed-to-initialize" programs are not silently deleted from the
     * program storage but rather marked as "ghost" programs.
     * Ghost program can be removed by their original author via an explicit call.
     * The funds stored by a ghost program will be release to the author once the program
     * has been removed.
     *
     * @param {BytesLike} code
     * @param {BytesLike} salt
     * @param {BytesLike} initPayload
     * @param {bigint} gasLimit
     * @param {bigint} value
     * @param {boolean} keepAlive
     **/
    uploadProgram: GenericTxCall<
      Rv,
      (
        code: BytesLike,
        salt: BytesLike,
        initPayload: BytesLike,
        gasLimit: bigint,
        value: bigint,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Gear';
          palletCall: {
            name: 'UploadProgram';
            params: {
              code: BytesLike;
              salt: BytesLike;
              initPayload: BytesLike;
              gasLimit: bigint;
              value: bigint;
              keepAlive: boolean;
            };
          };
        }
      >
    >;

    /**
     * Creates program via `code_id` from storage.
     *
     * Parameters:
     * - `code_id`: wasm code id in the code storage.
     * - `salt`: randomness term (a seed) to allow programs with identical code
     * to be created independently.
     * - `init_payload`: encoded parameters of the wasm module `init` function.
     * - `gas_limit`: maximum amount of gas the program can spend before it is halted.
     * - `value`: balance to be transferred to the program once it's been created.
     *
     * Emits the following events:
     * - `InitMessageEnqueued(MessageInfo)` when init message is placed in the queue.
     *
     * # NOTE
     *
     * For the details of this extrinsic, see `upload_code`.
     *
     * @param {GprimitivesCodeId} codeId
     * @param {BytesLike} salt
     * @param {BytesLike} initPayload
     * @param {bigint} gasLimit
     * @param {bigint} value
     * @param {boolean} keepAlive
     **/
    createProgram: GenericTxCall<
      Rv,
      (
        codeId: GprimitivesCodeId,
        salt: BytesLike,
        initPayload: BytesLike,
        gasLimit: bigint,
        value: bigint,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Gear';
          palletCall: {
            name: 'CreateProgram';
            params: {
              codeId: GprimitivesCodeId;
              salt: BytesLike;
              initPayload: BytesLike;
              gasLimit: bigint;
              value: bigint;
              keepAlive: boolean;
            };
          };
        }
      >
    >;

    /**
     * Sends a message to a program or to another account.
     *
     * The origin must be Signed and the sender must have sufficient funds to pay
     * for `gas` and `value` (in case the latter is being transferred).
     *
     * To avoid an undefined behavior a check is made that the destination address
     * is not a program in uninitialized state. If the opposite holds true,
     * the message is not enqueued for processing.
     *
     * Parameters:
     * - `destination`: the message destination.
     * - `payload`: in case of a program destination, parameters of the `handle` function.
     * - `gas_limit`: maximum amount of gas the program can spend before it is halted.
     * - `value`: balance to be transferred to the program once it's been created.
     *
     * Emits the following events:
     * - `DispatchMessageEnqueued(MessageInfo)` when dispatch message is placed in the queue.
     *
     * @param {GprimitivesActorId} destination
     * @param {BytesLike} payload
     * @param {bigint} gasLimit
     * @param {bigint} value
     * @param {boolean} keepAlive
     **/
    sendMessage: GenericTxCall<
      Rv,
      (
        destination: GprimitivesActorId,
        payload: BytesLike,
        gasLimit: bigint,
        value: bigint,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Gear';
          palletCall: {
            name: 'SendMessage';
            params: {
              destination: GprimitivesActorId;
              payload: BytesLike;
              gasLimit: bigint;
              value: bigint;
              keepAlive: boolean;
            };
          };
        }
      >
    >;

    /**
     * Send reply on message in `Mailbox`.
     *
     * Removes message by given `MessageId` from callers `Mailbox`:
     * rent funds become free, associated with the message value
     * transfers from message sender to extrinsic caller.
     *
     * Generates reply on removed message with given parameters
     * and pushes it in `MessageQueue`.
     *
     * NOTE: source of the message in mailbox guaranteed to be a program.
     *
     * NOTE: only user who is destination of the message, can claim value
     * or reply on the message from mailbox.
     *
     * @param {GprimitivesMessageId} replyToId
     * @param {BytesLike} payload
     * @param {bigint} gasLimit
     * @param {bigint} value
     * @param {boolean} keepAlive
     **/
    sendReply: GenericTxCall<
      Rv,
      (
        replyToId: GprimitivesMessageId,
        payload: BytesLike,
        gasLimit: bigint,
        value: bigint,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Gear';
          palletCall: {
            name: 'SendReply';
            params: {
              replyToId: GprimitivesMessageId;
              payload: BytesLike;
              gasLimit: bigint;
              value: bigint;
              keepAlive: boolean;
            };
          };
        }
      >
    >;

    /**
     * Claim value from message in `Mailbox`.
     *
     * Removes message by given `MessageId` from callers `Mailbox`:
     * rent funds become free, associated with the message value
     * transfers from message sender to extrinsic caller.
     *
     * NOTE: only user who is destination of the message, can claim value
     * or reply on the message from mailbox.
     *
     * @param {GprimitivesMessageId} messageId
     **/
    claimValue: GenericTxCall<
      Rv,
      (messageId: GprimitivesMessageId) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Gear';
          palletCall: {
            name: 'ClaimValue';
            params: { messageId: GprimitivesMessageId };
          };
        }
      >
    >;

    /**
     * Process message queue
     *
     * @param {bigint | undefined} maxGas
     **/
    run: GenericTxCall<
      Rv,
      (maxGas: bigint | undefined) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Gear';
          palletCall: {
            name: 'Run';
            params: { maxGas: bigint | undefined };
          };
        }
      >
    >;

    /**
     * Sets `ExecuteInherent` flag.
     *
     * Requires root origin (eventually, will only be set via referendum)
     *
     * @param {boolean} value
     **/
    setExecuteInherent: GenericTxCall<
      Rv,
      (value: boolean) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Gear';
          palletCall: {
            name: 'SetExecuteInherent';
            params: { value: boolean };
          };
        }
      >
    >;

    /**
     * Transfers value from chain of terminated or exited programs to its final inheritor.
     *
     * `depth` parameter is how far to traverse to inheritor.
     * A value of 10 is sufficient for most cases.
     *
     * # Example of chain
     *
     * - Program #1 exits (e.g `gr_exit syscall) with argument pointing to user.
     * Balance of program #1 has been sent to user.
     * - Program #2 exits with inheritor pointing to program #1.
     * Balance of program #2 has been sent to exited program #1.
     * - Program #3 exits with inheritor pointing to program #2
     * Balance of program #1 has been sent to exited program #2.
     *
     * So chain of inheritors looks like: Program #3 -> Program #2 -> Program #1 -> User.
     *
     * We have programs #1 and #2 with stuck value on their balances.
     * The balances should've been transferred to user (final inheritor) according to the chain.
     * But protocol doesn't traverse the chain automatically, so user have to call this extrinsic.
     *
     * @param {GprimitivesActorId} programId
     * @param {NonZeroU32} depth
     **/
    claimValueToInheritor: GenericTxCall<
      Rv,
      (
        programId: GprimitivesActorId,
        depth: NonZeroU32,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Gear';
          palletCall: {
            name: 'ClaimValueToInheritor';
            params: { programId: GprimitivesActorId; depth: NonZeroU32 };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `StakingRewards`'s transaction calls
   **/
  stakingRewards: {
    /**
     *
     * @param {bigint} value
     **/
    refill: GenericTxCall<
      Rv,
      (value: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'StakingRewards';
          palletCall: {
            name: 'Refill';
            params: { value: bigint };
          };
        }
      >
    >;

    /**
     *
     * @param {MultiAddressLike} from
     * @param {bigint} value
     **/
    forceRefill: GenericTxCall<
      Rv,
      (
        from: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'StakingRewards';
          palletCall: {
            name: 'ForceRefill';
            params: { from: MultiAddressLike; value: bigint };
          };
        }
      >
    >;

    /**
     *
     * @param {MultiAddressLike} to
     * @param {bigint} value
     **/
    withdraw: GenericTxCall<
      Rv,
      (
        to: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'StakingRewards';
          palletCall: {
            name: 'Withdraw';
            params: { to: MultiAddressLike; value: bigint };
          };
        }
      >
    >;

    /**
     *
     * @param {bigint} p
     * @param {bigint} n
     **/
    setTargetInflation: GenericTxCall<
      Rv,
      (
        p: bigint,
        n: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'StakingRewards';
          palletCall: {
            name: 'SetTargetInflation';
            params: { p: bigint; n: bigint };
          };
        }
      >
    >;

    /**
     *
     * @param {bigint} p
     * @param {bigint} n
     **/
    setIdealStakingRatio: GenericTxCall<
      Rv,
      (
        p: bigint,
        n: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'StakingRewards';
          palletCall: {
            name: 'SetIdealStakingRatio';
            params: { p: bigint; n: bigint };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `GearVoucher`'s transaction calls
   **/
  gearVoucher: {
    /**
     * Issue a new voucher.
     *
     * Deposits event `VoucherIssued`, that contains `VoucherId` to be
     * used by spender for balance-less on-chain interactions.
     *
     * Arguments:
     * * spender: user id that is eligible to use the voucher;
     * * balance: voucher balance could be used for transactions
     * fees and gas;
     * * programs: pool of programs spender can interact with,
     * if None - means any program,
     * limited by Config param;
     * * code_uploading:
     * allow voucher to be used as payer for `upload_code`
     * transactions fee;
     * * duration: amount of blocks voucher could be used by spender
     * and couldn't be revoked by owner.
     * Must be out in [MinDuration; MaxDuration] constants.
     * Expiration block of the voucher calculates as:
     * current bn (extrinsic exec bn) + duration + 1.
     *
     * @param {AccountId32Like} spender
     * @param {bigint} balance
     * @param {Array<GprimitivesActorId> | undefined} programs
     * @param {boolean} codeUploading
     * @param {number} duration
     **/
    issue: GenericTxCall<
      Rv,
      (
        spender: AccountId32Like,
        balance: bigint,
        programs: Array<GprimitivesActorId> | undefined,
        codeUploading: boolean,
        duration: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'GearVoucher';
          palletCall: {
            name: 'Issue';
            params: {
              spender: AccountId32Like;
              balance: bigint;
              programs: Array<GprimitivesActorId> | undefined;
              codeUploading: boolean;
              duration: number;
            };
          };
        }
      >
    >;

    /**
     * Execute prepaid call with given voucher id.
     *
     * Arguments:
     * * voucher_id: associated with origin existing vouchers id,
     * that should be used to pay for fees and gas
     * within the call;
     * * call: prepaid call that is requested to execute.
     *
     * @param {PalletGearVoucherInternalVoucherId} voucherId
     * @param {PalletGearVoucherInternalPrepaidCall} call
     **/
    call: GenericTxCall<
      Rv,
      (
        voucherId: PalletGearVoucherInternalVoucherId,
        call: PalletGearVoucherInternalPrepaidCall,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'GearVoucher';
          palletCall: {
            name: 'Call';
            params: { voucherId: PalletGearVoucherInternalVoucherId; call: PalletGearVoucherInternalPrepaidCall };
          };
        }
      >
    >;

    /**
     * Revoke existing voucher.
     *
     * This extrinsic revokes existing voucher, if current block is greater
     * than expiration block of the voucher (it is no longer valid).
     *
     * Currently it means sending of all balance from voucher account to
     * voucher owner without voucher removal from storage map, but this
     * behavior may change in future, as well as the origin validation:
     * only owner is able to revoke voucher now.
     *
     * Arguments:
     * * spender: account id of the voucher spender;
     * * voucher_id: voucher id to be revoked.
     *
     * @param {AccountId32Like} spender
     * @param {PalletGearVoucherInternalVoucherId} voucherId
     **/
    revoke: GenericTxCall<
      Rv,
      (
        spender: AccountId32Like,
        voucherId: PalletGearVoucherInternalVoucherId,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'GearVoucher';
          palletCall: {
            name: 'Revoke';
            params: { spender: AccountId32Like; voucherId: PalletGearVoucherInternalVoucherId };
          };
        }
      >
    >;

    /**
     * Update existing voucher.
     *
     * This extrinsic updates existing voucher: it can only extend vouchers
     * rights in terms of balance, validity or programs to interact pool.
     *
     * Can only be called by the voucher owner.
     *
     * Arguments:
     * * spender: account id of the voucher spender;
     * * voucher_id: voucher id to be updated;
     * * move_ownership: optionally moves ownership to another account;
     * * balance_top_up: optionally top ups balance of the voucher from
     * origins balance;
     * * append_programs: optionally extends pool of programs by
     * `Some(programs_set)` passed or allows
     * it to interact with any program by
     * `None` passed;
     * * code_uploading: optionally allows voucher to be used to pay
     * fees for `upload_code` extrinsics;
     * * prolong_duration: optionally increases expiry block number.
     * If voucher is expired, prolongs since current bn.
     * Validity prolongation (since current block number
     * for expired or since storage written expiry)
     * should be in [MinDuration; MaxDuration], in other
     * words voucher couldn't have expiry greater than
     * current block number + MaxDuration.
     *
     * @param {AccountId32Like} spender
     * @param {PalletGearVoucherInternalVoucherId} voucherId
     * @param {AccountId32Like | undefined} moveOwnership
     * @param {bigint | undefined} balanceTopUp
     * @param {Array<GprimitivesActorId> | undefined | undefined} appendPrograms
     * @param {boolean | undefined} codeUploading
     * @param {number | undefined} prolongDuration
     **/
    update: GenericTxCall<
      Rv,
      (
        spender: AccountId32Like,
        voucherId: PalletGearVoucherInternalVoucherId,
        moveOwnership: AccountId32Like | undefined,
        balanceTopUp: bigint | undefined,
        appendPrograms: Array<GprimitivesActorId> | undefined | undefined,
        codeUploading: boolean | undefined,
        prolongDuration: number | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'GearVoucher';
          palletCall: {
            name: 'Update';
            params: {
              spender: AccountId32Like;
              voucherId: PalletGearVoucherInternalVoucherId;
              moveOwnership: AccountId32Like | undefined;
              balanceTopUp: bigint | undefined;
              appendPrograms: Array<GprimitivesActorId> | undefined | undefined;
              codeUploading: boolean | undefined;
              prolongDuration: number | undefined;
            };
          };
        }
      >
    >;

    /**
     * Decline existing and not expired voucher.
     *
     * This extrinsic expires voucher of the caller, if it's still active,
     * allowing it to be revoked.
     *
     * Arguments:
     * * voucher_id: voucher id to be declined.
     *
     * @param {PalletGearVoucherInternalVoucherId} voucherId
     **/
    decline: GenericTxCall<
      Rv,
      (voucherId: PalletGearVoucherInternalVoucherId) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'GearVoucher';
          palletCall: {
            name: 'Decline';
            params: { voucherId: PalletGearVoucherInternalVoucherId };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `GearEthBridge`'s transaction calls
   **/
  gearEthBridge: {
    /**
     * Root extrinsic that pauses pallet.
     * When paused, no new messages could be queued.
     *
     **/
    pause: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'GearEthBridge';
          palletCall: {
            name: 'Pause';
          };
        }
      >
    >;

    /**
     * Root extrinsic that unpauses pallet.
     * When paused, no new messages could be queued.
     *
     **/
    unpause: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'GearEthBridge';
          palletCall: {
            name: 'Unpause';
          };
        }
      >
    >;

    /**
     * Extrinsic that inserts message in a bridging queue,
     * updating queue merkle root at the end of the block.
     *
     * @param {H160} destination
     * @param {BytesLike} payload
     **/
    sendEthMessage: GenericTxCall<
      Rv,
      (
        destination: H160,
        payload: BytesLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'GearEthBridge';
          palletCall: {
            name: 'SendEthMessage';
            params: { destination: H160; payload: BytesLike };
          };
        }
      >
    >;

    /**
     * Root extrinsic that sets fee for the transport of messages.
     *
     * @param {bigint} fee
     **/
    setFee: GenericTxCall<
      Rv,
      (fee: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'GearEthBridge';
          palletCall: {
            name: 'SetFee';
            params: { fee: bigint };
          };
        }
      >
    >;

    /**
     * Extrinsic that verifies some block finality that resets
     * overflowed within the current era queue.
     *
     * @param {BytesLike} encodedFinalityProof
     **/
    resetOverflowedQueue: GenericTxCall<
      Rv,
      (encodedFinalityProof: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'GearEthBridge';
          palletCall: {
            name: 'ResetOverflowedQueue';
            params: { encodedFinalityProof: BytesLike };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
}
