// Generated by dedot cli

import type { GenericChainErrors, GenericPalletError } from 'dedot/types';

export interface ChainErrors extends GenericChainErrors {
  /**
   * Pallet `System`'s errors
   **/
  system: {
    /**
     * The name of specification does not match between the current runtime
     * and the new runtime.
     **/
    InvalidSpecName: GenericPalletError;

    /**
     * The specification version is not allowed to decrease between the current runtime
     * and the new runtime.
     **/
    SpecVersionNeedsToIncrease: GenericPalletError;

    /**
     * Failed to extract the runtime version from the new runtime.
     *
     * Either calling `Core_version` or decoding `RuntimeVersion` failed.
     **/
    FailedToExtractRuntimeVersion: GenericPalletError;

    /**
     * Suicide called when the account has non-default composite data.
     **/
    NonDefaultComposite: GenericPalletError;

    /**
     * There is a non-zero reference count preventing the account from being purged.
     **/
    NonZeroRefCount: GenericPalletError;

    /**
     * The origin filter prevent the call to be dispatched.
     **/
    CallFiltered: GenericPalletError;

    /**
     * A multi-block migration is ongoing and prevents the current code from being replaced.
     **/
    MultiBlockMigrationsOngoing: GenericPalletError;

    /**
     * No upgrade authorized.
     **/
    NothingAuthorized: GenericPalletError;

    /**
     * The submitted code is not authorized.
     **/
    Unauthorized: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `ParachainSystem`'s errors
   **/
  parachainSystem: {
    /**
     * Attempt to upgrade validation function while existing upgrade pending.
     **/
    OverlappingUpgrades: GenericPalletError;

    /**
     * Polkadot currently prohibits this parachain from upgrading its validation function.
     **/
    ProhibitedByPolkadot: GenericPalletError;

    /**
     * The supplied validation function has compiled into a blob larger than Polkadot is
     * willing to run.
     **/
    TooBig: GenericPalletError;

    /**
     * The inherent which supplies the validation data did not run this block.
     **/
    ValidationDataNotAvailable: GenericPalletError;

    /**
     * The inherent which supplies the host configuration did not run this block.
     **/
    HostConfigurationNotAvailable: GenericPalletError;

    /**
     * No validation function upgrade is currently scheduled.
     **/
    NotScheduled: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `MultiBlockMigrations`'s errors
   **/
  multiBlockMigrations: {
    /**
     * The operation cannot complete since some MBMs are ongoing.
     **/
    Ongoing: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Balances`'s errors
   **/
  balances: {
    /**
     * Vesting balance too high to send value.
     **/
    VestingBalance: GenericPalletError;

    /**
     * Account liquidity restrictions prevent withdrawal.
     **/
    LiquidityRestrictions: GenericPalletError;

    /**
     * Balance too low to send value.
     **/
    InsufficientBalance: GenericPalletError;

    /**
     * Value too low to create account due to existential deposit.
     **/
    ExistentialDeposit: GenericPalletError;

    /**
     * Transfer/payment would kill account.
     **/
    Expendability: GenericPalletError;

    /**
     * A vesting schedule already exists for this account.
     **/
    ExistingVestingSchedule: GenericPalletError;

    /**
     * Beneficiary account must pre-exist.
     **/
    DeadAccount: GenericPalletError;

    /**
     * Number of named reserves exceed `MaxReserves`.
     **/
    TooManyReserves: GenericPalletError;

    /**
     * Number of holds exceed `VariantCountOf<T::RuntimeHoldReason>`.
     **/
    TooManyHolds: GenericPalletError;

    /**
     * Number of freezes exceed `MaxFreezes`.
     **/
    TooManyFreezes: GenericPalletError;

    /**
     * The issuance cannot be modified since it is already deactivated.
     **/
    IssuanceDeactivated: GenericPalletError;

    /**
     * The delta cannot be zero.
     **/
    DeltaZero: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Assets`'s errors
   **/
  assets: {
    /**
     * Account balance must be greater than or equal to the transfer amount.
     **/
    BalanceLow: GenericPalletError;

    /**
     * The account to alter does not exist.
     **/
    NoAccount: GenericPalletError;

    /**
     * The signing account has no permission to do the operation.
     **/
    NoPermission: GenericPalletError;

    /**
     * The given asset ID is unknown.
     **/
    Unknown: GenericPalletError;

    /**
     * The origin account is frozen.
     **/
    Frozen: GenericPalletError;

    /**
     * The asset ID is already taken.
     **/
    InUse: GenericPalletError;

    /**
     * Invalid witness data given.
     **/
    BadWitness: GenericPalletError;

    /**
     * Minimum balance should be non-zero.
     **/
    MinBalanceZero: GenericPalletError;

    /**
     * Unable to increment the consumer reference counters on the account. Either no provider
     * reference exists to allow a non-zero balance of a non-self-sufficient asset, or one
     * fewer then the maximum number of consumers has been reached.
     **/
    UnavailableConsumer: GenericPalletError;

    /**
     * Invalid metadata given.
     **/
    BadMetadata: GenericPalletError;

    /**
     * No approval exists that would allow the transfer.
     **/
    Unapproved: GenericPalletError;

    /**
     * The source account would not survive the transfer and it needs to stay alive.
     **/
    WouldDie: GenericPalletError;

    /**
     * The asset-account already exists.
     **/
    AlreadyExists: GenericPalletError;

    /**
     * The asset-account doesn't have an associated deposit.
     **/
    NoDeposit: GenericPalletError;

    /**
     * The operation would result in funds being burned.
     **/
    WouldBurn: GenericPalletError;

    /**
     * The asset is a live asset and is actively being used. Usually emit for operations such
     * as `start_destroy` which require the asset to be in a destroying state.
     **/
    LiveAsset: GenericPalletError;

    /**
     * The asset is not live, and likely being destroyed.
     **/
    AssetNotLive: GenericPalletError;

    /**
     * The asset status is not the expected status.
     **/
    IncorrectStatus: GenericPalletError;

    /**
     * The asset should be frozen before the given operation.
     **/
    NotFrozen: GenericPalletError;

    /**
     * Callback action resulted in error
     **/
    CallbackFailed: GenericPalletError;

    /**
     * The asset ID must be equal to the [`NextAssetId`].
     **/
    BadAssetId: GenericPalletError;

    /**
     * The asset cannot be destroyed because some accounts for this asset contain freezes.
     **/
    ContainsFreezes: GenericPalletError;

    /**
     * The asset cannot be destroyed because some accounts for this asset contain holds.
     **/
    ContainsHolds: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `AssetRate`'s errors
   **/
  assetRate: {
    /**
     * The given asset ID is unknown.
     **/
    UnknownAssetKind: GenericPalletError;

    /**
     * The given asset ID already has an assigned conversion rate and cannot be re-created.
     **/
    AlreadyExists: GenericPalletError;

    /**
     * Overflow ocurred when calculating the inverse rate.
     **/
    Overflow: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `AssetsHolder`'s errors
   **/
  assetsHolder: {
    /**
     * Number of holds on an account would exceed the count of `RuntimeHoldReason`.
     **/
    TooManyHolds: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `CollatorSelection`'s errors
   **/
  collatorSelection: {
    /**
     * The pallet has too many candidates.
     **/
    TooManyCandidates: GenericPalletError;

    /**
     * Leaving would result in too few candidates.
     **/
    TooFewEligibleCollators: GenericPalletError;

    /**
     * Account is already a candidate.
     **/
    AlreadyCandidate: GenericPalletError;

    /**
     * Account is not a candidate.
     **/
    NotCandidate: GenericPalletError;

    /**
     * There are too many Invulnerables.
     **/
    TooManyInvulnerables: GenericPalletError;

    /**
     * Account is already an Invulnerable.
     **/
    AlreadyInvulnerable: GenericPalletError;

    /**
     * Account is not an Invulnerable.
     **/
    NotInvulnerable: GenericPalletError;

    /**
     * Account has no associated validator ID.
     **/
    NoAssociatedValidatorId: GenericPalletError;

    /**
     * Validator ID is not yet registered.
     **/
    ValidatorNotRegistered: GenericPalletError;

    /**
     * Could not insert in the candidate list.
     **/
    InsertToCandidateListFailed: GenericPalletError;

    /**
     * Could not remove from the candidate list.
     **/
    RemoveFromCandidateListFailed: GenericPalletError;

    /**
     * New deposit amount would be below the minimum candidacy bond.
     **/
    DepositTooLow: GenericPalletError;

    /**
     * Could not update the candidate list.
     **/
    UpdateCandidateListFailed: GenericPalletError;

    /**
     * Deposit amount is too low to take the target's slot in the candidate list.
     **/
    InsufficientBond: GenericPalletError;

    /**
     * The target account to be replaced in the candidate list is not a candidate.
     **/
    TargetIsNotCandidate: GenericPalletError;

    /**
     * The updated deposit amount is equal to the amount already reserved.
     **/
    IdenticalDeposit: GenericPalletError;

    /**
     * Cannot lower candidacy bond while occupying a future collator slot in the list.
     **/
    InvalidUnreserve: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Session`'s errors
   **/
  session: {
    /**
     * Invalid ownership proof.
     **/
    InvalidProof: GenericPalletError;

    /**
     * No associated validator ID for account.
     **/
    NoAssociatedValidatorId: GenericPalletError;

    /**
     * Registered duplicate key.
     **/
    DuplicatedKey: GenericPalletError;

    /**
     * No keys are associated with this account.
     **/
    NoKeys: GenericPalletError;

    /**
     * Key setting account is not live, so it's impossible to associate keys.
     **/
    NoAccount: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `XcmpQueue`'s errors
   **/
  xcmpQueue: {
    /**
     * Setting the queue config failed since one of its values was invalid.
     **/
    BadQueueConfig: GenericPalletError;

    /**
     * The execution is already suspended.
     **/
    AlreadySuspended: GenericPalletError;

    /**
     * The execution is already resumed.
     **/
    AlreadyResumed: GenericPalletError;

    /**
     * There are too many active outbound channels.
     **/
    TooManyActiveOutboundChannels: GenericPalletError;

    /**
     * The message is too big.
     **/
    TooBig: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `PolkadotXcm`'s errors
   **/
  polkadotXcm: {
    /**
     * The desired destination was unreachable, generally because there is a no way of routing
     * to it.
     **/
    Unreachable: GenericPalletError;

    /**
     * There was some other issue (i.e. not to do with routing) in sending the message.
     * Perhaps a lack of space for buffering the message.
     **/
    SendFailure: GenericPalletError;

    /**
     * The message execution fails the filter.
     **/
    Filtered: GenericPalletError;

    /**
     * The message's weight could not be determined.
     **/
    UnweighableMessage: GenericPalletError;

    /**
     * The destination `Location` provided cannot be inverted.
     **/
    DestinationNotInvertible: GenericPalletError;

    /**
     * The assets to be sent are empty.
     **/
    Empty: GenericPalletError;

    /**
     * Could not re-anchor the assets to declare the fees for the destination chain.
     **/
    CannotReanchor: GenericPalletError;

    /**
     * Too many assets have been attempted for transfer.
     **/
    TooManyAssets: GenericPalletError;

    /**
     * Origin is invalid for sending.
     **/
    InvalidOrigin: GenericPalletError;

    /**
     * The version of the `Versioned` value used is not able to be interpreted.
     **/
    BadVersion: GenericPalletError;

    /**
     * The given location could not be used (e.g. because it cannot be expressed in the
     * desired version of XCM).
     **/
    BadLocation: GenericPalletError;

    /**
     * The referenced subscription could not be found.
     **/
    NoSubscription: GenericPalletError;

    /**
     * The location is invalid since it already has a subscription from us.
     **/
    AlreadySubscribed: GenericPalletError;

    /**
     * Could not check-out the assets for teleportation to the destination chain.
     **/
    CannotCheckOutTeleport: GenericPalletError;

    /**
     * The owner does not own (all) of the asset that they wish to do the operation on.
     **/
    LowBalance: GenericPalletError;

    /**
     * The asset owner has too many locks on the asset.
     **/
    TooManyLocks: GenericPalletError;

    /**
     * The given account is not an identifiable sovereign account for any location.
     **/
    AccountNotSovereign: GenericPalletError;

    /**
     * The operation required fees to be paid which the initiator could not meet.
     **/
    FeesNotMet: GenericPalletError;

    /**
     * A remote lock with the corresponding data could not be found.
     **/
    LockNotFound: GenericPalletError;

    /**
     * The unlock operation cannot succeed because there are still consumers of the lock.
     **/
    InUse: GenericPalletError;

    /**
     * Invalid asset, reserve chain could not be determined for it.
     **/
    InvalidAssetUnknownReserve: GenericPalletError;

    /**
     * Invalid asset, do not support remote asset reserves with different fees reserves.
     **/
    InvalidAssetUnsupportedReserve: GenericPalletError;

    /**
     * Too many assets with different reserve locations have been attempted for transfer.
     **/
    TooManyReserves: GenericPalletError;

    /**
     * Local XCM execution incomplete.
     **/
    LocalExecutionIncomplete: GenericPalletError;

    /**
     * Too many locations authorized to alias origin.
     *
     * @deprecated Use `LocalExecutionIncompleteWithError` instead (since 20.0.0)
     **/
    TooManyAuthorizedAliases: GenericPalletError;

    /**
     * Expiry block number is in the past.
     **/
    ExpiresInPast: GenericPalletError;

    /**
     * The alias to remove authorization for was not found.
     **/
    AliasNotFound: GenericPalletError;

    /**
     * Local XCM execution incomplete with the actual XCM error and the index of the
     * instruction that caused the error.
     **/
    LocalExecutionIncompleteWithError: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `MessageQueue`'s errors
   **/
  messageQueue: {
    /**
     * Page is not reapable because it has items remaining to be processed and is not old
     * enough.
     **/
    NotReapable: GenericPalletError;

    /**
     * Page to be reaped does not exist.
     **/
    NoPage: GenericPalletError;

    /**
     * The referenced message could not be found.
     **/
    NoMessage: GenericPalletError;

    /**
     * The message was already processed and cannot be processed again.
     **/
    AlreadyProcessed: GenericPalletError;

    /**
     * The message is queued for future execution.
     **/
    Queued: GenericPalletError;

    /**
     * There is temporarily not enough weight to continue servicing messages.
     **/
    InsufficientWeight: GenericPalletError;

    /**
     * This message is temporarily unprocessable.
     *
     * Such errors are expected, but not guaranteed, to resolve themselves eventually through
     * retrying.
     **/
    TemporarilyUnprocessable: GenericPalletError;

    /**
     * The queue is paused and no message can be executed from it.
     *
     * This can change at any time and may resolve in the future by re-trying.
     **/
    QueuePaused: GenericPalletError;

    /**
     * Another call is in progress and needs to finish before this call can happen.
     **/
    RecursiveDisallowed: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Utility`'s errors
   **/
  utility: {
    /**
     * Too many calls batched.
     **/
    TooManyCalls: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Multisig`'s errors
   **/
  multisig: {
    /**
     * Threshold must be 2 or greater.
     **/
    MinimumThreshold: GenericPalletError;

    /**
     * Call is already approved by this signatory.
     **/
    AlreadyApproved: GenericPalletError;

    /**
     * Call doesn't need any (more) approvals.
     **/
    NoApprovalsNeeded: GenericPalletError;

    /**
     * There are too few signatories in the list.
     **/
    TooFewSignatories: GenericPalletError;

    /**
     * There are too many signatories in the list.
     **/
    TooManySignatories: GenericPalletError;

    /**
     * The signatories were provided out of order; they should be ordered.
     **/
    SignatoriesOutOfOrder: GenericPalletError;

    /**
     * The sender was contained in the other signatories; it shouldn't be.
     **/
    SenderInSignatories: GenericPalletError;

    /**
     * Multisig operation not found in storage.
     **/
    NotFound: GenericPalletError;

    /**
     * Only the account that originally created the multisig is able to cancel it or update
     * its deposits.
     **/
    NotOwner: GenericPalletError;

    /**
     * No timepoint was given, yet the multisig operation is already underway.
     **/
    NoTimepoint: GenericPalletError;

    /**
     * A different timepoint was given to the multisig operation that is underway.
     **/
    WrongTimepoint: GenericPalletError;

    /**
     * A timepoint was given, yet no multisig operation is underway.
     **/
    UnexpectedTimepoint: GenericPalletError;

    /**
     * The maximum weight information provided was too low.
     **/
    MaxWeightTooLow: GenericPalletError;

    /**
     * The data to be stored is already stored.
     **/
    AlreadyStored: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Proxy`'s errors
   **/
  proxy: {
    /**
     * There are too many proxies registered or too many announcements pending.
     **/
    TooMany: GenericPalletError;

    /**
     * Proxy registration not found.
     **/
    NotFound: GenericPalletError;

    /**
     * Sender is not a proxy of the account to be proxied.
     **/
    NotProxy: GenericPalletError;

    /**
     * A call which is incompatible with the proxy type's filter was attempted.
     **/
    Unproxyable: GenericPalletError;

    /**
     * Account is already a proxy.
     **/
    Duplicate: GenericPalletError;

    /**
     * Call may not be made by proxy because it may escalate its privileges.
     **/
    NoPermission: GenericPalletError;

    /**
     * Announcement, if made at all, was made too recently.
     **/
    Unannounced: GenericPalletError;

    /**
     * Cannot add self as proxy.
     **/
    NoSelfProxy: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Identity`'s errors
   **/
  identity: {
    /**
     * Too many subs-accounts.
     **/
    TooManySubAccounts: GenericPalletError;

    /**
     * Account isn't found.
     **/
    NotFound: GenericPalletError;

    /**
     * Account isn't named.
     **/
    NotNamed: GenericPalletError;

    /**
     * Empty index.
     **/
    EmptyIndex: GenericPalletError;

    /**
     * Fee is changed.
     **/
    FeeChanged: GenericPalletError;

    /**
     * No identity found.
     **/
    NoIdentity: GenericPalletError;

    /**
     * Sticky judgement.
     **/
    StickyJudgement: GenericPalletError;

    /**
     * Judgement given.
     **/
    JudgementGiven: GenericPalletError;

    /**
     * Invalid judgement.
     **/
    InvalidJudgement: GenericPalletError;

    /**
     * The index is invalid.
     **/
    InvalidIndex: GenericPalletError;

    /**
     * The target is invalid.
     **/
    InvalidTarget: GenericPalletError;

    /**
     * Maximum amount of registrars reached. Cannot add any more.
     **/
    TooManyRegistrars: GenericPalletError;

    /**
     * Account ID is already named.
     **/
    AlreadyClaimed: GenericPalletError;

    /**
     * Sender is not a sub-account.
     **/
    NotSub: GenericPalletError;

    /**
     * Sub-account isn't owned by sender.
     **/
    NotOwned: GenericPalletError;

    /**
     * The provided judgement was for a different identity.
     **/
    JudgementForDifferentIdentity: GenericPalletError;

    /**
     * Error that occurs when there is an issue paying for judgement.
     **/
    JudgementPaymentFailed: GenericPalletError;

    /**
     * The provided suffix is too long.
     **/
    InvalidSuffix: GenericPalletError;

    /**
     * The sender does not have permission to issue a username.
     **/
    NotUsernameAuthority: GenericPalletError;

    /**
     * The authority cannot allocate any more usernames.
     **/
    NoAllocation: GenericPalletError;

    /**
     * The signature on a username was not valid.
     **/
    InvalidSignature: GenericPalletError;

    /**
     * Setting this username requires a signature, but none was provided.
     **/
    RequiresSignature: GenericPalletError;

    /**
     * The username does not meet the requirements.
     **/
    InvalidUsername: GenericPalletError;

    /**
     * The username is already taken.
     **/
    UsernameTaken: GenericPalletError;

    /**
     * The requested username does not exist.
     **/
    NoUsername: GenericPalletError;

    /**
     * The username cannot be forcefully removed because it can still be accepted.
     **/
    NotExpired: GenericPalletError;

    /**
     * The username cannot be removed because it's still in the grace period.
     **/
    TooEarly: GenericPalletError;

    /**
     * The username cannot be removed because it is not unbinding.
     **/
    NotUnbinding: GenericPalletError;

    /**
     * The username cannot be unbound because it is already unbinding.
     **/
    AlreadyUnbinding: GenericPalletError;

    /**
     * The action cannot be performed because of insufficient privileges (e.g. authority
     * trying to unbind a username provided by the system).
     **/
    InsufficientPrivileges: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Sudo`'s errors
   **/
  sudo: {
    /**
     * Sender must be the Sudo account.
     **/
    RequireSudo: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
}
