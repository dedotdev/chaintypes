// Generated by dedot cli

import type { GenericChainViewFunctions, GenericViewFunction } from 'dedot/types';
import type { Result, AccountId32Like } from 'dedot/codecs';
import type {
  AssetHubWestendRuntimeRuntimeCallLike,
  AssetHubWestendRuntimeProxyType,
  StagingXcmV5Location,
  PalletAssetConversionError,
} from './types.js';

export interface ChainViewFunctions extends GenericChainViewFunctions {
  /**
   * Pallet `Proxy`'s view functions
   **/
  proxy: {
    /**
     * Check if a `RuntimeCall` is allowed for a given `ProxyType`.
     *
     * @param {AssetHubWestendRuntimeRuntimeCallLike} call
     * @param {AssetHubWestendRuntimeProxyType} proxyType
     **/
    checkPermissions: GenericViewFunction<
      (call: AssetHubWestendRuntimeRuntimeCallLike, proxyType: AssetHubWestendRuntimeProxyType) => Promise<boolean>
    >;

    /**
     * Check if one `ProxyType` is a subset of another `ProxyType`.
     *
     * @param {AssetHubWestendRuntimeProxyType} toCheck
     * @param {AssetHubWestendRuntimeProxyType} against
     **/
    isSuperset: GenericViewFunction<
      (toCheck: AssetHubWestendRuntimeProxyType, against: AssetHubWestendRuntimeProxyType) => Promise<boolean>
    >;

    /**
     * Generic pallet view function
     **/
    [name: string]: GenericViewFunction;
  };
  /**
   * Pallet `AssetConversion`'s view functions
   **/
  assetConversion: {
    /**
     * Returns the balance of each asset in the pool.
     * The tuple result is in the order requested (not necessarily the same as pool order).
     *
     * @param {StagingXcmV5Location} asset1
     * @param {StagingXcmV5Location} asset2
     **/
    getReserves: GenericViewFunction<
      (
        asset1: StagingXcmV5Location,
        asset2: StagingXcmV5Location,
      ) => Promise<Result<[bigint, bigint], PalletAssetConversionError>>
    >;

    /**
     * Gets a quote for swapping an exact amount of `asset1` for `asset2`.
     *
     * If `include_fee` is true, the quote will include the liquidity provider fee.
     * If the pool does not exist or has no liquidity, `None` is returned.
     * Note that the price may have changed by the time the transaction is executed.
     * (Use `amount_out_min` to control slippage.)
     * Returns `Some(quoted_amount)` on success.
     *
     * @param {StagingXcmV5Location} asset1
     * @param {StagingXcmV5Location} asset2
     * @param {bigint} amount
     * @param {boolean} includeFee
     **/
    quotePriceExactTokensForTokens: GenericViewFunction<
      (
        asset1: StagingXcmV5Location,
        asset2: StagingXcmV5Location,
        amount: bigint,
        includeFee: boolean,
      ) => Promise<bigint | undefined>
    >;

    /**
     * Gets a quote for swapping `amount` of `asset1` for an exact amount of `asset2`.
     *
     * If `include_fee` is true, the quote will include the liquidity provider fee.
     * If the pool does not exist or has no liquidity, `None` is returned.
     * Note that the price may have changed by the time the transaction is executed.
     * (Use `amount_in_max` to control slippage.)
     * Returns `Some(quoted_amount)` on success.
     *
     * @param {StagingXcmV5Location} asset1
     * @param {StagingXcmV5Location} asset2
     * @param {bigint} amount
     * @param {boolean} includeFee
     **/
    quotePriceTokensForExactTokens: GenericViewFunction<
      (
        asset1: StagingXcmV5Location,
        asset2: StagingXcmV5Location,
        amount: bigint,
        includeFee: boolean,
      ) => Promise<bigint | undefined>
    >;

    /**
     * Generic pallet view function
     **/
    [name: string]: GenericViewFunction;
  };
  /**
   * Pallet `VoterList`'s view functions
   **/
  voterList: {
    /**
     * Get the current `score` of a given account.
     *
     * Returns `(current, real_score)`, the former being the current score that this pallet is
     * aware of, which may or may not be up to date, and the latter being the real score, as
     * provided by
     *
     * If the two differ, it means this node is eligible for [`Call::rebag`].
     *
     * @param {AccountId32Like} who
     **/
    scores: GenericViewFunction<(who: AccountId32Like) => Promise<[bigint | undefined, bigint | undefined]>>;

    /**
     * Generic pallet view function
     **/
    [name: string]: GenericViewFunction;
  };
  /**
   * Pallet `MultiBlockElectionSigned`'s view functions
   **/
  multiBlockElectionSigned: {
    /**
     * Get the deposit amount that will be held for a solution of `pages`.
     *
     * This allows an offchain application to know what [`Config::DepositPerPage`] and
     * [`Config::DepositBase`] are doing under the hood. It also takes into account if `who` is
     * [`Invulnerables`] or not.
     *
     * @param {AccountId32Like} who
     * @param {number} pages
     **/
    depositFor: GenericViewFunction<(who: AccountId32Like, pages: number) => Promise<bigint>>;

    /**
     * Generic pallet view function
     **/
    [name: string]: GenericViewFunction;
  };
}
