// Generated by dedot cli

import type {
  Phase,
  H256,
  DispatchInfo,
  DispatchError,
  AccountId32,
  FixedBytes,
  Result,
  Perbill,
  Bytes,
  BytesLike,
  Header,
  MultiAddress,
  MultiAddressLike,
  AccountId32Like,
  Percent,
  Data,
  PerU16,
  FixedArray,
  Perquintill,
  FixedI64,
  FixedU128,
  Era,
  UncheckedExtrinsic,
} from 'dedot/codecs';

export type FrameSystemAccountInfo = {
  nonce: number;
  consumers: number;
  providers: number;
  sufficients: number;
  data: PalletBalancesAccountData;
};

export type PalletBalancesAccountData = {
  free: bigint;
  reserved: bigint;
  frozen: bigint;
  flags: PalletBalancesExtraFlags;
};

export type PalletBalancesExtraFlags = bigint;

export type FrameSupportDispatchPerDispatchClass = {
  normal: SpWeightsWeightV2Weight;
  operational: SpWeightsWeightV2Weight;
  mandatory: SpWeightsWeightV2Weight;
};

export type SpWeightsWeightV2Weight = { refTime: bigint; proofSize: bigint };

export type FrameSystemEventRecord = { phase: Phase; event: VaraRuntimeRuntimeEvent; topics: Array<H256> };

export type VaraRuntimeRuntimeEvent =
  | { pallet: 'System'; palletEvent: FrameSystemEvent }
  | { pallet: 'Grandpa'; palletEvent: PalletGrandpaEvent }
  | { pallet: 'Balances'; palletEvent: PalletBalancesEvent }
  | { pallet: 'TransactionPayment'; palletEvent: PalletTransactionPaymentEvent }
  | { pallet: 'Session'; palletEvent: PalletSessionEvent }
  | { pallet: 'Utility'; palletEvent: PalletUtilityEvent }
  | { pallet: 'Vesting'; palletEvent: PalletVestingEvent }
  | { pallet: 'BagsList'; palletEvent: PalletBagsListEvent }
  | { pallet: 'ImOnline'; palletEvent: PalletImOnlineEvent }
  | { pallet: 'Staking'; palletEvent: PalletStakingPalletEvent }
  | { pallet: 'Treasury'; palletEvent: PalletTreasuryEvent }
  | { pallet: 'ConvictionVoting'; palletEvent: PalletConvictionVotingEvent }
  | { pallet: 'Referenda'; palletEvent: PalletReferendaEvent }
  | { pallet: 'FellowshipCollective'; palletEvent: PalletRankedCollectiveEvent }
  | { pallet: 'FellowshipReferenda'; palletEvent: PalletReferendaEvent002 }
  | { pallet: 'Whitelist'; palletEvent: PalletWhitelistEvent }
  | { pallet: 'Scheduler'; palletEvent: PalletSchedulerEvent }
  | { pallet: 'Preimage'; palletEvent: PalletPreimageEvent }
  | { pallet: 'Identity'; palletEvent: PalletIdentityEvent }
  | { pallet: 'Proxy'; palletEvent: PalletProxyEvent }
  | { pallet: 'Multisig'; palletEvent: PalletMultisigEvent }
  | { pallet: 'ElectionProviderMultiPhase'; palletEvent: PalletElectionProviderMultiPhaseEvent }
  | { pallet: 'Offences'; palletEvent: PalletOffencesEvent }
  | { pallet: 'Bounties'; palletEvent: PalletBountiesEvent }
  | { pallet: 'ChildBounties'; palletEvent: PalletChildBountiesEvent }
  | { pallet: 'NominationPools'; palletEvent: PalletNominationPoolsEvent }
  | { pallet: 'Gear'; palletEvent: PalletGearEvent }
  | { pallet: 'StakingRewards'; palletEvent: PalletGearStakingRewardsEvent }
  | { pallet: 'GearVoucher'; palletEvent: PalletGearVoucherEvent };

/**
 * Event for the System pallet.
 **/
export type FrameSystemEvent =
  /**
   * An extrinsic completed successfully.
   **/
  | { name: 'ExtrinsicSuccess'; data: { dispatchInfo: DispatchInfo } }
  /**
   * An extrinsic failed.
   **/
  | { name: 'ExtrinsicFailed'; data: { dispatchError: DispatchError; dispatchInfo: DispatchInfo } }
  /**
   * `:code` was updated.
   **/
  | { name: 'CodeUpdated' }
  /**
   * A new account was created.
   **/
  | { name: 'NewAccount'; data: { account: AccountId32 } }
  /**
   * An account was reaped.
   **/
  | { name: 'KilledAccount'; data: { account: AccountId32 } }
  /**
   * On on-chain remark happened.
   **/
  | { name: 'Remarked'; data: { sender: AccountId32; hash: H256 } }
  /**
   * An upgrade was authorized.
   **/
  | { name: 'UpgradeAuthorized'; data: { codeHash: H256; checkVersion: boolean } };

export type FrameSupportDispatchDispatchClass = 'Normal' | 'Operational' | 'Mandatory';

export type FrameSupportDispatchPays = 'Yes' | 'No';

/**
 * The `Event` enum of this pallet
 **/
export type PalletGrandpaEvent =
  /**
   * New authority set has been applied.
   **/
  | { name: 'NewAuthorities'; data: { authoritySet: Array<[SpConsensusGrandpaAppPublic, bigint]> } }
  /**
   * Current authority set has been paused.
   **/
  | { name: 'Paused' }
  /**
   * Current authority set has been resumed.
   **/
  | { name: 'Resumed' };

export type SpConsensusGrandpaAppPublic = FixedBytes<32>;

/**
 * The `Event` enum of this pallet
 **/
export type PalletBalancesEvent =
  /**
   * An account was created with some free balance.
   **/
  | { name: 'Endowed'; data: { account: AccountId32; freeBalance: bigint } }
  /**
   * An account was removed whose balance was non-zero but below ExistentialDeposit,
   * resulting in an outright loss.
   **/
  | { name: 'DustLost'; data: { account: AccountId32; amount: bigint } }
  /**
   * Transfer succeeded.
   **/
  | { name: 'Transfer'; data: { from: AccountId32; to: AccountId32; amount: bigint } }
  /**
   * A balance was set by root.
   **/
  | { name: 'BalanceSet'; data: { who: AccountId32; free: bigint } }
  /**
   * Some balance was reserved (moved from free to reserved).
   **/
  | { name: 'Reserved'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was unreserved (moved from reserved to free).
   **/
  | { name: 'Unreserved'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was moved from the reserve of the first account to the second account.
   * Final argument indicates the destination balance type.
   **/
  | {
      name: 'ReserveRepatriated';
      data: {
        from: AccountId32;
        to: AccountId32;
        amount: bigint;
        destinationStatus: FrameSupportTokensMiscBalanceStatus;
      };
    }
  /**
   * Some amount was deposited (e.g. for transaction fees).
   **/
  | { name: 'Deposit'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was withdrawn from the account (e.g. for transaction fees).
   **/
  | { name: 'Withdraw'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was removed from the account (e.g. for misbehavior).
   **/
  | { name: 'Slashed'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was minted into an account.
   **/
  | { name: 'Minted'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was burned from an account.
   **/
  | { name: 'Burned'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was suspended from an account (it can be restored later).
   **/
  | { name: 'Suspended'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was restored into an account.
   **/
  | { name: 'Restored'; data: { who: AccountId32; amount: bigint } }
  /**
   * An account was upgraded.
   **/
  | { name: 'Upgraded'; data: { who: AccountId32 } }
  /**
   * Total issuance was increased by `amount`, creating a credit to be balanced.
   **/
  | { name: 'Issued'; data: { amount: bigint } }
  /**
   * Total issuance was decreased by `amount`, creating a debt to be balanced.
   **/
  | { name: 'Rescinded'; data: { amount: bigint } }
  /**
   * Some balance was locked.
   **/
  | { name: 'Locked'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was unlocked.
   **/
  | { name: 'Unlocked'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was frozen.
   **/
  | { name: 'Frozen'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was thawed.
   **/
  | { name: 'Thawed'; data: { who: AccountId32; amount: bigint } }
  /**
   * The `TotalIssuance` was forcefully changed.
   **/
  | { name: 'TotalIssuanceForced'; data: { old: bigint; new: bigint } };

export type FrameSupportTokensMiscBalanceStatus = 'Free' | 'Reserved';

/**
 * The `Event` enum of this pallet
 **/
export type PalletTransactionPaymentEvent =
  /**
   * A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,
   * has been paid by `who`.
   **/
  { name: 'TransactionFeePaid'; data: { who: AccountId32; actualFee: bigint; tip: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletSessionEvent =
  /**
   * New session has happened. Note that the argument is the session index, not the
   * block number as the type might suggest.
   **/
  { name: 'NewSession'; data: { sessionIndex: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletUtilityEvent =
  /**
   * Batch of dispatches did not complete fully. Index of first failing dispatch given, as
   * well as the error.
   **/
  | { name: 'BatchInterrupted'; data: { index: number; error: DispatchError } }
  /**
   * Batch of dispatches completed fully with no error.
   **/
  | { name: 'BatchCompleted' }
  /**
   * Batch of dispatches completed but has errors.
   **/
  | { name: 'BatchCompletedWithErrors' }
  /**
   * A single item within a Batch of dispatches has completed with no error.
   **/
  | { name: 'ItemCompleted' }
  /**
   * A single item within a Batch of dispatches has completed with error.
   **/
  | { name: 'ItemFailed'; data: { error: DispatchError } }
  /**
   * A call was dispatched.
   **/
  | { name: 'DispatchedAs'; data: { result: Result<[], DispatchError> } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletVestingEvent =
  /**
   * The amount vested has been updated. This could indicate a change in funds available.
   * The balance given is the amount which is left unvested (and thus locked).
   **/
  | { name: 'VestingUpdated'; data: { account: AccountId32; unvested: bigint } }
  /**
   * An \[account\] has become fully vested.
   **/
  | { name: 'VestingCompleted'; data: { account: AccountId32 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletBagsListEvent =
  /**
   * Moved an account from one bag to another.
   **/
  | { name: 'Rebagged'; data: { who: AccountId32; from: bigint; to: bigint } }
  /**
   * Updated the score of some account to the given amount.
   **/
  | { name: 'ScoreUpdated'; data: { who: AccountId32; newScore: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletImOnlineEvent =
  /**
   * A new heartbeat was received from `AuthorityId`.
   **/
  | { name: 'HeartbeatReceived'; data: { authorityId: PalletImOnlineSr25519AppSr25519Public } }
  /**
   * At the end of the session, no offence was committed.
   **/
  | { name: 'AllGood' }
  /**
   * At the end of the session, at least one validator was found to be offline.
   **/
  | { name: 'SomeOffline'; data: { offline: Array<[AccountId32, SpStakingExposure]> } };

export type PalletImOnlineSr25519AppSr25519Public = FixedBytes<32>;

export type SpStakingExposure = { total: bigint; own: bigint; others: Array<SpStakingIndividualExposure> };

export type SpStakingIndividualExposure = { who: AccountId32; value: bigint };

/**
 * The `Event` enum of this pallet
 **/
export type PalletStakingPalletEvent =
  /**
   * The era payout has been set; the first balance is the validator-payout; the second is
   * the remainder from the maximum amount of reward.
   **/
  | { name: 'EraPaid'; data: { eraIndex: number; validatorPayout: bigint; remainder: bigint } }
  /**
   * The nominator has been rewarded by this amount to this destination.
   **/
  | { name: 'Rewarded'; data: { stash: AccountId32; dest: PalletStakingRewardDestination; amount: bigint } }
  /**
   * A staker (validator or nominator) has been slashed by the given amount.
   **/
  | { name: 'Slashed'; data: { staker: AccountId32; amount: bigint } }
  /**
   * A slash for the given validator, for the given percentage of their stake, at the given
   * era as been reported.
   **/
  | { name: 'SlashReported'; data: { validator: AccountId32; fraction: Perbill; slashEra: number } }
  /**
   * An old slashing report from a prior era was discarded because it could
   * not be processed.
   **/
  | { name: 'OldSlashingReportDiscarded'; data: { sessionIndex: number } }
  /**
   * A new set of stakers was elected.
   **/
  | { name: 'StakersElected' }
  /**
   * An account has bonded this amount. \[stash, amount\]
   *
   * NOTE: This event is only emitted when funds are bonded via a dispatchable. Notably,
   * it will not be emitted for staking rewards when they are added to stake.
   **/
  | { name: 'Bonded'; data: { stash: AccountId32; amount: bigint } }
  /**
   * An account has unbonded this amount.
   **/
  | { name: 'Unbonded'; data: { stash: AccountId32; amount: bigint } }
  /**
   * An account has called `withdraw_unbonded` and removed unbonding chunks worth `Balance`
   * from the unlocking queue.
   **/
  | { name: 'Withdrawn'; data: { stash: AccountId32; amount: bigint } }
  /**
   * A nominator has been kicked from a validator.
   **/
  | { name: 'Kicked'; data: { nominator: AccountId32; stash: AccountId32 } }
  /**
   * The election failed. No new era is planned.
   **/
  | { name: 'StakingElectionFailed' }
  /**
   * An account has stopped participating as either a validator or nominator.
   **/
  | { name: 'Chilled'; data: { stash: AccountId32 } }
  /**
   * The stakers' rewards are getting paid.
   **/
  | { name: 'PayoutStarted'; data: { eraIndex: number; validatorStash: AccountId32 } }
  /**
   * A validator has set their preferences.
   **/
  | { name: 'ValidatorPrefsSet'; data: { stash: AccountId32; prefs: PalletStakingValidatorPrefs } }
  /**
   * Voters size limit reached.
   **/
  | { name: 'SnapshotVotersSizeExceeded'; data: { size: number } }
  /**
   * Targets size limit reached.
   **/
  | { name: 'SnapshotTargetsSizeExceeded'; data: { size: number } }
  /**
   * A new force era mode was set.
   **/
  | { name: 'ForceEra'; data: { mode: PalletStakingForcing } }
  /**
   * Report of a controller batch deprecation.
   **/
  | { name: 'ControllerBatchDeprecated'; data: { failures: number } };

export type PalletStakingRewardDestination =
  | { type: 'Staked' }
  | { type: 'Stash' }
  | { type: 'Controller' }
  | { type: 'Account'; value: AccountId32 }
  | { type: 'None' };

export type PalletStakingValidatorPrefs = { commission: Perbill; blocked: boolean };

export type PalletStakingForcing = 'NotForcing' | 'ForceNew' | 'ForceNone' | 'ForceAlways';

/**
 * The `Event` enum of this pallet
 **/
export type PalletTreasuryEvent =
  /**
   * We have ended a spend period and will now allocate funds.
   **/
  | { name: 'Spending'; data: { budgetRemaining: bigint } }
  /**
   * Some funds have been allocated.
   **/
  | { name: 'Awarded'; data: { proposalIndex: number; award: bigint; account: AccountId32 } }
  /**
   * Some of our funds have been burnt.
   **/
  | { name: 'Burnt'; data: { burntFunds: bigint } }
  /**
   * Spending has finished; this is the amount that rolls over until next spend.
   **/
  | { name: 'Rollover'; data: { rolloverBalance: bigint } }
  /**
   * Some funds have been deposited.
   **/
  | { name: 'Deposit'; data: { value: bigint } }
  /**
   * A new spend proposal has been approved.
   **/
  | { name: 'SpendApproved'; data: { proposalIndex: number; amount: bigint; beneficiary: AccountId32 } }
  /**
   * The inactive funds of the pallet have been updated.
   **/
  | { name: 'UpdatedInactive'; data: { reactivated: bigint; deactivated: bigint } }
  /**
   * A new asset spend proposal has been approved.
   **/
  | {
      name: 'AssetSpendApproved';
      data: {
        index: number;
        assetKind: [];
        amount: bigint;
        beneficiary: AccountId32;
        validFrom: number;
        expireAt: number;
      };
    }
  /**
   * An approved spend was voided.
   **/
  | { name: 'AssetSpendVoided'; data: { index: number } }
  /**
   * A payment happened.
   **/
  | { name: 'Paid'; data: { index: number; paymentId: [] } }
  /**
   * A payment failed and can be retried.
   **/
  | { name: 'PaymentFailed'; data: { index: number; paymentId: [] } }
  /**
   * A spend was processed and removed from the storage. It might have been successfully
   * paid or it may have expired.
   **/
  | { name: 'SpendProcessed'; data: { index: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletConvictionVotingEvent =
  /**
   * An account has delegated their vote to another account. \[who, target\]
   **/
  | { name: 'Delegated'; data: [AccountId32, AccountId32] }
  /**
   * An \[account\] has cancelled a previous delegation operation.
   **/
  | { name: 'Undelegated'; data: AccountId32 }
  /**
   * An account that has voted
   **/
  | { name: 'Voted'; data: { who: AccountId32; vote: PalletConvictionVotingVoteAccountVote } }
  /**
   * A vote that been removed
   **/
  | { name: 'VoteRemoved'; data: { who: AccountId32; vote: PalletConvictionVotingVoteAccountVote } };

export type PalletConvictionVotingVoteAccountVote =
  | { type: 'Standard'; value: { vote: PalletConvictionVotingVote; balance: bigint } }
  | { type: 'Split'; value: { aye: bigint; nay: bigint } }
  | { type: 'SplitAbstain'; value: { aye: bigint; nay: bigint; abstain: bigint } };

export type PalletConvictionVotingVote = number;

/**
 * The `Event` enum of this pallet
 **/
export type PalletReferendaEvent =
  /**
   * A referendum has been submitted.
   **/
  | {
      name: 'Submitted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The track (and by extension proposal dispatch origin) of this referendum.
         **/
        track: number;

        /**
         * The proposal for the referendum.
         **/
        proposal: FrameSupportPreimagesBounded;
      };
    }
  /**
   * The decision deposit has been placed.
   **/
  | {
      name: 'DecisionDepositPlaced';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * The decision deposit has been refunded.
   **/
  | {
      name: 'DecisionDepositRefunded';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * A deposit has been slashed.
   **/
  | {
      name: 'DepositSlashed';
      data: {
        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * A referendum has moved into the deciding phase.
   **/
  | {
      name: 'DecisionStarted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The track (and by extension proposal dispatch origin) of this referendum.
         **/
        track: number;

        /**
         * The proposal for the referendum.
         **/
        proposal: FrameSupportPreimagesBounded;

        /**
         * The current tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  | {
      name: 'ConfirmStarted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  | {
      name: 'ConfirmAborted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  /**
   * A referendum has ended its confirmation phase and is ready for approval.
   **/
  | {
      name: 'Confirmed';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  /**
   * A referendum has been approved and its proposal has been scheduled.
   **/
  | {
      name: 'Approved';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  /**
   * A proposal has been rejected by referendum.
   **/
  | {
      name: 'Rejected';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  /**
   * A referendum has been timed out without being decided.
   **/
  | {
      name: 'TimedOut';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  /**
   * A referendum has been cancelled.
   **/
  | {
      name: 'Cancelled';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  /**
   * A referendum has been killed.
   **/
  | {
      name: 'Killed';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  /**
   * The submission deposit has been refunded.
   **/
  | {
      name: 'SubmissionDepositRefunded';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * Metadata for a referendum has been set.
   **/
  | {
      name: 'MetadataSet';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    }
  /**
   * Metadata for a referendum has been cleared.
   **/
  | {
      name: 'MetadataCleared';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    };

export type FrameSupportPreimagesBounded =
  | { type: 'Legacy'; value: { hash: H256 } }
  | { type: 'Inline'; value: Bytes }
  | { type: 'Lookup'; value: { hash: H256; len: number } };

export type VaraRuntimeRuntimeCall =
  | { pallet: 'System'; palletCall: FrameSystemCall }
  | { pallet: 'Timestamp'; palletCall: PalletTimestampCall }
  | { pallet: 'Babe'; palletCall: PalletBabeCall }
  | { pallet: 'Grandpa'; palletCall: PalletGrandpaCall }
  | { pallet: 'Balances'; palletCall: PalletBalancesCall }
  | { pallet: 'Session'; palletCall: PalletSessionCall }
  | { pallet: 'Utility'; palletCall: PalletUtilityCall }
  | { pallet: 'Vesting'; palletCall: PalletVestingCall }
  | { pallet: 'BagsList'; palletCall: PalletBagsListCall }
  | { pallet: 'ImOnline'; palletCall: PalletImOnlineCall }
  | { pallet: 'Staking'; palletCall: PalletStakingPalletCall }
  | { pallet: 'Treasury'; palletCall: PalletTreasuryCall }
  | { pallet: 'ConvictionVoting'; palletCall: PalletConvictionVotingCall }
  | { pallet: 'Referenda'; palletCall: PalletReferendaCall }
  | { pallet: 'FellowshipCollective'; palletCall: PalletRankedCollectiveCall }
  | { pallet: 'FellowshipReferenda'; palletCall: PalletReferendaCall }
  | { pallet: 'Whitelist'; palletCall: PalletWhitelistCall }
  | { pallet: 'Scheduler'; palletCall: PalletSchedulerCall }
  | { pallet: 'Preimage'; palletCall: PalletPreimageCall }
  | { pallet: 'Identity'; palletCall: PalletIdentityCall }
  | { pallet: 'Proxy'; palletCall: PalletProxyCall }
  | { pallet: 'Multisig'; palletCall: PalletMultisigCall }
  | { pallet: 'ElectionProviderMultiPhase'; palletCall: PalletElectionProviderMultiPhaseCall }
  | { pallet: 'Bounties'; palletCall: PalletBountiesCall }
  | { pallet: 'ChildBounties'; palletCall: PalletChildBountiesCall }
  | { pallet: 'NominationPools'; palletCall: PalletNominationPoolsCall }
  | { pallet: 'Gear'; palletCall: PalletGearCall }
  | { pallet: 'StakingRewards'; palletCall: PalletGearStakingRewardsCall }
  | { pallet: 'GearVoucher'; palletCall: PalletGearVoucherCall };

export type VaraRuntimeRuntimeCallLike =
  | { pallet: 'System'; palletCall: FrameSystemCallLike }
  | { pallet: 'Timestamp'; palletCall: PalletTimestampCallLike }
  | { pallet: 'Babe'; palletCall: PalletBabeCallLike }
  | { pallet: 'Grandpa'; palletCall: PalletGrandpaCallLike }
  | { pallet: 'Balances'; palletCall: PalletBalancesCallLike }
  | { pallet: 'Session'; palletCall: PalletSessionCallLike }
  | { pallet: 'Utility'; palletCall: PalletUtilityCallLike }
  | { pallet: 'Vesting'; palletCall: PalletVestingCallLike }
  | { pallet: 'BagsList'; palletCall: PalletBagsListCallLike }
  | { pallet: 'ImOnline'; palletCall: PalletImOnlineCallLike }
  | { pallet: 'Staking'; palletCall: PalletStakingPalletCallLike }
  | { pallet: 'Treasury'; palletCall: PalletTreasuryCallLike }
  | { pallet: 'ConvictionVoting'; palletCall: PalletConvictionVotingCallLike }
  | { pallet: 'Referenda'; palletCall: PalletReferendaCallLike }
  | { pallet: 'FellowshipCollective'; palletCall: PalletRankedCollectiveCallLike }
  | { pallet: 'FellowshipReferenda'; palletCall: PalletReferendaCallLike }
  | { pallet: 'Whitelist'; palletCall: PalletWhitelistCallLike }
  | { pallet: 'Scheduler'; palletCall: PalletSchedulerCallLike }
  | { pallet: 'Preimage'; palletCall: PalletPreimageCallLike }
  | { pallet: 'Identity'; palletCall: PalletIdentityCallLike }
  | { pallet: 'Proxy'; palletCall: PalletProxyCallLike }
  | { pallet: 'Multisig'; palletCall: PalletMultisigCallLike }
  | { pallet: 'ElectionProviderMultiPhase'; palletCall: PalletElectionProviderMultiPhaseCallLike }
  | { pallet: 'Bounties'; palletCall: PalletBountiesCallLike }
  | { pallet: 'ChildBounties'; palletCall: PalletChildBountiesCallLike }
  | { pallet: 'NominationPools'; palletCall: PalletNominationPoolsCallLike }
  | { pallet: 'Gear'; palletCall: PalletGearCallLike }
  | { pallet: 'StakingRewards'; palletCall: PalletGearStakingRewardsCallLike }
  | { pallet: 'GearVoucher'; palletCall: PalletGearVoucherCallLike };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type FrameSystemCall =
  /**
   * Make some on-chain remark.
   *
   * Can be executed by every `origin`.
   **/
  | { name: 'Remark'; params: { remark: Bytes } }
  /**
   * Set the number of pages in the WebAssembly environment's heap.
   **/
  | { name: 'SetHeapPages'; params: { pages: bigint } }
  /**
   * Set the new runtime code.
   **/
  | { name: 'SetCode'; params: { code: Bytes } }
  /**
   * Set the new runtime code without doing any checks of the given `code`.
   *
   * Note that runtime upgrades will not run if this is called with a not-increasing spec
   * version!
   **/
  | { name: 'SetCodeWithoutChecks'; params: { code: Bytes } }
  /**
   * Set some items of storage.
   **/
  | { name: 'SetStorage'; params: { items: Array<[Bytes, Bytes]> } }
  /**
   * Kill some items from storage.
   **/
  | { name: 'KillStorage'; params: { keys: Array<Bytes> } }
  /**
   * Kill all storage items with a key that starts with the given prefix.
   *
   * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
   * the prefix we are removing to accurately calculate the weight of this function.
   **/
  | { name: 'KillPrefix'; params: { prefix: Bytes; subkeys: number } }
  /**
   * Make some on-chain remark and emit event.
   **/
  | { name: 'RemarkWithEvent'; params: { remark: Bytes } }
  /**
   * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
   * later.
   *
   * This call requires Root origin.
   **/
  | { name: 'AuthorizeUpgrade'; params: { codeHash: H256 } }
  /**
   * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
   * later.
   *
   * WARNING: This authorizes an upgrade that will take place without any safety checks, for
   * example that the spec name remains the same and that the version number increases. Not
   * recommended for normal use. Use `authorize_upgrade` instead.
   *
   * This call requires Root origin.
   **/
  | { name: 'AuthorizeUpgradeWithoutChecks'; params: { codeHash: H256 } }
  /**
   * Provide the preimage (runtime binary) `code` for an upgrade that has been authorized.
   *
   * If the authorization required a version check, this call will ensure the spec name
   * remains unchanged and that the spec version has increased.
   *
   * Depending on the runtime's `OnSetCode` configuration, this function may directly apply
   * the new `code` in the same block or attempt to schedule the upgrade.
   *
   * All origins are allowed.
   **/
  | { name: 'ApplyAuthorizedUpgrade'; params: { code: Bytes } };

export type FrameSystemCallLike =
  /**
   * Make some on-chain remark.
   *
   * Can be executed by every `origin`.
   **/
  | { name: 'Remark'; params: { remark: BytesLike } }
  /**
   * Set the number of pages in the WebAssembly environment's heap.
   **/
  | { name: 'SetHeapPages'; params: { pages: bigint } }
  /**
   * Set the new runtime code.
   **/
  | { name: 'SetCode'; params: { code: BytesLike } }
  /**
   * Set the new runtime code without doing any checks of the given `code`.
   *
   * Note that runtime upgrades will not run if this is called with a not-increasing spec
   * version!
   **/
  | { name: 'SetCodeWithoutChecks'; params: { code: BytesLike } }
  /**
   * Set some items of storage.
   **/
  | { name: 'SetStorage'; params: { items: Array<[BytesLike, BytesLike]> } }
  /**
   * Kill some items from storage.
   **/
  | { name: 'KillStorage'; params: { keys: Array<BytesLike> } }
  /**
   * Kill all storage items with a key that starts with the given prefix.
   *
   * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
   * the prefix we are removing to accurately calculate the weight of this function.
   **/
  | { name: 'KillPrefix'; params: { prefix: BytesLike; subkeys: number } }
  /**
   * Make some on-chain remark and emit event.
   **/
  | { name: 'RemarkWithEvent'; params: { remark: BytesLike } }
  /**
   * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
   * later.
   *
   * This call requires Root origin.
   **/
  | { name: 'AuthorizeUpgrade'; params: { codeHash: H256 } }
  /**
   * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
   * later.
   *
   * WARNING: This authorizes an upgrade that will take place without any safety checks, for
   * example that the spec name remains the same and that the version number increases. Not
   * recommended for normal use. Use `authorize_upgrade` instead.
   *
   * This call requires Root origin.
   **/
  | { name: 'AuthorizeUpgradeWithoutChecks'; params: { codeHash: H256 } }
  /**
   * Provide the preimage (runtime binary) `code` for an upgrade that has been authorized.
   *
   * If the authorization required a version check, this call will ensure the spec name
   * remains unchanged and that the spec version has increased.
   *
   * Depending on the runtime's `OnSetCode` configuration, this function may directly apply
   * the new `code` in the same block or attempt to schedule the upgrade.
   *
   * All origins are allowed.
   **/
  | { name: 'ApplyAuthorizedUpgrade'; params: { code: BytesLike } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTimestampCall =
  /**
   * Set the current time.
   *
   * This call should be invoked exactly once per block. It will panic at the finalization
   * phase, if this call hasn't been invoked by that time.
   *
   * The timestamp should be greater than the previous one by the amount specified by
   * [`Config::MinimumPeriod`].
   *
   * The dispatch origin for this call must be _None_.
   *
   * This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware
   * that changing the complexity of this call could result exhausting the resources in a
   * block to execute any other calls.
   *
   * ## Complexity
   * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
   * - 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in
   * `on_finalize`)
   * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
   **/
  { name: 'Set'; params: { now: bigint } };

export type PalletTimestampCallLike =
  /**
   * Set the current time.
   *
   * This call should be invoked exactly once per block. It will panic at the finalization
   * phase, if this call hasn't been invoked by that time.
   *
   * The timestamp should be greater than the previous one by the amount specified by
   * [`Config::MinimumPeriod`].
   *
   * The dispatch origin for this call must be _None_.
   *
   * This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware
   * that changing the complexity of this call could result exhausting the resources in a
   * block to execute any other calls.
   *
   * ## Complexity
   * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
   * - 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in
   * `on_finalize`)
   * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
   **/
  { name: 'Set'; params: { now: bigint } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBabeCall =
  /**
   * Report authority equivocation/misbehavior. This method will verify
   * the equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence will
   * be reported.
   **/
  | {
      name: 'ReportEquivocation';
      params: { equivocationProof: SpConsensusSlotsEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * Report authority equivocation/misbehavior. This method will verify
   * the equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence will
   * be reported.
   * This extrinsic must be called unsigned and it is expected that only
   * block authors will call it (validated in `ValidateUnsigned`), as such
   * if the block author is defined it will be defined as the equivocation
   * reporter.
   **/
  | {
      name: 'ReportEquivocationUnsigned';
      params: { equivocationProof: SpConsensusSlotsEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * Plan an epoch config change. The epoch config change is recorded and will be enacted on
   * the next call to `enact_epoch_change`. The config will be activated one epoch after.
   * Multiple calls to this method will replace any existing planned config change that had
   * not been enacted yet.
   **/
  | { name: 'PlanConfigChange'; params: { config: SpConsensusBabeDigestsNextConfigDescriptor } };

export type PalletBabeCallLike =
  /**
   * Report authority equivocation/misbehavior. This method will verify
   * the equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence will
   * be reported.
   **/
  | {
      name: 'ReportEquivocation';
      params: { equivocationProof: SpConsensusSlotsEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * Report authority equivocation/misbehavior. This method will verify
   * the equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence will
   * be reported.
   * This extrinsic must be called unsigned and it is expected that only
   * block authors will call it (validated in `ValidateUnsigned`), as such
   * if the block author is defined it will be defined as the equivocation
   * reporter.
   **/
  | {
      name: 'ReportEquivocationUnsigned';
      params: { equivocationProof: SpConsensusSlotsEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * Plan an epoch config change. The epoch config change is recorded and will be enacted on
   * the next call to `enact_epoch_change`. The config will be activated one epoch after.
   * Multiple calls to this method will replace any existing planned config change that had
   * not been enacted yet.
   **/
  | { name: 'PlanConfigChange'; params: { config: SpConsensusBabeDigestsNextConfigDescriptor } };

export type SpConsensusSlotsEquivocationProof = {
  offender: SpConsensusBabeAppPublic;
  slot: SpConsensusSlotsSlot;
  firstHeader: Header;
  secondHeader: Header;
};

export type SpConsensusBabeAppPublic = FixedBytes<32>;

export type SpConsensusSlotsSlot = bigint;

export type SpSessionMembershipProof = { session: number; trieNodes: Array<Bytes>; validatorCount: number };

export type SpConsensusBabeDigestsNextConfigDescriptor = {
  type: 'V1';
  value: { c: [bigint, bigint]; allowedSlots: SpConsensusBabeAllowedSlots };
};

export type SpConsensusBabeAllowedSlots =
  | 'PrimarySlots'
  | 'PrimaryAndSecondaryPlainSlots'
  | 'PrimaryAndSecondaryVRFSlots';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletGrandpaCall =
  /**
   * Report voter equivocation/misbehavior. This method will verify the
   * equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence
   * will be reported.
   **/
  | {
      name: 'ReportEquivocation';
      params: { equivocationProof: SpConsensusGrandpaEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * Report voter equivocation/misbehavior. This method will verify the
   * equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence
   * will be reported.
   *
   * This extrinsic must be called unsigned and it is expected that only
   * block authors will call it (validated in `ValidateUnsigned`), as such
   * if the block author is defined it will be defined as the equivocation
   * reporter.
   **/
  | {
      name: 'ReportEquivocationUnsigned';
      params: { equivocationProof: SpConsensusGrandpaEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * Note that the current authority set of the GRANDPA finality gadget has stalled.
   *
   * This will trigger a forced authority set change at the beginning of the next session, to
   * be enacted `delay` blocks after that. The `delay` should be high enough to safely assume
   * that the block signalling the forced change will not be re-orged e.g. 1000 blocks.
   * The block production rate (which may be slowed down because of finality lagging) should
   * be taken into account when choosing the `delay`. The GRANDPA voters based on the new
   * authority will start voting on top of `best_finalized_block_number` for new finalized
   * blocks. `best_finalized_block_number` should be the highest of the latest finalized
   * block of all validators of the new authority set.
   *
   * Only callable by root.
   **/
  | { name: 'NoteStalled'; params: { delay: number; bestFinalizedBlockNumber: number } };

export type PalletGrandpaCallLike =
  /**
   * Report voter equivocation/misbehavior. This method will verify the
   * equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence
   * will be reported.
   **/
  | {
      name: 'ReportEquivocation';
      params: { equivocationProof: SpConsensusGrandpaEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * Report voter equivocation/misbehavior. This method will verify the
   * equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence
   * will be reported.
   *
   * This extrinsic must be called unsigned and it is expected that only
   * block authors will call it (validated in `ValidateUnsigned`), as such
   * if the block author is defined it will be defined as the equivocation
   * reporter.
   **/
  | {
      name: 'ReportEquivocationUnsigned';
      params: { equivocationProof: SpConsensusGrandpaEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  /**
   * Note that the current authority set of the GRANDPA finality gadget has stalled.
   *
   * This will trigger a forced authority set change at the beginning of the next session, to
   * be enacted `delay` blocks after that. The `delay` should be high enough to safely assume
   * that the block signalling the forced change will not be re-orged e.g. 1000 blocks.
   * The block production rate (which may be slowed down because of finality lagging) should
   * be taken into account when choosing the `delay`. The GRANDPA voters based on the new
   * authority will start voting on top of `best_finalized_block_number` for new finalized
   * blocks. `best_finalized_block_number` should be the highest of the latest finalized
   * block of all validators of the new authority set.
   *
   * Only callable by root.
   **/
  | { name: 'NoteStalled'; params: { delay: number; bestFinalizedBlockNumber: number } };

export type SpConsensusGrandpaEquivocationProof = { setId: bigint; equivocation: SpConsensusGrandpaEquivocation };

export type SpConsensusGrandpaEquivocation =
  | { type: 'Prevote'; value: FinalityGrandpaEquivocation }
  | { type: 'Precommit'; value: FinalityGrandpaEquivocationPrecommit };

export type FinalityGrandpaEquivocation = {
  roundNumber: bigint;
  identity: SpConsensusGrandpaAppPublic;
  first: [FinalityGrandpaPrevote, SpConsensusGrandpaAppSignature];
  second: [FinalityGrandpaPrevote, SpConsensusGrandpaAppSignature];
};

export type FinalityGrandpaPrevote = { targetHash: H256; targetNumber: number };

export type SpConsensusGrandpaAppSignature = FixedBytes<64>;

export type FinalityGrandpaEquivocationPrecommit = {
  roundNumber: bigint;
  identity: SpConsensusGrandpaAppPublic;
  first: [FinalityGrandpaPrecommit, SpConsensusGrandpaAppSignature];
  second: [FinalityGrandpaPrecommit, SpConsensusGrandpaAppSignature];
};

export type FinalityGrandpaPrecommit = { targetHash: H256; targetNumber: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBalancesCall =
  /**
   * Transfer some liquid free balance to another account.
   *
   * `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
   * If the sender's account is below the existential deposit as a result
   * of the transfer, the account will be reaped.
   *
   * The dispatch origin for this call must be `Signed` by the transactor.
   **/
  | { name: 'TransferAllowDeath'; params: { dest: MultiAddress; value: bigint } }
  /**
   * Exactly as `transfer_allow_death`, except the origin must be root and the source account
   * may be specified.
   **/
  | { name: 'ForceTransfer'; params: { source: MultiAddress; dest: MultiAddress; value: bigint } }
  /**
   * Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
   * kill the origin account.
   *
   * 99% of the time you want [`transfer_allow_death`] instead.
   *
   * [`transfer_allow_death`]: struct.Pallet.html#method.transfer
   **/
  | { name: 'TransferKeepAlive'; params: { dest: MultiAddress; value: bigint } }
  /**
   * Transfer the entire transferable balance from the caller account.
   *
   * NOTE: This function only attempts to transfer _transferable_ balances. This means that
   * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
   * transferred by this function. To ensure that this function results in a killed account,
   * you might need to prepare the account by removing any reference counters, storage
   * deposits, etc...
   *
   * The dispatch origin of this call must be Signed.
   *
   * - `dest`: The recipient of the transfer.
   * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
   * of the funds the account has, causing the sender account to be killed (false), or
   * transfer everything except at least the existential deposit, which will guarantee to
   * keep the sender account alive (true).
   **/
  | { name: 'TransferAll'; params: { dest: MultiAddress; keepAlive: boolean } }
  /**
   * Unreserve some balance from a user by force.
   *
   * Can only be called by ROOT.
   **/
  | { name: 'ForceUnreserve'; params: { who: MultiAddress; amount: bigint } }
  /**
   * Upgrade a specified account.
   *
   * - `origin`: Must be `Signed`.
   * - `who`: The account to be upgraded.
   *
   * This will waive the transaction fee if at least all but 10% of the accounts needed to
   * be upgraded. (We let some not have to be upgraded just in order to allow for the
   * possibility of churn).
   **/
  | { name: 'UpgradeAccounts'; params: { who: Array<AccountId32> } }
  /**
   * Set the regular balance of a given account.
   *
   * The dispatch origin for this call is `root`.
   **/
  | { name: 'ForceSetBalance'; params: { who: MultiAddress; newFree: bigint } }
  /**
   * Adjust the total issuance in a saturating way.
   *
   * Can only be called by root and always needs a positive `delta`.
   *
   * # Example
   **/
  | { name: 'ForceAdjustTotalIssuance'; params: { direction: PalletBalancesAdjustmentDirection; delta: bigint } }
  /**
   * Burn the specified liquid free balance from the origin account.
   *
   * If the origin's account ends up below the existential deposit as a result
   * of the burn and `keep_alive` is false, the account will be reaped.
   *
   * Unlike sending funds to a _burn_ address, which merely makes the funds inaccessible,
   * this `burn` operation will reduce total issuance by the amount _burned_.
   **/
  | { name: 'Burn'; params: { value: bigint; keepAlive: boolean } };

export type PalletBalancesCallLike =
  /**
   * Transfer some liquid free balance to another account.
   *
   * `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
   * If the sender's account is below the existential deposit as a result
   * of the transfer, the account will be reaped.
   *
   * The dispatch origin for this call must be `Signed` by the transactor.
   **/
  | { name: 'TransferAllowDeath'; params: { dest: MultiAddressLike; value: bigint } }
  /**
   * Exactly as `transfer_allow_death`, except the origin must be root and the source account
   * may be specified.
   **/
  | { name: 'ForceTransfer'; params: { source: MultiAddressLike; dest: MultiAddressLike; value: bigint } }
  /**
   * Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
   * kill the origin account.
   *
   * 99% of the time you want [`transfer_allow_death`] instead.
   *
   * [`transfer_allow_death`]: struct.Pallet.html#method.transfer
   **/
  | { name: 'TransferKeepAlive'; params: { dest: MultiAddressLike; value: bigint } }
  /**
   * Transfer the entire transferable balance from the caller account.
   *
   * NOTE: This function only attempts to transfer _transferable_ balances. This means that
   * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
   * transferred by this function. To ensure that this function results in a killed account,
   * you might need to prepare the account by removing any reference counters, storage
   * deposits, etc...
   *
   * The dispatch origin of this call must be Signed.
   *
   * - `dest`: The recipient of the transfer.
   * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
   * of the funds the account has, causing the sender account to be killed (false), or
   * transfer everything except at least the existential deposit, which will guarantee to
   * keep the sender account alive (true).
   **/
  | { name: 'TransferAll'; params: { dest: MultiAddressLike; keepAlive: boolean } }
  /**
   * Unreserve some balance from a user by force.
   *
   * Can only be called by ROOT.
   **/
  | { name: 'ForceUnreserve'; params: { who: MultiAddressLike; amount: bigint } }
  /**
   * Upgrade a specified account.
   *
   * - `origin`: Must be `Signed`.
   * - `who`: The account to be upgraded.
   *
   * This will waive the transaction fee if at least all but 10% of the accounts needed to
   * be upgraded. (We let some not have to be upgraded just in order to allow for the
   * possibility of churn).
   **/
  | { name: 'UpgradeAccounts'; params: { who: Array<AccountId32Like> } }
  /**
   * Set the regular balance of a given account.
   *
   * The dispatch origin for this call is `root`.
   **/
  | { name: 'ForceSetBalance'; params: { who: MultiAddressLike; newFree: bigint } }
  /**
   * Adjust the total issuance in a saturating way.
   *
   * Can only be called by root and always needs a positive `delta`.
   *
   * # Example
   **/
  | { name: 'ForceAdjustTotalIssuance'; params: { direction: PalletBalancesAdjustmentDirection; delta: bigint } }
  /**
   * Burn the specified liquid free balance from the origin account.
   *
   * If the origin's account ends up below the existential deposit as a result
   * of the burn and `keep_alive` is false, the account will be reaped.
   *
   * Unlike sending funds to a _burn_ address, which merely makes the funds inaccessible,
   * this `burn` operation will reduce total issuance by the amount _burned_.
   **/
  | { name: 'Burn'; params: { value: bigint; keepAlive: boolean } };

export type PalletBalancesAdjustmentDirection = 'Increase' | 'Decrease';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSessionCall =
  /**
   * Sets the session key(s) of the function caller to `keys`.
   * Allows an account to set its session key prior to becoming a validator.
   * This doesn't take effect until the next session.
   *
   * The dispatch origin of this function must be signed.
   *
   * ## Complexity
   * - `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is
   * fixed.
   **/
  | { name: 'SetKeys'; params: { keys: VaraRuntimeSessionKeys; proof: Bytes } }
  /**
   * Removes any session key(s) of the function caller.
   *
   * This doesn't take effect until the next session.
   *
   * The dispatch origin of this function must be Signed and the account must be either be
   * convertible to a validator ID using the chain's typical addressing system (this usually
   * means being a controller account) or directly convertible into a validator ID (which
   * usually means being a stash account).
   *
   * ## Complexity
   * - `O(1)` in number of key types. Actual cost depends on the number of length of
   * `T::Keys::key_ids()` which is fixed.
   **/
  | { name: 'PurgeKeys' };

export type PalletSessionCallLike =
  /**
   * Sets the session key(s) of the function caller to `keys`.
   * Allows an account to set its session key prior to becoming a validator.
   * This doesn't take effect until the next session.
   *
   * The dispatch origin of this function must be signed.
   *
   * ## Complexity
   * - `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is
   * fixed.
   **/
  | { name: 'SetKeys'; params: { keys: VaraRuntimeSessionKeys; proof: BytesLike } }
  /**
   * Removes any session key(s) of the function caller.
   *
   * This doesn't take effect until the next session.
   *
   * The dispatch origin of this function must be Signed and the account must be either be
   * convertible to a validator ID using the chain's typical addressing system (this usually
   * means being a controller account) or directly convertible into a validator ID (which
   * usually means being a stash account).
   *
   * ## Complexity
   * - `O(1)` in number of key types. Actual cost depends on the number of length of
   * `T::Keys::key_ids()` which is fixed.
   **/
  | { name: 'PurgeKeys' };

export type VaraRuntimeSessionKeys = {
  babe: SpConsensusBabeAppPublic;
  grandpa: SpConsensusGrandpaAppPublic;
  imOnline: PalletImOnlineSr25519AppSr25519Public;
  authorityDiscovery: SpAuthorityDiscoveryAppPublic;
};

export type SpAuthorityDiscoveryAppPublic = FixedBytes<32>;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletUtilityCall =
  /**
   * Send a batch of dispatch calls.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatched without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   *
   * This will return `Ok` in all circumstances. To determine the success of the batch, an
   * event is deposited. If a call failed and the batch was interrupted, then the
   * `BatchInterrupted` event is deposited, along with the number of successful calls made
   * and the error of the failed call. If all were successful, then the `BatchCompleted`
   * event is deposited.
   **/
  | { name: 'Batch'; params: { calls: Array<VaraRuntimeRuntimeCall> } }
  /**
   * Send a call through an indexed pseudonym of the sender.
   *
   * Filter from origin are passed along. The call will be dispatched with an origin which
   * use the same filter as the origin of this call.
   *
   * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
   * because you expect `proxy` to have been used prior in the call stack and you do not want
   * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
   * in the Multisig pallet instead.
   *
   * NOTE: Prior to version *12, this was called `as_limited_sub`.
   *
   * The dispatch origin for this call must be _Signed_.
   **/
  | { name: 'AsDerivative'; params: { index: number; call: VaraRuntimeRuntimeCall } }
  /**
   * Send a batch of dispatch calls and atomically execute them.
   * The whole transaction will rollback and fail if any of the calls failed.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatched without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   **/
  | { name: 'BatchAll'; params: { calls: Array<VaraRuntimeRuntimeCall> } }
  /**
   * Dispatches a function call with a provided origin.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'DispatchAs'; params: { asOrigin: VaraRuntimeOriginCaller; call: VaraRuntimeRuntimeCall } }
  /**
   * Send a batch of dispatch calls.
   * Unlike `batch`, it allows errors and won't interrupt.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatch without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   **/
  | { name: 'ForceBatch'; params: { calls: Array<VaraRuntimeRuntimeCall> } }
  /**
   * Dispatch a function call with a specified weight.
   *
   * This function does not check the weight of the call, and instead allows the
   * Root origin to specify the weight of the call.
   *
   * The dispatch origin for this call must be _Root_.
   **/
  | { name: 'WithWeight'; params: { call: VaraRuntimeRuntimeCall; weight: SpWeightsWeightV2Weight } };

export type PalletUtilityCallLike =
  /**
   * Send a batch of dispatch calls.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatched without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   *
   * This will return `Ok` in all circumstances. To determine the success of the batch, an
   * event is deposited. If a call failed and the batch was interrupted, then the
   * `BatchInterrupted` event is deposited, along with the number of successful calls made
   * and the error of the failed call. If all were successful, then the `BatchCompleted`
   * event is deposited.
   **/
  | { name: 'Batch'; params: { calls: Array<VaraRuntimeRuntimeCallLike> } }
  /**
   * Send a call through an indexed pseudonym of the sender.
   *
   * Filter from origin are passed along. The call will be dispatched with an origin which
   * use the same filter as the origin of this call.
   *
   * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
   * because you expect `proxy` to have been used prior in the call stack and you do not want
   * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
   * in the Multisig pallet instead.
   *
   * NOTE: Prior to version *12, this was called `as_limited_sub`.
   *
   * The dispatch origin for this call must be _Signed_.
   **/
  | { name: 'AsDerivative'; params: { index: number; call: VaraRuntimeRuntimeCallLike } }
  /**
   * Send a batch of dispatch calls and atomically execute them.
   * The whole transaction will rollback and fail if any of the calls failed.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatched without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   **/
  | { name: 'BatchAll'; params: { calls: Array<VaraRuntimeRuntimeCallLike> } }
  /**
   * Dispatches a function call with a provided origin.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'DispatchAs'; params: { asOrigin: VaraRuntimeOriginCaller; call: VaraRuntimeRuntimeCallLike } }
  /**
   * Send a batch of dispatch calls.
   * Unlike `batch`, it allows errors and won't interrupt.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatch without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   **/
  | { name: 'ForceBatch'; params: { calls: Array<VaraRuntimeRuntimeCallLike> } }
  /**
   * Dispatch a function call with a specified weight.
   *
   * This function does not check the weight of the call, and instead allows the
   * Root origin to specify the weight of the call.
   *
   * The dispatch origin for this call must be _Root_.
   **/
  | { name: 'WithWeight'; params: { call: VaraRuntimeRuntimeCallLike; weight: SpWeightsWeightV2Weight } };

export type VaraRuntimeOriginCaller =
  | { type: 'System'; value: FrameSupportDispatchRawOrigin }
  | { type: 'Origins'; value: VaraRuntimeGovernanceOriginsPalletCustomOriginsOrigin }
  | { type: 'Void'; value: SpCoreVoid };

export type FrameSupportDispatchRawOrigin =
  | { type: 'Root' }
  | { type: 'Signed'; value: AccountId32 }
  | { type: 'None' };

export type VaraRuntimeGovernanceOriginsPalletCustomOriginsOrigin =
  | 'StakingAdmin'
  | 'Treasurer'
  | 'FellowshipAdmin'
  | 'GeneralAdmin'
  | 'ReferendumCanceller'
  | 'ReferendumKiller'
  | 'SmallTipper'
  | 'BigTipper'
  | 'SmallSpender'
  | 'MediumSpender'
  | 'BigSpender'
  | 'WhitelistedCaller'
  | 'FellowshipInitiates'
  | 'Fellows'
  | 'FellowshipExperts'
  | 'FellowshipMasters'
  | 'Fellowship1Dan'
  | 'Fellowship2Dan'
  | 'Fellowship3Dan'
  | 'Fellowship4Dan'
  | 'Fellowship5Dan'
  | 'Fellowship6Dan'
  | 'Fellowship7Dan'
  | 'Fellowship8Dan'
  | 'Fellowship9Dan';

export type SpCoreVoid = null;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletVestingCall =
  /**
   * Unlock any vested funds of the sender account.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have funds still
   * locked under this pallet.
   *
   * Emits either `VestingCompleted` or `VestingUpdated`.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'Vest' }
  /**
   * Unlock any vested funds of a `target` account.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `target`: The account whose vested funds should be unlocked. Must have funds still
   * locked under this pallet.
   *
   * Emits either `VestingCompleted` or `VestingUpdated`.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'VestOther'; params: { target: MultiAddress } }
  /**
   * Create a vested transfer.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `target`: The account receiving the vested funds.
   * - `schedule`: The vesting schedule attached to the transfer.
   *
   * Emits `VestingCreated`.
   *
   * NOTE: This will unlock all schedules through the current block.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'VestedTransfer'; params: { target: MultiAddress; schedule: PalletVestingVestingInfo } }
  /**
   * Force a vested transfer.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * - `source`: The account whose funds should be transferred.
   * - `target`: The account that should be transferred the vested funds.
   * - `schedule`: The vesting schedule attached to the transfer.
   *
   * Emits `VestingCreated`.
   *
   * NOTE: This will unlock all schedules through the current block.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | {
      name: 'ForceVestedTransfer';
      params: { source: MultiAddress; target: MultiAddress; schedule: PalletVestingVestingInfo };
    }
  /**
   * Merge two vesting schedules together, creating a new vesting schedule that unlocks over
   * the highest possible start and end blocks. If both schedules have already started the
   * current block will be used as the schedule start; with the caveat that if one schedule
   * is finished by the current block, the other will be treated as the new merged schedule,
   * unmodified.
   *
   * NOTE: If `schedule1_index == schedule2_index` this is a no-op.
   * NOTE: This will unlock all schedules through the current block prior to merging.
   * NOTE: If both schedules have ended by the current block, no new schedule will be created
   * and both will be removed.
   *
   * Merged schedule attributes:
   * - `starting_block`: `MAX(schedule1.starting_block, scheduled2.starting_block,
   * current_block)`.
   * - `ending_block`: `MAX(schedule1.ending_block, schedule2.ending_block)`.
   * - `locked`: `schedule1.locked_at(current_block) + schedule2.locked_at(current_block)`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `schedule1_index`: index of the first schedule to merge.
   * - `schedule2_index`: index of the second schedule to merge.
   **/
  | { name: 'MergeSchedules'; params: { schedule1Index: number; schedule2Index: number } }
  /**
   * Force remove a vesting schedule
   *
   * The dispatch origin for this call must be _Root_.
   *
   * - `target`: An account that has a vesting schedule
   * - `schedule_index`: The vesting schedule index that should be removed
   **/
  | { name: 'ForceRemoveVestingSchedule'; params: { target: MultiAddress; scheduleIndex: number } };

export type PalletVestingCallLike =
  /**
   * Unlock any vested funds of the sender account.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have funds still
   * locked under this pallet.
   *
   * Emits either `VestingCompleted` or `VestingUpdated`.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'Vest' }
  /**
   * Unlock any vested funds of a `target` account.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `target`: The account whose vested funds should be unlocked. Must have funds still
   * locked under this pallet.
   *
   * Emits either `VestingCompleted` or `VestingUpdated`.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'VestOther'; params: { target: MultiAddressLike } }
  /**
   * Create a vested transfer.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `target`: The account receiving the vested funds.
   * - `schedule`: The vesting schedule attached to the transfer.
   *
   * Emits `VestingCreated`.
   *
   * NOTE: This will unlock all schedules through the current block.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: 'VestedTransfer'; params: { target: MultiAddressLike; schedule: PalletVestingVestingInfo } }
  /**
   * Force a vested transfer.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * - `source`: The account whose funds should be transferred.
   * - `target`: The account that should be transferred the vested funds.
   * - `schedule`: The vesting schedule attached to the transfer.
   *
   * Emits `VestingCreated`.
   *
   * NOTE: This will unlock all schedules through the current block.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | {
      name: 'ForceVestedTransfer';
      params: { source: MultiAddressLike; target: MultiAddressLike; schedule: PalletVestingVestingInfo };
    }
  /**
   * Merge two vesting schedules together, creating a new vesting schedule that unlocks over
   * the highest possible start and end blocks. If both schedules have already started the
   * current block will be used as the schedule start; with the caveat that if one schedule
   * is finished by the current block, the other will be treated as the new merged schedule,
   * unmodified.
   *
   * NOTE: If `schedule1_index == schedule2_index` this is a no-op.
   * NOTE: This will unlock all schedules through the current block prior to merging.
   * NOTE: If both schedules have ended by the current block, no new schedule will be created
   * and both will be removed.
   *
   * Merged schedule attributes:
   * - `starting_block`: `MAX(schedule1.starting_block, scheduled2.starting_block,
   * current_block)`.
   * - `ending_block`: `MAX(schedule1.ending_block, schedule2.ending_block)`.
   * - `locked`: `schedule1.locked_at(current_block) + schedule2.locked_at(current_block)`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `schedule1_index`: index of the first schedule to merge.
   * - `schedule2_index`: index of the second schedule to merge.
   **/
  | { name: 'MergeSchedules'; params: { schedule1Index: number; schedule2Index: number } }
  /**
   * Force remove a vesting schedule
   *
   * The dispatch origin for this call must be _Root_.
   *
   * - `target`: An account that has a vesting schedule
   * - `schedule_index`: The vesting schedule index that should be removed
   **/
  | { name: 'ForceRemoveVestingSchedule'; params: { target: MultiAddressLike; scheduleIndex: number } };

export type PalletVestingVestingInfo = { locked: bigint; perBlock: bigint; startingBlock: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBagsListCall =
  /**
   * Declare that some `dislocated` account has, through rewards or penalties, sufficiently
   * changed its score that it should properly fall into a different bag than its current
   * one.
   *
   * Anyone can call this function about any potentially dislocated account.
   *
   * Will always update the stored score of `dislocated` to the correct score, based on
   * `ScoreProvider`.
   *
   * If `dislocated` does not exists, it returns an error.
   **/
  | { name: 'Rebag'; params: { dislocated: MultiAddress } }
  /**
   * Move the caller's Id directly in front of `lighter`.
   *
   * The dispatch origin for this call must be _Signed_ and can only be called by the Id of
   * the account going in front of `lighter`. Fee is payed by the origin under all
   * circumstances.
   *
   * Only works if:
   *
   * - both nodes are within the same bag,
   * - and `origin` has a greater `Score` than `lighter`.
   **/
  | { name: 'PutInFrontOf'; params: { lighter: MultiAddress } }
  /**
   * Same as [`Pallet::put_in_front_of`], but it can be called by anyone.
   *
   * Fee is paid by the origin under all circumstances.
   **/
  | { name: 'PutInFrontOfOther'; params: { heavier: MultiAddress; lighter: MultiAddress } };

export type PalletBagsListCallLike =
  /**
   * Declare that some `dislocated` account has, through rewards or penalties, sufficiently
   * changed its score that it should properly fall into a different bag than its current
   * one.
   *
   * Anyone can call this function about any potentially dislocated account.
   *
   * Will always update the stored score of `dislocated` to the correct score, based on
   * `ScoreProvider`.
   *
   * If `dislocated` does not exists, it returns an error.
   **/
  | { name: 'Rebag'; params: { dislocated: MultiAddressLike } }
  /**
   * Move the caller's Id directly in front of `lighter`.
   *
   * The dispatch origin for this call must be _Signed_ and can only be called by the Id of
   * the account going in front of `lighter`. Fee is payed by the origin under all
   * circumstances.
   *
   * Only works if:
   *
   * - both nodes are within the same bag,
   * - and `origin` has a greater `Score` than `lighter`.
   **/
  | { name: 'PutInFrontOf'; params: { lighter: MultiAddressLike } }
  /**
   * Same as [`Pallet::put_in_front_of`], but it can be called by anyone.
   *
   * Fee is paid by the origin under all circumstances.
   **/
  | { name: 'PutInFrontOfOther'; params: { heavier: MultiAddressLike; lighter: MultiAddressLike } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletImOnlineCall =
  /**
   * ## Complexity:
   * - `O(K)` where K is length of `Keys` (heartbeat.validators_len)
   * - `O(K)`: decoding of length `K`
   **/
  {
    name: 'Heartbeat';
    params: { heartbeat: PalletImOnlineHeartbeat; signature: PalletImOnlineSr25519AppSr25519Signature };
  };

export type PalletImOnlineCallLike =
  /**
   * ## Complexity:
   * - `O(K)` where K is length of `Keys` (heartbeat.validators_len)
   * - `O(K)`: decoding of length `K`
   **/
  {
    name: 'Heartbeat';
    params: { heartbeat: PalletImOnlineHeartbeat; signature: PalletImOnlineSr25519AppSr25519Signature };
  };

export type PalletImOnlineHeartbeat = {
  blockNumber: number;
  sessionIndex: number;
  authorityIndex: number;
  validatorsLen: number;
};

export type PalletImOnlineSr25519AppSr25519Signature = FixedBytes<64>;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletStakingPalletCall =
  /**
   * Take the origin account as a stash and lock up `value` of its balance. `controller` will
   * be the account that controls it.
   *
   * `value` must be more than the `minimum_balance` specified by `T::Currency`.
   *
   * The dispatch origin for this call must be _Signed_ by the stash account.
   *
   * Emits `Bonded`.
   * ## Complexity
   * - Independent of the arguments. Moderate complexity.
   * - O(1).
   * - Three extra DB entries.
   *
   * NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned
   * unless the `origin` falls below _existential deposit_ (or equal to 0) and gets removed
   * as dust.
   **/
  | { name: 'Bond'; params: { value: bigint; payee: PalletStakingRewardDestination } }
  /**
   * Add some extra amount that have appeared in the stash `free_balance` into the balance up
   * for staking.
   *
   * The dispatch origin for this call must be _Signed_ by the stash, not the controller.
   *
   * Use this if there are additional funds in your stash account that you wish to bond.
   * Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose
   * any limitation on the amount that can be added.
   *
   * Emits `Bonded`.
   *
   * ## Complexity
   * - Independent of the arguments. Insignificant complexity.
   * - O(1).
   **/
  | { name: 'BondExtra'; params: { maxAdditional: bigint } }
  /**
   * Schedule a portion of the stash to be unlocked ready for transfer out after the bond
   * period ends. If this leaves an amount actively bonded less than
   * T::Currency::minimum_balance(), then it is increased to the full amount.
   *
   * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
   *
   * Once the unlock period is done, you can call `withdraw_unbonded` to actually move
   * the funds out of management ready for transfer.
   *
   * No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)
   * can co-exists at the same time. If there are no unlocking chunks slots available
   * [`Call::withdraw_unbonded`] is called to remove some of the chunks (if possible).
   *
   * If a user encounters the `InsufficientBond` error when calling this extrinsic,
   * they should call `chill` first in order to free up their bonded funds.
   *
   * Emits `Unbonded`.
   *
   * See also [`Call::withdraw_unbonded`].
   **/
  | { name: 'Unbond'; params: { value: bigint } }
  /**
   * Remove any unlocked chunks from the `unlocking` queue from our management.
   *
   * This essentially frees up that balance to be used by the stash account to do whatever
   * it wants.
   *
   * The dispatch origin for this call must be _Signed_ by the controller.
   *
   * Emits `Withdrawn`.
   *
   * See also [`Call::unbond`].
   *
   * ## Parameters
   *
   * - `num_slashing_spans` indicates the number of metadata slashing spans to clear when
   * this call results in a complete removal of all the data related to the stash account.
   * In this case, the `num_slashing_spans` must be larger or equal to the number of
   * slashing spans associated with the stash account in the [`SlashingSpans`] storage type,
   * otherwise the call will fail. The call weight is directly proportional to
   * `num_slashing_spans`.
   *
   * ## Complexity
   * O(S) where S is the number of slashing spans to remove
   * NOTE: Weight annotation is the kill scenario, we refund otherwise.
   **/
  | { name: 'WithdrawUnbonded'; params: { numSlashingSpans: number } }
  /**
   * Declare the desire to validate for the origin controller.
   *
   * Effects will be felt at the beginning of the next era.
   *
   * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
   **/
  | { name: 'Validate'; params: { prefs: PalletStakingValidatorPrefs } }
  /**
   * Declare the desire to nominate `targets` for the origin controller.
   *
   * Effects will be felt at the beginning of the next era.
   *
   * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
   *
   * ## Complexity
   * - The transaction's complexity is proportional to the size of `targets` (N)
   * which is capped at CompactAssignments::LIMIT (T::MaxNominations).
   * - Both the reads and writes follow a similar pattern.
   **/
  | { name: 'Nominate'; params: { targets: Array<MultiAddress> } }
  /**
   * Declare no desire to either validate or nominate.
   *
   * Effects will be felt at the beginning of the next era.
   *
   * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
   *
   * ## Complexity
   * - Independent of the arguments. Insignificant complexity.
   * - Contains one read.
   * - Writes are limited to the `origin` account key.
   **/
  | { name: 'Chill' }
  /**
   * (Re-)set the payment target for a controller.
   *
   * Effects will be felt instantly (as soon as this function is completed successfully).
   *
   * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
   *
   * ## Complexity
   * - O(1)
   * - Independent of the arguments. Insignificant complexity.
   * - Contains a limited number of reads.
   * - Writes are limited to the `origin` account key.
   * ---------
   **/
  | { name: 'SetPayee'; params: { payee: PalletStakingRewardDestination } }
  /**
   * (Re-)sets the controller of a stash to the stash itself. This function previously
   * accepted a `controller` argument to set the controller to an account other than the
   * stash itself. This functionality has now been removed, now only setting the controller
   * to the stash, if it is not already.
   *
   * Effects will be felt instantly (as soon as this function is completed successfully).
   *
   * The dispatch origin for this call must be _Signed_ by the stash, not the controller.
   *
   * ## Complexity
   * O(1)
   * - Independent of the arguments. Insignificant complexity.
   * - Contains a limited number of reads.
   * - Writes are limited to the `origin` account key.
   **/
  | { name: 'SetController' }
  /**
   * Sets the ideal number of validators.
   *
   * The dispatch origin must be Root.
   *
   * ## Complexity
   * O(1)
   **/
  | { name: 'SetValidatorCount'; params: { new: number } }
  /**
   * Increments the ideal number of validators up to maximum of
   * `ElectionProviderBase::MaxWinners`.
   *
   * The dispatch origin must be Root.
   *
   * ## Complexity
   * Same as [`Self::set_validator_count`].
   **/
  | { name: 'IncreaseValidatorCount'; params: { additional: number } }
  /**
   * Scale up the ideal number of validators by a factor up to maximum of
   * `ElectionProviderBase::MaxWinners`.
   *
   * The dispatch origin must be Root.
   *
   * ## Complexity
   * Same as [`Self::set_validator_count`].
   **/
  | { name: 'ScaleValidatorCount'; params: { factor: Percent } }
  /**
   * Force there to be no new eras indefinitely.
   *
   * The dispatch origin must be Root.
   *
   * # Warning
   *
   * The election process starts multiple blocks before the end of the era.
   * Thus the election process may be ongoing when this is called. In this case the
   * election will continue until the next era is triggered.
   *
   * ## Complexity
   * - No arguments.
   * - Weight: O(1)
   **/
  | { name: 'ForceNoEras' }
  /**
   * Force there to be a new era at the end of the next session. After this, it will be
   * reset to normal (non-forced) behaviour.
   *
   * The dispatch origin must be Root.
   *
   * # Warning
   *
   * The election process starts multiple blocks before the end of the era.
   * If this is called just before a new era is triggered, the election process may not
   * have enough blocks to get a result.
   *
   * ## Complexity
   * - No arguments.
   * - Weight: O(1)
   **/
  | { name: 'ForceNewEra' }
  /**
   * Set the validators who cannot be slashed (if any).
   *
   * The dispatch origin must be Root.
   **/
  | { name: 'SetInvulnerables'; params: { invulnerables: Array<AccountId32> } }
  /**
   * Force a current staker to become completely unstaked, immediately.
   *
   * The dispatch origin must be Root.
   *
   * ## Parameters
   *
   * - `num_slashing_spans`: Refer to comments on [`Call::withdraw_unbonded`] for more
   * details.
   **/
  | { name: 'ForceUnstake'; params: { stash: AccountId32; numSlashingSpans: number } }
  /**
   * Force there to be a new era at the end of sessions indefinitely.
   *
   * The dispatch origin must be Root.
   *
   * # Warning
   *
   * The election process starts multiple blocks before the end of the era.
   * If this is called just before a new era is triggered, the election process may not
   * have enough blocks to get a result.
   **/
  | { name: 'ForceNewEraAlways' }
  /**
   * Cancel enactment of a deferred slash.
   *
   * Can be called by the `T::AdminOrigin`.
   *
   * Parameters: era and indices of the slashes for that era to kill.
   **/
  | { name: 'CancelDeferredSlash'; params: { era: number; slashIndices: Array<number> } }
  /**
   * Pay out next page of the stakers behind a validator for the given era.
   *
   * - `validator_stash` is the stash account of the validator.
   * - `era` may be any era between `[current_era - history_depth; current_era]`.
   *
   * The origin of this call must be _Signed_. Any account can call this function, even if
   * it is not one of the stakers.
   *
   * The reward payout could be paged in case there are too many nominators backing the
   * `validator_stash`. This call will payout unpaid pages in an ascending order. To claim a
   * specific page, use `payout_stakers_by_page`.`
   *
   * If all pages are claimed, it returns an error `InvalidPage`.
   **/
  | { name: 'PayoutStakers'; params: { validatorStash: AccountId32; era: number } }
  /**
   * Rebond a portion of the stash scheduled to be unlocked.
   *
   * The dispatch origin must be signed by the controller.
   *
   * ## Complexity
   * - Time complexity: O(L), where L is unlocking chunks
   * - Bounded by `MaxUnlockingChunks`.
   **/
  | { name: 'Rebond'; params: { value: bigint } }
  /**
   * Remove all data structures concerning a staker/stash once it is at a state where it can
   * be considered `dust` in the staking system. The requirements are:
   *
   * 1. the `total_balance` of the stash is below existential deposit.
   * 2. or, the `ledger.total` of the stash is below existential deposit.
   * 3. or, existential deposit is zero and either `total_balance` or `ledger.total` is zero.
   *
   * The former can happen in cases like a slash; the latter when a fully unbonded account
   * is still receiving staking rewards in `RewardDestination::Staked`.
   *
   * It can be called by anyone, as long as `stash` meets the above requirements.
   *
   * Refunds the transaction fees upon successful execution.
   *
   * ## Parameters
   *
   * - `num_slashing_spans`: Refer to comments on [`Call::withdraw_unbonded`] for more
   * details.
   **/
  | { name: 'ReapStash'; params: { stash: AccountId32; numSlashingSpans: number } }
  /**
   * Remove the given nominations from the calling validator.
   *
   * Effects will be felt at the beginning of the next era.
   *
   * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
   *
   * - `who`: A list of nominator stash accounts who are nominating this validator which
   * should no longer be nominating this validator.
   *
   * Note: Making this call only makes sense if you first set the validator preferences to
   * block any further nominations.
   **/
  | { name: 'Kick'; params: { who: Array<MultiAddress> } }
  /**
   * Update the various staking configurations .
   *
   * * `min_nominator_bond`: The minimum active bond needed to be a nominator.
   * * `min_validator_bond`: The minimum active bond needed to be a validator.
   * * `max_nominator_count`: The max number of users who can be a nominator at once. When
   * set to `None`, no limit is enforced.
   * * `max_validator_count`: The max number of users who can be a validator at once. When
   * set to `None`, no limit is enforced.
   * * `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which
   * should be filled in order for the `chill_other` transaction to work.
   * * `min_commission`: The minimum amount of commission that each validators must maintain.
   * This is checked only upon calling `validate`. Existing validators are not affected.
   *
   * RuntimeOrigin must be Root to call this function.
   *
   * NOTE: Existing nominators and validators will not be affected by this update.
   * to kick people under the new limits, `chill_other` should be called.
   **/
  | {
      name: 'SetStakingConfigs';
      params: {
        minNominatorBond: PalletStakingPalletConfigOp;
        minValidatorBond: PalletStakingPalletConfigOp;
        maxNominatorCount: PalletStakingPalletConfigOpU32;
        maxValidatorCount: PalletStakingPalletConfigOpU32;
        chillThreshold: PalletStakingPalletConfigOpPercent;
        minCommission: PalletStakingPalletConfigOpPerbill;
        maxStakedRewards: PalletStakingPalletConfigOpPercent;
      };
    }
  /**
   * Declare a `controller` to stop participating as either a validator or nominator.
   *
   * Effects will be felt at the beginning of the next era.
   *
   * The dispatch origin for this call must be _Signed_, but can be called by anyone.
   *
   * If the caller is the same as the controller being targeted, then no further checks are
   * enforced, and this function behaves just like `chill`.
   *
   * If the caller is different than the controller being targeted, the following conditions
   * must be met:
   *
   * * `controller` must belong to a nominator who has become non-decodable,
   *
   * Or:
   *
   * * A `ChillThreshold` must be set and checked which defines how close to the max
   * nominators or validators we must reach before users can start chilling one-another.
   * * A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine
   * how close we are to the threshold.
   * * A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines
   * if this is a person that should be chilled because they have not met the threshold
   * bond required.
   *
   * This can be helpful if bond requirements are updated, and we need to remove old users
   * who do not satisfy these requirements.
   **/
  | { name: 'ChillOther'; params: { stash: AccountId32 } }
  /**
   * Force a validator to have at least the minimum commission. This will not affect a
   * validator who already has a commission greater than or equal to the minimum. Any account
   * can call this.
   **/
  | { name: 'ForceApplyMinCommission'; params: { validatorStash: AccountId32 } }
  /**
   * Sets the minimum amount of commission that each validators must maintain.
   *
   * This call has lower privilege requirements than `set_staking_config` and can be called
   * by the `T::AdminOrigin`. Root can always call this.
   **/
  | { name: 'SetMinCommission'; params: { new: Perbill } }
  /**
   * Pay out a page of the stakers behind a validator for the given era and page.
   *
   * - `validator_stash` is the stash account of the validator.
   * - `era` may be any era between `[current_era - history_depth; current_era]`.
   * - `page` is the page index of nominators to pay out with value between 0 and
   * `num_nominators / T::MaxExposurePageSize`.
   *
   * The origin of this call must be _Signed_. Any account can call this function, even if
   * it is not one of the stakers.
   *
   * If a validator has more than [`Config::MaxExposurePageSize`] nominators backing
   * them, then the list of nominators is paged, with each page being capped at
   * [`Config::MaxExposurePageSize`.] If a validator has more than one page of nominators,
   * the call needs to be made for each page separately in order for all the nominators
   * backing a validator to receive the reward. The nominators are not sorted across pages
   * and so it should not be assumed the highest staker would be on the topmost page and vice
   * versa. If rewards are not claimed in [`Config::HistoryDepth`] eras, they are lost.
   **/
  | { name: 'PayoutStakersByPage'; params: { validatorStash: AccountId32; era: number; page: number } }
  /**
   * Migrates an account's `RewardDestination::Controller` to
   * `RewardDestination::Account(controller)`.
   *
   * Effects will be felt instantly (as soon as this function is completed successfully).
   *
   * This will waive the transaction fee if the `payee` is successfully migrated.
   **/
  | { name: 'UpdatePayee'; params: { controller: AccountId32 } }
  /**
   * Updates a batch of controller accounts to their corresponding stash account if they are
   * not the same. Ignores any controller accounts that do not exist, and does not operate if
   * the stash and controller are already the same.
   *
   * Effects will be felt instantly (as soon as this function is completed successfully).
   *
   * The dispatch origin must be `T::AdminOrigin`.
   **/
  | { name: 'DeprecateControllerBatch'; params: { controllers: Array<AccountId32> } }
  /**
   * Restores the state of a ledger which is in an inconsistent state.
   *
   * The requirements to restore a ledger are the following:
   * * The stash is bonded; or
   * * The stash is not bonded but it has a staking lock left behind; or
   * * If the stash has an associated ledger and its state is inconsistent; or
   * * If the ledger is not corrupted *but* its staking lock is out of sync.
   *
   * The `maybe_*` input parameters will overwrite the corresponding data and metadata of the
   * ledger associated with the stash. If the input parameters are not set, the ledger will
   * be reset values from on-chain state.
   **/
  | {
      name: 'RestoreLedger';
      params: {
        stash: AccountId32;
        maybeController?: AccountId32 | undefined;
        maybeTotal?: bigint | undefined;
        maybeUnlocking?: Array<PalletStakingUnlockChunk> | undefined;
      };
    };

export type PalletStakingPalletCallLike =
  /**
   * Take the origin account as a stash and lock up `value` of its balance. `controller` will
   * be the account that controls it.
   *
   * `value` must be more than the `minimum_balance` specified by `T::Currency`.
   *
   * The dispatch origin for this call must be _Signed_ by the stash account.
   *
   * Emits `Bonded`.
   * ## Complexity
   * - Independent of the arguments. Moderate complexity.
   * - O(1).
   * - Three extra DB entries.
   *
   * NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned
   * unless the `origin` falls below _existential deposit_ (or equal to 0) and gets removed
   * as dust.
   **/
  | { name: 'Bond'; params: { value: bigint; payee: PalletStakingRewardDestination } }
  /**
   * Add some extra amount that have appeared in the stash `free_balance` into the balance up
   * for staking.
   *
   * The dispatch origin for this call must be _Signed_ by the stash, not the controller.
   *
   * Use this if there are additional funds in your stash account that you wish to bond.
   * Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose
   * any limitation on the amount that can be added.
   *
   * Emits `Bonded`.
   *
   * ## Complexity
   * - Independent of the arguments. Insignificant complexity.
   * - O(1).
   **/
  | { name: 'BondExtra'; params: { maxAdditional: bigint } }
  /**
   * Schedule a portion of the stash to be unlocked ready for transfer out after the bond
   * period ends. If this leaves an amount actively bonded less than
   * T::Currency::minimum_balance(), then it is increased to the full amount.
   *
   * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
   *
   * Once the unlock period is done, you can call `withdraw_unbonded` to actually move
   * the funds out of management ready for transfer.
   *
   * No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)
   * can co-exists at the same time. If there are no unlocking chunks slots available
   * [`Call::withdraw_unbonded`] is called to remove some of the chunks (if possible).
   *
   * If a user encounters the `InsufficientBond` error when calling this extrinsic,
   * they should call `chill` first in order to free up their bonded funds.
   *
   * Emits `Unbonded`.
   *
   * See also [`Call::withdraw_unbonded`].
   **/
  | { name: 'Unbond'; params: { value: bigint } }
  /**
   * Remove any unlocked chunks from the `unlocking` queue from our management.
   *
   * This essentially frees up that balance to be used by the stash account to do whatever
   * it wants.
   *
   * The dispatch origin for this call must be _Signed_ by the controller.
   *
   * Emits `Withdrawn`.
   *
   * See also [`Call::unbond`].
   *
   * ## Parameters
   *
   * - `num_slashing_spans` indicates the number of metadata slashing spans to clear when
   * this call results in a complete removal of all the data related to the stash account.
   * In this case, the `num_slashing_spans` must be larger or equal to the number of
   * slashing spans associated with the stash account in the [`SlashingSpans`] storage type,
   * otherwise the call will fail. The call weight is directly proportional to
   * `num_slashing_spans`.
   *
   * ## Complexity
   * O(S) where S is the number of slashing spans to remove
   * NOTE: Weight annotation is the kill scenario, we refund otherwise.
   **/
  | { name: 'WithdrawUnbonded'; params: { numSlashingSpans: number } }
  /**
   * Declare the desire to validate for the origin controller.
   *
   * Effects will be felt at the beginning of the next era.
   *
   * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
   **/
  | { name: 'Validate'; params: { prefs: PalletStakingValidatorPrefs } }
  /**
   * Declare the desire to nominate `targets` for the origin controller.
   *
   * Effects will be felt at the beginning of the next era.
   *
   * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
   *
   * ## Complexity
   * - The transaction's complexity is proportional to the size of `targets` (N)
   * which is capped at CompactAssignments::LIMIT (T::MaxNominations).
   * - Both the reads and writes follow a similar pattern.
   **/
  | { name: 'Nominate'; params: { targets: Array<MultiAddressLike> } }
  /**
   * Declare no desire to either validate or nominate.
   *
   * Effects will be felt at the beginning of the next era.
   *
   * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
   *
   * ## Complexity
   * - Independent of the arguments. Insignificant complexity.
   * - Contains one read.
   * - Writes are limited to the `origin` account key.
   **/
  | { name: 'Chill' }
  /**
   * (Re-)set the payment target for a controller.
   *
   * Effects will be felt instantly (as soon as this function is completed successfully).
   *
   * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
   *
   * ## Complexity
   * - O(1)
   * - Independent of the arguments. Insignificant complexity.
   * - Contains a limited number of reads.
   * - Writes are limited to the `origin` account key.
   * ---------
   **/
  | { name: 'SetPayee'; params: { payee: PalletStakingRewardDestination } }
  /**
   * (Re-)sets the controller of a stash to the stash itself. This function previously
   * accepted a `controller` argument to set the controller to an account other than the
   * stash itself. This functionality has now been removed, now only setting the controller
   * to the stash, if it is not already.
   *
   * Effects will be felt instantly (as soon as this function is completed successfully).
   *
   * The dispatch origin for this call must be _Signed_ by the stash, not the controller.
   *
   * ## Complexity
   * O(1)
   * - Independent of the arguments. Insignificant complexity.
   * - Contains a limited number of reads.
   * - Writes are limited to the `origin` account key.
   **/
  | { name: 'SetController' }
  /**
   * Sets the ideal number of validators.
   *
   * The dispatch origin must be Root.
   *
   * ## Complexity
   * O(1)
   **/
  | { name: 'SetValidatorCount'; params: { new: number } }
  /**
   * Increments the ideal number of validators up to maximum of
   * `ElectionProviderBase::MaxWinners`.
   *
   * The dispatch origin must be Root.
   *
   * ## Complexity
   * Same as [`Self::set_validator_count`].
   **/
  | { name: 'IncreaseValidatorCount'; params: { additional: number } }
  /**
   * Scale up the ideal number of validators by a factor up to maximum of
   * `ElectionProviderBase::MaxWinners`.
   *
   * The dispatch origin must be Root.
   *
   * ## Complexity
   * Same as [`Self::set_validator_count`].
   **/
  | { name: 'ScaleValidatorCount'; params: { factor: Percent } }
  /**
   * Force there to be no new eras indefinitely.
   *
   * The dispatch origin must be Root.
   *
   * # Warning
   *
   * The election process starts multiple blocks before the end of the era.
   * Thus the election process may be ongoing when this is called. In this case the
   * election will continue until the next era is triggered.
   *
   * ## Complexity
   * - No arguments.
   * - Weight: O(1)
   **/
  | { name: 'ForceNoEras' }
  /**
   * Force there to be a new era at the end of the next session. After this, it will be
   * reset to normal (non-forced) behaviour.
   *
   * The dispatch origin must be Root.
   *
   * # Warning
   *
   * The election process starts multiple blocks before the end of the era.
   * If this is called just before a new era is triggered, the election process may not
   * have enough blocks to get a result.
   *
   * ## Complexity
   * - No arguments.
   * - Weight: O(1)
   **/
  | { name: 'ForceNewEra' }
  /**
   * Set the validators who cannot be slashed (if any).
   *
   * The dispatch origin must be Root.
   **/
  | { name: 'SetInvulnerables'; params: { invulnerables: Array<AccountId32Like> } }
  /**
   * Force a current staker to become completely unstaked, immediately.
   *
   * The dispatch origin must be Root.
   *
   * ## Parameters
   *
   * - `num_slashing_spans`: Refer to comments on [`Call::withdraw_unbonded`] for more
   * details.
   **/
  | { name: 'ForceUnstake'; params: { stash: AccountId32Like; numSlashingSpans: number } }
  /**
   * Force there to be a new era at the end of sessions indefinitely.
   *
   * The dispatch origin must be Root.
   *
   * # Warning
   *
   * The election process starts multiple blocks before the end of the era.
   * If this is called just before a new era is triggered, the election process may not
   * have enough blocks to get a result.
   **/
  | { name: 'ForceNewEraAlways' }
  /**
   * Cancel enactment of a deferred slash.
   *
   * Can be called by the `T::AdminOrigin`.
   *
   * Parameters: era and indices of the slashes for that era to kill.
   **/
  | { name: 'CancelDeferredSlash'; params: { era: number; slashIndices: Array<number> } }
  /**
   * Pay out next page of the stakers behind a validator for the given era.
   *
   * - `validator_stash` is the stash account of the validator.
   * - `era` may be any era between `[current_era - history_depth; current_era]`.
   *
   * The origin of this call must be _Signed_. Any account can call this function, even if
   * it is not one of the stakers.
   *
   * The reward payout could be paged in case there are too many nominators backing the
   * `validator_stash`. This call will payout unpaid pages in an ascending order. To claim a
   * specific page, use `payout_stakers_by_page`.`
   *
   * If all pages are claimed, it returns an error `InvalidPage`.
   **/
  | { name: 'PayoutStakers'; params: { validatorStash: AccountId32Like; era: number } }
  /**
   * Rebond a portion of the stash scheduled to be unlocked.
   *
   * The dispatch origin must be signed by the controller.
   *
   * ## Complexity
   * - Time complexity: O(L), where L is unlocking chunks
   * - Bounded by `MaxUnlockingChunks`.
   **/
  | { name: 'Rebond'; params: { value: bigint } }
  /**
   * Remove all data structures concerning a staker/stash once it is at a state where it can
   * be considered `dust` in the staking system. The requirements are:
   *
   * 1. the `total_balance` of the stash is below existential deposit.
   * 2. or, the `ledger.total` of the stash is below existential deposit.
   * 3. or, existential deposit is zero and either `total_balance` or `ledger.total` is zero.
   *
   * The former can happen in cases like a slash; the latter when a fully unbonded account
   * is still receiving staking rewards in `RewardDestination::Staked`.
   *
   * It can be called by anyone, as long as `stash` meets the above requirements.
   *
   * Refunds the transaction fees upon successful execution.
   *
   * ## Parameters
   *
   * - `num_slashing_spans`: Refer to comments on [`Call::withdraw_unbonded`] for more
   * details.
   **/
  | { name: 'ReapStash'; params: { stash: AccountId32Like; numSlashingSpans: number } }
  /**
   * Remove the given nominations from the calling validator.
   *
   * Effects will be felt at the beginning of the next era.
   *
   * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
   *
   * - `who`: A list of nominator stash accounts who are nominating this validator which
   * should no longer be nominating this validator.
   *
   * Note: Making this call only makes sense if you first set the validator preferences to
   * block any further nominations.
   **/
  | { name: 'Kick'; params: { who: Array<MultiAddressLike> } }
  /**
   * Update the various staking configurations .
   *
   * * `min_nominator_bond`: The minimum active bond needed to be a nominator.
   * * `min_validator_bond`: The minimum active bond needed to be a validator.
   * * `max_nominator_count`: The max number of users who can be a nominator at once. When
   * set to `None`, no limit is enforced.
   * * `max_validator_count`: The max number of users who can be a validator at once. When
   * set to `None`, no limit is enforced.
   * * `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which
   * should be filled in order for the `chill_other` transaction to work.
   * * `min_commission`: The minimum amount of commission that each validators must maintain.
   * This is checked only upon calling `validate`. Existing validators are not affected.
   *
   * RuntimeOrigin must be Root to call this function.
   *
   * NOTE: Existing nominators and validators will not be affected by this update.
   * to kick people under the new limits, `chill_other` should be called.
   **/
  | {
      name: 'SetStakingConfigs';
      params: {
        minNominatorBond: PalletStakingPalletConfigOp;
        minValidatorBond: PalletStakingPalletConfigOp;
        maxNominatorCount: PalletStakingPalletConfigOpU32;
        maxValidatorCount: PalletStakingPalletConfigOpU32;
        chillThreshold: PalletStakingPalletConfigOpPercent;
        minCommission: PalletStakingPalletConfigOpPerbill;
        maxStakedRewards: PalletStakingPalletConfigOpPercent;
      };
    }
  /**
   * Declare a `controller` to stop participating as either a validator or nominator.
   *
   * Effects will be felt at the beginning of the next era.
   *
   * The dispatch origin for this call must be _Signed_, but can be called by anyone.
   *
   * If the caller is the same as the controller being targeted, then no further checks are
   * enforced, and this function behaves just like `chill`.
   *
   * If the caller is different than the controller being targeted, the following conditions
   * must be met:
   *
   * * `controller` must belong to a nominator who has become non-decodable,
   *
   * Or:
   *
   * * A `ChillThreshold` must be set and checked which defines how close to the max
   * nominators or validators we must reach before users can start chilling one-another.
   * * A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine
   * how close we are to the threshold.
   * * A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines
   * if this is a person that should be chilled because they have not met the threshold
   * bond required.
   *
   * This can be helpful if bond requirements are updated, and we need to remove old users
   * who do not satisfy these requirements.
   **/
  | { name: 'ChillOther'; params: { stash: AccountId32Like } }
  /**
   * Force a validator to have at least the minimum commission. This will not affect a
   * validator who already has a commission greater than or equal to the minimum. Any account
   * can call this.
   **/
  | { name: 'ForceApplyMinCommission'; params: { validatorStash: AccountId32Like } }
  /**
   * Sets the minimum amount of commission that each validators must maintain.
   *
   * This call has lower privilege requirements than `set_staking_config` and can be called
   * by the `T::AdminOrigin`. Root can always call this.
   **/
  | { name: 'SetMinCommission'; params: { new: Perbill } }
  /**
   * Pay out a page of the stakers behind a validator for the given era and page.
   *
   * - `validator_stash` is the stash account of the validator.
   * - `era` may be any era between `[current_era - history_depth; current_era]`.
   * - `page` is the page index of nominators to pay out with value between 0 and
   * `num_nominators / T::MaxExposurePageSize`.
   *
   * The origin of this call must be _Signed_. Any account can call this function, even if
   * it is not one of the stakers.
   *
   * If a validator has more than [`Config::MaxExposurePageSize`] nominators backing
   * them, then the list of nominators is paged, with each page being capped at
   * [`Config::MaxExposurePageSize`.] If a validator has more than one page of nominators,
   * the call needs to be made for each page separately in order for all the nominators
   * backing a validator to receive the reward. The nominators are not sorted across pages
   * and so it should not be assumed the highest staker would be on the topmost page and vice
   * versa. If rewards are not claimed in [`Config::HistoryDepth`] eras, they are lost.
   **/
  | { name: 'PayoutStakersByPage'; params: { validatorStash: AccountId32Like; era: number; page: number } }
  /**
   * Migrates an account's `RewardDestination::Controller` to
   * `RewardDestination::Account(controller)`.
   *
   * Effects will be felt instantly (as soon as this function is completed successfully).
   *
   * This will waive the transaction fee if the `payee` is successfully migrated.
   **/
  | { name: 'UpdatePayee'; params: { controller: AccountId32Like } }
  /**
   * Updates a batch of controller accounts to their corresponding stash account if they are
   * not the same. Ignores any controller accounts that do not exist, and does not operate if
   * the stash and controller are already the same.
   *
   * Effects will be felt instantly (as soon as this function is completed successfully).
   *
   * The dispatch origin must be `T::AdminOrigin`.
   **/
  | { name: 'DeprecateControllerBatch'; params: { controllers: Array<AccountId32Like> } }
  /**
   * Restores the state of a ledger which is in an inconsistent state.
   *
   * The requirements to restore a ledger are the following:
   * * The stash is bonded; or
   * * The stash is not bonded but it has a staking lock left behind; or
   * * If the stash has an associated ledger and its state is inconsistent; or
   * * If the ledger is not corrupted *but* its staking lock is out of sync.
   *
   * The `maybe_*` input parameters will overwrite the corresponding data and metadata of the
   * ledger associated with the stash. If the input parameters are not set, the ledger will
   * be reset values from on-chain state.
   **/
  | {
      name: 'RestoreLedger';
      params: {
        stash: AccountId32Like;
        maybeController?: AccountId32Like | undefined;
        maybeTotal?: bigint | undefined;
        maybeUnlocking?: Array<PalletStakingUnlockChunk> | undefined;
      };
    };

export type PalletStakingPalletConfigOp = { type: 'Noop' } | { type: 'Set'; value: bigint } | { type: 'Remove' };

export type PalletStakingPalletConfigOpU32 = { type: 'Noop' } | { type: 'Set'; value: number } | { type: 'Remove' };

export type PalletStakingPalletConfigOpPercent =
  | { type: 'Noop' }
  | { type: 'Set'; value: Percent }
  | { type: 'Remove' };

export type PalletStakingPalletConfigOpPerbill =
  | { type: 'Noop' }
  | { type: 'Set'; value: Perbill }
  | { type: 'Remove' };

export type PalletStakingUnlockChunk = { value: bigint; era: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTreasuryCall =
  /**
   * Propose and approve a spend of treasury funds.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::SpendOrigin`] with the `Success` value being at least `amount`.
   *
   * ### Details
   * NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
   * beneficiary.
   *
   * ### Parameters
   * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
   * - `beneficiary`: The destination account for the transfer.
   *
   * ## Events
   *
   * Emits [`Event::SpendApproved`] if successful.
   **/
  | { name: 'SpendLocal'; params: { amount: bigint; beneficiary: MultiAddress } }
  /**
   * Force a previously approved proposal to be removed from the approval queue.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::RejectOrigin`].
   *
   * ## Details
   *
   * The original deposit will no longer be returned.
   *
   * ### Parameters
   * - `proposal_id`: The index of a proposal
   *
   * ### Complexity
   * - O(A) where `A` is the number of approvals
   *
   * ### Errors
   * - [`Error::ProposalNotApproved`]: The `proposal_id` supplied was not found in the
   * approval queue, i.e., the proposal has not been approved. This could also mean the
   * proposal does not exist altogether, thus there is no way it would have been approved
   * in the first place.
   **/
  | { name: 'RemoveApproval'; params: { proposalId: number } }
  /**
   * Propose and approve a spend of treasury funds.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::SpendOrigin`] with the `Success` value being at least
   * `amount` of `asset_kind` in the native asset. The amount of `asset_kind` is converted
   * for assertion using the [`Config::BalanceConverter`].
   *
   * ## Details
   *
   * Create an approved spend for transferring a specific `amount` of `asset_kind` to a
   * designated beneficiary. The spend must be claimed using the `payout` dispatchable within
   * the [`Config::PayoutPeriod`].
   *
   * ### Parameters
   * - `asset_kind`: An indicator of the specific asset class to be spent.
   * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
   * - `beneficiary`: The beneficiary of the spend.
   * - `valid_from`: The block number from which the spend can be claimed. It can refer to
   * the past if the resulting spend has not yet expired according to the
   * [`Config::PayoutPeriod`]. If `None`, the spend can be claimed immediately after
   * approval.
   *
   * ## Events
   *
   * Emits [`Event::AssetSpendApproved`] if successful.
   **/
  | {
      name: 'Spend';
      params: { assetKind: []; amount: bigint; beneficiary: AccountId32; validFrom?: number | undefined };
    }
  /**
   * Claim a spend.
   *
   * ## Dispatch Origin
   *
   * Must be signed
   *
   * ## Details
   *
   * Spends must be claimed within some temporal bounds. A spend may be claimed within one
   * [`Config::PayoutPeriod`] from the `valid_from` block.
   * In case of a payout failure, the spend status must be updated with the `check_status`
   * dispatchable before retrying with the current function.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::Paid`] if successful.
   **/
  | { name: 'Payout'; params: { index: number } }
  /**
   * Check the status of the spend and remove it from the storage if processed.
   *
   * ## Dispatch Origin
   *
   * Must be signed.
   *
   * ## Details
   *
   * The status check is a prerequisite for retrying a failed payout.
   * If a spend has either succeeded or expired, it is removed from the storage by this
   * function. In such instances, transaction fees are refunded.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::PaymentFailed`] if the spend payout has failed.
   * Emits [`Event::SpendProcessed`] if the spend payout has succeed.
   **/
  | { name: 'CheckStatus'; params: { index: number } }
  /**
   * Void previously approved spend.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::RejectOrigin`].
   *
   * ## Details
   *
   * A spend void is only possible if the payout has not been attempted yet.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::AssetSpendVoided`] if successful.
   **/
  | { name: 'VoidSpend'; params: { index: number } };

export type PalletTreasuryCallLike =
  /**
   * Propose and approve a spend of treasury funds.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::SpendOrigin`] with the `Success` value being at least `amount`.
   *
   * ### Details
   * NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
   * beneficiary.
   *
   * ### Parameters
   * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
   * - `beneficiary`: The destination account for the transfer.
   *
   * ## Events
   *
   * Emits [`Event::SpendApproved`] if successful.
   **/
  | { name: 'SpendLocal'; params: { amount: bigint; beneficiary: MultiAddressLike } }
  /**
   * Force a previously approved proposal to be removed from the approval queue.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::RejectOrigin`].
   *
   * ## Details
   *
   * The original deposit will no longer be returned.
   *
   * ### Parameters
   * - `proposal_id`: The index of a proposal
   *
   * ### Complexity
   * - O(A) where `A` is the number of approvals
   *
   * ### Errors
   * - [`Error::ProposalNotApproved`]: The `proposal_id` supplied was not found in the
   * approval queue, i.e., the proposal has not been approved. This could also mean the
   * proposal does not exist altogether, thus there is no way it would have been approved
   * in the first place.
   **/
  | { name: 'RemoveApproval'; params: { proposalId: number } }
  /**
   * Propose and approve a spend of treasury funds.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::SpendOrigin`] with the `Success` value being at least
   * `amount` of `asset_kind` in the native asset. The amount of `asset_kind` is converted
   * for assertion using the [`Config::BalanceConverter`].
   *
   * ## Details
   *
   * Create an approved spend for transferring a specific `amount` of `asset_kind` to a
   * designated beneficiary. The spend must be claimed using the `payout` dispatchable within
   * the [`Config::PayoutPeriod`].
   *
   * ### Parameters
   * - `asset_kind`: An indicator of the specific asset class to be spent.
   * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
   * - `beneficiary`: The beneficiary of the spend.
   * - `valid_from`: The block number from which the spend can be claimed. It can refer to
   * the past if the resulting spend has not yet expired according to the
   * [`Config::PayoutPeriod`]. If `None`, the spend can be claimed immediately after
   * approval.
   *
   * ## Events
   *
   * Emits [`Event::AssetSpendApproved`] if successful.
   **/
  | {
      name: 'Spend';
      params: { assetKind: []; amount: bigint; beneficiary: AccountId32Like; validFrom?: number | undefined };
    }
  /**
   * Claim a spend.
   *
   * ## Dispatch Origin
   *
   * Must be signed
   *
   * ## Details
   *
   * Spends must be claimed within some temporal bounds. A spend may be claimed within one
   * [`Config::PayoutPeriod`] from the `valid_from` block.
   * In case of a payout failure, the spend status must be updated with the `check_status`
   * dispatchable before retrying with the current function.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::Paid`] if successful.
   **/
  | { name: 'Payout'; params: { index: number } }
  /**
   * Check the status of the spend and remove it from the storage if processed.
   *
   * ## Dispatch Origin
   *
   * Must be signed.
   *
   * ## Details
   *
   * The status check is a prerequisite for retrying a failed payout.
   * If a spend has either succeeded or expired, it is removed from the storage by this
   * function. In such instances, transaction fees are refunded.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::PaymentFailed`] if the spend payout has failed.
   * Emits [`Event::SpendProcessed`] if the spend payout has succeed.
   **/
  | { name: 'CheckStatus'; params: { index: number } }
  /**
   * Void previously approved spend.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::RejectOrigin`].
   *
   * ## Details
   *
   * A spend void is only possible if the payout has not been attempted yet.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::AssetSpendVoided`] if successful.
   **/
  | { name: 'VoidSpend'; params: { index: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletConvictionVotingCall =
  /**
   * Vote in a poll. If `vote.is_aye()`, the vote is to enact the proposal;
   * otherwise it is a vote to keep the status quo.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `poll_index`: The index of the poll to vote for.
   * - `vote`: The vote configuration.
   *
   * Weight: `O(R)` where R is the number of polls the voter has voted on.
   **/
  | { name: 'Vote'; params: { pollIndex: number; vote: PalletConvictionVotingVoteAccountVote } }
  /**
   * Delegate the voting power (with some given conviction) of the sending account for a
   * particular class of polls.
   *
   * The balance delegated is locked for as long as it's delegated, and thereafter for the
   * time appropriate for the conviction's lock period.
   *
   * The dispatch origin of this call must be _Signed_, and the signing account must either:
   * - be delegating already; or
   * - have no voting activity (if there is, then it will need to be removed through
   * `remove_vote`).
   *
   * - `to`: The account whose voting the `target` account's voting power will follow.
   * - `class`: The class of polls to delegate. To delegate multiple classes, multiple calls
   * to this function are required.
   * - `conviction`: The conviction that will be attached to the delegated votes. When the
   * account is undelegated, the funds will be locked for the corresponding period.
   * - `balance`: The amount of the account's balance to be used in delegating. This must not
   * be more than the account's current balance.
   *
   * Emits `Delegated`.
   *
   * Weight: `O(R)` where R is the number of polls the voter delegating to has
   * voted on. Weight is initially charged as if maximum votes, but is refunded later.
   **/
  | {
      name: 'Delegate';
      params: { class: number; to: MultiAddress; conviction: PalletConvictionVotingConviction; balance: bigint };
    }
  /**
   * Undelegate the voting power of the sending account for a particular class of polls.
   *
   * Tokens may be unlocked following once an amount of time consistent with the lock period
   * of the conviction with which the delegation was issued has passed.
   *
   * The dispatch origin of this call must be _Signed_ and the signing account must be
   * currently delegating.
   *
   * - `class`: The class of polls to remove the delegation from.
   *
   * Emits `Undelegated`.
   *
   * Weight: `O(R)` where R is the number of polls the voter delegating to has
   * voted on. Weight is initially charged as if maximum votes, but is refunded later.
   **/
  | { name: 'Undelegate'; params: { class: number } }
  /**
   * Remove the lock caused by prior voting/delegating which has expired within a particular
   * class.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `class`: The class of polls to unlock.
   * - `target`: The account to remove the lock on.
   *
   * Weight: `O(R)` with R number of vote of target.
   **/
  | { name: 'Unlock'; params: { class: number; target: MultiAddress } }
  /**
   * Remove a vote for a poll.
   *
   * If:
   * - the poll was cancelled, or
   * - the poll is ongoing, or
   * - the poll has ended such that
   * - the vote of the account was in opposition to the result; or
   * - there was no conviction to the account's vote; or
   * - the account made a split vote
   * ...then the vote is removed cleanly and a following call to `unlock` may result in more
   * funds being available.
   *
   * If, however, the poll has ended and:
   * - it finished corresponding to the vote of the account, and
   * - the account made a standard vote with conviction, and
   * - the lock period of the conviction is not over
   * ...then the lock will be aggregated into the overall account's lock, which may involve
   * *overlocking* (where the two locks are combined into a single lock that is the maximum
   * of both the amount locked and the time is it locked for).
   *
   * The dispatch origin of this call must be _Signed_, and the signer must have a vote
   * registered for poll `index`.
   *
   * - `index`: The index of poll of the vote to be removed.
   * - `class`: Optional parameter, if given it indicates the class of the poll. For polls
   * which have finished or are cancelled, this must be `Some`.
   *
   * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: 'RemoveVote'; params: { class?: number | undefined; index: number } }
  /**
   * Remove a vote for a poll.
   *
   * If the `target` is equal to the signer, then this function is exactly equivalent to
   * `remove_vote`. If not equal to the signer, then the vote must have expired,
   * either because the poll was cancelled, because the voter lost the poll or
   * because the conviction period is over.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `target`: The account of the vote to be removed; this account must have voted for poll
   * `index`.
   * - `index`: The index of poll of the vote to be removed.
   * - `class`: The class of the poll.
   *
   * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: 'RemoveOtherVote'; params: { target: MultiAddress; class: number; index: number } };

export type PalletConvictionVotingCallLike =
  /**
   * Vote in a poll. If `vote.is_aye()`, the vote is to enact the proposal;
   * otherwise it is a vote to keep the status quo.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `poll_index`: The index of the poll to vote for.
   * - `vote`: The vote configuration.
   *
   * Weight: `O(R)` where R is the number of polls the voter has voted on.
   **/
  | { name: 'Vote'; params: { pollIndex: number; vote: PalletConvictionVotingVoteAccountVote } }
  /**
   * Delegate the voting power (with some given conviction) of the sending account for a
   * particular class of polls.
   *
   * The balance delegated is locked for as long as it's delegated, and thereafter for the
   * time appropriate for the conviction's lock period.
   *
   * The dispatch origin of this call must be _Signed_, and the signing account must either:
   * - be delegating already; or
   * - have no voting activity (if there is, then it will need to be removed through
   * `remove_vote`).
   *
   * - `to`: The account whose voting the `target` account's voting power will follow.
   * - `class`: The class of polls to delegate. To delegate multiple classes, multiple calls
   * to this function are required.
   * - `conviction`: The conviction that will be attached to the delegated votes. When the
   * account is undelegated, the funds will be locked for the corresponding period.
   * - `balance`: The amount of the account's balance to be used in delegating. This must not
   * be more than the account's current balance.
   *
   * Emits `Delegated`.
   *
   * Weight: `O(R)` where R is the number of polls the voter delegating to has
   * voted on. Weight is initially charged as if maximum votes, but is refunded later.
   **/
  | {
      name: 'Delegate';
      params: { class: number; to: MultiAddressLike; conviction: PalletConvictionVotingConviction; balance: bigint };
    }
  /**
   * Undelegate the voting power of the sending account for a particular class of polls.
   *
   * Tokens may be unlocked following once an amount of time consistent with the lock period
   * of the conviction with which the delegation was issued has passed.
   *
   * The dispatch origin of this call must be _Signed_ and the signing account must be
   * currently delegating.
   *
   * - `class`: The class of polls to remove the delegation from.
   *
   * Emits `Undelegated`.
   *
   * Weight: `O(R)` where R is the number of polls the voter delegating to has
   * voted on. Weight is initially charged as if maximum votes, but is refunded later.
   **/
  | { name: 'Undelegate'; params: { class: number } }
  /**
   * Remove the lock caused by prior voting/delegating which has expired within a particular
   * class.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `class`: The class of polls to unlock.
   * - `target`: The account to remove the lock on.
   *
   * Weight: `O(R)` with R number of vote of target.
   **/
  | { name: 'Unlock'; params: { class: number; target: MultiAddressLike } }
  /**
   * Remove a vote for a poll.
   *
   * If:
   * - the poll was cancelled, or
   * - the poll is ongoing, or
   * - the poll has ended such that
   * - the vote of the account was in opposition to the result; or
   * - there was no conviction to the account's vote; or
   * - the account made a split vote
   * ...then the vote is removed cleanly and a following call to `unlock` may result in more
   * funds being available.
   *
   * If, however, the poll has ended and:
   * - it finished corresponding to the vote of the account, and
   * - the account made a standard vote with conviction, and
   * - the lock period of the conviction is not over
   * ...then the lock will be aggregated into the overall account's lock, which may involve
   * *overlocking* (where the two locks are combined into a single lock that is the maximum
   * of both the amount locked and the time is it locked for).
   *
   * The dispatch origin of this call must be _Signed_, and the signer must have a vote
   * registered for poll `index`.
   *
   * - `index`: The index of poll of the vote to be removed.
   * - `class`: Optional parameter, if given it indicates the class of the poll. For polls
   * which have finished or are cancelled, this must be `Some`.
   *
   * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: 'RemoveVote'; params: { class?: number | undefined; index: number } }
  /**
   * Remove a vote for a poll.
   *
   * If the `target` is equal to the signer, then this function is exactly equivalent to
   * `remove_vote`. If not equal to the signer, then the vote must have expired,
   * either because the poll was cancelled, because the voter lost the poll or
   * because the conviction period is over.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `target`: The account of the vote to be removed; this account must have voted for poll
   * `index`.
   * - `index`: The index of poll of the vote to be removed.
   * - `class`: The class of the poll.
   *
   * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: 'RemoveOtherVote'; params: { target: MultiAddressLike; class: number; index: number } };

export type PalletConvictionVotingConviction =
  | 'None'
  | 'Locked1x'
  | 'Locked2x'
  | 'Locked3x'
  | 'Locked4x'
  | 'Locked5x'
  | 'Locked6x';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletReferendaCall =
  /**
   * Propose a referendum on a privileged action.
   *
   * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
   * available.
   * - `proposal_origin`: The origin from which the proposal should be executed.
   * - `proposal`: The proposal.
   * - `enactment_moment`: The moment that the proposal should be enacted.
   *
   * Emits `Submitted`.
   **/
  | {
      name: 'Submit';
      params: {
        proposalOrigin: VaraRuntimeOriginCaller;
        proposal: FrameSupportPreimagesBounded;
        enactmentMoment: FrameSupportScheduleDispatchTime;
      };
    }
  /**
   * Post the Decision Deposit for a referendum.
   *
   * - `origin`: must be `Signed` and the account must have funds available for the
   * referendum's track's Decision Deposit.
   * - `index`: The index of the submitted referendum whose Decision Deposit is yet to be
   * posted.
   *
   * Emits `DecisionDepositPlaced`.
   **/
  | { name: 'PlaceDecisionDeposit'; params: { index: number } }
  /**
   * Refund the Decision Deposit for a closed referendum back to the depositor.
   *
   * - `origin`: must be `Signed` or `Root`.
   * - `index`: The index of a closed referendum whose Decision Deposit has not yet been
   * refunded.
   *
   * Emits `DecisionDepositRefunded`.
   **/
  | { name: 'RefundDecisionDeposit'; params: { index: number } }
  /**
   * Cancel an ongoing referendum.
   *
   * - `origin`: must be the `CancelOrigin`.
   * - `index`: The index of the referendum to be cancelled.
   *
   * Emits `Cancelled`.
   **/
  | { name: 'Cancel'; params: { index: number } }
  /**
   * Cancel an ongoing referendum and slash the deposits.
   *
   * - `origin`: must be the `KillOrigin`.
   * - `index`: The index of the referendum to be cancelled.
   *
   * Emits `Killed` and `DepositSlashed`.
   **/
  | { name: 'Kill'; params: { index: number } }
  /**
   * Advance a referendum onto its next logical state. Only used internally.
   *
   * - `origin`: must be `Root`.
   * - `index`: the referendum to be advanced.
   **/
  | { name: 'NudgeReferendum'; params: { index: number } }
  /**
   * Advance a track onto its next logical state. Only used internally.
   *
   * - `origin`: must be `Root`.
   * - `track`: the track to be advanced.
   *
   * Action item for when there is now one fewer referendum in the deciding phase and the
   * `DecidingCount` is not yet updated. This means that we should either:
   * - begin deciding another referendum (and leave `DecidingCount` alone); or
   * - decrement `DecidingCount`.
   **/
  | { name: 'OneFewerDeciding'; params: { track: number } }
  /**
   * Refund the Submission Deposit for a closed referendum back to the depositor.
   *
   * - `origin`: must be `Signed` or `Root`.
   * - `index`: The index of a closed referendum whose Submission Deposit has not yet been
   * refunded.
   *
   * Emits `SubmissionDepositRefunded`.
   **/
  | { name: 'RefundSubmissionDeposit'; params: { index: number } }
  /**
   * Set or clear metadata of a referendum.
   *
   * Parameters:
   * - `origin`: Must be `Signed` by a creator of a referendum or by anyone to clear a
   * metadata of a finished referendum.
   * - `index`: The index of a referendum to set or clear metadata for.
   * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
   **/
  | { name: 'SetMetadata'; params: { index: number; maybeHash?: H256 | undefined } };

export type PalletReferendaCallLike =
  /**
   * Propose a referendum on a privileged action.
   *
   * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
   * available.
   * - `proposal_origin`: The origin from which the proposal should be executed.
   * - `proposal`: The proposal.
   * - `enactment_moment`: The moment that the proposal should be enacted.
   *
   * Emits `Submitted`.
   **/
  | {
      name: 'Submit';
      params: {
        proposalOrigin: VaraRuntimeOriginCaller;
        proposal: FrameSupportPreimagesBounded;
        enactmentMoment: FrameSupportScheduleDispatchTime;
      };
    }
  /**
   * Post the Decision Deposit for a referendum.
   *
   * - `origin`: must be `Signed` and the account must have funds available for the
   * referendum's track's Decision Deposit.
   * - `index`: The index of the submitted referendum whose Decision Deposit is yet to be
   * posted.
   *
   * Emits `DecisionDepositPlaced`.
   **/
  | { name: 'PlaceDecisionDeposit'; params: { index: number } }
  /**
   * Refund the Decision Deposit for a closed referendum back to the depositor.
   *
   * - `origin`: must be `Signed` or `Root`.
   * - `index`: The index of a closed referendum whose Decision Deposit has not yet been
   * refunded.
   *
   * Emits `DecisionDepositRefunded`.
   **/
  | { name: 'RefundDecisionDeposit'; params: { index: number } }
  /**
   * Cancel an ongoing referendum.
   *
   * - `origin`: must be the `CancelOrigin`.
   * - `index`: The index of the referendum to be cancelled.
   *
   * Emits `Cancelled`.
   **/
  | { name: 'Cancel'; params: { index: number } }
  /**
   * Cancel an ongoing referendum and slash the deposits.
   *
   * - `origin`: must be the `KillOrigin`.
   * - `index`: The index of the referendum to be cancelled.
   *
   * Emits `Killed` and `DepositSlashed`.
   **/
  | { name: 'Kill'; params: { index: number } }
  /**
   * Advance a referendum onto its next logical state. Only used internally.
   *
   * - `origin`: must be `Root`.
   * - `index`: the referendum to be advanced.
   **/
  | { name: 'NudgeReferendum'; params: { index: number } }
  /**
   * Advance a track onto its next logical state. Only used internally.
   *
   * - `origin`: must be `Root`.
   * - `track`: the track to be advanced.
   *
   * Action item for when there is now one fewer referendum in the deciding phase and the
   * `DecidingCount` is not yet updated. This means that we should either:
   * - begin deciding another referendum (and leave `DecidingCount` alone); or
   * - decrement `DecidingCount`.
   **/
  | { name: 'OneFewerDeciding'; params: { track: number } }
  /**
   * Refund the Submission Deposit for a closed referendum back to the depositor.
   *
   * - `origin`: must be `Signed` or `Root`.
   * - `index`: The index of a closed referendum whose Submission Deposit has not yet been
   * refunded.
   *
   * Emits `SubmissionDepositRefunded`.
   **/
  | { name: 'RefundSubmissionDeposit'; params: { index: number } }
  /**
   * Set or clear metadata of a referendum.
   *
   * Parameters:
   * - `origin`: Must be `Signed` by a creator of a referendum or by anyone to clear a
   * metadata of a finished referendum.
   * - `index`: The index of a referendum to set or clear metadata for.
   * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
   **/
  | { name: 'SetMetadata'; params: { index: number; maybeHash?: H256 | undefined } };

export type FrameSupportScheduleDispatchTime = { type: 'At'; value: number } | { type: 'After'; value: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletRankedCollectiveCall =
  /**
   * Introduce a new member.
   *
   * - `origin`: Must be the `AddOrigin`.
   * - `who`: Account of non-member which will become a member.
   *
   * Weight: `O(1)`
   **/
  | { name: 'AddMember'; params: { who: MultiAddress } }
  /**
   * Increment the rank of an existing member by one.
   *
   * - `origin`: Must be the `PromoteOrigin`.
   * - `who`: Account of existing member.
   *
   * Weight: `O(1)`
   **/
  | { name: 'PromoteMember'; params: { who: MultiAddress } }
  /**
   * Decrement the rank of an existing member by one. If the member is already at rank zero,
   * then they are removed entirely.
   *
   * - `origin`: Must be the `DemoteOrigin`.
   * - `who`: Account of existing member of rank greater than zero.
   *
   * Weight: `O(1)`, less if the member's index is highest in its rank.
   **/
  | { name: 'DemoteMember'; params: { who: MultiAddress } }
  /**
   * Remove the member entirely.
   *
   * - `origin`: Must be the `RemoveOrigin`.
   * - `who`: Account of existing member of rank greater than zero.
   * - `min_rank`: The rank of the member or greater.
   *
   * Weight: `O(min_rank)`.
   **/
  | { name: 'RemoveMember'; params: { who: MultiAddress; minRank: number } }
  /**
   * Add an aye or nay vote for the sender to the given proposal.
   *
   * - `origin`: Must be `Signed` by a member account.
   * - `poll`: Index of a poll which is ongoing.
   * - `aye`: `true` if the vote is to approve the proposal, `false` otherwise.
   *
   * Transaction fees are be waived if the member is voting on any particular proposal
   * for the first time and the call is successful. Subsequent vote changes will charge a
   * fee.
   *
   * Weight: `O(1)`, less if there was no previous vote on the poll by the member.
   **/
  | { name: 'Vote'; params: { poll: number; aye: boolean } }
  /**
   * Remove votes from the given poll. It must have ended.
   *
   * - `origin`: Must be `Signed` by any account.
   * - `poll_index`: Index of a poll which is completed and for which votes continue to
   * exist.
   * - `max`: Maximum number of vote items from remove in this call.
   *
   * Transaction fees are waived if the operation is successful.
   *
   * Weight `O(max)` (less if there are fewer items to remove than `max`).
   **/
  | { name: 'CleanupPoll'; params: { pollIndex: number; max: number } }
  /**
   * Exchanges a member with a new account and the same existing rank.
   *
   * - `origin`: Must be the `ExchangeOrigin`.
   * - `who`: Account of existing member of rank greater than zero to be exchanged.
   * - `new_who`: New Account of existing member of rank greater than zero to exchanged to.
   **/
  | { name: 'ExchangeMember'; params: { who: MultiAddress; newWho: MultiAddress } };

export type PalletRankedCollectiveCallLike =
  /**
   * Introduce a new member.
   *
   * - `origin`: Must be the `AddOrigin`.
   * - `who`: Account of non-member which will become a member.
   *
   * Weight: `O(1)`
   **/
  | { name: 'AddMember'; params: { who: MultiAddressLike } }
  /**
   * Increment the rank of an existing member by one.
   *
   * - `origin`: Must be the `PromoteOrigin`.
   * - `who`: Account of existing member.
   *
   * Weight: `O(1)`
   **/
  | { name: 'PromoteMember'; params: { who: MultiAddressLike } }
  /**
   * Decrement the rank of an existing member by one. If the member is already at rank zero,
   * then they are removed entirely.
   *
   * - `origin`: Must be the `DemoteOrigin`.
   * - `who`: Account of existing member of rank greater than zero.
   *
   * Weight: `O(1)`, less if the member's index is highest in its rank.
   **/
  | { name: 'DemoteMember'; params: { who: MultiAddressLike } }
  /**
   * Remove the member entirely.
   *
   * - `origin`: Must be the `RemoveOrigin`.
   * - `who`: Account of existing member of rank greater than zero.
   * - `min_rank`: The rank of the member or greater.
   *
   * Weight: `O(min_rank)`.
   **/
  | { name: 'RemoveMember'; params: { who: MultiAddressLike; minRank: number } }
  /**
   * Add an aye or nay vote for the sender to the given proposal.
   *
   * - `origin`: Must be `Signed` by a member account.
   * - `poll`: Index of a poll which is ongoing.
   * - `aye`: `true` if the vote is to approve the proposal, `false` otherwise.
   *
   * Transaction fees are be waived if the member is voting on any particular proposal
   * for the first time and the call is successful. Subsequent vote changes will charge a
   * fee.
   *
   * Weight: `O(1)`, less if there was no previous vote on the poll by the member.
   **/
  | { name: 'Vote'; params: { poll: number; aye: boolean } }
  /**
   * Remove votes from the given poll. It must have ended.
   *
   * - `origin`: Must be `Signed` by any account.
   * - `poll_index`: Index of a poll which is completed and for which votes continue to
   * exist.
   * - `max`: Maximum number of vote items from remove in this call.
   *
   * Transaction fees are waived if the operation is successful.
   *
   * Weight `O(max)` (less if there are fewer items to remove than `max`).
   **/
  | { name: 'CleanupPoll'; params: { pollIndex: number; max: number } }
  /**
   * Exchanges a member with a new account and the same existing rank.
   *
   * - `origin`: Must be the `ExchangeOrigin`.
   * - `who`: Account of existing member of rank greater than zero to be exchanged.
   * - `new_who`: New Account of existing member of rank greater than zero to exchanged to.
   **/
  | { name: 'ExchangeMember'; params: { who: MultiAddressLike; newWho: MultiAddressLike } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletWhitelistCall =
  | { name: 'WhitelistCall'; params: { callHash: H256 } }
  | { name: 'RemoveWhitelistedCall'; params: { callHash: H256 } }
  | {
      name: 'DispatchWhitelistedCall';
      params: { callHash: H256; callEncodedLen: number; callWeightWitness: SpWeightsWeightV2Weight };
    }
  | { name: 'DispatchWhitelistedCallWithPreimage'; params: { call: VaraRuntimeRuntimeCall } };

export type PalletWhitelistCallLike =
  | { name: 'WhitelistCall'; params: { callHash: H256 } }
  | { name: 'RemoveWhitelistedCall'; params: { callHash: H256 } }
  | {
      name: 'DispatchWhitelistedCall';
      params: { callHash: H256; callEncodedLen: number; callWeightWitness: SpWeightsWeightV2Weight };
    }
  | { name: 'DispatchWhitelistedCallWithPreimage'; params: { call: VaraRuntimeRuntimeCallLike } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSchedulerCall =
  /**
   * Anonymously schedule a task.
   **/
  | {
      name: 'Schedule';
      params: {
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: VaraRuntimeRuntimeCall;
      };
    }
  /**
   * Cancel an anonymously scheduled task.
   **/
  | { name: 'Cancel'; params: { when: number; index: number } }
  /**
   * Schedule a named task.
   **/
  | {
      name: 'ScheduleNamed';
      params: {
        id: FixedBytes<32>;
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: VaraRuntimeRuntimeCall;
      };
    }
  /**
   * Cancel a named scheduled task.
   **/
  | { name: 'CancelNamed'; params: { id: FixedBytes<32> } }
  /**
   * Anonymously schedule a task after a delay.
   **/
  | {
      name: 'ScheduleAfter';
      params: {
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: VaraRuntimeRuntimeCall;
      };
    }
  /**
   * Schedule a named task after a delay.
   **/
  | {
      name: 'ScheduleNamedAfter';
      params: {
        id: FixedBytes<32>;
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: VaraRuntimeRuntimeCall;
      };
    }
  /**
   * Set a retry configuration for a task so that, in case its scheduled run fails, it will
   * be retried after `period` blocks, for a total amount of `retries` retries or until it
   * succeeds.
   *
   * Tasks which need to be scheduled for a retry are still subject to weight metering and
   * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
   * normally while the task is retrying.
   *
   * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
   * clones of the original task. Their retry configuration will be derived from the
   * original task's configuration, but will have a lower value for `remaining` than the
   * original `total_retries`.
   **/
  | { name: 'SetRetry'; params: { task: [number, number]; retries: number; period: number } }
  /**
   * Set a retry configuration for a named task so that, in case its scheduled run fails, it
   * will be retried after `period` blocks, for a total amount of `retries` retries or until
   * it succeeds.
   *
   * Tasks which need to be scheduled for a retry are still subject to weight metering and
   * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
   * normally while the task is retrying.
   *
   * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
   * clones of the original task. Their retry configuration will be derived from the
   * original task's configuration, but will have a lower value for `remaining` than the
   * original `total_retries`.
   **/
  | { name: 'SetRetryNamed'; params: { id: FixedBytes<32>; retries: number; period: number } }
  /**
   * Removes the retry configuration of a task.
   **/
  | { name: 'CancelRetry'; params: { task: [number, number] } }
  /**
   * Cancel the retry configuration of a named task.
   **/
  | { name: 'CancelRetryNamed'; params: { id: FixedBytes<32> } };

export type PalletSchedulerCallLike =
  /**
   * Anonymously schedule a task.
   **/
  | {
      name: 'Schedule';
      params: {
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: VaraRuntimeRuntimeCallLike;
      };
    }
  /**
   * Cancel an anonymously scheduled task.
   **/
  | { name: 'Cancel'; params: { when: number; index: number } }
  /**
   * Schedule a named task.
   **/
  | {
      name: 'ScheduleNamed';
      params: {
        id: FixedBytes<32>;
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: VaraRuntimeRuntimeCallLike;
      };
    }
  /**
   * Cancel a named scheduled task.
   **/
  | { name: 'CancelNamed'; params: { id: FixedBytes<32> } }
  /**
   * Anonymously schedule a task after a delay.
   **/
  | {
      name: 'ScheduleAfter';
      params: {
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: VaraRuntimeRuntimeCallLike;
      };
    }
  /**
   * Schedule a named task after a delay.
   **/
  | {
      name: 'ScheduleNamedAfter';
      params: {
        id: FixedBytes<32>;
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: VaraRuntimeRuntimeCallLike;
      };
    }
  /**
   * Set a retry configuration for a task so that, in case its scheduled run fails, it will
   * be retried after `period` blocks, for a total amount of `retries` retries or until it
   * succeeds.
   *
   * Tasks which need to be scheduled for a retry are still subject to weight metering and
   * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
   * normally while the task is retrying.
   *
   * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
   * clones of the original task. Their retry configuration will be derived from the
   * original task's configuration, but will have a lower value for `remaining` than the
   * original `total_retries`.
   **/
  | { name: 'SetRetry'; params: { task: [number, number]; retries: number; period: number } }
  /**
   * Set a retry configuration for a named task so that, in case its scheduled run fails, it
   * will be retried after `period` blocks, for a total amount of `retries` retries or until
   * it succeeds.
   *
   * Tasks which need to be scheduled for a retry are still subject to weight metering and
   * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
   * normally while the task is retrying.
   *
   * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
   * clones of the original task. Their retry configuration will be derived from the
   * original task's configuration, but will have a lower value for `remaining` than the
   * original `total_retries`.
   **/
  | { name: 'SetRetryNamed'; params: { id: FixedBytes<32>; retries: number; period: number } }
  /**
   * Removes the retry configuration of a task.
   **/
  | { name: 'CancelRetry'; params: { task: [number, number] } }
  /**
   * Cancel the retry configuration of a named task.
   **/
  | { name: 'CancelRetryNamed'; params: { id: FixedBytes<32> } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletPreimageCall =
  /**
   * Register a preimage on-chain.
   *
   * If the preimage was previously requested, no fees or deposits are taken for providing
   * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
   **/
  | { name: 'NotePreimage'; params: { bytes: Bytes } }
  /**
   * Clear an unrequested preimage from the runtime storage.
   *
   * If `len` is provided, then it will be a much cheaper operation.
   *
   * - `hash`: The hash of the preimage to be removed from the store.
   * - `len`: The length of the preimage of `hash`.
   **/
  | { name: 'UnnotePreimage'; params: { hash: H256 } }
  /**
   * Request a preimage be uploaded to the chain without paying any fees or deposits.
   *
   * If the preimage requests has already been provided on-chain, we unreserve any deposit
   * a user may have paid, and take the control of the preimage out of their hands.
   **/
  | { name: 'RequestPreimage'; params: { hash: H256 } }
  /**
   * Clear a previously made request for a preimage.
   *
   * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
   **/
  | { name: 'UnrequestPreimage'; params: { hash: H256 } }
  /**
   * Ensure that the a bulk of pre-images is upgraded.
   *
   * The caller pays no fee if at least 90% of pre-images were successfully updated.
   **/
  | { name: 'EnsureUpdated'; params: { hashes: Array<H256> } };

export type PalletPreimageCallLike =
  /**
   * Register a preimage on-chain.
   *
   * If the preimage was previously requested, no fees or deposits are taken for providing
   * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
   **/
  | { name: 'NotePreimage'; params: { bytes: BytesLike } }
  /**
   * Clear an unrequested preimage from the runtime storage.
   *
   * If `len` is provided, then it will be a much cheaper operation.
   *
   * - `hash`: The hash of the preimage to be removed from the store.
   * - `len`: The length of the preimage of `hash`.
   **/
  | { name: 'UnnotePreimage'; params: { hash: H256 } }
  /**
   * Request a preimage be uploaded to the chain without paying any fees or deposits.
   *
   * If the preimage requests has already been provided on-chain, we unreserve any deposit
   * a user may have paid, and take the control of the preimage out of their hands.
   **/
  | { name: 'RequestPreimage'; params: { hash: H256 } }
  /**
   * Clear a previously made request for a preimage.
   *
   * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
   **/
  | { name: 'UnrequestPreimage'; params: { hash: H256 } }
  /**
   * Ensure that the a bulk of pre-images is upgraded.
   *
   * The caller pays no fee if at least 90% of pre-images were successfully updated.
   **/
  | { name: 'EnsureUpdated'; params: { hashes: Array<H256> } };

/**
 * Identity pallet declaration.
 **/
export type PalletIdentityCall =
  /**
   * Add a registrar to the system.
   *
   * The dispatch origin for this call must be `T::RegistrarOrigin`.
   *
   * - `account`: the account of the registrar.
   *
   * Emits `RegistrarAdded` if successful.
   **/
  | { name: 'AddRegistrar'; params: { account: MultiAddress } }
  /**
   * Set an account's identity information and reserve the appropriate deposit.
   *
   * If the account already has identity information, the deposit is taken as part payment
   * for the new deposit.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `info`: The identity information.
   *
   * Emits `IdentitySet` if successful.
   **/
  | { name: 'SetIdentity'; params: { info: PalletIdentityLegacyIdentityInfo } }
  /**
   * Set the sub-accounts of the sender.
   *
   * Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
   * and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * identity.
   *
   * - `subs`: The identity's (new) sub-accounts.
   **/
  | { name: 'SetSubs'; params: { subs: Array<[AccountId32, Data]> } }
  /**
   * Clear an account's identity info and all sub-accounts and return all deposits.
   *
   * Payment: All reserved balances on the account are returned.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * identity.
   *
   * Emits `IdentityCleared` if successful.
   **/
  | { name: 'ClearIdentity' }
  /**
   * Request a judgement from a registrar.
   *
   * Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
   * given.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a
   * registered identity.
   *
   * - `reg_index`: The index of the registrar whose judgement is requested.
   * - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
   *
   * ```nocompile
   * Registrars::<T>::get().get(reg_index).unwrap().fee
   * ```
   *
   * Emits `JudgementRequested` if successful.
   **/
  | { name: 'RequestJudgement'; params: { regIndex: number; maxFee: bigint } }
  /**
   * Cancel a previous request.
   *
   * Payment: A previously reserved deposit is returned on success.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a
   * registered identity.
   *
   * - `reg_index`: The index of the registrar whose judgement is no longer requested.
   *
   * Emits `JudgementUnrequested` if successful.
   **/
  | { name: 'CancelRequest'; params: { regIndex: number } }
  /**
   * Set the fee required for a judgement to be requested from a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `fee`: the new fee.
   **/
  | { name: 'SetFee'; params: { index: number; fee: bigint } }
  /**
   * Change the account associated with a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `new`: the new account ID.
   **/
  | { name: 'SetAccountId'; params: { index: number; new: MultiAddress } }
  /**
   * Set the field information for a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `fields`: the fields that the registrar concerns themselves with.
   **/
  | { name: 'SetFields'; params: { index: number; fields: bigint } }
  /**
   * Provide a judgement for an account's identity.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `reg_index`.
   *
   * - `reg_index`: the index of the registrar whose judgement is being made.
   * - `target`: the account whose identity the judgement is upon. This must be an account
   * with a registered identity.
   * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
   * - `identity`: The hash of the [`IdentityInformationProvider`] for that the judgement is
   * provided.
   *
   * Note: Judgements do not apply to a username.
   *
   * Emits `JudgementGiven` if successful.
   **/
  | {
      name: 'ProvideJudgement';
      params: { regIndex: number; target: MultiAddress; judgement: PalletIdentityJudgement; identity: H256 };
    }
  /**
   * Remove an account's identity and sub-account information and slash the deposits.
   *
   * Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
   * `Slash`. Verification request deposits are not returned; they should be cancelled
   * manually using `cancel_request`.
   *
   * The dispatch origin for this call must match `T::ForceOrigin`.
   *
   * - `target`: the account whose identity the judgement is upon. This must be an account
   * with a registered identity.
   *
   * Emits `IdentityKilled` if successful.
   **/
  | { name: 'KillIdentity'; params: { target: MultiAddress } }
  /**
   * Add the given account to the sender's subs.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'AddSub'; params: { sub: MultiAddress; data: Data } }
  /**
   * Alter the associated name of the given sub-account.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'RenameSub'; params: { sub: MultiAddress; data: Data } }
  /**
   * Remove the given account from the sender's subs.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'RemoveSub'; params: { sub: MultiAddress } }
  /**
   * Remove the sender as a sub-account.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender (*not* the original depositor).
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * super-identity.
   *
   * NOTE: This should not normally be used, but is provided in the case that the non-
   * controller of an account is maliciously registered as a sub-account.
   **/
  | { name: 'QuitSub' }
  /**
   * Add an `AccountId` with permission to grant usernames with a given `suffix` appended.
   *
   * The authority can grant up to `allocation` usernames. To top up their allocation, they
   * should just issue (or request via governance) a new `add_username_authority` call.
   **/
  | { name: 'AddUsernameAuthority'; params: { authority: MultiAddress; suffix: Bytes; allocation: number } }
  /**
   * Remove `authority` from the username authorities.
   **/
  | { name: 'RemoveUsernameAuthority'; params: { authority: MultiAddress } }
  /**
   * Set the username for `who`. Must be called by a username authority.
   *
   * The authority must have an `allocation`. Users can either pre-sign their usernames or
   * accept them later.
   *
   * Usernames must:
   * - Only contain lowercase ASCII characters or digits.
   * - When combined with the suffix of the issuing authority be _less than_ the
   * `MaxUsernameLength`.
   **/
  | {
      name: 'SetUsernameFor';
      params: { who: MultiAddress; username: Bytes; signature?: SpRuntimeMultiSignature | undefined };
    }
  /**
   * Accept a given username that an `authority` granted. The call must include the full
   * username, as in `username.suffix`.
   **/
  | { name: 'AcceptUsername'; params: { username: Bytes } }
  /**
   * Remove an expired username approval. The username was approved by an authority but never
   * accepted by the user and must now be beyond its expiration. The call must include the
   * full username, as in `username.suffix`.
   **/
  | { name: 'RemoveExpiredApproval'; params: { username: Bytes } }
  /**
   * Set a given username as the primary. The username should include the suffix.
   **/
  | { name: 'SetPrimaryUsername'; params: { username: Bytes } }
  /**
   * Remove a username that corresponds to an account with no identity. Exists when a user
   * gets a username but then calls `clear_identity`.
   **/
  | { name: 'RemoveDanglingUsername'; params: { username: Bytes } };

export type PalletIdentityCallLike =
  /**
   * Add a registrar to the system.
   *
   * The dispatch origin for this call must be `T::RegistrarOrigin`.
   *
   * - `account`: the account of the registrar.
   *
   * Emits `RegistrarAdded` if successful.
   **/
  | { name: 'AddRegistrar'; params: { account: MultiAddressLike } }
  /**
   * Set an account's identity information and reserve the appropriate deposit.
   *
   * If the account already has identity information, the deposit is taken as part payment
   * for the new deposit.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `info`: The identity information.
   *
   * Emits `IdentitySet` if successful.
   **/
  | { name: 'SetIdentity'; params: { info: PalletIdentityLegacyIdentityInfo } }
  /**
   * Set the sub-accounts of the sender.
   *
   * Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
   * and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * identity.
   *
   * - `subs`: The identity's (new) sub-accounts.
   **/
  | { name: 'SetSubs'; params: { subs: Array<[AccountId32Like, Data]> } }
  /**
   * Clear an account's identity info and all sub-accounts and return all deposits.
   *
   * Payment: All reserved balances on the account are returned.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * identity.
   *
   * Emits `IdentityCleared` if successful.
   **/
  | { name: 'ClearIdentity' }
  /**
   * Request a judgement from a registrar.
   *
   * Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
   * given.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a
   * registered identity.
   *
   * - `reg_index`: The index of the registrar whose judgement is requested.
   * - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
   *
   * ```nocompile
   * Registrars::<T>::get().get(reg_index).unwrap().fee
   * ```
   *
   * Emits `JudgementRequested` if successful.
   **/
  | { name: 'RequestJudgement'; params: { regIndex: number; maxFee: bigint } }
  /**
   * Cancel a previous request.
   *
   * Payment: A previously reserved deposit is returned on success.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a
   * registered identity.
   *
   * - `reg_index`: The index of the registrar whose judgement is no longer requested.
   *
   * Emits `JudgementUnrequested` if successful.
   **/
  | { name: 'CancelRequest'; params: { regIndex: number } }
  /**
   * Set the fee required for a judgement to be requested from a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `fee`: the new fee.
   **/
  | { name: 'SetFee'; params: { index: number; fee: bigint } }
  /**
   * Change the account associated with a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `new`: the new account ID.
   **/
  | { name: 'SetAccountId'; params: { index: number; new: MultiAddressLike } }
  /**
   * Set the field information for a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `fields`: the fields that the registrar concerns themselves with.
   **/
  | { name: 'SetFields'; params: { index: number; fields: bigint } }
  /**
   * Provide a judgement for an account's identity.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `reg_index`.
   *
   * - `reg_index`: the index of the registrar whose judgement is being made.
   * - `target`: the account whose identity the judgement is upon. This must be an account
   * with a registered identity.
   * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
   * - `identity`: The hash of the [`IdentityInformationProvider`] for that the judgement is
   * provided.
   *
   * Note: Judgements do not apply to a username.
   *
   * Emits `JudgementGiven` if successful.
   **/
  | {
      name: 'ProvideJudgement';
      params: { regIndex: number; target: MultiAddressLike; judgement: PalletIdentityJudgement; identity: H256 };
    }
  /**
   * Remove an account's identity and sub-account information and slash the deposits.
   *
   * Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
   * `Slash`. Verification request deposits are not returned; they should be cancelled
   * manually using `cancel_request`.
   *
   * The dispatch origin for this call must match `T::ForceOrigin`.
   *
   * - `target`: the account whose identity the judgement is upon. This must be an account
   * with a registered identity.
   *
   * Emits `IdentityKilled` if successful.
   **/
  | { name: 'KillIdentity'; params: { target: MultiAddressLike } }
  /**
   * Add the given account to the sender's subs.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'AddSub'; params: { sub: MultiAddressLike; data: Data } }
  /**
   * Alter the associated name of the given sub-account.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'RenameSub'; params: { sub: MultiAddressLike; data: Data } }
  /**
   * Remove the given account from the sender's subs.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'RemoveSub'; params: { sub: MultiAddressLike } }
  /**
   * Remove the sender as a sub-account.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender (*not* the original depositor).
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * super-identity.
   *
   * NOTE: This should not normally be used, but is provided in the case that the non-
   * controller of an account is maliciously registered as a sub-account.
   **/
  | { name: 'QuitSub' }
  /**
   * Add an `AccountId` with permission to grant usernames with a given `suffix` appended.
   *
   * The authority can grant up to `allocation` usernames. To top up their allocation, they
   * should just issue (or request via governance) a new `add_username_authority` call.
   **/
  | { name: 'AddUsernameAuthority'; params: { authority: MultiAddressLike; suffix: BytesLike; allocation: number } }
  /**
   * Remove `authority` from the username authorities.
   **/
  | { name: 'RemoveUsernameAuthority'; params: { authority: MultiAddressLike } }
  /**
   * Set the username for `who`. Must be called by a username authority.
   *
   * The authority must have an `allocation`. Users can either pre-sign their usernames or
   * accept them later.
   *
   * Usernames must:
   * - Only contain lowercase ASCII characters or digits.
   * - When combined with the suffix of the issuing authority be _less than_ the
   * `MaxUsernameLength`.
   **/
  | {
      name: 'SetUsernameFor';
      params: { who: MultiAddressLike; username: BytesLike; signature?: SpRuntimeMultiSignature | undefined };
    }
  /**
   * Accept a given username that an `authority` granted. The call must include the full
   * username, as in `username.suffix`.
   **/
  | { name: 'AcceptUsername'; params: { username: BytesLike } }
  /**
   * Remove an expired username approval. The username was approved by an authority but never
   * accepted by the user and must now be beyond its expiration. The call must include the
   * full username, as in `username.suffix`.
   **/
  | { name: 'RemoveExpiredApproval'; params: { username: BytesLike } }
  /**
   * Set a given username as the primary. The username should include the suffix.
   **/
  | { name: 'SetPrimaryUsername'; params: { username: BytesLike } }
  /**
   * Remove a username that corresponds to an account with no identity. Exists when a user
   * gets a username but then calls `clear_identity`.
   **/
  | { name: 'RemoveDanglingUsername'; params: { username: BytesLike } };

export type PalletIdentityLegacyIdentityInfo = {
  additional: Array<[Data, Data]>;
  display: Data;
  legal: Data;
  web: Data;
  riot: Data;
  email: Data;
  pgpFingerprint?: FixedBytes<20> | undefined;
  image: Data;
  twitter: Data;
};

export type PalletIdentityJudgement =
  | { type: 'Unknown' }
  | { type: 'FeePaid'; value: bigint }
  | { type: 'Reasonable' }
  | { type: 'KnownGood' }
  | { type: 'OutOfDate' }
  | { type: 'LowQuality' }
  | { type: 'Erroneous' };

export type SpRuntimeMultiSignature =
  | { type: 'Ed25519'; value: FixedBytes<64> }
  | { type: 'Sr25519'; value: FixedBytes<64> }
  | { type: 'Ecdsa'; value: FixedBytes<65> };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletProxyCall =
  /**
   * Dispatch the given `call` from an account that the sender is authorised for through
   * `add_proxy`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
   * - `call`: The call to be made by the `real` account.
   **/
  | {
      name: 'Proxy';
      params: { real: MultiAddress; forceProxyType?: VaraRuntimeProxyType | undefined; call: VaraRuntimeRuntimeCall };
    }
  /**
   * Register a proxy account for the sender that is able to make calls on its behalf.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `proxy`: The account that the `caller` would like to make a proxy.
   * - `proxy_type`: The permissions allowed for this proxy account.
   * - `delay`: The announcement period required of the initial proxy. Will generally be
   * zero.
   **/
  | { name: 'AddProxy'; params: { delegate: MultiAddress; proxyType: VaraRuntimeProxyType; delay: number } }
  /**
   * Unregister a proxy account for the sender.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `proxy`: The account that the `caller` would like to remove as a proxy.
   * - `proxy_type`: The permissions currently enabled for the removed proxy account.
   **/
  | { name: 'RemoveProxy'; params: { delegate: MultiAddress; proxyType: VaraRuntimeProxyType; delay: number } }
  /**
   * Unregister all proxy accounts for the sender.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * WARNING: This may be called on accounts created by `pure`, however if done, then
   * the unreserved fees will be inaccessible. **All access to this account will be lost.**
   **/
  | { name: 'RemoveProxies' }
  /**
   * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
   * initialize it with a proxy of `proxy_type` for `origin` sender.
   *
   * Requires a `Signed` origin.
   *
   * - `proxy_type`: The type of the proxy that the sender will be registered as over the
   * new account. This will almost always be the most permissive `ProxyType` possible to
   * allow for maximum flexibility.
   * - `index`: A disambiguation index, in case this is called multiple times in the same
   * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
   * want to use `0`.
   * - `delay`: The announcement period required of the initial proxy. Will generally be
   * zero.
   *
   * Fails with `Duplicate` if this has already been called in this transaction, from the
   * same sender, with the same parameters.
   *
   * Fails if there are insufficient funds to pay for deposit.
   **/
  | { name: 'CreatePure'; params: { proxyType: VaraRuntimeProxyType; delay: number; index: number } }
  /**
   * Removes a previously spawned pure proxy.
   *
   * WARNING: **All access to this account will be lost.** Any funds held in it will be
   * inaccessible.
   *
   * Requires a `Signed` origin, and the sender account must have been created by a call to
   * `pure` with corresponding parameters.
   *
   * - `spawner`: The account that originally called `pure` to create this account.
   * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
   * - `proxy_type`: The proxy type originally passed to `pure`.
   * - `height`: The height of the chain when the call to `pure` was processed.
   * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
   *
   * Fails with `NoPermission` in case the caller is not a previously created pure
   * account whose `pure` call has corresponding parameters.
   **/
  | {
      name: 'KillPure';
      params: {
        spawner: MultiAddress;
        proxyType: VaraRuntimeProxyType;
        index: number;
        height: number;
        extIndex: number;
      };
    }
  /**
   * Publish the hash of a proxy-call that will be made in the future.
   *
   * This must be called some number of blocks before the corresponding `proxy` is attempted
   * if the delay associated with the proxy relationship is greater than zero.
   *
   * No more than `MaxPending` announcements may be made at any one time.
   *
   * This will take a deposit of `AnnouncementDepositFactor` as well as
   * `AnnouncementDepositBase` if there are no other pending announcements.
   *
   * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `call_hash`: The hash of the call to be made by the `real` account.
   **/
  | { name: 'Announce'; params: { real: MultiAddress; callHash: H256 } }
  /**
   * Remove a given announcement.
   *
   * May be called by a proxy account to remove a call they previously announced and return
   * the deposit.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `call_hash`: The hash of the call to be made by the `real` account.
   **/
  | { name: 'RemoveAnnouncement'; params: { real: MultiAddress; callHash: H256 } }
  /**
   * Remove the given announcement of a delegate.
   *
   * May be called by a target (proxied) account to remove a call that one of their delegates
   * (`delegate`) has announced they want to execute. The deposit is returned.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `delegate`: The account that previously announced the call.
   * - `call_hash`: The hash of the call to be made.
   **/
  | { name: 'RejectAnnouncement'; params: { delegate: MultiAddress; callHash: H256 } }
  /**
   * Dispatch the given `call` from an account that the sender is authorized for through
   * `add_proxy`.
   *
   * Removes any corresponding announcement(s).
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
   * - `call`: The call to be made by the `real` account.
   **/
  | {
      name: 'ProxyAnnounced';
      params: {
        delegate: MultiAddress;
        real: MultiAddress;
        forceProxyType?: VaraRuntimeProxyType | undefined;
        call: VaraRuntimeRuntimeCall;
      };
    };

export type PalletProxyCallLike =
  /**
   * Dispatch the given `call` from an account that the sender is authorised for through
   * `add_proxy`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
   * - `call`: The call to be made by the `real` account.
   **/
  | {
      name: 'Proxy';
      params: {
        real: MultiAddressLike;
        forceProxyType?: VaraRuntimeProxyType | undefined;
        call: VaraRuntimeRuntimeCallLike;
      };
    }
  /**
   * Register a proxy account for the sender that is able to make calls on its behalf.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `proxy`: The account that the `caller` would like to make a proxy.
   * - `proxy_type`: The permissions allowed for this proxy account.
   * - `delay`: The announcement period required of the initial proxy. Will generally be
   * zero.
   **/
  | { name: 'AddProxy'; params: { delegate: MultiAddressLike; proxyType: VaraRuntimeProxyType; delay: number } }
  /**
   * Unregister a proxy account for the sender.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `proxy`: The account that the `caller` would like to remove as a proxy.
   * - `proxy_type`: The permissions currently enabled for the removed proxy account.
   **/
  | { name: 'RemoveProxy'; params: { delegate: MultiAddressLike; proxyType: VaraRuntimeProxyType; delay: number } }
  /**
   * Unregister all proxy accounts for the sender.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * WARNING: This may be called on accounts created by `pure`, however if done, then
   * the unreserved fees will be inaccessible. **All access to this account will be lost.**
   **/
  | { name: 'RemoveProxies' }
  /**
   * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
   * initialize it with a proxy of `proxy_type` for `origin` sender.
   *
   * Requires a `Signed` origin.
   *
   * - `proxy_type`: The type of the proxy that the sender will be registered as over the
   * new account. This will almost always be the most permissive `ProxyType` possible to
   * allow for maximum flexibility.
   * - `index`: A disambiguation index, in case this is called multiple times in the same
   * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
   * want to use `0`.
   * - `delay`: The announcement period required of the initial proxy. Will generally be
   * zero.
   *
   * Fails with `Duplicate` if this has already been called in this transaction, from the
   * same sender, with the same parameters.
   *
   * Fails if there are insufficient funds to pay for deposit.
   **/
  | { name: 'CreatePure'; params: { proxyType: VaraRuntimeProxyType; delay: number; index: number } }
  /**
   * Removes a previously spawned pure proxy.
   *
   * WARNING: **All access to this account will be lost.** Any funds held in it will be
   * inaccessible.
   *
   * Requires a `Signed` origin, and the sender account must have been created by a call to
   * `pure` with corresponding parameters.
   *
   * - `spawner`: The account that originally called `pure` to create this account.
   * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
   * - `proxy_type`: The proxy type originally passed to `pure`.
   * - `height`: The height of the chain when the call to `pure` was processed.
   * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
   *
   * Fails with `NoPermission` in case the caller is not a previously created pure
   * account whose `pure` call has corresponding parameters.
   **/
  | {
      name: 'KillPure';
      params: {
        spawner: MultiAddressLike;
        proxyType: VaraRuntimeProxyType;
        index: number;
        height: number;
        extIndex: number;
      };
    }
  /**
   * Publish the hash of a proxy-call that will be made in the future.
   *
   * This must be called some number of blocks before the corresponding `proxy` is attempted
   * if the delay associated with the proxy relationship is greater than zero.
   *
   * No more than `MaxPending` announcements may be made at any one time.
   *
   * This will take a deposit of `AnnouncementDepositFactor` as well as
   * `AnnouncementDepositBase` if there are no other pending announcements.
   *
   * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `call_hash`: The hash of the call to be made by the `real` account.
   **/
  | { name: 'Announce'; params: { real: MultiAddressLike; callHash: H256 } }
  /**
   * Remove a given announcement.
   *
   * May be called by a proxy account to remove a call they previously announced and return
   * the deposit.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `call_hash`: The hash of the call to be made by the `real` account.
   **/
  | { name: 'RemoveAnnouncement'; params: { real: MultiAddressLike; callHash: H256 } }
  /**
   * Remove the given announcement of a delegate.
   *
   * May be called by a target (proxied) account to remove a call that one of their delegates
   * (`delegate`) has announced they want to execute. The deposit is returned.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `delegate`: The account that previously announced the call.
   * - `call_hash`: The hash of the call to be made.
   **/
  | { name: 'RejectAnnouncement'; params: { delegate: MultiAddressLike; callHash: H256 } }
  /**
   * Dispatch the given `call` from an account that the sender is authorized for through
   * `add_proxy`.
   *
   * Removes any corresponding announcement(s).
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
   * - `call`: The call to be made by the `real` account.
   **/
  | {
      name: 'ProxyAnnounced';
      params: {
        delegate: MultiAddressLike;
        real: MultiAddressLike;
        forceProxyType?: VaraRuntimeProxyType | undefined;
        call: VaraRuntimeRuntimeCallLike;
      };
    };

export type VaraRuntimeProxyType =
  | 'Any'
  | 'NonTransfer'
  | 'Governance'
  | 'Staking'
  | 'IdentityJudgement'
  | 'CancelProxy';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMultisigCall =
  /**
   * Immediately dispatch a multi-signature call using a single approval from the caller.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `other_signatories`: The accounts (other than the sender) who are part of the
   * multi-signature, but do not participate in the approval process.
   * - `call`: The call to be executed.
   *
   * Result is equivalent to the dispatched result.
   *
   * ## Complexity
   * O(Z + C) where Z is the length of the call and C its execution weight.
   **/
  | { name: 'AsMultiThreshold1'; params: { otherSignatories: Array<AccountId32>; call: VaraRuntimeRuntimeCall } }
  /**
   * Register approval for a dispatch to be made from a deterministic composite account if
   * approved by a total of `threshold - 1` of `other_signatories`.
   *
   * If there are enough, then dispatch the call.
   *
   * Payment: `DepositBase` will be reserved if this is the first approval, plus
   * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
   * is cancelled.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
   * not the first approval, then it must be `Some`, with the timepoint (block number and
   * transaction index) of the first approval transaction.
   * - `call`: The call to be executed.
   *
   * NOTE: Unless this is the final approval, you will generally want to use
   * `approve_as_multi` instead, since it only requires a hash of the call.
   *
   * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
   * on success, result is `Ok` and the result from the interior call, if it was executed,
   * may be found in the deposited `MultisigExecuted` event.
   *
   * ## Complexity
   * - `O(S + Z + Call)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
   * - One encode & hash, both of complexity `O(S)`.
   * - Up to one binary search and insert (`O(logS + S)`).
   * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
   * - One event.
   * - The weight of the `call`.
   * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
   * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
   **/
  | {
      name: 'AsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        call: VaraRuntimeRuntimeCall;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Register approval for a dispatch to be made from a deterministic composite account if
   * approved by a total of `threshold - 1` of `other_signatories`.
   *
   * Payment: `DepositBase` will be reserved if this is the first approval, plus
   * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
   * is cancelled.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
   * not the first approval, then it must be `Some`, with the timepoint (block number and
   * transaction index) of the first approval transaction.
   * - `call_hash`: The hash of the call to be executed.
   *
   * NOTE: If this is the final approval, you will want to use `as_multi` instead.
   *
   * ## Complexity
   * - `O(S)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One encode & hash, both of complexity `O(S)`.
   * - Up to one binary search and insert (`O(logS + S)`).
   * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
   * - One event.
   * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
   * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
   **/
  | {
      name: 'ApproveAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        callHash: FixedBytes<32>;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
   * for this operation will be unreserved on success.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `timepoint`: The timepoint (block number and transaction index) of the first approval
   * transaction for this dispatch.
   * - `call_hash`: The hash of the call to be executed.
   *
   * ## Complexity
   * - `O(S)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One encode & hash, both of complexity `O(S)`.
   * - One event.
   * - I/O: 1 read `O(S)`, one remove.
   * - Storage: removes one item.
   **/
  | {
      name: 'CancelAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        timepoint: PalletMultisigTimepoint;
        callHash: FixedBytes<32>;
      };
    };

export type PalletMultisigCallLike =
  /**
   * Immediately dispatch a multi-signature call using a single approval from the caller.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `other_signatories`: The accounts (other than the sender) who are part of the
   * multi-signature, but do not participate in the approval process.
   * - `call`: The call to be executed.
   *
   * Result is equivalent to the dispatched result.
   *
   * ## Complexity
   * O(Z + C) where Z is the length of the call and C its execution weight.
   **/
  | {
      name: 'AsMultiThreshold1';
      params: { otherSignatories: Array<AccountId32Like>; call: VaraRuntimeRuntimeCallLike };
    }
  /**
   * Register approval for a dispatch to be made from a deterministic composite account if
   * approved by a total of `threshold - 1` of `other_signatories`.
   *
   * If there are enough, then dispatch the call.
   *
   * Payment: `DepositBase` will be reserved if this is the first approval, plus
   * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
   * is cancelled.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
   * not the first approval, then it must be `Some`, with the timepoint (block number and
   * transaction index) of the first approval transaction.
   * - `call`: The call to be executed.
   *
   * NOTE: Unless this is the final approval, you will generally want to use
   * `approve_as_multi` instead, since it only requires a hash of the call.
   *
   * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
   * on success, result is `Ok` and the result from the interior call, if it was executed,
   * may be found in the deposited `MultisigExecuted` event.
   *
   * ## Complexity
   * - `O(S + Z + Call)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
   * - One encode & hash, both of complexity `O(S)`.
   * - Up to one binary search and insert (`O(logS + S)`).
   * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
   * - One event.
   * - The weight of the `call`.
   * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
   * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
   **/
  | {
      name: 'AsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        call: VaraRuntimeRuntimeCallLike;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Register approval for a dispatch to be made from a deterministic composite account if
   * approved by a total of `threshold - 1` of `other_signatories`.
   *
   * Payment: `DepositBase` will be reserved if this is the first approval, plus
   * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
   * is cancelled.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
   * not the first approval, then it must be `Some`, with the timepoint (block number and
   * transaction index) of the first approval transaction.
   * - `call_hash`: The hash of the call to be executed.
   *
   * NOTE: If this is the final approval, you will want to use `as_multi` instead.
   *
   * ## Complexity
   * - `O(S)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One encode & hash, both of complexity `O(S)`.
   * - Up to one binary search and insert (`O(logS + S)`).
   * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
   * - One event.
   * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
   * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
   **/
  | {
      name: 'ApproveAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        callHash: FixedBytes<32>;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
   * for this operation will be unreserved on success.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `timepoint`: The timepoint (block number and transaction index) of the first approval
   * transaction for this dispatch.
   * - `call_hash`: The hash of the call to be executed.
   *
   * ## Complexity
   * - `O(S)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One encode & hash, both of complexity `O(S)`.
   * - One event.
   * - I/O: 1 read `O(S)`, one remove.
   * - Storage: removes one item.
   **/
  | {
      name: 'CancelAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        timepoint: PalletMultisigTimepoint;
        callHash: FixedBytes<32>;
      };
    };

export type PalletMultisigTimepoint = { height: number; index: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletElectionProviderMultiPhaseCall =
  /**
   * Submit a solution for the unsigned phase.
   *
   * The dispatch origin fo this call must be __none__.
   *
   * This submission is checked on the fly. Moreover, this unsigned solution is only
   * validated when submitted to the pool from the **local** node. Effectively, this means
   * that only active validators can submit this transaction when authoring a block (similar
   * to an inherent).
   *
   * To prevent any incorrect solution (and thus wasted time/weight), this transaction will
   * panic if the solution submitted by the validator is invalid in any way, effectively
   * putting their authoring reward at risk.
   *
   * No deposit or reward is associated with this submission.
   **/
  | {
      name: 'SubmitUnsigned';
      params: {
        rawSolution: PalletElectionProviderMultiPhaseRawSolution;
        witness: PalletElectionProviderMultiPhaseSolutionOrSnapshotSize;
      };
    }
  /**
   * Set a new value for `MinimumUntrustedScore`.
   *
   * Dispatch origin must be aligned with `T::ForceOrigin`.
   *
   * This check can be turned off by setting the value to `None`.
   **/
  | { name: 'SetMinimumUntrustedScore'; params: { maybeNextScore?: SpNposElectionsElectionScore | undefined } }
  /**
   * Set a solution in the queue, to be handed out to the client of this pallet in the next
   * call to `ElectionProvider::elect`.
   *
   * This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`.
   *
   * The solution is not checked for any feasibility and is assumed to be trustworthy, as any
   * feasibility check itself can in principle cause the election process to fail (due to
   * memory/weight constrains).
   **/
  | { name: 'SetEmergencyElectionResult'; params: { supports: Array<[AccountId32, SpNposElectionsSupport]> } }
  /**
   * Submit a solution for the signed phase.
   *
   * The dispatch origin fo this call must be __signed__.
   *
   * The solution is potentially queued, based on the claimed score and processed at the end
   * of the signed phase.
   *
   * A deposit is reserved and recorded for the solution. Based on the outcome, the solution
   * might be rewarded, slashed, or get all or a part of the deposit back.
   **/
  | { name: 'Submit'; params: { rawSolution: PalletElectionProviderMultiPhaseRawSolution } }
  /**
   * Trigger the governance fallback.
   *
   * This can only be called when [`Phase::Emergency`] is enabled, as an alternative to
   * calling [`Call::set_emergency_election_result`].
   **/
  | {
      name: 'GovernanceFallback';
      params: { maybeMaxVoters?: number | undefined; maybeMaxTargets?: number | undefined };
    };

export type PalletElectionProviderMultiPhaseCallLike =
  /**
   * Submit a solution for the unsigned phase.
   *
   * The dispatch origin fo this call must be __none__.
   *
   * This submission is checked on the fly. Moreover, this unsigned solution is only
   * validated when submitted to the pool from the **local** node. Effectively, this means
   * that only active validators can submit this transaction when authoring a block (similar
   * to an inherent).
   *
   * To prevent any incorrect solution (and thus wasted time/weight), this transaction will
   * panic if the solution submitted by the validator is invalid in any way, effectively
   * putting their authoring reward at risk.
   *
   * No deposit or reward is associated with this submission.
   **/
  | {
      name: 'SubmitUnsigned';
      params: {
        rawSolution: PalletElectionProviderMultiPhaseRawSolution;
        witness: PalletElectionProviderMultiPhaseSolutionOrSnapshotSize;
      };
    }
  /**
   * Set a new value for `MinimumUntrustedScore`.
   *
   * Dispatch origin must be aligned with `T::ForceOrigin`.
   *
   * This check can be turned off by setting the value to `None`.
   **/
  | { name: 'SetMinimumUntrustedScore'; params: { maybeNextScore?: SpNposElectionsElectionScore | undefined } }
  /**
   * Set a solution in the queue, to be handed out to the client of this pallet in the next
   * call to `ElectionProvider::elect`.
   *
   * This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`.
   *
   * The solution is not checked for any feasibility and is assumed to be trustworthy, as any
   * feasibility check itself can in principle cause the election process to fail (due to
   * memory/weight constrains).
   **/
  | { name: 'SetEmergencyElectionResult'; params: { supports: Array<[AccountId32Like, SpNposElectionsSupport]> } }
  /**
   * Submit a solution for the signed phase.
   *
   * The dispatch origin fo this call must be __signed__.
   *
   * The solution is potentially queued, based on the claimed score and processed at the end
   * of the signed phase.
   *
   * A deposit is reserved and recorded for the solution. Based on the outcome, the solution
   * might be rewarded, slashed, or get all or a part of the deposit back.
   **/
  | { name: 'Submit'; params: { rawSolution: PalletElectionProviderMultiPhaseRawSolution } }
  /**
   * Trigger the governance fallback.
   *
   * This can only be called when [`Phase::Emergency`] is enabled, as an alternative to
   * calling [`Call::set_emergency_election_result`].
   **/
  | {
      name: 'GovernanceFallback';
      params: { maybeMaxVoters?: number | undefined; maybeMaxTargets?: number | undefined };
    };

export type PalletElectionProviderMultiPhaseRawSolution = {
  solution: VaraRuntimeNposSolution16;
  score: SpNposElectionsElectionScore;
  round: number;
};

export type VaraRuntimeNposSolution16 = {
  votes1: Array<[number, number]>;
  votes2: Array<[number, [number, PerU16], number]>;
  votes3: Array<[number, FixedArray<[number, PerU16], 2>, number]>;
  votes4: Array<[number, FixedArray<[number, PerU16], 3>, number]>;
  votes5: Array<[number, FixedArray<[number, PerU16], 4>, number]>;
  votes6: Array<[number, FixedArray<[number, PerU16], 5>, number]>;
  votes7: Array<[number, FixedArray<[number, PerU16], 6>, number]>;
  votes8: Array<[number, FixedArray<[number, PerU16], 7>, number]>;
  votes9: Array<[number, FixedArray<[number, PerU16], 8>, number]>;
  votes10: Array<[number, FixedArray<[number, PerU16], 9>, number]>;
  votes11: Array<[number, FixedArray<[number, PerU16], 10>, number]>;
  votes12: Array<[number, FixedArray<[number, PerU16], 11>, number]>;
  votes13: Array<[number, FixedArray<[number, PerU16], 12>, number]>;
  votes14: Array<[number, FixedArray<[number, PerU16], 13>, number]>;
  votes15: Array<[number, FixedArray<[number, PerU16], 14>, number]>;
  votes16: Array<[number, FixedArray<[number, PerU16], 15>, number]>;
};

export type SpNposElectionsElectionScore = { minimalStake: bigint; sumStake: bigint; sumStakeSquared: bigint };

export type PalletElectionProviderMultiPhaseSolutionOrSnapshotSize = { voters: number; targets: number };

export type SpNposElectionsSupport = { total: bigint; voters: Array<[AccountId32, bigint]> };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBountiesCall =
  /**
   * Propose a new bounty.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
   * `DataDepositPerByte` for each byte in `reason`. It will be unreserved upon approval,
   * or slashed when rejected.
   *
   * - `curator`: The curator account whom will manage this bounty.
   * - `fee`: The curator fee.
   * - `value`: The total payment amount of this bounty, curator fee included.
   * - `description`: The description of this bounty.
   **/
  | { name: 'ProposeBounty'; params: { value: bigint; description: Bytes } }
  /**
   * Approve a bounty proposal. At a later time, the bounty will be funded and become active
   * and the original deposit will be returned.
   *
   * May only be called from `T::SpendOrigin`.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'ApproveBounty'; params: { bountyId: number } }
  /**
   * Propose a curator to a funded bounty.
   *
   * May only be called from `T::SpendOrigin`.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'ProposeCurator'; params: { bountyId: number; curator: MultiAddress; fee: bigint } }
  /**
   * Unassign curator from a bounty.
   *
   * This function can only be called by the `RejectOrigin` a signed origin.
   *
   * If this function is called by the `RejectOrigin`, we assume that the curator is
   * malicious or inactive. As a result, we will slash the curator when possible.
   *
   * If the origin is the curator, we take this as a sign they are unable to do their job and
   * they willingly give up. We could slash them, but for now we allow them to recover their
   * deposit and exit without issue. (We may want to change this if it is abused.)
   *
   * Finally, the origin can be anyone if and only if the curator is "inactive". This allows
   * anyone in the community to call out that a curator is not doing their due diligence, and
   * we should pick a new curator. In this case the curator should also be slashed.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'UnassignCurator'; params: { bountyId: number } }
  /**
   * Accept the curator role for a bounty.
   * A deposit will be reserved from curator and refund upon successful payout.
   *
   * May only be called from the curator.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'AcceptCurator'; params: { bountyId: number } }
  /**
   * Award bounty to a beneficiary account. The beneficiary will be able to claim the funds
   * after a delay.
   *
   * The dispatch origin for this call must be the curator of this bounty.
   *
   * - `bounty_id`: Bounty ID to award.
   * - `beneficiary`: The beneficiary account whom will receive the payout.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'AwardBounty'; params: { bountyId: number; beneficiary: MultiAddress } }
  /**
   * Claim the payout from an awarded bounty after payout delay.
   *
   * The dispatch origin for this call must be the beneficiary of this bounty.
   *
   * - `bounty_id`: Bounty ID to claim.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'ClaimBounty'; params: { bountyId: number } }
  /**
   * Cancel a proposed or active bounty. All the funds will be sent to treasury and
   * the curator deposit will be unreserved if possible.
   *
   * Only `T::RejectOrigin` is able to cancel a bounty.
   *
   * - `bounty_id`: Bounty ID to cancel.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'CloseBounty'; params: { bountyId: number } }
  /**
   * Extend the expiry time of an active bounty.
   *
   * The dispatch origin for this call must be the curator of this bounty.
   *
   * - `bounty_id`: Bounty ID to extend.
   * - `remark`: additional information.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'ExtendBountyExpiry'; params: { bountyId: number; remark: Bytes } };

export type PalletBountiesCallLike =
  /**
   * Propose a new bounty.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
   * `DataDepositPerByte` for each byte in `reason`. It will be unreserved upon approval,
   * or slashed when rejected.
   *
   * - `curator`: The curator account whom will manage this bounty.
   * - `fee`: The curator fee.
   * - `value`: The total payment amount of this bounty, curator fee included.
   * - `description`: The description of this bounty.
   **/
  | { name: 'ProposeBounty'; params: { value: bigint; description: BytesLike } }
  /**
   * Approve a bounty proposal. At a later time, the bounty will be funded and become active
   * and the original deposit will be returned.
   *
   * May only be called from `T::SpendOrigin`.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'ApproveBounty'; params: { bountyId: number } }
  /**
   * Propose a curator to a funded bounty.
   *
   * May only be called from `T::SpendOrigin`.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'ProposeCurator'; params: { bountyId: number; curator: MultiAddressLike; fee: bigint } }
  /**
   * Unassign curator from a bounty.
   *
   * This function can only be called by the `RejectOrigin` a signed origin.
   *
   * If this function is called by the `RejectOrigin`, we assume that the curator is
   * malicious or inactive. As a result, we will slash the curator when possible.
   *
   * If the origin is the curator, we take this as a sign they are unable to do their job and
   * they willingly give up. We could slash them, but for now we allow them to recover their
   * deposit and exit without issue. (We may want to change this if it is abused.)
   *
   * Finally, the origin can be anyone if and only if the curator is "inactive". This allows
   * anyone in the community to call out that a curator is not doing their due diligence, and
   * we should pick a new curator. In this case the curator should also be slashed.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'UnassignCurator'; params: { bountyId: number } }
  /**
   * Accept the curator role for a bounty.
   * A deposit will be reserved from curator and refund upon successful payout.
   *
   * May only be called from the curator.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'AcceptCurator'; params: { bountyId: number } }
  /**
   * Award bounty to a beneficiary account. The beneficiary will be able to claim the funds
   * after a delay.
   *
   * The dispatch origin for this call must be the curator of this bounty.
   *
   * - `bounty_id`: Bounty ID to award.
   * - `beneficiary`: The beneficiary account whom will receive the payout.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'AwardBounty'; params: { bountyId: number; beneficiary: MultiAddressLike } }
  /**
   * Claim the payout from an awarded bounty after payout delay.
   *
   * The dispatch origin for this call must be the beneficiary of this bounty.
   *
   * - `bounty_id`: Bounty ID to claim.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'ClaimBounty'; params: { bountyId: number } }
  /**
   * Cancel a proposed or active bounty. All the funds will be sent to treasury and
   * the curator deposit will be unreserved if possible.
   *
   * Only `T::RejectOrigin` is able to cancel a bounty.
   *
   * - `bounty_id`: Bounty ID to cancel.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'CloseBounty'; params: { bountyId: number } }
  /**
   * Extend the expiry time of an active bounty.
   *
   * The dispatch origin for this call must be the curator of this bounty.
   *
   * - `bounty_id`: Bounty ID to extend.
   * - `remark`: additional information.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'ExtendBountyExpiry'; params: { bountyId: number; remark: BytesLike } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletChildBountiesCall =
  /**
   * Add a new child-bounty.
   *
   * The dispatch origin for this call must be the curator of parent
   * bounty and the parent bounty must be in "active" state.
   *
   * Child-bounty gets added successfully & fund gets transferred from
   * parent bounty to child-bounty account, if parent bounty has enough
   * funds, else the call fails.
   *
   * Upper bound to maximum number of active child bounties that can be
   * added are managed via runtime trait config
   * [`Config::MaxActiveChildBountyCount`].
   *
   * If the call is success, the status of child-bounty is updated to
   * "Added".
   *
   * - `parent_bounty_id`: Index of parent bounty for which child-bounty is being added.
   * - `value`: Value for executing the proposal.
   * - `description`: Text description for the child-bounty.
   **/
  | { name: 'AddChildBounty'; params: { parentBountyId: number; value: bigint; description: Bytes } }
  /**
   * Propose curator for funded child-bounty.
   *
   * The dispatch origin for this call must be curator of parent bounty.
   *
   * Parent bounty must be in active state, for this child-bounty call to
   * work.
   *
   * Child-bounty must be in "Added" state, for processing the call. And
   * state of child-bounty is moved to "CuratorProposed" on successful
   * call completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   * - `curator`: Address of child-bounty curator.
   * - `fee`: payment fee to child-bounty curator for execution.
   **/
  | {
      name: 'ProposeCurator';
      params: { parentBountyId: number; childBountyId: number; curator: MultiAddress; fee: bigint };
    }
  /**
   * Accept the curator role for the child-bounty.
   *
   * The dispatch origin for this call must be the curator of this
   * child-bounty.
   *
   * A deposit will be reserved from the curator and refund upon
   * successful payout or cancellation.
   *
   * Fee for curator is deducted from curator fee of parent bounty.
   *
   * Parent bounty must be in active state, for this child-bounty call to
   * work.
   *
   * Child-bounty must be in "CuratorProposed" state, for processing the
   * call. And state of child-bounty is moved to "Active" on successful
   * call completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   **/
  | { name: 'AcceptCurator'; params: { parentBountyId: number; childBountyId: number } }
  /**
   * Unassign curator from a child-bounty.
   *
   * The dispatch origin for this call can be either `RejectOrigin`, or
   * the curator of the parent bounty, or any signed origin.
   *
   * For the origin other than T::RejectOrigin and the child-bounty
   * curator, parent bounty must be in active state, for this call to
   * work. We allow child-bounty curator and T::RejectOrigin to execute
   * this call irrespective of the parent bounty state.
   *
   * If this function is called by the `RejectOrigin` or the
   * parent bounty curator, we assume that the child-bounty curator is
   * malicious or inactive. As a result, child-bounty curator deposit is
   * slashed.
   *
   * If the origin is the child-bounty curator, we take this as a sign
   * that they are unable to do their job, and are willingly giving up.
   * We could slash the deposit, but for now we allow them to unreserve
   * their deposit and exit without issue. (We may want to change this if
   * it is abused.)
   *
   * Finally, the origin can be anyone iff the child-bounty curator is
   * "inactive". Expiry update due of parent bounty is used to estimate
   * inactive state of child-bounty curator.
   *
   * This allows anyone in the community to call out that a child-bounty
   * curator is not doing their due diligence, and we should pick a new
   * one. In this case the child-bounty curator deposit is slashed.
   *
   * State of child-bounty is moved to Added state on successful call
   * completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   **/
  | { name: 'UnassignCurator'; params: { parentBountyId: number; childBountyId: number } }
  /**
   * Award child-bounty to a beneficiary.
   *
   * The beneficiary will be able to claim the funds after a delay.
   *
   * The dispatch origin for this call must be the parent curator or
   * curator of this child-bounty.
   *
   * Parent bounty must be in active state, for this child-bounty call to
   * work.
   *
   * Child-bounty must be in active state, for processing the call. And
   * state of child-bounty is moved to "PendingPayout" on successful call
   * completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   * - `beneficiary`: Beneficiary account.
   **/
  | { name: 'AwardChildBounty'; params: { parentBountyId: number; childBountyId: number; beneficiary: MultiAddress } }
  /**
   * Claim the payout from an awarded child-bounty after payout delay.
   *
   * The dispatch origin for this call may be any signed origin.
   *
   * Call works independent of parent bounty state, No need for parent
   * bounty to be in active state.
   *
   * The Beneficiary is paid out with agreed bounty value. Curator fee is
   * paid & curator deposit is unreserved.
   *
   * Child-bounty must be in "PendingPayout" state, for processing the
   * call. And instance of child-bounty is removed from the state on
   * successful call completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   **/
  | { name: 'ClaimChildBounty'; params: { parentBountyId: number; childBountyId: number } }
  /**
   * Cancel a proposed or active child-bounty. Child-bounty account funds
   * are transferred to parent bounty account. The child-bounty curator
   * deposit may be unreserved if possible.
   *
   * The dispatch origin for this call must be either parent curator or
   * `T::RejectOrigin`.
   *
   * If the state of child-bounty is `Active`, curator deposit is
   * unreserved.
   *
   * If the state of child-bounty is `PendingPayout`, call fails &
   * returns `PendingPayout` error.
   *
   * For the origin other than T::RejectOrigin, parent bounty must be in
   * active state, for this child-bounty call to work. For origin
   * T::RejectOrigin execution is forced.
   *
   * Instance of child-bounty is removed from the state on successful
   * call completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   **/
  | { name: 'CloseChildBounty'; params: { parentBountyId: number; childBountyId: number } };

export type PalletChildBountiesCallLike =
  /**
   * Add a new child-bounty.
   *
   * The dispatch origin for this call must be the curator of parent
   * bounty and the parent bounty must be in "active" state.
   *
   * Child-bounty gets added successfully & fund gets transferred from
   * parent bounty to child-bounty account, if parent bounty has enough
   * funds, else the call fails.
   *
   * Upper bound to maximum number of active child bounties that can be
   * added are managed via runtime trait config
   * [`Config::MaxActiveChildBountyCount`].
   *
   * If the call is success, the status of child-bounty is updated to
   * "Added".
   *
   * - `parent_bounty_id`: Index of parent bounty for which child-bounty is being added.
   * - `value`: Value for executing the proposal.
   * - `description`: Text description for the child-bounty.
   **/
  | { name: 'AddChildBounty'; params: { parentBountyId: number; value: bigint; description: BytesLike } }
  /**
   * Propose curator for funded child-bounty.
   *
   * The dispatch origin for this call must be curator of parent bounty.
   *
   * Parent bounty must be in active state, for this child-bounty call to
   * work.
   *
   * Child-bounty must be in "Added" state, for processing the call. And
   * state of child-bounty is moved to "CuratorProposed" on successful
   * call completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   * - `curator`: Address of child-bounty curator.
   * - `fee`: payment fee to child-bounty curator for execution.
   **/
  | {
      name: 'ProposeCurator';
      params: { parentBountyId: number; childBountyId: number; curator: MultiAddressLike; fee: bigint };
    }
  /**
   * Accept the curator role for the child-bounty.
   *
   * The dispatch origin for this call must be the curator of this
   * child-bounty.
   *
   * A deposit will be reserved from the curator and refund upon
   * successful payout or cancellation.
   *
   * Fee for curator is deducted from curator fee of parent bounty.
   *
   * Parent bounty must be in active state, for this child-bounty call to
   * work.
   *
   * Child-bounty must be in "CuratorProposed" state, for processing the
   * call. And state of child-bounty is moved to "Active" on successful
   * call completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   **/
  | { name: 'AcceptCurator'; params: { parentBountyId: number; childBountyId: number } }
  /**
   * Unassign curator from a child-bounty.
   *
   * The dispatch origin for this call can be either `RejectOrigin`, or
   * the curator of the parent bounty, or any signed origin.
   *
   * For the origin other than T::RejectOrigin and the child-bounty
   * curator, parent bounty must be in active state, for this call to
   * work. We allow child-bounty curator and T::RejectOrigin to execute
   * this call irrespective of the parent bounty state.
   *
   * If this function is called by the `RejectOrigin` or the
   * parent bounty curator, we assume that the child-bounty curator is
   * malicious or inactive. As a result, child-bounty curator deposit is
   * slashed.
   *
   * If the origin is the child-bounty curator, we take this as a sign
   * that they are unable to do their job, and are willingly giving up.
   * We could slash the deposit, but for now we allow them to unreserve
   * their deposit and exit without issue. (We may want to change this if
   * it is abused.)
   *
   * Finally, the origin can be anyone iff the child-bounty curator is
   * "inactive". Expiry update due of parent bounty is used to estimate
   * inactive state of child-bounty curator.
   *
   * This allows anyone in the community to call out that a child-bounty
   * curator is not doing their due diligence, and we should pick a new
   * one. In this case the child-bounty curator deposit is slashed.
   *
   * State of child-bounty is moved to Added state on successful call
   * completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   **/
  | { name: 'UnassignCurator'; params: { parentBountyId: number; childBountyId: number } }
  /**
   * Award child-bounty to a beneficiary.
   *
   * The beneficiary will be able to claim the funds after a delay.
   *
   * The dispatch origin for this call must be the parent curator or
   * curator of this child-bounty.
   *
   * Parent bounty must be in active state, for this child-bounty call to
   * work.
   *
   * Child-bounty must be in active state, for processing the call. And
   * state of child-bounty is moved to "PendingPayout" on successful call
   * completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   * - `beneficiary`: Beneficiary account.
   **/
  | {
      name: 'AwardChildBounty';
      params: { parentBountyId: number; childBountyId: number; beneficiary: MultiAddressLike };
    }
  /**
   * Claim the payout from an awarded child-bounty after payout delay.
   *
   * The dispatch origin for this call may be any signed origin.
   *
   * Call works independent of parent bounty state, No need for parent
   * bounty to be in active state.
   *
   * The Beneficiary is paid out with agreed bounty value. Curator fee is
   * paid & curator deposit is unreserved.
   *
   * Child-bounty must be in "PendingPayout" state, for processing the
   * call. And instance of child-bounty is removed from the state on
   * successful call completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   **/
  | { name: 'ClaimChildBounty'; params: { parentBountyId: number; childBountyId: number } }
  /**
   * Cancel a proposed or active child-bounty. Child-bounty account funds
   * are transferred to parent bounty account. The child-bounty curator
   * deposit may be unreserved if possible.
   *
   * The dispatch origin for this call must be either parent curator or
   * `T::RejectOrigin`.
   *
   * If the state of child-bounty is `Active`, curator deposit is
   * unreserved.
   *
   * If the state of child-bounty is `PendingPayout`, call fails &
   * returns `PendingPayout` error.
   *
   * For the origin other than T::RejectOrigin, parent bounty must be in
   * active state, for this child-bounty call to work. For origin
   * T::RejectOrigin execution is forced.
   *
   * Instance of child-bounty is removed from the state on successful
   * call completion.
   *
   * - `parent_bounty_id`: Index of parent bounty.
   * - `child_bounty_id`: Index of child bounty.
   **/
  | { name: 'CloseChildBounty'; params: { parentBountyId: number; childBountyId: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletNominationPoolsCall =
  /**
   * Stake funds with a pool. The amount to bond is transferred from the member to the pool
   * account and immediately increases the pools bond.
   *
   * The method of transferring the amount to the pool account is determined by
   * [`adapter::StakeStrategyType`]. If the pool is configured to use
   * [`adapter::StakeStrategyType::Delegate`], the funds remain in the account of
   * the `origin`, while the pool gains the right to use these funds for staking.
   *
   * # Note
   *
   * * An account can only be a member of a single pool.
   * * An account cannot join the same pool multiple times.
   * * This call will *not* dust the member account, so the member must have at least
   * `existential deposit + amount` in their account.
   * * Only a pool with [`PoolState::Open`] can be joined
   **/
  | { name: 'Join'; params: { amount: bigint; poolId: number } }
  /**
   * Bond `extra` more funds from `origin` into the pool to which they already belong.
   *
   * Additional funds can come from either the free balance of the account, of from the
   * accumulated rewards, see [`BondExtra`].
   *
   * Bonding extra funds implies an automatic payout of all pending rewards as well.
   * See `bond_extra_other` to bond pending rewards of `other` members.
   **/
  | { name: 'BondExtra'; params: { extra: PalletNominationPoolsBondExtra } }
  /**
   * A bonded member can use this to claim their payout based on the rewards that the pool
   * has accumulated since their last claimed payout (OR since joining if this is their first
   * time claiming rewards). The payout will be transferred to the member's account.
   *
   * The member will earn rewards pro rata based on the members stake vs the sum of the
   * members in the pools stake. Rewards do not "expire".
   *
   * See `claim_payout_other` to claim rewards on behalf of some `other` pool member.
   **/
  | { name: 'ClaimPayout' }
  /**
   * Unbond up to `unbonding_points` of the `member_account`'s funds from the pool. It
   * implicitly collects the rewards one last time, since not doing so would mean some
   * rewards would be forfeited.
   *
   * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
   * account).
   *
   * # Conditions for a permissionless dispatch.
   *
   * * The pool is blocked and the caller is either the root or bouncer. This is refereed to
   * as a kick.
   * * The pool is destroying and the member is not the depositor.
   * * The pool is destroying, the member is the depositor and no other members are in the
   * pool.
   *
   * ## Conditions for permissioned dispatch (i.e. the caller is also the
   * `member_account`):
   *
   * * The caller is not the depositor.
   * * The caller is the depositor, the pool is destroying and no other members are in the
   * pool.
   *
   * # Note
   *
   * If there are too many unlocking chunks to unbond with the pool account,
   * [`Call::pool_withdraw_unbonded`] can be called to try and minimize unlocking chunks.
   * The [`StakingInterface::unbond`] will implicitly call [`Call::pool_withdraw_unbonded`]
   * to try to free chunks if necessary (ie. if unbound was called and no unlocking chunks
   * are available). However, it may not be possible to release the current unlocking chunks,
   * in which case, the result of this call will likely be the `NoMoreChunks` error from the
   * staking system.
   **/
  | { name: 'Unbond'; params: { memberAccount: MultiAddress; unbondingPoints: bigint } }
  /**
   * Call `withdraw_unbonded` for the pools account. This call can be made by any account.
   *
   * This is useful if there are too many unlocking chunks to call `unbond`, and some
   * can be cleared by withdrawing. In the case there are too many unlocking chunks, the user
   * would probably see an error like `NoMoreChunks` emitted from the staking system when
   * they attempt to unbond.
   **/
  | { name: 'PoolWithdrawUnbonded'; params: { poolId: number; numSlashingSpans: number } }
  /**
   * Withdraw unbonded funds from `member_account`. If no bonded funds can be unbonded, an
   * error is returned.
   *
   * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
   * account).
   *
   * # Conditions for a permissionless dispatch
   *
   * * The pool is in destroy mode and the target is not the depositor.
   * * The target is the depositor and they are the only member in the sub pools.
   * * The pool is blocked and the caller is either the root or bouncer.
   *
   * # Conditions for permissioned dispatch
   *
   * * The caller is the target and they are not the depositor.
   *
   * # Note
   *
   * - If the target is the depositor, the pool will be destroyed.
   * - If the pool has any pending slash, we also try to slash the member before letting them
   * withdraw. This calculation adds some weight overhead and is only defensive. In reality,
   * pool slashes must have been already applied via permissionless [`Call::apply_slash`].
   **/
  | { name: 'WithdrawUnbonded'; params: { memberAccount: MultiAddress; numSlashingSpans: number } }
  /**
   * Create a new delegation pool.
   *
   * # Arguments
   *
   * * `amount` - The amount of funds to delegate to the pool. This also acts of a sort of
   * deposit since the pools creator cannot fully unbond funds until the pool is being
   * destroyed.
   * * `index` - A disambiguation index for creating the account. Likely only useful when
   * creating multiple pools in the same extrinsic.
   * * `root` - The account to set as [`PoolRoles::root`].
   * * `nominator` - The account to set as the [`PoolRoles::nominator`].
   * * `bouncer` - The account to set as the [`PoolRoles::bouncer`].
   *
   * # Note
   *
   * In addition to `amount`, the caller will transfer the existential deposit; so the caller
   * needs at have at least `amount + existential_deposit` transferable.
   **/
  | { name: 'Create'; params: { amount: bigint; root: MultiAddress; nominator: MultiAddress; bouncer: MultiAddress } }
  /**
   * Create a new delegation pool with a previously used pool id
   *
   * # Arguments
   *
   * same as `create` with the inclusion of
   * * `pool_id` - `A valid PoolId.
   **/
  | {
      name: 'CreateWithPoolId';
      params: { amount: bigint; root: MultiAddress; nominator: MultiAddress; bouncer: MultiAddress; poolId: number };
    }
  /**
   * Nominate on behalf of the pool.
   *
   * The dispatch origin of this call must be signed by the pool nominator or the pool
   * root role.
   *
   * This directly forward the call to the staking pallet, on behalf of the pool bonded
   * account.
   *
   * # Note
   *
   * In addition to a `root` or `nominator` role of `origin`, pool's depositor needs to have
   * at least `depositor_min_bond` in the pool to start nominating.
   **/
  | { name: 'Nominate'; params: { poolId: number; validators: Array<AccountId32> } }
  /**
   * Set a new state for the pool.
   *
   * If a pool is already in the `Destroying` state, then under no condition can its state
   * change again.
   *
   * The dispatch origin of this call must be either:
   *
   * 1. signed by the bouncer, or the root role of the pool,
   * 2. if the pool conditions to be open are NOT met (as described by `ok_to_be_open`), and
   * then the state of the pool can be permissionlessly changed to `Destroying`.
   **/
  | { name: 'SetState'; params: { poolId: number; state: PalletNominationPoolsPoolState } }
  /**
   * Set a new metadata for the pool.
   *
   * The dispatch origin of this call must be signed by the bouncer, or the root role of the
   * pool.
   **/
  | { name: 'SetMetadata'; params: { poolId: number; metadata: Bytes } }
  /**
   * Update configurations for the nomination pools. The origin for this call must be
   * [`Config::AdminOrigin`].
   *
   * # Arguments
   *
   * * `min_join_bond` - Set [`MinJoinBond`].
   * * `min_create_bond` - Set [`MinCreateBond`].
   * * `max_pools` - Set [`MaxPools`].
   * * `max_members` - Set [`MaxPoolMembers`].
   * * `max_members_per_pool` - Set [`MaxPoolMembersPerPool`].
   * * `global_max_commission` - Set [`GlobalMaxCommission`].
   **/
  | {
      name: 'SetConfigs';
      params: {
        minJoinBond: PalletNominationPoolsConfigOp;
        minCreateBond: PalletNominationPoolsConfigOp;
        maxPools: PalletNominationPoolsConfigOpU32;
        maxMembers: PalletNominationPoolsConfigOpU32;
        maxMembersPerPool: PalletNominationPoolsConfigOpU32;
        globalMaxCommission: PalletNominationPoolsConfigOpPerbill;
      };
    }
  /**
   * Update the roles of the pool.
   *
   * The root is the only entity that can change any of the roles, including itself,
   * excluding the depositor, who can never change.
   *
   * It emits an event, notifying UIs of the role change. This event is quite relevant to
   * most pool members and they should be informed of changes to pool roles.
   **/
  | {
      name: 'UpdateRoles';
      params: {
        poolId: number;
        newRoot: PalletNominationPoolsConfigOp004;
        newNominator: PalletNominationPoolsConfigOp004;
        newBouncer: PalletNominationPoolsConfigOp004;
      };
    }
  /**
   * Chill on behalf of the pool.
   *
   * The dispatch origin of this call can be signed by the pool nominator or the pool
   * root role, same as [`Pallet::nominate`].
   *
   * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
   * account).
   *
   * # Conditions for a permissionless dispatch:
   * * When pool depositor has less than `MinNominatorBond` staked, otherwise pool members
   * are unable to unbond.
   *
   * # Conditions for permissioned dispatch:
   * * The caller has a nominator or root role of the pool.
   * This directly forward the call to the staking pallet, on behalf of the pool bonded
   * account.
   **/
  | { name: 'Chill'; params: { poolId: number } }
  /**
   * `origin` bonds funds from `extra` for some pool member `member` into their respective
   * pools.
   *
   * `origin` can bond extra funds from free balance or pending rewards when `origin ==
   * other`.
   *
   * In the case of `origin != other`, `origin` can only bond extra pending rewards of
   * `other` members assuming set_claim_permission for the given member is
   * `PermissionlessCompound` or `PermissionlessAll`.
   **/
  | { name: 'BondExtraOther'; params: { member: MultiAddress; extra: PalletNominationPoolsBondExtra } }
  /**
   * Allows a pool member to set a claim permission to allow or disallow permissionless
   * bonding and withdrawing.
   *
   * # Arguments
   *
   * * `origin` - Member of a pool.
   * * `permission` - The permission to be applied.
   **/
  | { name: 'SetClaimPermission'; params: { permission: PalletNominationPoolsClaimPermission } }
  /**
   * `origin` can claim payouts on some pool member `other`'s behalf.
   *
   * Pool member `other` must have a `PermissionlessWithdraw` or `PermissionlessAll` claim
   * permission for this call to be successful.
   **/
  | { name: 'ClaimPayoutOther'; params: { other: AccountId32 } }
  /**
   * Set the commission of a pool.
   * Both a commission percentage and a commission payee must be provided in the `current`
   * tuple. Where a `current` of `None` is provided, any current commission will be removed.
   *
   * - If a `None` is supplied to `new_commission`, existing commission will be removed.
   **/
  | { name: 'SetCommission'; params: { poolId: number; newCommission?: [Perbill, AccountId32] | undefined } }
  /**
   * Set the maximum commission of a pool.
   *
   * - Initial max can be set to any `Perbill`, and only smaller values thereafter.
   * - Current commission will be lowered in the event it is higher than a new max
   * commission.
   **/
  | { name: 'SetCommissionMax'; params: { poolId: number; maxCommission: Perbill } }
  /**
   * Set the commission change rate for a pool.
   *
   * Initial change rate is not bounded, whereas subsequent updates can only be more
   * restrictive than the current.
   **/
  | {
      name: 'SetCommissionChangeRate';
      params: { poolId: number; changeRate: PalletNominationPoolsCommissionChangeRate };
    }
  /**
   * Claim pending commission.
   *
   * The dispatch origin of this call must be signed by the `root` role of the pool. Pending
   * commission is paid out and added to total claimed commission`. Total pending commission
   * is reset to zero. the current.
   **/
  | { name: 'ClaimCommission'; params: { poolId: number } }
  /**
   * Top up the deficit or withdraw the excess ED from the pool.
   *
   * When a pool is created, the pool depositor transfers ED to the reward account of the
   * pool. ED is subject to change and over time, the deposit in the reward account may be
   * insufficient to cover the ED deficit of the pool or vice-versa where there is excess
   * deposit to the pool. This call allows anyone to adjust the ED deposit of the
   * pool by either topping up the deficit or claiming the excess.
   **/
  | { name: 'AdjustPoolDeposit'; params: { poolId: number } }
  /**
   * Set or remove a pool's commission claim permission.
   *
   * Determines who can claim the pool's pending commission. Only the `Root` role of the pool
   * is able to configure commission claim permissions.
   **/
  | {
      name: 'SetCommissionClaimPermission';
      params: { poolId: number; permission?: PalletNominationPoolsCommissionClaimPermission | undefined };
    }
  /**
   * Apply a pending slash on a member.
   *
   * Fails unless [`crate::pallet::Config::StakeAdapter`] is of strategy type:
   * [`adapter::StakeStrategyType::Delegate`].
   *
   * This call can be dispatched permissionlessly (i.e. by any account). If the member has
   * slash to be applied, caller may be rewarded with the part of the slash.
   **/
  | { name: 'ApplySlash'; params: { memberAccount: MultiAddress } }
  /**
   * Migrates delegated funds from the pool account to the `member_account`.
   *
   * Fails unless [`crate::pallet::Config::StakeAdapter`] is of strategy type:
   * [`adapter::StakeStrategyType::Delegate`].
   *
   * This is a permission-less call and refunds any fee if claim is successful.
   *
   * If the pool has migrated to delegation based staking, the staked tokens of pool members
   * can be moved and held in their own account. See [`adapter::DelegateStake`]
   **/
  | { name: 'MigrateDelegation'; params: { memberAccount: MultiAddress } }
  /**
   * Migrate pool from [`adapter::StakeStrategyType::Transfer`] to
   * [`adapter::StakeStrategyType::Delegate`].
   *
   * Fails unless [`crate::pallet::Config::StakeAdapter`] is of strategy type:
   * [`adapter::StakeStrategyType::Delegate`].
   *
   * This call can be dispatched permissionlessly, and refunds any fee if successful.
   *
   * If the pool has already migrated to delegation based staking, this call will fail.
   **/
  | { name: 'MigratePoolToDelegateStake'; params: { poolId: number } };

export type PalletNominationPoolsCallLike =
  /**
   * Stake funds with a pool. The amount to bond is transferred from the member to the pool
   * account and immediately increases the pools bond.
   *
   * The method of transferring the amount to the pool account is determined by
   * [`adapter::StakeStrategyType`]. If the pool is configured to use
   * [`adapter::StakeStrategyType::Delegate`], the funds remain in the account of
   * the `origin`, while the pool gains the right to use these funds for staking.
   *
   * # Note
   *
   * * An account can only be a member of a single pool.
   * * An account cannot join the same pool multiple times.
   * * This call will *not* dust the member account, so the member must have at least
   * `existential deposit + amount` in their account.
   * * Only a pool with [`PoolState::Open`] can be joined
   **/
  | { name: 'Join'; params: { amount: bigint; poolId: number } }
  /**
   * Bond `extra` more funds from `origin` into the pool to which they already belong.
   *
   * Additional funds can come from either the free balance of the account, of from the
   * accumulated rewards, see [`BondExtra`].
   *
   * Bonding extra funds implies an automatic payout of all pending rewards as well.
   * See `bond_extra_other` to bond pending rewards of `other` members.
   **/
  | { name: 'BondExtra'; params: { extra: PalletNominationPoolsBondExtra } }
  /**
   * A bonded member can use this to claim their payout based on the rewards that the pool
   * has accumulated since their last claimed payout (OR since joining if this is their first
   * time claiming rewards). The payout will be transferred to the member's account.
   *
   * The member will earn rewards pro rata based on the members stake vs the sum of the
   * members in the pools stake. Rewards do not "expire".
   *
   * See `claim_payout_other` to claim rewards on behalf of some `other` pool member.
   **/
  | { name: 'ClaimPayout' }
  /**
   * Unbond up to `unbonding_points` of the `member_account`'s funds from the pool. It
   * implicitly collects the rewards one last time, since not doing so would mean some
   * rewards would be forfeited.
   *
   * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
   * account).
   *
   * # Conditions for a permissionless dispatch.
   *
   * * The pool is blocked and the caller is either the root or bouncer. This is refereed to
   * as a kick.
   * * The pool is destroying and the member is not the depositor.
   * * The pool is destroying, the member is the depositor and no other members are in the
   * pool.
   *
   * ## Conditions for permissioned dispatch (i.e. the caller is also the
   * `member_account`):
   *
   * * The caller is not the depositor.
   * * The caller is the depositor, the pool is destroying and no other members are in the
   * pool.
   *
   * # Note
   *
   * If there are too many unlocking chunks to unbond with the pool account,
   * [`Call::pool_withdraw_unbonded`] can be called to try and minimize unlocking chunks.
   * The [`StakingInterface::unbond`] will implicitly call [`Call::pool_withdraw_unbonded`]
   * to try to free chunks if necessary (ie. if unbound was called and no unlocking chunks
   * are available). However, it may not be possible to release the current unlocking chunks,
   * in which case, the result of this call will likely be the `NoMoreChunks` error from the
   * staking system.
   **/
  | { name: 'Unbond'; params: { memberAccount: MultiAddressLike; unbondingPoints: bigint } }
  /**
   * Call `withdraw_unbonded` for the pools account. This call can be made by any account.
   *
   * This is useful if there are too many unlocking chunks to call `unbond`, and some
   * can be cleared by withdrawing. In the case there are too many unlocking chunks, the user
   * would probably see an error like `NoMoreChunks` emitted from the staking system when
   * they attempt to unbond.
   **/
  | { name: 'PoolWithdrawUnbonded'; params: { poolId: number; numSlashingSpans: number } }
  /**
   * Withdraw unbonded funds from `member_account`. If no bonded funds can be unbonded, an
   * error is returned.
   *
   * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
   * account).
   *
   * # Conditions for a permissionless dispatch
   *
   * * The pool is in destroy mode and the target is not the depositor.
   * * The target is the depositor and they are the only member in the sub pools.
   * * The pool is blocked and the caller is either the root or bouncer.
   *
   * # Conditions for permissioned dispatch
   *
   * * The caller is the target and they are not the depositor.
   *
   * # Note
   *
   * - If the target is the depositor, the pool will be destroyed.
   * - If the pool has any pending slash, we also try to slash the member before letting them
   * withdraw. This calculation adds some weight overhead and is only defensive. In reality,
   * pool slashes must have been already applied via permissionless [`Call::apply_slash`].
   **/
  | { name: 'WithdrawUnbonded'; params: { memberAccount: MultiAddressLike; numSlashingSpans: number } }
  /**
   * Create a new delegation pool.
   *
   * # Arguments
   *
   * * `amount` - The amount of funds to delegate to the pool. This also acts of a sort of
   * deposit since the pools creator cannot fully unbond funds until the pool is being
   * destroyed.
   * * `index` - A disambiguation index for creating the account. Likely only useful when
   * creating multiple pools in the same extrinsic.
   * * `root` - The account to set as [`PoolRoles::root`].
   * * `nominator` - The account to set as the [`PoolRoles::nominator`].
   * * `bouncer` - The account to set as the [`PoolRoles::bouncer`].
   *
   * # Note
   *
   * In addition to `amount`, the caller will transfer the existential deposit; so the caller
   * needs at have at least `amount + existential_deposit` transferable.
   **/
  | {
      name: 'Create';
      params: { amount: bigint; root: MultiAddressLike; nominator: MultiAddressLike; bouncer: MultiAddressLike };
    }
  /**
   * Create a new delegation pool with a previously used pool id
   *
   * # Arguments
   *
   * same as `create` with the inclusion of
   * * `pool_id` - `A valid PoolId.
   **/
  | {
      name: 'CreateWithPoolId';
      params: {
        amount: bigint;
        root: MultiAddressLike;
        nominator: MultiAddressLike;
        bouncer: MultiAddressLike;
        poolId: number;
      };
    }
  /**
   * Nominate on behalf of the pool.
   *
   * The dispatch origin of this call must be signed by the pool nominator or the pool
   * root role.
   *
   * This directly forward the call to the staking pallet, on behalf of the pool bonded
   * account.
   *
   * # Note
   *
   * In addition to a `root` or `nominator` role of `origin`, pool's depositor needs to have
   * at least `depositor_min_bond` in the pool to start nominating.
   **/
  | { name: 'Nominate'; params: { poolId: number; validators: Array<AccountId32Like> } }
  /**
   * Set a new state for the pool.
   *
   * If a pool is already in the `Destroying` state, then under no condition can its state
   * change again.
   *
   * The dispatch origin of this call must be either:
   *
   * 1. signed by the bouncer, or the root role of the pool,
   * 2. if the pool conditions to be open are NOT met (as described by `ok_to_be_open`), and
   * then the state of the pool can be permissionlessly changed to `Destroying`.
   **/
  | { name: 'SetState'; params: { poolId: number; state: PalletNominationPoolsPoolState } }
  /**
   * Set a new metadata for the pool.
   *
   * The dispatch origin of this call must be signed by the bouncer, or the root role of the
   * pool.
   **/
  | { name: 'SetMetadata'; params: { poolId: number; metadata: BytesLike } }
  /**
   * Update configurations for the nomination pools. The origin for this call must be
   * [`Config::AdminOrigin`].
   *
   * # Arguments
   *
   * * `min_join_bond` - Set [`MinJoinBond`].
   * * `min_create_bond` - Set [`MinCreateBond`].
   * * `max_pools` - Set [`MaxPools`].
   * * `max_members` - Set [`MaxPoolMembers`].
   * * `max_members_per_pool` - Set [`MaxPoolMembersPerPool`].
   * * `global_max_commission` - Set [`GlobalMaxCommission`].
   **/
  | {
      name: 'SetConfigs';
      params: {
        minJoinBond: PalletNominationPoolsConfigOp;
        minCreateBond: PalletNominationPoolsConfigOp;
        maxPools: PalletNominationPoolsConfigOpU32;
        maxMembers: PalletNominationPoolsConfigOpU32;
        maxMembersPerPool: PalletNominationPoolsConfigOpU32;
        globalMaxCommission: PalletNominationPoolsConfigOpPerbill;
      };
    }
  /**
   * Update the roles of the pool.
   *
   * The root is the only entity that can change any of the roles, including itself,
   * excluding the depositor, who can never change.
   *
   * It emits an event, notifying UIs of the role change. This event is quite relevant to
   * most pool members and they should be informed of changes to pool roles.
   **/
  | {
      name: 'UpdateRoles';
      params: {
        poolId: number;
        newRoot: PalletNominationPoolsConfigOp004;
        newNominator: PalletNominationPoolsConfigOp004;
        newBouncer: PalletNominationPoolsConfigOp004;
      };
    }
  /**
   * Chill on behalf of the pool.
   *
   * The dispatch origin of this call can be signed by the pool nominator or the pool
   * root role, same as [`Pallet::nominate`].
   *
   * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
   * account).
   *
   * # Conditions for a permissionless dispatch:
   * * When pool depositor has less than `MinNominatorBond` staked, otherwise pool members
   * are unable to unbond.
   *
   * # Conditions for permissioned dispatch:
   * * The caller has a nominator or root role of the pool.
   * This directly forward the call to the staking pallet, on behalf of the pool bonded
   * account.
   **/
  | { name: 'Chill'; params: { poolId: number } }
  /**
   * `origin` bonds funds from `extra` for some pool member `member` into their respective
   * pools.
   *
   * `origin` can bond extra funds from free balance or pending rewards when `origin ==
   * other`.
   *
   * In the case of `origin != other`, `origin` can only bond extra pending rewards of
   * `other` members assuming set_claim_permission for the given member is
   * `PermissionlessCompound` or `PermissionlessAll`.
   **/
  | { name: 'BondExtraOther'; params: { member: MultiAddressLike; extra: PalletNominationPoolsBondExtra } }
  /**
   * Allows a pool member to set a claim permission to allow or disallow permissionless
   * bonding and withdrawing.
   *
   * # Arguments
   *
   * * `origin` - Member of a pool.
   * * `permission` - The permission to be applied.
   **/
  | { name: 'SetClaimPermission'; params: { permission: PalletNominationPoolsClaimPermission } }
  /**
   * `origin` can claim payouts on some pool member `other`'s behalf.
   *
   * Pool member `other` must have a `PermissionlessWithdraw` or `PermissionlessAll` claim
   * permission for this call to be successful.
   **/
  | { name: 'ClaimPayoutOther'; params: { other: AccountId32Like } }
  /**
   * Set the commission of a pool.
   * Both a commission percentage and a commission payee must be provided in the `current`
   * tuple. Where a `current` of `None` is provided, any current commission will be removed.
   *
   * - If a `None` is supplied to `new_commission`, existing commission will be removed.
   **/
  | { name: 'SetCommission'; params: { poolId: number; newCommission?: [Perbill, AccountId32Like] | undefined } }
  /**
   * Set the maximum commission of a pool.
   *
   * - Initial max can be set to any `Perbill`, and only smaller values thereafter.
   * - Current commission will be lowered in the event it is higher than a new max
   * commission.
   **/
  | { name: 'SetCommissionMax'; params: { poolId: number; maxCommission: Perbill } }
  /**
   * Set the commission change rate for a pool.
   *
   * Initial change rate is not bounded, whereas subsequent updates can only be more
   * restrictive than the current.
   **/
  | {
      name: 'SetCommissionChangeRate';
      params: { poolId: number; changeRate: PalletNominationPoolsCommissionChangeRate };
    }
  /**
   * Claim pending commission.
   *
   * The dispatch origin of this call must be signed by the `root` role of the pool. Pending
   * commission is paid out and added to total claimed commission`. Total pending commission
   * is reset to zero. the current.
   **/
  | { name: 'ClaimCommission'; params: { poolId: number } }
  /**
   * Top up the deficit or withdraw the excess ED from the pool.
   *
   * When a pool is created, the pool depositor transfers ED to the reward account of the
   * pool. ED is subject to change and over time, the deposit in the reward account may be
   * insufficient to cover the ED deficit of the pool or vice-versa where there is excess
   * deposit to the pool. This call allows anyone to adjust the ED deposit of the
   * pool by either topping up the deficit or claiming the excess.
   **/
  | { name: 'AdjustPoolDeposit'; params: { poolId: number } }
  /**
   * Set or remove a pool's commission claim permission.
   *
   * Determines who can claim the pool's pending commission. Only the `Root` role of the pool
   * is able to configure commission claim permissions.
   **/
  | {
      name: 'SetCommissionClaimPermission';
      params: { poolId: number; permission?: PalletNominationPoolsCommissionClaimPermission | undefined };
    }
  /**
   * Apply a pending slash on a member.
   *
   * Fails unless [`crate::pallet::Config::StakeAdapter`] is of strategy type:
   * [`adapter::StakeStrategyType::Delegate`].
   *
   * This call can be dispatched permissionlessly (i.e. by any account). If the member has
   * slash to be applied, caller may be rewarded with the part of the slash.
   **/
  | { name: 'ApplySlash'; params: { memberAccount: MultiAddressLike } }
  /**
   * Migrates delegated funds from the pool account to the `member_account`.
   *
   * Fails unless [`crate::pallet::Config::StakeAdapter`] is of strategy type:
   * [`adapter::StakeStrategyType::Delegate`].
   *
   * This is a permission-less call and refunds any fee if claim is successful.
   *
   * If the pool has migrated to delegation based staking, the staked tokens of pool members
   * can be moved and held in their own account. See [`adapter::DelegateStake`]
   **/
  | { name: 'MigrateDelegation'; params: { memberAccount: MultiAddressLike } }
  /**
   * Migrate pool from [`adapter::StakeStrategyType::Transfer`] to
   * [`adapter::StakeStrategyType::Delegate`].
   *
   * Fails unless [`crate::pallet::Config::StakeAdapter`] is of strategy type:
   * [`adapter::StakeStrategyType::Delegate`].
   *
   * This call can be dispatched permissionlessly, and refunds any fee if successful.
   *
   * If the pool has already migrated to delegation based staking, this call will fail.
   **/
  | { name: 'MigratePoolToDelegateStake'; params: { poolId: number } };

export type PalletNominationPoolsBondExtra = { type: 'FreeBalance'; value: bigint } | { type: 'Rewards' };

export type PalletNominationPoolsPoolState = 'Open' | 'Blocked' | 'Destroying';

export type PalletNominationPoolsConfigOp = { type: 'Noop' } | { type: 'Set'; value: bigint } | { type: 'Remove' };

export type PalletNominationPoolsConfigOpU32 = { type: 'Noop' } | { type: 'Set'; value: number } | { type: 'Remove' };

export type PalletNominationPoolsConfigOpPerbill =
  | { type: 'Noop' }
  | { type: 'Set'; value: Perbill }
  | { type: 'Remove' };

export type PalletNominationPoolsConfigOp004 =
  | { type: 'Noop' }
  | { type: 'Set'; value: AccountId32 }
  | { type: 'Remove' };

export type PalletNominationPoolsClaimPermission =
  | 'Permissioned'
  | 'PermissionlessCompound'
  | 'PermissionlessWithdraw'
  | 'PermissionlessAll';

export type PalletNominationPoolsCommissionChangeRate = { maxIncrease: Perbill; minDelay: number };

export type PalletNominationPoolsCommissionClaimPermission =
  | { type: 'Permissionless' }
  | { type: 'Account'; value: AccountId32 };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletGearCall =
  /**
   * Saves program `code` in storage.
   *
   * The extrinsic was created to provide _deploy program from program_ functionality.
   * Anyone who wants to define a "factory" logic in program should first store the code and metadata for the "child"
   * program in storage. So the code for the child will be initialized by program initialization request only if it exists in storage.
   *
   * More precisely, the code and its metadata are actually saved in the storage under the hash of the `code`. The code hash is computed
   * as Blake256 hash. At the time of the call the `code` hash should not be in the storage. If it was stored previously, call will end up
   * with an `CodeAlreadyExists` error. In this case user can be sure, that he can actually use the hash of his program's code bytes to define
   * "program factory" logic in his program.
   *
   * Parameters
   * - `code`: wasm code of a program as a byte vector.
   *
   * Emits the following events:
   * - `SavedCode(H256)` - when the code is saved in storage.
   **/
  | { name: 'UploadCode'; params: { code: Bytes } }
  /**
   * Creates program initialization request (message), that is scheduled to be run in the same block.
   *
   * There are no guarantees that initialization message will be run in the same block due to block
   * gas limit restrictions. For example, when it will be the message's turn, required gas limit for it
   * could be more than remaining block gas limit. Therefore, the message processing will be postponed
   * until the next block.
   *
   * `ProgramId` is computed as Blake256 hash of concatenated bytes of `code` + `salt`. (todo #512 `code_hash` + `salt`)
   * Such `ProgramId` must not exist in the Program Storage at the time of this call.
   *
   * There is the same guarantee here as in `upload_code`. That is, future program's
   * `code` and metadata are stored before message was added to the queue and processed.
   *
   * The origin must be Signed and the sender must have sufficient funds to pay
   * for `gas` and `value` (in case the latter is being transferred).
   *
   * Gear runtime guarantees that an active program always has an account to store value.
   * If the underlying account management platform (e.g. Substrate's System pallet) requires
   * an existential deposit to keep an account alive, the related overhead is considered an
   * extra cost related with a program instantiation and is charged to the program's creator
   * and is released back to the creator when the program is removed.
   * In context of the above, the `value` parameter represents the so-called `reducible` balance
   * a program should have at its disposal upon instantiation. It is not used to offset the
   * existential deposit required for an account creation.
   *
   * Parameters:
   * - `code`: wasm code of a program as a byte vector.
   * - `salt`: randomness term (a seed) to allow programs with identical code
   * to be created independently.
   * - `init_payload`: encoded parameters of the wasm module `init` function.
   * - `gas_limit`: maximum amount of gas the program can spend before it is halted.
   * - `value`: balance to be transferred to the program once it's been created.
   *
   * Emits the following events:
   * - `InitMessageEnqueued(MessageInfo)` when init message is placed in the queue.
   *
   * # Note
   * Faulty (uninitialized) programs still have a valid addresses (program ids) that can deterministically be derived on the
   * caller's side upfront. It means that if messages are sent to such an address, they might still linger in the queue.
   *
   * In order to mitigate the risk of users' funds being sent to an address,
   * where a valid program should have resided, while it's not,
   * such "failed-to-initialize" programs are not silently deleted from the
   * program storage but rather marked as "ghost" programs.
   * Ghost program can be removed by their original author via an explicit call.
   * The funds stored by a ghost program will be release to the author once the program
   * has been removed.
   **/
  | {
      name: 'UploadProgram';
      params: { code: Bytes; salt: Bytes; initPayload: Bytes; gasLimit: bigint; value: bigint; keepAlive: boolean };
    }
  /**
   * Creates program via `code_id` from storage.
   *
   * Parameters:
   * - `code_id`: wasm code id in the code storage.
   * - `salt`: randomness term (a seed) to allow programs with identical code
   * to be created independently.
   * - `init_payload`: encoded parameters of the wasm module `init` function.
   * - `gas_limit`: maximum amount of gas the program can spend before it is halted.
   * - `value`: balance to be transferred to the program once it's been created.
   *
   * Emits the following events:
   * - `InitMessageEnqueued(MessageInfo)` when init message is placed in the queue.
   *
   * # NOTE
   *
   * For the details of this extrinsic, see `upload_code`.
   **/
  | {
      name: 'CreateProgram';
      params: {
        codeId: GprimitivesCodeId;
        salt: Bytes;
        initPayload: Bytes;
        gasLimit: bigint;
        value: bigint;
        keepAlive: boolean;
      };
    }
  /**
   * Sends a message to a program or to another account.
   *
   * The origin must be Signed and the sender must have sufficient funds to pay
   * for `gas` and `value` (in case the latter is being transferred).
   *
   * To avoid an undefined behavior a check is made that the destination address
   * is not a program in uninitialized state. If the opposite holds true,
   * the message is not enqueued for processing.
   *
   * Parameters:
   * - `destination`: the message destination.
   * - `payload`: in case of a program destination, parameters of the `handle` function.
   * - `gas_limit`: maximum amount of gas the program can spend before it is halted.
   * - `value`: balance to be transferred to the program once it's been created.
   *
   * Emits the following events:
   * - `DispatchMessageEnqueued(MessageInfo)` when dispatch message is placed in the queue.
   **/
  | {
      name: 'SendMessage';
      params: { destination: GprimitivesActorId; payload: Bytes; gasLimit: bigint; value: bigint; keepAlive: boolean };
    }
  /**
   * Send reply on message in `Mailbox`.
   *
   * Removes message by given `MessageId` from callers `Mailbox`:
   * rent funds become free, associated with the message value
   * transfers from message sender to extrinsic caller.
   *
   * Generates reply on removed message with given parameters
   * and pushes it in `MessageQueue`.
   *
   * NOTE: source of the message in mailbox guaranteed to be a program.
   *
   * NOTE: only user who is destination of the message, can claim value
   * or reply on the message from mailbox.
   **/
  | {
      name: 'SendReply';
      params: { replyToId: GprimitivesMessageId; payload: Bytes; gasLimit: bigint; value: bigint; keepAlive: boolean };
    }
  /**
   * Claim value from message in `Mailbox`.
   *
   * Removes message by given `MessageId` from callers `Mailbox`:
   * rent funds become free, associated with the message value
   * transfers from message sender to extrinsic caller.
   *
   * NOTE: only user who is destination of the message, can claim value
   * or reply on the message from mailbox.
   **/
  | { name: 'ClaimValue'; params: { messageId: GprimitivesMessageId } }
  /**
   * Process message queue
   **/
  | { name: 'Run'; params: { maxGas?: bigint | undefined } }
  /**
   * Sets `ExecuteInherent` flag.
   *
   * Requires root origin (eventually, will only be set via referendum)
   **/
  | { name: 'SetExecuteInherent'; params: { value: boolean } }
  /**
   * Transfers value from chain of terminated or exited programs to its final inheritor.
   *
   * `depth` parameter is how far to traverse to inheritor.
   * A value of 10 is sufficient for most cases.
   *
   * # Example of chain
   *
   * - Program #1 exits (e.g `gr_exit syscall) with argument pointing to user.
   * Balance of program #1 has been sent to user.
   * - Program #2 exits with inheritor pointing to program #1.
   * Balance of program #2 has been sent to exited program #1.
   * - Program #3 exits with inheritor pointing to program #2
   * Balance of program #1 has been sent to exited program #2.
   *
   * So chain of inheritors looks like: Program #3 -> Program #2 -> Program #1 -> User.
   *
   * We have programs #1 and #2 with stuck value on their balances.
   * The balances should've been transferred to user (final inheritor) according to the chain.
   * But protocol doesn't traverse the chain automatically, so user have to call this extrinsic.
   **/
  | { name: 'ClaimValueToInheritor'; params: { programId: GprimitivesActorId; depth: NonZeroU32 } };

export type PalletGearCallLike =
  /**
   * Saves program `code` in storage.
   *
   * The extrinsic was created to provide _deploy program from program_ functionality.
   * Anyone who wants to define a "factory" logic in program should first store the code and metadata for the "child"
   * program in storage. So the code for the child will be initialized by program initialization request only if it exists in storage.
   *
   * More precisely, the code and its metadata are actually saved in the storage under the hash of the `code`. The code hash is computed
   * as Blake256 hash. At the time of the call the `code` hash should not be in the storage. If it was stored previously, call will end up
   * with an `CodeAlreadyExists` error. In this case user can be sure, that he can actually use the hash of his program's code bytes to define
   * "program factory" logic in his program.
   *
   * Parameters
   * - `code`: wasm code of a program as a byte vector.
   *
   * Emits the following events:
   * - `SavedCode(H256)` - when the code is saved in storage.
   **/
  | { name: 'UploadCode'; params: { code: BytesLike } }
  /**
   * Creates program initialization request (message), that is scheduled to be run in the same block.
   *
   * There are no guarantees that initialization message will be run in the same block due to block
   * gas limit restrictions. For example, when it will be the message's turn, required gas limit for it
   * could be more than remaining block gas limit. Therefore, the message processing will be postponed
   * until the next block.
   *
   * `ProgramId` is computed as Blake256 hash of concatenated bytes of `code` + `salt`. (todo #512 `code_hash` + `salt`)
   * Such `ProgramId` must not exist in the Program Storage at the time of this call.
   *
   * There is the same guarantee here as in `upload_code`. That is, future program's
   * `code` and metadata are stored before message was added to the queue and processed.
   *
   * The origin must be Signed and the sender must have sufficient funds to pay
   * for `gas` and `value` (in case the latter is being transferred).
   *
   * Gear runtime guarantees that an active program always has an account to store value.
   * If the underlying account management platform (e.g. Substrate's System pallet) requires
   * an existential deposit to keep an account alive, the related overhead is considered an
   * extra cost related with a program instantiation and is charged to the program's creator
   * and is released back to the creator when the program is removed.
   * In context of the above, the `value` parameter represents the so-called `reducible` balance
   * a program should have at its disposal upon instantiation. It is not used to offset the
   * existential deposit required for an account creation.
   *
   * Parameters:
   * - `code`: wasm code of a program as a byte vector.
   * - `salt`: randomness term (a seed) to allow programs with identical code
   * to be created independently.
   * - `init_payload`: encoded parameters of the wasm module `init` function.
   * - `gas_limit`: maximum amount of gas the program can spend before it is halted.
   * - `value`: balance to be transferred to the program once it's been created.
   *
   * Emits the following events:
   * - `InitMessageEnqueued(MessageInfo)` when init message is placed in the queue.
   *
   * # Note
   * Faulty (uninitialized) programs still have a valid addresses (program ids) that can deterministically be derived on the
   * caller's side upfront. It means that if messages are sent to such an address, they might still linger in the queue.
   *
   * In order to mitigate the risk of users' funds being sent to an address,
   * where a valid program should have resided, while it's not,
   * such "failed-to-initialize" programs are not silently deleted from the
   * program storage but rather marked as "ghost" programs.
   * Ghost program can be removed by their original author via an explicit call.
   * The funds stored by a ghost program will be release to the author once the program
   * has been removed.
   **/
  | {
      name: 'UploadProgram';
      params: {
        code: BytesLike;
        salt: BytesLike;
        initPayload: BytesLike;
        gasLimit: bigint;
        value: bigint;
        keepAlive: boolean;
      };
    }
  /**
   * Creates program via `code_id` from storage.
   *
   * Parameters:
   * - `code_id`: wasm code id in the code storage.
   * - `salt`: randomness term (a seed) to allow programs with identical code
   * to be created independently.
   * - `init_payload`: encoded parameters of the wasm module `init` function.
   * - `gas_limit`: maximum amount of gas the program can spend before it is halted.
   * - `value`: balance to be transferred to the program once it's been created.
   *
   * Emits the following events:
   * - `InitMessageEnqueued(MessageInfo)` when init message is placed in the queue.
   *
   * # NOTE
   *
   * For the details of this extrinsic, see `upload_code`.
   **/
  | {
      name: 'CreateProgram';
      params: {
        codeId: GprimitivesCodeId;
        salt: BytesLike;
        initPayload: BytesLike;
        gasLimit: bigint;
        value: bigint;
        keepAlive: boolean;
      };
    }
  /**
   * Sends a message to a program or to another account.
   *
   * The origin must be Signed and the sender must have sufficient funds to pay
   * for `gas` and `value` (in case the latter is being transferred).
   *
   * To avoid an undefined behavior a check is made that the destination address
   * is not a program in uninitialized state. If the opposite holds true,
   * the message is not enqueued for processing.
   *
   * Parameters:
   * - `destination`: the message destination.
   * - `payload`: in case of a program destination, parameters of the `handle` function.
   * - `gas_limit`: maximum amount of gas the program can spend before it is halted.
   * - `value`: balance to be transferred to the program once it's been created.
   *
   * Emits the following events:
   * - `DispatchMessageEnqueued(MessageInfo)` when dispatch message is placed in the queue.
   **/
  | {
      name: 'SendMessage';
      params: {
        destination: GprimitivesActorId;
        payload: BytesLike;
        gasLimit: bigint;
        value: bigint;
        keepAlive: boolean;
      };
    }
  /**
   * Send reply on message in `Mailbox`.
   *
   * Removes message by given `MessageId` from callers `Mailbox`:
   * rent funds become free, associated with the message value
   * transfers from message sender to extrinsic caller.
   *
   * Generates reply on removed message with given parameters
   * and pushes it in `MessageQueue`.
   *
   * NOTE: source of the message in mailbox guaranteed to be a program.
   *
   * NOTE: only user who is destination of the message, can claim value
   * or reply on the message from mailbox.
   **/
  | {
      name: 'SendReply';
      params: {
        replyToId: GprimitivesMessageId;
        payload: BytesLike;
        gasLimit: bigint;
        value: bigint;
        keepAlive: boolean;
      };
    }
  /**
   * Claim value from message in `Mailbox`.
   *
   * Removes message by given `MessageId` from callers `Mailbox`:
   * rent funds become free, associated with the message value
   * transfers from message sender to extrinsic caller.
   *
   * NOTE: only user who is destination of the message, can claim value
   * or reply on the message from mailbox.
   **/
  | { name: 'ClaimValue'; params: { messageId: GprimitivesMessageId } }
  /**
   * Process message queue
   **/
  | { name: 'Run'; params: { maxGas?: bigint | undefined } }
  /**
   * Sets `ExecuteInherent` flag.
   *
   * Requires root origin (eventually, will only be set via referendum)
   **/
  | { name: 'SetExecuteInherent'; params: { value: boolean } }
  /**
   * Transfers value from chain of terminated or exited programs to its final inheritor.
   *
   * `depth` parameter is how far to traverse to inheritor.
   * A value of 10 is sufficient for most cases.
   *
   * # Example of chain
   *
   * - Program #1 exits (e.g `gr_exit syscall) with argument pointing to user.
   * Balance of program #1 has been sent to user.
   * - Program #2 exits with inheritor pointing to program #1.
   * Balance of program #2 has been sent to exited program #1.
   * - Program #3 exits with inheritor pointing to program #2
   * Balance of program #1 has been sent to exited program #2.
   *
   * So chain of inheritors looks like: Program #3 -> Program #2 -> Program #1 -> User.
   *
   * We have programs #1 and #2 with stuck value on their balances.
   * The balances should've been transferred to user (final inheritor) according to the chain.
   * But protocol doesn't traverse the chain automatically, so user have to call this extrinsic.
   **/
  | { name: 'ClaimValueToInheritor'; params: { programId: GprimitivesActorId; depth: NonZeroU32 } };

export type GprimitivesCodeId = FixedBytes<32>;

export type GprimitivesActorId = FixedBytes<32>;

export type GprimitivesMessageId = FixedBytes<32>;

export type NonZeroU32 = number;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletGearStakingRewardsCall =
  | { name: 'Refill'; params: { value: bigint } }
  | { name: 'ForceRefill'; params: { from: MultiAddress; value: bigint } }
  | { name: 'Withdraw'; params: { to: MultiAddress; value: bigint } }
  | { name: 'SetTargetInflation'; params: { p: bigint; n: bigint } }
  | { name: 'SetIdealStakingRatio'; params: { p: bigint; n: bigint } };

export type PalletGearStakingRewardsCallLike =
  | { name: 'Refill'; params: { value: bigint } }
  | { name: 'ForceRefill'; params: { from: MultiAddressLike; value: bigint } }
  | { name: 'Withdraw'; params: { to: MultiAddressLike; value: bigint } }
  | { name: 'SetTargetInflation'; params: { p: bigint; n: bigint } }
  | { name: 'SetIdealStakingRatio'; params: { p: bigint; n: bigint } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletGearVoucherCall =
  /**
   * Issue a new voucher.
   *
   * Deposits event `VoucherIssued`, that contains `VoucherId` to be
   * used by spender for balance-less on-chain interactions.
   *
   * Arguments:
   * * spender: user id that is eligible to use the voucher;
   * * balance: voucher balance could be used for transactions
   * fees and gas;
   * * programs: pool of programs spender can interact with,
   * if None - means any program,
   * limited by Config param;
   * * code_uploading:
   * allow voucher to be used as payer for `upload_code`
   * transactions fee;
   * * duration: amount of blocks voucher could be used by spender
   * and couldn't be revoked by owner.
   * Must be out in [MinDuration; MaxDuration] constants.
   * Expiration block of the voucher calculates as:
   * current bn (extrinsic exec bn) + duration + 1.
   **/
  | {
      name: 'Issue';
      params: {
        spender: AccountId32;
        balance: bigint;
        programs?: Array<GprimitivesActorId> | undefined;
        codeUploading: boolean;
        duration: number;
      };
    }
  /**
   * Execute prepaid call with given voucher id.
   *
   * Arguments:
   * * voucher_id: associated with origin existing vouchers id,
   * that should be used to pay for fees and gas
   * within the call;
   * * call: prepaid call that is requested to execute.
   **/
  | {
      name: 'Call';
      params: { voucherId: PalletGearVoucherInternalVoucherId; call: PalletGearVoucherInternalPrepaidCall };
    }
  /**
   * Revoke existing voucher.
   *
   * This extrinsic revokes existing voucher, if current block is greater
   * than expiration block of the voucher (it is no longer valid).
   *
   * Currently it means sending of all balance from voucher account to
   * voucher owner without voucher removal from storage map, but this
   * behavior may change in future, as well as the origin validation:
   * only owner is able to revoke voucher now.
   *
   * Arguments:
   * * spender: account id of the voucher spender;
   * * voucher_id: voucher id to be revoked.
   **/
  | { name: 'Revoke'; params: { spender: AccountId32; voucherId: PalletGearVoucherInternalVoucherId } }
  /**
   * Update existing voucher.
   *
   * This extrinsic updates existing voucher: it can only extend vouchers
   * rights in terms of balance, validity or programs to interact pool.
   *
   * Can only be called by the voucher owner.
   *
   * Arguments:
   * * spender: account id of the voucher spender;
   * * voucher_id: voucher id to be updated;
   * * move_ownership: optionally moves ownership to another account;
   * * balance_top_up: optionally top ups balance of the voucher from
   * origins balance;
   * * append_programs: optionally extends pool of programs by
   * `Some(programs_set)` passed or allows
   * it to interact with any program by
   * `None` passed;
   * * code_uploading: optionally allows voucher to be used to pay
   * fees for `upload_code` extrinsics;
   * * prolong_duration: optionally increases expiry block number.
   * If voucher is expired, prolongs since current bn.
   * Validity prolongation (since current block number
   * for expired or since storage written expiry)
   * should be in [MinDuration; MaxDuration], in other
   * words voucher couldn't have expiry greater than
   * current block number + MaxDuration.
   **/
  | {
      name: 'Update';
      params: {
        spender: AccountId32;
        voucherId: PalletGearVoucherInternalVoucherId;
        moveOwnership?: AccountId32 | undefined;
        balanceTopUp?: bigint | undefined;
        appendPrograms?: Array<GprimitivesActorId> | undefined | undefined;
        codeUploading?: boolean | undefined;
        prolongDuration?: number | undefined;
      };
    }
  /**
   * Decline existing and not expired voucher.
   *
   * This extrinsic expires voucher of the caller, if it's still active,
   * allowing it to be revoked.
   *
   * Arguments:
   * * voucher_id: voucher id to be declined.
   **/
  | { name: 'Decline'; params: { voucherId: PalletGearVoucherInternalVoucherId } };

export type PalletGearVoucherCallLike =
  /**
   * Issue a new voucher.
   *
   * Deposits event `VoucherIssued`, that contains `VoucherId` to be
   * used by spender for balance-less on-chain interactions.
   *
   * Arguments:
   * * spender: user id that is eligible to use the voucher;
   * * balance: voucher balance could be used for transactions
   * fees and gas;
   * * programs: pool of programs spender can interact with,
   * if None - means any program,
   * limited by Config param;
   * * code_uploading:
   * allow voucher to be used as payer for `upload_code`
   * transactions fee;
   * * duration: amount of blocks voucher could be used by spender
   * and couldn't be revoked by owner.
   * Must be out in [MinDuration; MaxDuration] constants.
   * Expiration block of the voucher calculates as:
   * current bn (extrinsic exec bn) + duration + 1.
   **/
  | {
      name: 'Issue';
      params: {
        spender: AccountId32Like;
        balance: bigint;
        programs?: Array<GprimitivesActorId> | undefined;
        codeUploading: boolean;
        duration: number;
      };
    }
  /**
   * Execute prepaid call with given voucher id.
   *
   * Arguments:
   * * voucher_id: associated with origin existing vouchers id,
   * that should be used to pay for fees and gas
   * within the call;
   * * call: prepaid call that is requested to execute.
   **/
  | {
      name: 'Call';
      params: { voucherId: PalletGearVoucherInternalVoucherId; call: PalletGearVoucherInternalPrepaidCall };
    }
  /**
   * Revoke existing voucher.
   *
   * This extrinsic revokes existing voucher, if current block is greater
   * than expiration block of the voucher (it is no longer valid).
   *
   * Currently it means sending of all balance from voucher account to
   * voucher owner without voucher removal from storage map, but this
   * behavior may change in future, as well as the origin validation:
   * only owner is able to revoke voucher now.
   *
   * Arguments:
   * * spender: account id of the voucher spender;
   * * voucher_id: voucher id to be revoked.
   **/
  | { name: 'Revoke'; params: { spender: AccountId32Like; voucherId: PalletGearVoucherInternalVoucherId } }
  /**
   * Update existing voucher.
   *
   * This extrinsic updates existing voucher: it can only extend vouchers
   * rights in terms of balance, validity or programs to interact pool.
   *
   * Can only be called by the voucher owner.
   *
   * Arguments:
   * * spender: account id of the voucher spender;
   * * voucher_id: voucher id to be updated;
   * * move_ownership: optionally moves ownership to another account;
   * * balance_top_up: optionally top ups balance of the voucher from
   * origins balance;
   * * append_programs: optionally extends pool of programs by
   * `Some(programs_set)` passed or allows
   * it to interact with any program by
   * `None` passed;
   * * code_uploading: optionally allows voucher to be used to pay
   * fees for `upload_code` extrinsics;
   * * prolong_duration: optionally increases expiry block number.
   * If voucher is expired, prolongs since current bn.
   * Validity prolongation (since current block number
   * for expired or since storage written expiry)
   * should be in [MinDuration; MaxDuration], in other
   * words voucher couldn't have expiry greater than
   * current block number + MaxDuration.
   **/
  | {
      name: 'Update';
      params: {
        spender: AccountId32Like;
        voucherId: PalletGearVoucherInternalVoucherId;
        moveOwnership?: AccountId32Like | undefined;
        balanceTopUp?: bigint | undefined;
        appendPrograms?: Array<GprimitivesActorId> | undefined | undefined;
        codeUploading?: boolean | undefined;
        prolongDuration?: number | undefined;
      };
    }
  /**
   * Decline existing and not expired voucher.
   *
   * This extrinsic expires voucher of the caller, if it's still active,
   * allowing it to be revoked.
   *
   * Arguments:
   * * voucher_id: voucher id to be declined.
   **/
  | { name: 'Decline'; params: { voucherId: PalletGearVoucherInternalVoucherId } };

export type PalletGearVoucherInternalVoucherId = FixedBytes<32>;

export type PalletGearVoucherInternalPrepaidCall =
  | {
      type: 'SendMessage';
      value: { destination: GprimitivesActorId; payload: Bytes; gasLimit: bigint; value: bigint; keepAlive: boolean };
    }
  | {
      type: 'SendReply';
      value: { replyToId: GprimitivesMessageId; payload: Bytes; gasLimit: bigint; value: bigint; keepAlive: boolean };
    }
  | { type: 'UploadCode'; value: { code: Bytes } }
  | { type: 'DeclineVoucher' };

export type SpRuntimeBlakeTwo256 = {};

export type PalletConvictionVotingTally = { ayes: bigint; nays: bigint; support: bigint };

/**
 * The `Event` enum of this pallet
 **/
export type PalletRankedCollectiveEvent =
  /**
   * A member `who` has been added.
   **/
  | { name: 'MemberAdded'; data: { who: AccountId32 } }
  /**
   * The member `who`se rank has been changed to the given `rank`.
   **/
  | { name: 'RankChanged'; data: { who: AccountId32; rank: number } }
  /**
   * The member `who` of given `rank` has been removed from the collective.
   **/
  | { name: 'MemberRemoved'; data: { who: AccountId32; rank: number } }
  /**
   * The member `who` has voted for the `poll` with the given `vote` leading to an updated
   * `tally`.
   **/
  | {
      name: 'Voted';
      data: {
        who: AccountId32;
        poll: number;
        vote: PalletRankedCollectiveVoteRecord;
        tally: PalletRankedCollectiveTally;
      };
    }
  /**
   * The member `who` had their `AccountId` changed to `new_who`.
   **/
  | { name: 'MemberExchanged'; data: { who: AccountId32; newWho: AccountId32 } };

export type PalletRankedCollectiveVoteRecord = { type: 'Aye'; value: number } | { type: 'Nay'; value: number };

export type PalletRankedCollectiveTally = { bareAyes: number; ayes: number; nays: number };

/**
 * The `Event` enum of this pallet
 **/
export type PalletReferendaEvent002 =
  /**
   * A referendum has been submitted.
   **/
  | {
      name: 'Submitted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The track (and by extension proposal dispatch origin) of this referendum.
         **/
        track: number;

        /**
         * The proposal for the referendum.
         **/
        proposal: FrameSupportPreimagesBounded;
      };
    }
  /**
   * The decision deposit has been placed.
   **/
  | {
      name: 'DecisionDepositPlaced';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * The decision deposit has been refunded.
   **/
  | {
      name: 'DecisionDepositRefunded';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * A deposit has been slashed.
   **/
  | {
      name: 'DepositSlashed';
      data: {
        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * A referendum has moved into the deciding phase.
   **/
  | {
      name: 'DecisionStarted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The track (and by extension proposal dispatch origin) of this referendum.
         **/
        track: number;

        /**
         * The proposal for the referendum.
         **/
        proposal: FrameSupportPreimagesBounded;

        /**
         * The current tally of votes in this referendum.
         **/
        tally: PalletRankedCollectiveTally;
      };
    }
  | {
      name: 'ConfirmStarted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  | {
      name: 'ConfirmAborted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  /**
   * A referendum has ended its confirmation phase and is ready for approval.
   **/
  | {
      name: 'Confirmed';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletRankedCollectiveTally;
      };
    }
  /**
   * A referendum has been approved and its proposal has been scheduled.
   **/
  | {
      name: 'Approved';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  /**
   * A proposal has been rejected by referendum.
   **/
  | {
      name: 'Rejected';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletRankedCollectiveTally;
      };
    }
  /**
   * A referendum has been timed out without being decided.
   **/
  | {
      name: 'TimedOut';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletRankedCollectiveTally;
      };
    }
  /**
   * A referendum has been cancelled.
   **/
  | {
      name: 'Cancelled';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletRankedCollectiveTally;
      };
    }
  /**
   * A referendum has been killed.
   **/
  | {
      name: 'Killed';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletRankedCollectiveTally;
      };
    }
  /**
   * The submission deposit has been refunded.
   **/
  | {
      name: 'SubmissionDepositRefunded';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * Metadata for a referendum has been set.
   **/
  | {
      name: 'MetadataSet';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    }
  /**
   * Metadata for a referendum has been cleared.
   **/
  | {
      name: 'MetadataCleared';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletWhitelistEvent =
  | { name: 'CallWhitelisted'; data: { callHash: H256 } }
  | { name: 'WhitelistedCallRemoved'; data: { callHash: H256 } }
  | {
      name: 'WhitelistedCallDispatched';
      data: {
        callHash: H256;
        result: Result<FrameSupportDispatchPostDispatchInfo, SpRuntimeDispatchErrorWithPostInfo>;
      };
    };

export type FrameSupportDispatchPostDispatchInfo = {
  actualWeight?: SpWeightsWeightV2Weight | undefined;
  paysFee: FrameSupportDispatchPays;
};

export type SpRuntimeDispatchErrorWithPostInfo = {
  postInfo: FrameSupportDispatchPostDispatchInfo;
  error: DispatchError;
};

/**
 * Events type.
 **/
export type PalletSchedulerEvent =
  /**
   * Scheduled some task.
   **/
  | { name: 'Scheduled'; data: { when: number; index: number } }
  /**
   * Canceled some task.
   **/
  | { name: 'Canceled'; data: { when: number; index: number } }
  /**
   * Dispatched some task.
   **/
  | {
      name: 'Dispatched';
      data: { task: [number, number]; id?: FixedBytes<32> | undefined; result: Result<[], DispatchError> };
    }
  /**
   * Set a retry configuration for some task.
   **/
  | {
      name: 'RetrySet';
      data: { task: [number, number]; id?: FixedBytes<32> | undefined; period: number; retries: number };
    }
  /**
   * Cancel a retry configuration for some task.
   **/
  | { name: 'RetryCancelled'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } }
  /**
   * The call for the provided hash was not found so the task has been aborted.
   **/
  | { name: 'CallUnavailable'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } }
  /**
   * The given task was unable to be renewed since the agenda is full at that block.
   **/
  | { name: 'PeriodicFailed'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } }
  /**
   * The given task was unable to be retried since the agenda is full at that block or there
   * was not enough weight to reschedule it.
   **/
  | { name: 'RetryFailed'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } }
  /**
   * The given task can never be executed since it is overweight.
   **/
  | { name: 'PermanentlyOverweight'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletPreimageEvent =
  /**
   * A preimage has been noted.
   **/
  | { name: 'Noted'; data: { hash: H256 } }
  /**
   * A preimage has been requested.
   **/
  | { name: 'Requested'; data: { hash: H256 } }
  /**
   * A preimage has ben cleared.
   **/
  | { name: 'Cleared'; data: { hash: H256 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletIdentityEvent =
  /**
   * A name was set or reset (which will remove all judgements).
   **/
  | { name: 'IdentitySet'; data: { who: AccountId32 } }
  /**
   * A name was cleared, and the given balance returned.
   **/
  | { name: 'IdentityCleared'; data: { who: AccountId32; deposit: bigint } }
  /**
   * A name was removed and the given balance slashed.
   **/
  | { name: 'IdentityKilled'; data: { who: AccountId32; deposit: bigint } }
  /**
   * A judgement was asked from a registrar.
   **/
  | { name: 'JudgementRequested'; data: { who: AccountId32; registrarIndex: number } }
  /**
   * A judgement request was retracted.
   **/
  | { name: 'JudgementUnrequested'; data: { who: AccountId32; registrarIndex: number } }
  /**
   * A judgement was given by a registrar.
   **/
  | { name: 'JudgementGiven'; data: { target: AccountId32; registrarIndex: number } }
  /**
   * A registrar was added.
   **/
  | { name: 'RegistrarAdded'; data: { registrarIndex: number } }
  /**
   * A sub-identity was added to an identity and the deposit paid.
   **/
  | { name: 'SubIdentityAdded'; data: { sub: AccountId32; main: AccountId32; deposit: bigint } }
  /**
   * A sub-identity was removed from an identity and the deposit freed.
   **/
  | { name: 'SubIdentityRemoved'; data: { sub: AccountId32; main: AccountId32; deposit: bigint } }
  /**
   * A sub-identity was cleared, and the given deposit repatriated from the
   * main identity account to the sub-identity account.
   **/
  | { name: 'SubIdentityRevoked'; data: { sub: AccountId32; main: AccountId32; deposit: bigint } }
  /**
   * A username authority was added.
   **/
  | { name: 'AuthorityAdded'; data: { authority: AccountId32 } }
  /**
   * A username authority was removed.
   **/
  | { name: 'AuthorityRemoved'; data: { authority: AccountId32 } }
  /**
   * A username was set for `who`.
   **/
  | { name: 'UsernameSet'; data: { who: AccountId32; username: Bytes } }
  /**
   * A username was queued, but `who` must accept it prior to `expiration`.
   **/
  | { name: 'UsernameQueued'; data: { who: AccountId32; username: Bytes; expiration: number } }
  /**
   * A queued username passed its expiration without being claimed and was removed.
   **/
  | { name: 'PreapprovalExpired'; data: { whose: AccountId32 } }
  /**
   * A username was set as a primary and can be looked up from `who`.
   **/
  | { name: 'PrimaryUsernameSet'; data: { who: AccountId32; username: Bytes } }
  /**
   * A dangling username (as in, a username corresponding to an account that has removed its
   * identity) has been removed.
   **/
  | { name: 'DanglingUsernameRemoved'; data: { who: AccountId32; username: Bytes } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletProxyEvent =
  /**
   * A proxy was executed correctly, with the given.
   **/
  | { name: 'ProxyExecuted'; data: { result: Result<[], DispatchError> } }
  /**
   * A pure account has been created by new proxy with given
   * disambiguation index and proxy type.
   **/
  | {
      name: 'PureCreated';
      data: { pure: AccountId32; who: AccountId32; proxyType: VaraRuntimeProxyType; disambiguationIndex: number };
    }
  /**
   * An announcement was placed to make a call in the future.
   **/
  | { name: 'Announced'; data: { real: AccountId32; proxy: AccountId32; callHash: H256 } }
  /**
   * A proxy was added.
   **/
  | {
      name: 'ProxyAdded';
      data: { delegator: AccountId32; delegatee: AccountId32; proxyType: VaraRuntimeProxyType; delay: number };
    }
  /**
   * A proxy was removed.
   **/
  | {
      name: 'ProxyRemoved';
      data: { delegator: AccountId32; delegatee: AccountId32; proxyType: VaraRuntimeProxyType; delay: number };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletMultisigEvent =
  /**
   * A new multisig operation has begun.
   **/
  | { name: 'NewMultisig'; data: { approving: AccountId32; multisig: AccountId32; callHash: FixedBytes<32> } }
  /**
   * A multisig operation has been approved by someone.
   **/
  | {
      name: 'MultisigApproval';
      data: {
        approving: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
      };
    }
  /**
   * A multisig operation has been executed.
   **/
  | {
      name: 'MultisigExecuted';
      data: {
        approving: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
        result: Result<[], DispatchError>;
      };
    }
  /**
   * A multisig operation has been cancelled.
   **/
  | {
      name: 'MultisigCancelled';
      data: {
        cancelling: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
      };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletElectionProviderMultiPhaseEvent =
  /**
   * A solution was stored with the given compute.
   *
   * The `origin` indicates the origin of the solution. If `origin` is `Some(AccountId)`,
   * the stored solution was submitted in the signed phase by a miner with the `AccountId`.
   * Otherwise, the solution was stored either during the unsigned phase or by
   * `T::ForceOrigin`. The `bool` is `true` when a previous solution was ejected to make
   * room for this one.
   **/
  | {
      name: 'SolutionStored';
      data: {
        compute: PalletElectionProviderMultiPhaseElectionCompute;
        origin?: AccountId32 | undefined;
        prevEjected: boolean;
      };
    }
  /**
   * The election has been finalized, with the given computation and score.
   **/
  | {
      name: 'ElectionFinalized';
      data: { compute: PalletElectionProviderMultiPhaseElectionCompute; score: SpNposElectionsElectionScore };
    }
  /**
   * An election failed.
   *
   * Not much can be said about which computes failed in the process.
   **/
  | { name: 'ElectionFailed' }
  /**
   * An account has been rewarded for their signed submission being finalized.
   **/
  | { name: 'Rewarded'; data: { account: AccountId32; value: bigint } }
  /**
   * An account has been slashed for submitting an invalid signed submission.
   **/
  | { name: 'Slashed'; data: { account: AccountId32; value: bigint } }
  /**
   * There was a phase transition in a given round.
   **/
  | {
      name: 'PhaseTransitioned';
      data: { from: PalletElectionProviderMultiPhasePhase; to: PalletElectionProviderMultiPhasePhase; round: number };
    };

export type PalletElectionProviderMultiPhaseElectionCompute =
  | 'OnChain'
  | 'Signed'
  | 'Unsigned'
  | 'Fallback'
  | 'Emergency';

export type PalletElectionProviderMultiPhasePhase =
  | { type: 'Off' }
  | { type: 'Signed' }
  | { type: 'Unsigned'; value: [boolean, number] }
  | { type: 'Emergency' };

/**
 * Events type.
 **/
export type PalletOffencesEvent =
  /**
   * There is an offence reported of the given `kind` happened at the `session_index` and
   * (kind-specific) time slot. This event is not deposited for duplicate slashes.
   * \[kind, timeslot\].
   **/
  { name: 'Offence'; data: { kind: FixedBytes<16>; timeslot: Bytes } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletBountiesEvent =
  /**
   * New bounty proposal.
   **/
  | { name: 'BountyProposed'; data: { index: number } }
  /**
   * A bounty proposal was rejected; funds were slashed.
   **/
  | { name: 'BountyRejected'; data: { index: number; bond: bigint } }
  /**
   * A bounty proposal is funded and became active.
   **/
  | { name: 'BountyBecameActive'; data: { index: number } }
  /**
   * A bounty is awarded to a beneficiary.
   **/
  | { name: 'BountyAwarded'; data: { index: number; beneficiary: AccountId32 } }
  /**
   * A bounty is claimed by beneficiary.
   **/
  | { name: 'BountyClaimed'; data: { index: number; payout: bigint; beneficiary: AccountId32 } }
  /**
   * A bounty is cancelled.
   **/
  | { name: 'BountyCanceled'; data: { index: number } }
  /**
   * A bounty expiry is extended.
   **/
  | { name: 'BountyExtended'; data: { index: number } }
  /**
   * A bounty is approved.
   **/
  | { name: 'BountyApproved'; data: { index: number } }
  /**
   * A bounty curator is proposed.
   **/
  | { name: 'CuratorProposed'; data: { bountyId: number; curator: AccountId32 } }
  /**
   * A bounty curator is unassigned.
   **/
  | { name: 'CuratorUnassigned'; data: { bountyId: number } }
  /**
   * A bounty curator is accepted.
   **/
  | { name: 'CuratorAccepted'; data: { bountyId: number; curator: AccountId32 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletChildBountiesEvent =
  /**
   * A child-bounty is added.
   **/
  | { name: 'Added'; data: { index: number; childIndex: number } }
  /**
   * A child-bounty is awarded to a beneficiary.
   **/
  | { name: 'Awarded'; data: { index: number; childIndex: number; beneficiary: AccountId32 } }
  /**
   * A child-bounty is claimed by beneficiary.
   **/
  | { name: 'Claimed'; data: { index: number; childIndex: number; payout: bigint; beneficiary: AccountId32 } }
  /**
   * A child-bounty is cancelled.
   **/
  | { name: 'Canceled'; data: { index: number; childIndex: number } };

/**
 * Events of this pallet.
 **/
export type PalletNominationPoolsEvent =
  /**
   * A pool has been created.
   **/
  | { name: 'Created'; data: { depositor: AccountId32; poolId: number } }
  /**
   * A member has became bonded in a pool.
   **/
  | { name: 'Bonded'; data: { member: AccountId32; poolId: number; bonded: bigint; joined: boolean } }
  /**
   * A payout has been made to a member.
   **/
  | { name: 'PaidOut'; data: { member: AccountId32; poolId: number; payout: bigint } }
  /**
   * A member has unbonded from their pool.
   *
   * - `balance` is the corresponding balance of the number of points that has been
   * requested to be unbonded (the argument of the `unbond` transaction) from the bonded
   * pool.
   * - `points` is the number of points that are issued as a result of `balance` being
   * dissolved into the corresponding unbonding pool.
   * - `era` is the era in which the balance will be unbonded.
   * In the absence of slashing, these values will match. In the presence of slashing, the
   * number of points that are issued in the unbonding pool will be less than the amount
   * requested to be unbonded.
   **/
  | { name: 'Unbonded'; data: { member: AccountId32; poolId: number; balance: bigint; points: bigint; era: number } }
  /**
   * A member has withdrawn from their pool.
   *
   * The given number of `points` have been dissolved in return of `balance`.
   *
   * Similar to `Unbonded` event, in the absence of slashing, the ratio of point to balance
   * will be 1.
   **/
  | { name: 'Withdrawn'; data: { member: AccountId32; poolId: number; balance: bigint; points: bigint } }
  /**
   * A pool has been destroyed.
   **/
  | { name: 'Destroyed'; data: { poolId: number } }
  /**
   * The state of a pool has changed
   **/
  | { name: 'StateChanged'; data: { poolId: number; newState: PalletNominationPoolsPoolState } }
  /**
   * A member has been removed from a pool.
   *
   * The removal can be voluntary (withdrawn all unbonded funds) or involuntary (kicked).
   * Any funds that are still delegated (i.e. dangling delegation) are released and are
   * represented by `released_balance`.
   **/
  | { name: 'MemberRemoved'; data: { poolId: number; member: AccountId32; releasedBalance: bigint } }
  /**
   * The roles of a pool have been updated to the given new roles. Note that the depositor
   * can never change.
   **/
  | {
      name: 'RolesUpdated';
      data: { root?: AccountId32 | undefined; bouncer?: AccountId32 | undefined; nominator?: AccountId32 | undefined };
    }
  /**
   * The active balance of pool `pool_id` has been slashed to `balance`.
   **/
  | { name: 'PoolSlashed'; data: { poolId: number; balance: bigint } }
  /**
   * The unbond pool at `era` of pool `pool_id` has been slashed to `balance`.
   **/
  | { name: 'UnbondingPoolSlashed'; data: { poolId: number; era: number; balance: bigint } }
  /**
   * A pool's commission setting has been changed.
   **/
  | { name: 'PoolCommissionUpdated'; data: { poolId: number; current?: [Perbill, AccountId32] | undefined } }
  /**
   * A pool's maximum commission setting has been changed.
   **/
  | { name: 'PoolMaxCommissionUpdated'; data: { poolId: number; maxCommission: Perbill } }
  /**
   * A pool's commission `change_rate` has been changed.
   **/
  | {
      name: 'PoolCommissionChangeRateUpdated';
      data: { poolId: number; changeRate: PalletNominationPoolsCommissionChangeRate };
    }
  /**
   * Pool commission claim permission has been updated.
   **/
  | {
      name: 'PoolCommissionClaimPermissionUpdated';
      data: { poolId: number; permission?: PalletNominationPoolsCommissionClaimPermission | undefined };
    }
  /**
   * Pool commission has been claimed.
   **/
  | { name: 'PoolCommissionClaimed'; data: { poolId: number; commission: bigint } }
  /**
   * Topped up deficit in frozen ED of the reward pool.
   **/
  | { name: 'MinBalanceDeficitAdjusted'; data: { poolId: number; amount: bigint } }
  /**
   * Claimed excess frozen ED of af the reward pool.
   **/
  | { name: 'MinBalanceExcessAdjusted'; data: { poolId: number; amount: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletGearEvent =
  /**
   * User sends message to program, which was successfully
   * added to the Gear message queue.
   **/
  | {
      name: 'MessageQueued';
      data: {
        /**
         * Generated id of the message.
         **/
        id: GprimitivesMessageId;

        /**
         * Account id of the source of the message.
         **/
        source: AccountId32;

        /**
         * Program id, who is the message's destination.
         **/
        destination: GprimitivesActorId;

        /**
         * Entry point for processing of the message.
         * On the sending stage, the processing function
         * of the program is always known.
         **/
        entry: GearCommonEventMessageEntry;
      };
    }
  /**
   * Somebody sent a message to the user.
   **/
  | {
      name: 'UserMessageSent';
      data: {
        /**
         * Message sent.
         **/
        message: GearCoreMessageUserUserMessage;

        /**
         * Block number of expiration from `Mailbox`.
         *
         * Equals `Some(_)` with block number when message
         * will be removed from `Mailbox` due to some
         * reasons (see #642, #646 and #1010).
         *
         * Equals `None` if message wasn't inserted to
         * `Mailbox` and appears as only `Event`.
         **/
        expiration?: number | undefined;
      };
    }
  /**
   * Message marked as "read" and removes it from `Mailbox`.
   * This event only affects messages that were
   * already inserted in `Mailbox`.
   **/
  | {
      name: 'UserMessageRead';
      data: {
        /**
         * Id of the message read.
         **/
        id: GprimitivesMessageId;

        /**
         * The reason for the reading (removal from `Mailbox`).
         *
         * NOTE: See more docs about reasons at `gear_common::event`.
         **/
        reason: GearCommonEventReason;
      };
    }
  /**
   * The result of processing the messages within the block.
   **/
  | {
      name: 'MessagesDispatched';
      data: {
        /**
         * Total amount of messages removed from message queue.
         **/
        total: number;

        /**
         * Execution statuses of the messages, which were already known
         * by `Event::MessageQueued` (sent from user to program).
         **/
        statuses: Array<[GprimitivesMessageId, GearCommonEventDispatchStatus]>;

        /**
         * Ids of programs, which state changed during queue processing.
         **/
        stateChanges: Array<GprimitivesActorId>;
      };
    }
  /**
   * Messages execution delayed (waited) and successfully
   * added to gear waitlist.
   **/
  | {
      name: 'MessageWaited';
      data: {
        /**
         * Id of the message waited.
         **/
        id: GprimitivesMessageId;

        /**
         * Origin message id, which started messaging chain with programs,
         * where currently waited message was created.
         *
         * Used to identify by the user that this message associated
         * with him and the concrete initial message.
         **/
        origin?: GearCommonGasProviderNodeGasNodeId | undefined;

        /**
         * The reason of the waiting (addition to `Waitlist`).
         *
         * NOTE: See more docs about reasons at `gear_common::event`.
         **/
        reason: GearCommonEventReasonMessageWaitedRuntimeReason;

        /**
         * Block number of expiration from `Waitlist`.
         *
         * Equals block number when message will be removed from `Waitlist`
         * due to some reasons (see #642, #646 and #1010).
         **/
        expiration: number;
      };
    }
  /**
   * Message is ready to continue its execution
   * and was removed from `Waitlist`.
   **/
  | {
      name: 'MessageWoken';
      data: {
        /**
         * Id of the message woken.
         **/
        id: GprimitivesMessageId;

        /**
         * The reason of the waking (removal from `Waitlist`).
         *
         * NOTE: See more docs about reasons at `gear_common::event`.
         **/
        reason: GearCommonEventReasonMessageWokenRuntimeReason;
      };
    }
  /**
   * Any data related to program codes changed.
   **/
  | {
      name: 'CodeChanged';
      data: {
        /**
         * Id of the code affected.
         **/
        id: GprimitivesCodeId;

        /**
         * Change applied on code with current id.
         *
         * NOTE: See more docs about change kinds at `gear_common::event`.
         **/
        change: GearCommonEventCodeChangeKind;
      };
    }
  /**
   * Any data related to programs changed.
   **/
  | {
      name: 'ProgramChanged';
      data: {
        /**
         * Id of the program affected.
         **/
        id: GprimitivesActorId;

        /**
         * Change applied on program with current id.
         *
         * NOTE: See more docs about change kinds at `gear_common::event`.
         **/
        change: GearCommonEventProgramChangeKind;
      };
    }
  /**
   * The pseudo-inherent extrinsic that runs queue processing rolled back or not executed.
   **/
  | { name: 'QueueNotProcessed' };

export type GearCommonEventMessageEntry =
  | { type: 'Init' }
  | { type: 'Handle' }
  | { type: 'Reply'; value: GprimitivesMessageId }
  | { type: 'Signal' };

export type GearCoreMessageUserUserMessage = {
  id: GprimitivesMessageId;
  source: GprimitivesActorId;
  destination: GprimitivesActorId;
  payload: GearCoreBufferLimitedVec;
  value: bigint;
  details?: GearCoreMessageCommonReplyDetails | undefined;
};

export type GearCoreBufferLimitedVec = Bytes;

export type GearCoreMessagePayloadSizeError = {};

export type GearCoreMessageCommonReplyDetails = { to: GprimitivesMessageId; code: GearCoreErrorsSimpleReplyCode };

export type GearCoreErrorsSimpleReplyCode =
  | { type: 'Success'; value: GearCoreErrorsSimpleSuccessReplyReason }
  | { type: 'Error'; value: GearCoreErrorsSimpleErrorReplyReason }
  | { type: 'Unsupported' };

export type GearCoreErrorsSimpleSuccessReplyReason = 'Auto' | 'Manual' | 'Unsupported';

export type GearCoreErrorsSimpleErrorReplyReason =
  | { type: 'Execution'; value: GearCoreErrorsSimpleSimpleExecutionError }
  | { type: 'UnavailableActor'; value: GearCoreErrorsSimpleSimpleUnavailableActorError }
  | { type: 'RemovedFromWaitlist' }
  | { type: 'Unsupported' };

export type GearCoreErrorsSimpleSimpleExecutionError =
  | 'RanOutOfGas'
  | 'MemoryOverflow'
  | 'BackendError'
  | 'UserspacePanic'
  | 'UnreachableInstruction'
  | 'StackLimitExceeded'
  | 'Unsupported';

export type GearCoreErrorsSimpleSimpleUnavailableActorError =
  | 'ProgramExited'
  | 'InitializationFailure'
  | 'Uninitialized'
  | 'ProgramNotCreated'
  | 'ReinstrumentationFailure'
  | 'Unsupported';

export type GearCommonEventReason =
  | { type: 'Runtime'; value: GearCommonEventUserMessageReadRuntimeReason }
  | { type: 'System'; value: GearCommonEventUserMessageReadSystemReason };

export type GearCommonEventUserMessageReadRuntimeReason = 'MessageReplied' | 'MessageClaimed';

export type GearCommonEventUserMessageReadSystemReason = 'OutOfRent';

export type GearCommonEventDispatchStatus = 'Success' | 'Failed' | 'NotExecuted';

export type GearCommonGasProviderNodeGasNodeId =
  | { type: 'Node'; value: GprimitivesMessageId }
  | { type: 'Reservation'; value: GprimitivesReservationId };

export type GprimitivesReservationId = FixedBytes<32>;

export type GearCommonEventReasonMessageWaitedRuntimeReason =
  | { type: 'Runtime'; value: GearCommonEventMessageWaitedRuntimeReason }
  | { type: 'System'; value: GearCommonEventMessageWaitedSystemReason };

export type GearCommonEventMessageWaitedRuntimeReason =
  | 'WaitCalled'
  | 'WaitForCalled'
  | 'WaitUpToCalled'
  | 'WaitUpToCalledFull';

export type GearCommonEventMessageWaitedSystemReason = null;

export type GearCommonEventReasonMessageWokenRuntimeReason =
  | { type: 'Runtime'; value: GearCommonEventMessageWokenRuntimeReason }
  | { type: 'System'; value: GearCommonEventMessageWokenSystemReason };

export type GearCommonEventMessageWokenRuntimeReason = 'WakeCalled';

export type GearCommonEventMessageWokenSystemReason = 'ProgramGotInitialized' | 'TimeoutHasCome' | 'OutOfRent';

export type GearCommonEventCodeChangeKind =
  | { type: 'Active'; value: { expiration?: number | undefined } }
  | { type: 'Inactive' }
  | { type: 'Reinstrumented' };

export type GearCommonEventProgramChangeKind =
  | { type: 'Active'; value: { expiration: number } }
  | { type: 'Inactive' }
  | { type: 'Paused' }
  | { type: 'Terminated' }
  | { type: 'ExpirationChanged'; value: { expiration: number } }
  | { type: 'ProgramSet'; value: { expiration: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletGearStakingRewardsEvent =
  /**
   * Deposited to the pool.
   **/
  | { name: 'Deposited'; data: { amount: bigint } }
  /**
   * Transferred from the pool to an external account.
   **/
  | { name: 'Withdrawn'; data: { amount: bigint } }
  /**
   * Burned from the pool.
   **/
  | { name: 'Burned'; data: { amount: bigint } }
  /**
   * Minted to the pool.
   **/
  | { name: 'Minted'; data: { amount: bigint } }
  /**
   * Target inflation changed.
   **/
  | { name: 'TargetInflationChanged'; data: { value: Perquintill } }
  /**
   * Ideal staking ratio changed.
   **/
  | { name: 'IdealStakingRatioChanged'; data: { value: Perquintill } };

/**
 * Pallet Gear Voucher event.
 **/
export type PalletGearVoucherEvent =
  /**
   * Voucher has been issued.
   **/
  | {
      name: 'VoucherIssued';
      data: {
        /**
         * Account id of owner and manager of the voucher.
         **/
        owner: AccountId32;

        /**
         * Account id of user eligible to use the voucher.
         **/
        spender: AccountId32;

        /**
         * Voucher identifier.
         **/
        voucherId: PalletGearVoucherInternalVoucherId;
      };
    }
  /**
   * Voucher has been revoked by owner.
   *
   * NOTE: currently means only "refunded".
   **/
  | {
      name: 'VoucherRevoked';
      data: {
        /**
         * Account id of the user whose voucher was revoked.
         **/
        spender: AccountId32;

        /**
         * Voucher identifier.
         **/
        voucherId: PalletGearVoucherInternalVoucherId;
      };
    }
  /**
   * Voucher has been updated.
   **/
  | {
      name: 'VoucherUpdated';
      data: {
        /**
         * Account id of user whose voucher was updated.
         **/
        spender: AccountId32;

        /**
         * Voucher identifier.
         **/
        voucherId: PalletGearVoucherInternalVoucherId;

        /**
         * Optional field defining was the owner changed during update.
         **/
        newOwner?: AccountId32 | undefined;
      };
    }
  /**
   * Voucher has been declined (set to expired state).
   **/
  | {
      name: 'VoucherDeclined';
      data: {
        /**
         * Account id of user who declined its own voucher.
         **/
        spender: AccountId32;

        /**
         * Voucher identifier.
         **/
        voucherId: PalletGearVoucherInternalVoucherId;
      };
    };

export type FrameSystemLastRuntimeUpgradeInfo = { specVersion: number; specName: string };

export type FrameSystemCodeUpgradeAuthorization = { codeHash: H256; checkVersion: boolean };

export type FrameSystemLimitsBlockWeights = {
  baseBlock: SpWeightsWeightV2Weight;
  maxBlock: SpWeightsWeightV2Weight;
  perClass: FrameSupportDispatchPerDispatchClassWeightsPerClass;
};

export type FrameSupportDispatchPerDispatchClassWeightsPerClass = {
  normal: FrameSystemLimitsWeightsPerClass;
  operational: FrameSystemLimitsWeightsPerClass;
  mandatory: FrameSystemLimitsWeightsPerClass;
};

export type FrameSystemLimitsWeightsPerClass = {
  baseExtrinsic: SpWeightsWeightV2Weight;
  maxExtrinsic?: SpWeightsWeightV2Weight | undefined;
  maxTotal?: SpWeightsWeightV2Weight | undefined;
  reserved?: SpWeightsWeightV2Weight | undefined;
};

export type FrameSystemLimitsBlockLength = { max: FrameSupportDispatchPerDispatchClassU32 };

export type FrameSupportDispatchPerDispatchClassU32 = { normal: number; operational: number; mandatory: number };

export type SpWeightsRuntimeDbWeight = { read: bigint; write: bigint };

/**
 * Error for the System pallet
 **/
export type FrameSystemError =
  /**
   * The name of specification does not match between the current runtime
   * and the new runtime.
   **/
  | 'InvalidSpecName'
  /**
   * The specification version is not allowed to decrease between the current runtime
   * and the new runtime.
   **/
  | 'SpecVersionNeedsToIncrease'
  /**
   * Failed to extract the runtime version from the new runtime.
   *
   * Either calling `Core_version` or decoding `RuntimeVersion` failed.
   **/
  | 'FailedToExtractRuntimeVersion'
  /**
   * Suicide called when the account has non-default composite data.
   **/
  | 'NonDefaultComposite'
  /**
   * There is a non-zero reference count preventing the account from being purged.
   **/
  | 'NonZeroRefCount'
  /**
   * The origin filter prevent the call to be dispatched.
   **/
  | 'CallFiltered'
  /**
   * A multi-block migration is ongoing and prevents the current code from being replaced.
   **/
  | 'MultiBlockMigrationsOngoing'
  /**
   * No upgrade authorized.
   **/
  | 'NothingAuthorized'
  /**
   * The submitted code is not authorized.
   **/
  | 'Unauthorized';

export type SpConsensusBabeDigestsPreDigest =
  | { type: 'Primary'; value: SpConsensusBabeDigestsPrimaryPreDigest }
  | { type: 'SecondaryPlain'; value: SpConsensusBabeDigestsSecondaryPlainPreDigest }
  | { type: 'SecondaryVRF'; value: SpConsensusBabeDigestsSecondaryVRFPreDigest };

export type SpConsensusBabeDigestsPrimaryPreDigest = {
  authorityIndex: number;
  slot: SpConsensusSlotsSlot;
  vrfSignature: SpCoreSr25519VrfVrfSignature;
};

export type SpCoreSr25519VrfVrfSignature = { preOutput: FixedBytes<32>; proof: FixedBytes<64> };

export type SpConsensusBabeDigestsSecondaryPlainPreDigest = { authorityIndex: number; slot: SpConsensusSlotsSlot };

export type SpConsensusBabeDigestsSecondaryVRFPreDigest = {
  authorityIndex: number;
  slot: SpConsensusSlotsSlot;
  vrfSignature: SpCoreSr25519VrfVrfSignature;
};

export type SpConsensusBabeBabeEpochConfiguration = { c: [bigint, bigint]; allowedSlots: SpConsensusBabeAllowedSlots };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBabeError =
  /**
   * An equivocation proof provided as part of an equivocation report is invalid.
   **/
  | 'InvalidEquivocationProof'
  /**
   * A key ownership proof provided as part of an equivocation report is invalid.
   **/
  | 'InvalidKeyOwnershipProof'
  /**
   * A given equivocation report is valid but already previously reported.
   **/
  | 'DuplicateOffenceReport'
  /**
   * Submitted configuration is invalid.
   **/
  | 'InvalidConfiguration';

export type PalletGrandpaStoredState =
  | { type: 'Live' }
  | { type: 'PendingPause'; value: { scheduledAt: number; delay: number } }
  | { type: 'Paused' }
  | { type: 'PendingResume'; value: { scheduledAt: number; delay: number } };

export type PalletGrandpaStoredPendingChange = {
  scheduledAt: number;
  delay: number;
  nextAuthorities: Array<[SpConsensusGrandpaAppPublic, bigint]>;
  forced?: number | undefined;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletGrandpaError =
  /**
   * Attempt to signal GRANDPA pause when the authority set isn't live
   * (either paused or already pending pause).
   **/
  | 'PauseFailed'
  /**
   * Attempt to signal GRANDPA resume when the authority set isn't paused
   * (either live or already pending resume).
   **/
  | 'ResumeFailed'
  /**
   * Attempt to signal GRANDPA change with one already pending.
   **/
  | 'ChangePending'
  /**
   * Cannot signal forced change so soon after last.
   **/
  | 'TooSoon'
  /**
   * A key ownership proof provided as part of an equivocation report is invalid.
   **/
  | 'InvalidKeyOwnershipProof'
  /**
   * An equivocation proof provided as part of an equivocation report is invalid.
   **/
  | 'InvalidEquivocationProof'
  /**
   * A given equivocation report is valid but already previously reported.
   **/
  | 'DuplicateOffenceReport';

export type PalletBalancesBalanceLock = { id: FixedBytes<8>; amount: bigint; reasons: PalletBalancesReasons };

export type PalletBalancesReasons = 'Fee' | 'Misc' | 'All';

export type PalletBalancesReserveData = { id: FixedBytes<8>; amount: bigint };

export type FrameSupportTokensMiscIdAmount = { id: VaraRuntimeRuntimeHoldReason; amount: bigint };

export type VaraRuntimeRuntimeHoldReason = { type: 'Preimage'; value: PalletPreimageHoldReason };

export type PalletPreimageHoldReason = 'Preimage';

export type FrameSupportTokensMiscIdAmountRuntimeFreezeReason = { id: VaraRuntimeRuntimeFreezeReason; amount: bigint };

export type VaraRuntimeRuntimeFreezeReason = { type: 'NominationPools'; value: PalletNominationPoolsFreezeReason };

export type PalletNominationPoolsFreezeReason = 'PoolMinBalance';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBalancesError =
  /**
   * Vesting balance too high to send value.
   **/
  | 'VestingBalance'
  /**
   * Account liquidity restrictions prevent withdrawal.
   **/
  | 'LiquidityRestrictions'
  /**
   * Balance too low to send value.
   **/
  | 'InsufficientBalance'
  /**
   * Value too low to create account due to existential deposit.
   **/
  | 'ExistentialDeposit'
  /**
   * Transfer/payment would kill account.
   **/
  | 'Expendability'
  /**
   * A vesting schedule already exists for this account.
   **/
  | 'ExistingVestingSchedule'
  /**
   * Beneficiary account must pre-exist.
   **/
  | 'DeadAccount'
  /**
   * Number of named reserves exceed `MaxReserves`.
   **/
  | 'TooManyReserves'
  /**
   * Number of holds exceed `VariantCountOf<T::RuntimeHoldReason>`.
   **/
  | 'TooManyHolds'
  /**
   * Number of freezes exceed `MaxFreezes`.
   **/
  | 'TooManyFreezes'
  /**
   * The issuance cannot be modified since it is already deactivated.
   **/
  | 'IssuanceDeactivated'
  /**
   * The delta cannot be zero.
   **/
  | 'DeltaZero';

export type PalletTransactionPaymentReleases = 'V1Ancient' | 'V2';

export type SpCoreCryptoKeyTypeId = FixedBytes<4>;

/**
 * Error for the session pallet.
 **/
export type PalletSessionError =
  /**
   * Invalid ownership proof.
   **/
  | 'InvalidProof'
  /**
   * No associated validator ID for account.
   **/
  | 'NoAssociatedValidatorId'
  /**
   * Registered duplicate key.
   **/
  | 'DuplicatedKey'
  /**
   * No keys are associated with this account.
   **/
  | 'NoKeys'
  /**
   * Key setting account is not live, so it's impossible to associate keys.
   **/
  | 'NoAccount';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletUtilityError =
  /**
   * Too many calls batched.
   **/
  'TooManyCalls';

export type PalletVestingReleases = 'V0' | 'V1';

/**
 * Error for the vesting pallet.
 **/
export type PalletVestingError =
  /**
   * The account given is not vesting.
   **/
  | 'NotVesting'
  /**
   * The account already has `MaxVestingSchedules` count of schedules and thus
   * cannot add another one. Consider merging existing schedules in order to add another.
   **/
  | 'AtMaxVestingSchedules'
  /**
   * Amount being transferred is too low to create a vesting schedule.
   **/
  | 'AmountLow'
  /**
   * An index was out of bounds of the vesting schedules.
   **/
  | 'ScheduleIndexOutOfBounds'
  /**
   * Failed to create a new schedule because some parameter was invalid.
   **/
  | 'InvalidScheduleParams';

export type PalletBagsListListNode = {
  id: AccountId32;
  prev?: AccountId32 | undefined;
  next?: AccountId32 | undefined;
  bagUpper: bigint;
  score: bigint;
};

export type PalletBagsListListBag = { head?: AccountId32 | undefined; tail?: AccountId32 | undefined };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBagsListError =
  /**
   * A error in the list interface implementation.
   **/
  { name: 'List'; data: PalletBagsListListListError };

export type PalletBagsListListListError = 'Duplicate' | 'NotHeavier' | 'NotInSameBag' | 'NodeNotFound';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletImOnlineError =
  /**
   * Non existent public key.
   **/
  | 'InvalidKey'
  /**
   * Duplicated heartbeat.
   **/
  | 'DuplicatedHeartbeat';

export type PalletStakingStakingLedger = {
  stash: AccountId32;
  total: bigint;
  active: bigint;
  unlocking: Array<PalletStakingUnlockChunk>;
  legacyClaimedRewards: Array<number>;
};

export type PalletStakingNominations = { targets: Array<AccountId32>; submittedIn: number; suppressed: boolean };

export type PalletStakingActiveEraInfo = { index: number; start?: bigint | undefined };

export type SpStakingPagedExposureMetadata = { total: bigint; own: bigint; nominatorCount: number; pageCount: number };

export type SpStakingExposurePage = { pageTotal: bigint; others: Array<SpStakingIndividualExposure> };

export type PalletStakingEraRewardPoints = { total: number; individual: Array<[AccountId32, number]> };

export type PalletStakingUnappliedSlash = {
  validator: AccountId32;
  own: bigint;
  others: Array<[AccountId32, bigint]>;
  reporters: Array<AccountId32>;
  payout: bigint;
};

export type PalletStakingSlashingSlashingSpans = {
  spanIndex: number;
  lastStart: number;
  lastNonzeroSlash: number;
  prior: Array<number>;
};

export type PalletStakingSlashingSpanRecord = { slashed: bigint; paidOut: bigint };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletStakingPalletError =
  /**
   * Not a controller account.
   **/
  | 'NotController'
  /**
   * Not a stash account.
   **/
  | 'NotStash'
  /**
   * Stash is already bonded.
   **/
  | 'AlreadyBonded'
  /**
   * Controller is already paired.
   **/
  | 'AlreadyPaired'
  /**
   * Targets cannot be empty.
   **/
  | 'EmptyTargets'
  /**
   * Duplicate index.
   **/
  | 'DuplicateIndex'
  /**
   * Slash record index out of bounds.
   **/
  | 'InvalidSlashIndex'
  /**
   * Cannot have a validator or nominator role, with value less than the minimum defined by
   * governance (see `MinValidatorBond` and `MinNominatorBond`). If unbonding is the
   * intention, `chill` first to remove one's role as validator/nominator.
   **/
  | 'InsufficientBond'
  /**
   * Can not schedule more unlock chunks.
   **/
  | 'NoMoreChunks'
  /**
   * Can not rebond without unlocking chunks.
   **/
  | 'NoUnlockChunk'
  /**
   * Attempting to target a stash that still has funds.
   **/
  | 'FundedTarget'
  /**
   * Invalid era to reward.
   **/
  | 'InvalidEraToReward'
  /**
   * Invalid number of nominations.
   **/
  | 'InvalidNumberOfNominations'
  /**
   * Items are not sorted and unique.
   **/
  | 'NotSortedAndUnique'
  /**
   * Rewards for this era have already been claimed for this validator.
   **/
  | 'AlreadyClaimed'
  /**
   * No nominators exist on this page.
   **/
  | 'InvalidPage'
  /**
   * Incorrect previous history depth input provided.
   **/
  | 'IncorrectHistoryDepth'
  /**
   * Incorrect number of slashing spans provided.
   **/
  | 'IncorrectSlashingSpans'
  /**
   * Internal state has become somehow corrupted and the operation cannot continue.
   **/
  | 'BadState'
  /**
   * Too many nomination targets supplied.
   **/
  | 'TooManyTargets'
  /**
   * A nomination target was supplied that was blocked or otherwise not a validator.
   **/
  | 'BadTarget'
  /**
   * The user has enough bond and thus cannot be chilled forcefully by an external person.
   **/
  | 'CannotChillOther'
  /**
   * There are too many nominators in the system. Governance needs to adjust the staking
   * settings to keep things safe for the runtime.
   **/
  | 'TooManyNominators'
  /**
   * There are too many validator candidates in the system. Governance needs to adjust the
   * staking settings to keep things safe for the runtime.
   **/
  | 'TooManyValidators'
  /**
   * Commission is too low. Must be at least `MinCommission`.
   **/
  | 'CommissionTooLow'
  /**
   * Some bound is not met.
   **/
  | 'BoundNotMet'
  /**
   * Used when attempting to use deprecated controller account logic.
   **/
  | 'ControllerDeprecated'
  /**
   * Cannot reset a ledger.
   **/
  | 'CannotRestoreLedger'
  /**
   * Provided reward destination is not allowed.
   **/
  | 'RewardDestinationRestricted'
  /**
   * Not enough funds available to withdraw.
   **/
  | 'NotEnoughFunds'
  /**
   * Operation not allowed for virtual stakers.
   **/
  | 'VirtualStakerNotAllowed';

export type PalletTreasuryProposal = { proposer: AccountId32; value: bigint; beneficiary: AccountId32; bond: bigint };

export type PalletTreasurySpendStatus = {
  assetKind: [];
  amount: bigint;
  beneficiary: AccountId32;
  validFrom: number;
  expireAt: number;
  status: PalletTreasuryPaymentState;
};

export type PalletTreasuryPaymentState =
  | { type: 'Pending' }
  | { type: 'Attempted'; value: { id: [] } }
  | { type: 'Failed' };

export type FrameSupportPalletId = FixedBytes<8>;

/**
 * Error for the treasury pallet.
 **/
export type PalletTreasuryError =
  /**
   * No proposal, bounty or spend at that index.
   **/
  | 'InvalidIndex'
  /**
   * Too many approvals in the queue.
   **/
  | 'TooManyApprovals'
  /**
   * The spend origin is valid but the amount it is allowed to spend is lower than the
   * amount to be spent.
   **/
  | 'InsufficientPermission'
  /**
   * Proposal has not been approved.
   **/
  | 'ProposalNotApproved'
  /**
   * The balance of the asset kind is not convertible to the balance of the native asset.
   **/
  | 'FailedToConvertBalance'
  /**
   * The spend has expired and cannot be claimed.
   **/
  | 'SpendExpired'
  /**
   * The spend is not yet eligible for payout.
   **/
  | 'EarlyPayout'
  /**
   * The payment has already been attempted.
   **/
  | 'AlreadyAttempted'
  /**
   * There was some issue with the mechanism of payment.
   **/
  | 'PayoutError'
  /**
   * The payout was not yet attempted/claimed.
   **/
  | 'NotAttempted'
  /**
   * The payment has neither failed nor succeeded yet.
   **/
  | 'Inconclusive';

export type PalletConvictionVotingVoteVoting =
  | { type: 'Casting'; value: PalletConvictionVotingVoteCasting }
  | { type: 'Delegating'; value: PalletConvictionVotingVoteDelegating };

export type PalletConvictionVotingVoteCasting = {
  votes: Array<[number, PalletConvictionVotingVoteAccountVote]>;
  delegations: PalletConvictionVotingDelegations;
  prior: PalletConvictionVotingVotePriorLock;
};

export type PalletConvictionVotingDelegations = { votes: bigint; capital: bigint };

export type PalletConvictionVotingVotePriorLock = [number, bigint];

export type PalletConvictionVotingVoteDelegating = {
  balance: bigint;
  target: AccountId32;
  conviction: PalletConvictionVotingConviction;
  delegations: PalletConvictionVotingDelegations;
  prior: PalletConvictionVotingVotePriorLock;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletConvictionVotingError =
  /**
   * Poll is not ongoing.
   **/
  | 'NotOngoing'
  /**
   * The given account did not vote on the poll.
   **/
  | 'NotVoter'
  /**
   * The actor has no permission to conduct the action.
   **/
  | 'NoPermission'
  /**
   * The actor has no permission to conduct the action right now but will do in the future.
   **/
  | 'NoPermissionYet'
  /**
   * The account is already delegating.
   **/
  | 'AlreadyDelegating'
  /**
   * The account currently has votes attached to it and the operation cannot succeed until
   * these are removed through `remove_vote`.
   **/
  | 'AlreadyVoting'
  /**
   * Too high a balance was provided that the account cannot afford.
   **/
  | 'InsufficientFunds'
  /**
   * The account is not currently delegating.
   **/
  | 'NotDelegating'
  /**
   * Delegation to oneself makes no sense.
   **/
  | 'Nonsense'
  /**
   * Maximum number of votes reached.
   **/
  | 'MaxVotesReached'
  /**
   * The class must be supplied since it is not easily determinable from the state.
   **/
  | 'ClassNeeded'
  /**
   * The class ID supplied is invalid.
   **/
  | 'BadClass';

export type PalletReferendaReferendumInfo =
  | { type: 'Ongoing'; value: PalletReferendaReferendumStatus }
  | { type: 'Approved'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { type: 'Rejected'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { type: 'Cancelled'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { type: 'TimedOut'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { type: 'Killed'; value: number };

export type PalletReferendaReferendumStatus = {
  track: number;
  origin: VaraRuntimeOriginCaller;
  proposal: FrameSupportPreimagesBounded;
  enactment: FrameSupportScheduleDispatchTime;
  submitted: number;
  submissionDeposit: PalletReferendaDeposit;
  decisionDeposit?: PalletReferendaDeposit | undefined;
  deciding?: PalletReferendaDecidingStatus | undefined;
  tally: PalletConvictionVotingTally;
  inQueue: boolean;
  alarm?: [number, [number, number]] | undefined;
};

export type PalletReferendaDeposit = { who: AccountId32; amount: bigint };

export type PalletReferendaDecidingStatus = { since: number; confirming?: number | undefined };

export type PalletReferendaTrackInfo = {
  name: string;
  maxDeciding: number;
  decisionDeposit: bigint;
  preparePeriod: number;
  decisionPeriod: number;
  confirmPeriod: number;
  minEnactmentPeriod: number;
  minApproval: PalletReferendaCurve;
  minSupport: PalletReferendaCurve;
};

export type PalletReferendaCurve =
  | { type: 'LinearDecreasing'; value: { length: Perbill; floor: Perbill; ceil: Perbill } }
  | { type: 'SteppedDecreasing'; value: { begin: Perbill; end: Perbill; step: Perbill; period: Perbill } }
  | { type: 'Reciprocal'; value: { factor: FixedI64; xOffset: FixedI64; yOffset: FixedI64 } };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletReferendaError =
  /**
   * Referendum is not ongoing.
   **/
  | 'NotOngoing'
  /**
   * Referendum's decision deposit is already paid.
   **/
  | 'HasDeposit'
  /**
   * The track identifier given was invalid.
   **/
  | 'BadTrack'
  /**
   * There are already a full complement of referenda in progress for this track.
   **/
  | 'Full'
  /**
   * The queue of the track is empty.
   **/
  | 'QueueEmpty'
  /**
   * The referendum index provided is invalid in this context.
   **/
  | 'BadReferendum'
  /**
   * There was nothing to do in the advancement.
   **/
  | 'NothingToDo'
  /**
   * No track exists for the proposal origin.
   **/
  | 'NoTrack'
  /**
   * Any deposit cannot be refunded until after the decision is over.
   **/
  | 'Unfinished'
  /**
   * The deposit refunder is not the depositor.
   **/
  | 'NoPermission'
  /**
   * The deposit cannot be refunded since none was made.
   **/
  | 'NoDeposit'
  /**
   * The referendum status is invalid for this operation.
   **/
  | 'BadStatus'
  /**
   * The preimage does not exist.
   **/
  | 'PreimageNotExist'
  /**
   * The preimage is stored with a different length than the one provided.
   **/
  | 'PreimageStoredWithDifferentLength';

export type PalletRankedCollectiveMemberRecord = { rank: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletRankedCollectiveError =
  /**
   * Account is already a member.
   **/
  | 'AlreadyMember'
  /**
   * Account is not a member.
   **/
  | 'NotMember'
  /**
   * The given poll index is unknown or has closed.
   **/
  | 'NotPolling'
  /**
   * The given poll is still ongoing.
   **/
  | 'Ongoing'
  /**
   * There are no further records to be removed.
   **/
  | 'NoneRemaining'
  /**
   * Unexpected error in state.
   **/
  | 'Corruption'
  /**
   * The member's rank is too low to vote.
   **/
  | 'RankTooLow'
  /**
   * The information provided is incorrect.
   **/
  | 'InvalidWitness'
  /**
   * The origin is not sufficiently privileged to do the operation.
   **/
  | 'NoPermission'
  /**
   * The new member to exchange is the same as the old member
   **/
  | 'SameMember'
  /**
   * The max member count for the rank has been reached.
   **/
  | 'TooManyMembers';

export type PalletReferendaReferendumInfoTally =
  | { type: 'Ongoing'; value: PalletReferendaReferendumStatusTally }
  | { type: 'Approved'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { type: 'Rejected'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { type: 'Cancelled'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { type: 'TimedOut'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { type: 'Killed'; value: number };

export type PalletReferendaReferendumStatusTally = {
  track: number;
  origin: VaraRuntimeOriginCaller;
  proposal: FrameSupportPreimagesBounded;
  enactment: FrameSupportScheduleDispatchTime;
  submitted: number;
  submissionDeposit: PalletReferendaDeposit;
  decisionDeposit?: PalletReferendaDeposit | undefined;
  deciding?: PalletReferendaDecidingStatus | undefined;
  tally: PalletRankedCollectiveTally;
  inQueue: boolean;
  alarm?: [number, [number, number]] | undefined;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletWhitelistError =
  /**
   * The preimage of the call hash could not be loaded.
   **/
  | 'UnavailablePreImage'
  /**
   * The call could not be decoded.
   **/
  | 'UndecodableCall'
  /**
   * The weight of the decoded call was higher than the witness.
   **/
  | 'InvalidCallWeightWitness'
  /**
   * The call was not whitelisted.
   **/
  | 'CallIsNotWhitelisted'
  /**
   * The call was already whitelisted; No-Op.
   **/
  | 'CallAlreadyWhitelisted';

export type PalletSchedulerScheduled = {
  maybeId?: FixedBytes<32> | undefined;
  priority: number;
  call: FrameSupportPreimagesBounded;
  maybePeriodic?: [number, number] | undefined;
  origin: VaraRuntimeOriginCaller;
};

export type PalletSchedulerRetryConfig = { totalRetries: number; remaining: number; period: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletSchedulerError =
  /**
   * Failed to schedule a call
   **/
  | 'FailedToSchedule'
  /**
   * Cannot find the scheduled call.
   **/
  | 'NotFound'
  /**
   * Given target block number is in the past.
   **/
  | 'TargetBlockNumberInPast'
  /**
   * Reschedule failed because it does not change scheduled time.
   **/
  | 'RescheduleNoChange'
  /**
   * Attempt to use a non-named function on a named task.
   **/
  | 'Named';

export type PalletPreimageOldRequestStatus =
  | { type: 'Unrequested'; value: { deposit: [AccountId32, bigint]; len: number } }
  | {
      type: 'Requested';
      value: { deposit?: [AccountId32, bigint] | undefined; count: number; len?: number | undefined };
    };

export type PalletPreimageRequestStatus =
  | { type: 'Unrequested'; value: { ticket: [AccountId32, FrameSupportTokensFungibleHoldConsideration]; len: number } }
  | {
      type: 'Requested';
      value: {
        maybeTicket?: [AccountId32, FrameSupportTokensFungibleHoldConsideration] | undefined;
        count: number;
        maybeLen?: number | undefined;
      };
    };

export type FrameSupportTokensFungibleHoldConsideration = bigint;

/**
 * The `Error` enum of this pallet.
 **/
export type PalletPreimageError =
  /**
   * Preimage is too large to store on-chain.
   **/
  | 'TooBig'
  /**
   * Preimage has already been noted on-chain.
   **/
  | 'AlreadyNoted'
  /**
   * The user is not authorized to perform this action.
   **/
  | 'NotAuthorized'
  /**
   * The preimage cannot be removed since it has not yet been noted.
   **/
  | 'NotNoted'
  /**
   * A preimage may not be removed when there are outstanding requests.
   **/
  | 'Requested'
  /**
   * The preimage request cannot be removed since no outstanding requests exist.
   **/
  | 'NotRequested'
  /**
   * More than `MAX_HASH_UPGRADE_BULK_COUNT` hashes were requested to be upgraded at once.
   **/
  | 'TooMany'
  /**
   * Too few hashes were requested to be upgraded (i.e. zero).
   **/
  | 'TooFew';

export type PalletIdentityRegistration = {
  judgements: Array<[number, PalletIdentityJudgement]>;
  deposit: bigint;
  info: PalletIdentityLegacyIdentityInfo;
};

export type PalletIdentityRegistrarInfo = { account: AccountId32; fee: bigint; fields: bigint };

export type PalletIdentityAuthorityProperties = { suffix: Bytes; allocation: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletIdentityError =
  /**
   * Too many subs-accounts.
   **/
  | 'TooManySubAccounts'
  /**
   * Account isn't found.
   **/
  | 'NotFound'
  /**
   * Account isn't named.
   **/
  | 'NotNamed'
  /**
   * Empty index.
   **/
  | 'EmptyIndex'
  /**
   * Fee is changed.
   **/
  | 'FeeChanged'
  /**
   * No identity found.
   **/
  | 'NoIdentity'
  /**
   * Sticky judgement.
   **/
  | 'StickyJudgement'
  /**
   * Judgement given.
   **/
  | 'JudgementGiven'
  /**
   * Invalid judgement.
   **/
  | 'InvalidJudgement'
  /**
   * The index is invalid.
   **/
  | 'InvalidIndex'
  /**
   * The target is invalid.
   **/
  | 'InvalidTarget'
  /**
   * Maximum amount of registrars reached. Cannot add any more.
   **/
  | 'TooManyRegistrars'
  /**
   * Account ID is already named.
   **/
  | 'AlreadyClaimed'
  /**
   * Sender is not a sub-account.
   **/
  | 'NotSub'
  /**
   * Sub-account isn't owned by sender.
   **/
  | 'NotOwned'
  /**
   * The provided judgement was for a different identity.
   **/
  | 'JudgementForDifferentIdentity'
  /**
   * Error that occurs when there is an issue paying for judgement.
   **/
  | 'JudgementPaymentFailed'
  /**
   * The provided suffix is too long.
   **/
  | 'InvalidSuffix'
  /**
   * The sender does not have permission to issue a username.
   **/
  | 'NotUsernameAuthority'
  /**
   * The authority cannot allocate any more usernames.
   **/
  | 'NoAllocation'
  /**
   * The signature on a username was not valid.
   **/
  | 'InvalidSignature'
  /**
   * Setting this username requires a signature, but none was provided.
   **/
  | 'RequiresSignature'
  /**
   * The username does not meet the requirements.
   **/
  | 'InvalidUsername'
  /**
   * The username is already taken.
   **/
  | 'UsernameTaken'
  /**
   * The requested username does not exist.
   **/
  | 'NoUsername'
  /**
   * The username cannot be forcefully removed because it can still be accepted.
   **/
  | 'NotExpired';

export type PalletProxyProxyDefinition = { delegate: AccountId32; proxyType: VaraRuntimeProxyType; delay: number };

export type PalletProxyAnnouncement = { real: AccountId32; callHash: H256; height: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletProxyError =
  /**
   * There are too many proxies registered or too many announcements pending.
   **/
  | 'TooMany'
  /**
   * Proxy registration not found.
   **/
  | 'NotFound'
  /**
   * Sender is not a proxy of the account to be proxied.
   **/
  | 'NotProxy'
  /**
   * A call which is incompatible with the proxy type's filter was attempted.
   **/
  | 'Unproxyable'
  /**
   * Account is already a proxy.
   **/
  | 'Duplicate'
  /**
   * Call may not be made by proxy because it may escalate its privileges.
   **/
  | 'NoPermission'
  /**
   * Announcement, if made at all, was made too recently.
   **/
  | 'Unannounced'
  /**
   * Cannot add self as proxy.
   **/
  | 'NoSelfProxy';

export type PalletMultisigMultisig = {
  when: PalletMultisigTimepoint;
  deposit: bigint;
  depositor: AccountId32;
  approvals: Array<AccountId32>;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletMultisigError =
  /**
   * Threshold must be 2 or greater.
   **/
  | 'MinimumThreshold'
  /**
   * Call is already approved by this signatory.
   **/
  | 'AlreadyApproved'
  /**
   * Call doesn't need any (more) approvals.
   **/
  | 'NoApprovalsNeeded'
  /**
   * There are too few signatories in the list.
   **/
  | 'TooFewSignatories'
  /**
   * There are too many signatories in the list.
   **/
  | 'TooManySignatories'
  /**
   * The signatories were provided out of order; they should be ordered.
   **/
  | 'SignatoriesOutOfOrder'
  /**
   * The sender was contained in the other signatories; it shouldn't be.
   **/
  | 'SenderInSignatories'
  /**
   * Multisig operation not found when attempting to cancel.
   **/
  | 'NotFound'
  /**
   * Only the account that originally created the multisig is able to cancel it.
   **/
  | 'NotOwner'
  /**
   * No timepoint was given, yet the multisig operation is already underway.
   **/
  | 'NoTimepoint'
  /**
   * A different timepoint was given to the multisig operation that is underway.
   **/
  | 'WrongTimepoint'
  /**
   * A timepoint was given, yet no multisig operation is underway.
   **/
  | 'UnexpectedTimepoint'
  /**
   * The maximum weight information provided was too low.
   **/
  | 'MaxWeightTooLow'
  /**
   * The data to be stored is already stored.
   **/
  | 'AlreadyStored';

export type PalletElectionProviderMultiPhaseReadySolution = {
  supports: Array<[AccountId32, SpNposElectionsSupport]>;
  score: SpNposElectionsElectionScore;
  compute: PalletElectionProviderMultiPhaseElectionCompute;
};

export type PalletElectionProviderMultiPhaseRoundSnapshot = {
  voters: Array<[AccountId32, bigint, Array<AccountId32>]>;
  targets: Array<AccountId32>;
};

export type PalletElectionProviderMultiPhaseSignedSignedSubmission = {
  who: AccountId32;
  deposit: bigint;
  rawSolution: PalletElectionProviderMultiPhaseRawSolution;
  callFee: bigint;
};

/**
 * Error of the pallet that can be returned in response to dispatches.
 **/
export type PalletElectionProviderMultiPhaseError =
  /**
   * Submission was too early.
   **/
  | 'PreDispatchEarlySubmission'
  /**
   * Wrong number of winners presented.
   **/
  | 'PreDispatchWrongWinnerCount'
  /**
   * Submission was too weak, score-wise.
   **/
  | 'PreDispatchWeakSubmission'
  /**
   * The queue was full, and the solution was not better than any of the existing ones.
   **/
  | 'SignedQueueFull'
  /**
   * The origin failed to pay the deposit.
   **/
  | 'SignedCannotPayDeposit'
  /**
   * Witness data to dispatchable is invalid.
   **/
  | 'SignedInvalidWitness'
  /**
   * The signed submission consumes too much weight
   **/
  | 'SignedTooMuchWeight'
  /**
   * OCW submitted solution for wrong round
   **/
  | 'OcwCallWrongEra'
  /**
   * Snapshot metadata should exist but didn't.
   **/
  | 'MissingSnapshotMetadata'
  /**
   * `Self::insert_submission` returned an invalid index.
   **/
  | 'InvalidSubmissionIndex'
  /**
   * The call is not allowed at this point.
   **/
  | 'CallNotAllowed'
  /**
   * The fallback failed
   **/
  | 'FallbackFailed'
  /**
   * Some bound not met
   **/
  | 'BoundNotMet'
  /**
   * Submitted solution has too many winners
   **/
  | 'TooManyWinners'
  /**
   * Submission was prepared for a different round.
   **/
  | 'PreDispatchDifferentRound';

export type SpStakingOffenceOffenceDetails = {
  offender: [AccountId32, SpStakingExposure];
  reporters: Array<AccountId32>;
};

export type PalletBountiesBounty = {
  proposer: AccountId32;
  value: bigint;
  fee: bigint;
  curatorDeposit: bigint;
  bond: bigint;
  status: PalletBountiesBountyStatus;
};

export type PalletBountiesBountyStatus =
  | { type: 'Proposed' }
  | { type: 'Approved' }
  | { type: 'Funded' }
  | { type: 'CuratorProposed'; value: { curator: AccountId32 } }
  | { type: 'Active'; value: { curator: AccountId32; updateDue: number } }
  | { type: 'PendingPayout'; value: { curator: AccountId32; beneficiary: AccountId32; unlockAt: number } };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBountiesError =
  /**
   * Proposer's balance is too low.
   **/
  | 'InsufficientProposersBalance'
  /**
   * No proposal or bounty at that index.
   **/
  | 'InvalidIndex'
  /**
   * The reason given is just too big.
   **/
  | 'ReasonTooBig'
  /**
   * The bounty status is unexpected.
   **/
  | 'UnexpectedStatus'
  /**
   * Require bounty curator.
   **/
  | 'RequireCurator'
  /**
   * Invalid bounty value.
   **/
  | 'InvalidValue'
  /**
   * Invalid bounty fee.
   **/
  | 'InvalidFee'
  /**
   * A bounty payout is pending.
   * To cancel the bounty, you must unassign and slash the curator.
   **/
  | 'PendingPayout'
  /**
   * The bounties cannot be claimed/closed because it's still in the countdown period.
   **/
  | 'Premature'
  /**
   * The bounty cannot be closed because it has active child bounties.
   **/
  | 'HasActiveChildBounty'
  /**
   * Too many approvals are already queued.
   **/
  | 'TooManyQueued';

export type PalletChildBountiesChildBounty = {
  parentBounty: number;
  value: bigint;
  fee: bigint;
  curatorDeposit: bigint;
  status: PalletChildBountiesChildBountyStatus;
};

export type PalletChildBountiesChildBountyStatus =
  | { type: 'Added' }
  | { type: 'CuratorProposed'; value: { curator: AccountId32 } }
  | { type: 'Active'; value: { curator: AccountId32 } }
  | { type: 'PendingPayout'; value: { curator: AccountId32; beneficiary: AccountId32; unlockAt: number } };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletChildBountiesError =
  /**
   * The parent bounty is not in active state.
   **/
  | 'ParentBountyNotActive'
  /**
   * The bounty balance is not enough to add new child-bounty.
   **/
  | 'InsufficientBountyBalance'
  /**
   * Number of child bounties exceeds limit `MaxActiveChildBountyCount`.
   **/
  | 'TooManyChildBounties';

export type PalletNominationPoolsPoolMember = {
  poolId: number;
  points: bigint;
  lastRecordedRewardCounter: FixedU128;
  unbondingEras: Array<[number, bigint]>;
};

export type PalletNominationPoolsBondedPoolInner = {
  commission: PalletNominationPoolsCommission;
  memberCounter: number;
  points: bigint;
  roles: PalletNominationPoolsPoolRoles;
  state: PalletNominationPoolsPoolState;
};

export type PalletNominationPoolsCommission = {
  current?: [Perbill, AccountId32] | undefined;
  max?: Perbill | undefined;
  changeRate?: PalletNominationPoolsCommissionChangeRate | undefined;
  throttleFrom?: number | undefined;
  claimPermission?: PalletNominationPoolsCommissionClaimPermission | undefined;
};

export type PalletNominationPoolsPoolRoles = {
  depositor: AccountId32;
  root?: AccountId32 | undefined;
  nominator?: AccountId32 | undefined;
  bouncer?: AccountId32 | undefined;
};

export type PalletNominationPoolsRewardPool = {
  lastRecordedRewardCounter: FixedU128;
  lastRecordedTotalPayouts: bigint;
  totalRewardsClaimed: bigint;
  totalCommissionPending: bigint;
  totalCommissionClaimed: bigint;
};

export type PalletNominationPoolsSubPools = {
  noEra: PalletNominationPoolsUnbondPool;
  withEra: Array<[number, PalletNominationPoolsUnbondPool]>;
};

export type PalletNominationPoolsUnbondPool = { points: bigint; balance: bigint };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletNominationPoolsError =
  /**
   * A (bonded) pool id does not exist.
   **/
  | { name: 'PoolNotFound' }
  /**
   * An account is not a member.
   **/
  | { name: 'PoolMemberNotFound' }
  /**
   * A reward pool does not exist. In all cases this is a system logic error.
   **/
  | { name: 'RewardPoolNotFound' }
  /**
   * A sub pool does not exist.
   **/
  | { name: 'SubPoolsNotFound' }
  /**
   * An account is already delegating in another pool. An account may only belong to one
   * pool at a time.
   **/
  | { name: 'AccountBelongsToOtherPool' }
  /**
   * The member is fully unbonded (and thus cannot access the bonded and reward pool
   * anymore to, for example, collect rewards).
   **/
  | { name: 'FullyUnbonding' }
  /**
   * The member cannot unbond further chunks due to reaching the limit.
   **/
  | { name: 'MaxUnbondingLimit' }
  /**
   * None of the funds can be withdrawn yet because the bonding duration has not passed.
   **/
  | { name: 'CannotWithdrawAny' }
  /**
   * The amount does not meet the minimum bond to either join or create a pool.
   *
   * The depositor can never unbond to a value less than `Pallet::depositor_min_bond`. The
   * caller does not have nominating permissions for the pool. Members can never unbond to a
   * value below `MinJoinBond`.
   **/
  | { name: 'MinimumBondNotMet' }
  /**
   * The transaction could not be executed due to overflow risk for the pool.
   **/
  | { name: 'OverflowRisk' }
  /**
   * A pool must be in [`PoolState::Destroying`] in order for the depositor to unbond or for
   * other members to be permissionlessly unbonded.
   **/
  | { name: 'NotDestroying' }
  /**
   * The caller does not have nominating permissions for the pool.
   **/
  | { name: 'NotNominator' }
  /**
   * Either a) the caller cannot make a valid kick or b) the pool is not destroying.
   **/
  | { name: 'NotKickerOrDestroying' }
  /**
   * The pool is not open to join
   **/
  | { name: 'NotOpen' }
  /**
   * The system is maxed out on pools.
   **/
  | { name: 'MaxPools' }
  /**
   * Too many members in the pool or system.
   **/
  | { name: 'MaxPoolMembers' }
  /**
   * The pools state cannot be changed.
   **/
  | { name: 'CanNotChangeState' }
  /**
   * The caller does not have adequate permissions.
   **/
  | { name: 'DoesNotHavePermission' }
  /**
   * Metadata exceeds [`Config::MaxMetadataLen`]
   **/
  | { name: 'MetadataExceedsMaxLen' }
  /**
   * Some error occurred that should never happen. This should be reported to the
   * maintainers.
   **/
  | { name: 'Defensive'; data: PalletNominationPoolsDefensiveError }
  /**
   * Partial unbonding now allowed permissionlessly.
   **/
  | { name: 'PartialUnbondNotAllowedPermissionlessly' }
  /**
   * The pool's max commission cannot be set higher than the existing value.
   **/
  | { name: 'MaxCommissionRestricted' }
  /**
   * The supplied commission exceeds the max allowed commission.
   **/
  | { name: 'CommissionExceedsMaximum' }
  /**
   * The supplied commission exceeds global maximum commission.
   **/
  | { name: 'CommissionExceedsGlobalMaximum' }
  /**
   * Not enough blocks have surpassed since the last commission update.
   **/
  | { name: 'CommissionChangeThrottled' }
  /**
   * The submitted changes to commission change rate are not allowed.
   **/
  | { name: 'CommissionChangeRateNotAllowed' }
  /**
   * There is no pending commission to claim.
   **/
  | { name: 'NoPendingCommission' }
  /**
   * No commission current has been set.
   **/
  | { name: 'NoCommissionCurrentSet' }
  /**
   * Pool id currently in use.
   **/
  | { name: 'PoolIdInUse' }
  /**
   * Pool id provided is not correct/usable.
   **/
  | { name: 'InvalidPoolId' }
  /**
   * Bonding extra is restricted to the exact pending reward amount.
   **/
  | { name: 'BondExtraRestricted' }
  /**
   * No imbalance in the ED deposit for the pool.
   **/
  | { name: 'NothingToAdjust' }
  /**
   * No slash pending that can be applied to the member.
   **/
  | { name: 'NothingToSlash' }
  /**
   * The pool or member delegation has already migrated to delegate stake.
   **/
  | { name: 'AlreadyMigrated' }
  /**
   * The pool or member delegation has not migrated yet to delegate stake.
   **/
  | { name: 'NotMigrated' }
  /**
   * This call is not allowed in the current state of the pallet.
   **/
  | { name: 'NotSupported' };

export type PalletNominationPoolsDefensiveError =
  | 'NotEnoughSpaceInUnbondPool'
  | 'PoolNotFound'
  | 'RewardPoolNotFound'
  | 'SubPoolsNotFound'
  | 'BondedStashKilledPrematurely'
  | 'DelegationUnsupported'
  | 'SlashNotApplied';

export type GearCoreCodeInstrumentedInstrumentedCode = {
  code: Bytes;
  originalCodeLen: number;
  exports: Array<GearCoreMessageDispatchKind>;
  staticPages: GearCorePagesPagesAmount;
  stackEnd?: GearCorePagesPage | undefined;
  instantiatedSectionSizes: GearCoreCodeInstrumentedInstantiatedSectionSizes;
  version: number;
};

export type GearCoreMessageDispatchKind = 'Init' | 'Handle' | 'Reply' | 'Signal';

export type GearCorePagesPagesAmount = number;

export type GearCorePagesPage = number;

export type GearCoreCodeInstrumentedInstantiatedSectionSizes = {
  codeSection: number;
  dataSection: number;
  globalSection: number;
  tableSection: number;
  elementSection: number;
  typeSection: number;
};

export type GearCommonCodeMetadata = { author: H256; blockNumber: number };

export type NumeratedTreeIntervalsTree = { inner: Array<[GearCorePagesPage, GearCorePagesPage]> };

export type GearCoreProgram =
  | { type: 'Active'; value: GearCoreProgramActiveProgram }
  | { type: 'Exited'; value: GprimitivesActorId }
  | { type: 'Terminated'; value: GprimitivesActorId };

export type GearCoreProgramActiveProgram = {
  allocationsTreeLen: number;
  memoryInfix: GearCoreProgramMemoryInfix;
  gasReservationMap: Array<[GprimitivesReservationId, GearCoreReservationGasReservationSlot]>;
  codeHash: H256;
  codeExports: Array<GearCoreMessageDispatchKind>;
  staticPages: GearCorePagesPagesAmount;
  state: GearCoreProgramProgramState;
  expirationBlock: number;
};

export type GearCoreProgramMemoryInfix = number;

export type GearCoreReservationGasReservationSlot = { amount: bigint; start: number; finish: number };

export type GearCoreProgramProgramState =
  | { type: 'Uninitialized'; value: { messageId: GprimitivesMessageId } }
  | { type: 'Initialized' };

export type GearCoreMemoryPageBuf = GearCoreBufferLimitedVecIntoPageBufError;

export type GearCoreBufferLimitedVecIntoPageBufError = Bytes;

export type GearCoreMemoryIntoPageBufError = {};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletGearProgramError =
  | 'DuplicateItem'
  | 'ProgramNotFound'
  | 'NotActiveProgram'
  | 'CannotFindDataForPage'
  | 'ProgramCodeNotFound';

export type GearCommonStorageComplicatedDequeueLinkedNode = {
  next?: GprimitivesMessageId | undefined;
  value: GearCoreMessageStoredStoredDispatch;
};

export type GearCoreMessageStoredStoredDispatch = {
  kind: GearCoreMessageDispatchKind;
  message: GearCoreMessageStoredStoredMessage;
  context?: GearCoreMessageContextContextStore | undefined;
};

export type GearCoreMessageStoredStoredMessage = {
  id: GprimitivesMessageId;
  source: GprimitivesActorId;
  destination: GprimitivesActorId;
  payload: GearCoreBufferLimitedVec;
  value: bigint;
  details?: GearCoreMessageCommonMessageDetails | undefined;
};

export type GearCoreMessageCommonMessageDetails =
  | { type: 'Reply'; value: GearCoreMessageCommonReplyDetails }
  | { type: 'Signal'; value: GearCoreMessageCommonSignalDetails };

export type GearCoreMessageCommonSignalDetails = { to: GprimitivesMessageId; code: GearCoreErrorsSimpleSignalCode };

export type GearCoreErrorsSimpleSignalCode =
  | { type: 'Execution'; value: GearCoreErrorsSimpleSimpleExecutionError }
  | { type: 'RemovedFromWaitlist' };

export type GearCoreMessageContextContextStore = {
  initialized: Array<GprimitivesActorId>;
  reservationNonce: GearCoreReservationReservationNonce;
  systemReservation?: bigint | undefined;
  localNonce: number;
};

export type GearCoreReservationReservationNonce = bigint;

export type GearCoreMessageUserUserStoredMessage = {
  id: GprimitivesMessageId;
  source: GprimitivesActorId;
  destination: GprimitivesActorId;
  payload: GearCoreBufferLimitedVec;
  value: bigint;
};

export type GearCommonStoragePrimitivesInterval = { start: number; finish: number };

export type GearCoreMessageStoredStoredDelayedDispatch = {
  kind: GearCoreMessageDispatchKind;
  message: GearCoreMessageStoredStoredMessage;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletGearMessengerError =
  /**
   * Occurs when given key already exists in queue.
   **/
  | 'QueueDuplicateKey'
  /**
   * Occurs when queue's element wasn't found in storage.
   **/
  | 'QueueElementNotFound'
  /**
   * Occurs when queue's head should contain value,
   * but it's empty for some reason.
   **/
  | 'QueueHeadShouldBeSet'
  /**
   * Occurs when queue's head should be empty,
   * but it contains value for some reason.
   **/
  | 'QueueHeadShouldNotBeSet'
  /**
   * Occurs when queue's tail element contains link
   * to the next element.
   **/
  | 'QueueTailHasNextKey'
  /**
   * Occurs when while searching queue's pre-tail,
   * element wasn't found.
   **/
  | 'QueueTailParentNotFound'
  /**
   * Occurs when queue's tail should contain value,
   * but it's empty for some reason.
   **/
  | 'QueueTailShouldBeSet'
  /**
   * Occurs when queue's tail should be empty,
   * but it contains value for some reason.
   **/
  | 'QueueTailShouldNotBeSet'
  /**
   * Occurs when given value already exists in mailbox.
   **/
  | 'MailboxDuplicateKey'
  /**
   * Occurs when mailbox's element wasn't found in storage.
   **/
  | 'MailboxElementNotFound'
  /**
   * Occurs when given value already exists in waitlist.
   **/
  | 'WaitlistDuplicateKey'
  /**
   * Occurs when waitlist's element wasn't found in storage.
   **/
  | 'WaitlistElementNotFound';

export type GearCoreTasksScheduledTask =
  | { type: 'PauseProgram'; value: GprimitivesActorId }
  | { type: 'RemoveCode'; value: GprimitivesCodeId }
  | { type: 'RemoveFromMailbox'; value: [AccountId32, GprimitivesMessageId] }
  | { type: 'RemoveFromWaitlist'; value: [GprimitivesActorId, GprimitivesMessageId] }
  | { type: 'RemovePausedProgram'; value: GprimitivesActorId }
  | { type: 'WakeMessage'; value: [GprimitivesActorId, GprimitivesMessageId] }
  | { type: 'SendDispatch'; value: GprimitivesMessageId }
  | { type: 'SendUserMessage'; value: { messageId: GprimitivesMessageId; toMailbox: boolean } }
  | { type: 'RemoveGasReservation'; value: [GprimitivesActorId, GprimitivesReservationId] }
  | { type: 'RemoveResumeSession'; value: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletGearSchedulerError =
  /**
   * Occurs when given task already exists in task pool.
   **/
  | 'DuplicateTask'
  /**
   * Occurs when task wasn't found in storage.
   **/
  | 'TaskNotFound';

export type GearCommonGasProviderNodeGasNode =
  | {
      type: 'External';
      value: {
        id: AccountId32;
        multiplier: GearCommonGasMultiplier;
        value: bigint;
        lock: GearCommonGasProviderNodeNodeLock;
        systemReserve: bigint;
        refs: GearCommonGasProviderNodeChildrenRefs;
        consumed: boolean;
        deposit: boolean;
      };
    }
  | {
      type: 'Cut';
      value: {
        id: AccountId32;
        multiplier: GearCommonGasMultiplier;
        value: bigint;
        lock: GearCommonGasProviderNodeNodeLock;
      };
    }
  | {
      type: 'Reserved';
      value: {
        id: AccountId32;
        multiplier: GearCommonGasMultiplier;
        value: bigint;
        lock: GearCommonGasProviderNodeNodeLock;
        refs: GearCommonGasProviderNodeChildrenRefs;
        consumed: boolean;
      };
    }
  | {
      type: 'SpecifiedLocal';
      value: {
        parent: GearCommonGasProviderNodeGasNodeId;
        root: GearCommonGasProviderNodeGasNodeId;
        value: bigint;
        lock: GearCommonGasProviderNodeNodeLock;
        systemReserve: bigint;
        refs: GearCommonGasProviderNodeChildrenRefs;
        consumed: boolean;
      };
    }
  | {
      type: 'UnspecifiedLocal';
      value: {
        parent: GearCommonGasProviderNodeGasNodeId;
        root: GearCommonGasProviderNodeGasNodeId;
        lock: GearCommonGasProviderNodeNodeLock;
        systemReserve: bigint;
      };
    };

export type GearCommonGasMultiplier = { type: 'ValuePerGas'; value: bigint } | { type: 'GasPerValue'; value: bigint };

export type GearCommonGasProviderNodeNodeLock = FixedArray<bigint, 4>;

export type GearCommonGasProviderNodeChildrenRefs = { specRefs: number; unspecRefs: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletGearGasError =
  | 'Forbidden'
  | 'NodeAlreadyExists'
  | 'InsufficientBalance'
  | 'NodeNotFound'
  | 'NodeWasConsumed'
  /**
   * Errors stating that gas tree has been invalidated
   **/
  | 'ParentIsLost'
  | 'ParentHasNoChildren'
  /**
   * Output of `Tree::consume` procedure that wasn't expected.
   *
   * Outputs of consumption procedure are determined. The error is returned
   * when unexpected one occurred. That signals, that algorithm works wrong
   * and expected invariants are not correct.
   **/
  | 'UnexpectedConsumeOutput'
  /**
   * Node type that can't occur if algorithm work well
   **/
  | 'UnexpectedNodeType'
  /**
   * Value must have been caught, but was missed or blocked (for more info see `ValueNode::catch_value`).
   **/
  | 'ValueIsNotCaught'
  /**
   * Value must have been caught or moved upstream, but was blocked (for more info see `ValueNode::catch_value`).
   **/
  | 'ValueIsBlocked'
  /**
   * Value must have been blocked, but was either moved or caught (for more info see `ValueNode::catch_value`).
   **/
  | 'ValueIsNotBlocked'
  /**
   * `GasTree::consume` called on node, which has some balance locked.
   **/
  | 'ConsumedWithLock'
  /**
   * `GasTree::consume` called on node, which has some system reservation.
   **/
  | 'ConsumedWithSystemReservation'
  /**
   * `GasTree::create` called with some value amount leading to
   * the total value overflow.
   **/
  | 'TotalValueIsOverflowed'
  /**
   * Either `GasTree::consume` or `GasTree::spent` called on a node creating
   * negative imbalance which leads to the total value drop below 0.
   **/
  | 'TotalValueIsUnderflowed';

export type PalletGearSchedule = {
  limits: PalletGearScheduleLimits;
  instructionWeights: PalletGearScheduleInstructionWeights;
  syscallWeights: PalletGearScheduleSyscallWeights;
  memoryWeights: PalletGearScheduleMemoryWeights;
  rentWeights: PalletGearScheduleRentWeights;
  dbWeights: PalletGearScheduleDbWeights;
  taskWeights: PalletGearScheduleTaskWeights;
  instantiationWeights: PalletGearScheduleInstantiationWeights;
  codeInstrumentationCost: SpWeightsWeightV2Weight;
  codeInstrumentationByteCost: SpWeightsWeightV2Weight;
  loadAllocationsWeight: SpWeightsWeightV2Weight;
};

export type PalletGearScheduleLimits = {
  stackHeight?: number | undefined;
  globals: number;
  locals: number;
  parameters: number;
  memoryPages: number;
  tableSize: number;
  brTableSize: number;
  subjectLen: number;
  callDepth: number;
  payloadLen: number;
  codeLen: number;
  dataSegmentsAmount: number;
};

export type PalletGearScheduleInstructionWeights = {
  version: number;
  i64const: number;
  i64load: number;
  i32load: number;
  i64store: number;
  i32store: number;
  select: number;
  rIf: number;
  br: number;
  brIf: number;
  brTable: number;
  brTablePerEntry: number;
  call: number;
  callIndirect: number;
  callIndirectPerParam: number;
  callPerLocal: number;
  localGet: number;
  localSet: number;
  localTee: number;
  globalGet: number;
  globalSet: number;
  memoryCurrent: number;
  i64clz: number;
  i32clz: number;
  i64ctz: number;
  i32ctz: number;
  i64popcnt: number;
  i32popcnt: number;
  i64eqz: number;
  i32eqz: number;
  i32extend8s: number;
  i32extend16s: number;
  i64extend8s: number;
  i64extend16s: number;
  i64extend32s: number;
  i64extendsi32: number;
  i64extendui32: number;
  i32wrapi64: number;
  i64eq: number;
  i32eq: number;
  i64ne: number;
  i32ne: number;
  i64lts: number;
  i32lts: number;
  i64ltu: number;
  i32ltu: number;
  i64gts: number;
  i32gts: number;
  i64gtu: number;
  i32gtu: number;
  i64les: number;
  i32les: number;
  i64leu: number;
  i32leu: number;
  i64ges: number;
  i32ges: number;
  i64geu: number;
  i32geu: number;
  i64add: number;
  i32add: number;
  i64sub: number;
  i32sub: number;
  i64mul: number;
  i32mul: number;
  i64divs: number;
  i32divs: number;
  i64divu: number;
  i32divu: number;
  i64rems: number;
  i32rems: number;
  i64remu: number;
  i32remu: number;
  i64and: number;
  i32and: number;
  i64or: number;
  i32or: number;
  i64xor: number;
  i32xor: number;
  i64shl: number;
  i32shl: number;
  i64shrs: number;
  i32shrs: number;
  i64shru: number;
  i32shru: number;
  i64rotl: number;
  i32rotl: number;
  i64rotr: number;
  i32rotr: number;
};

export type PalletGearScheduleSyscallWeights = {
  alloc: SpWeightsWeightV2Weight;
  free: SpWeightsWeightV2Weight;
  freeRange: SpWeightsWeightV2Weight;
  freeRangePerPage: SpWeightsWeightV2Weight;
  grReserveGas: SpWeightsWeightV2Weight;
  grUnreserveGas: SpWeightsWeightV2Weight;
  grSystemReserveGas: SpWeightsWeightV2Weight;
  grGasAvailable: SpWeightsWeightV2Weight;
  grMessageId: SpWeightsWeightV2Weight;
  grProgramId: SpWeightsWeightV2Weight;
  grSource: SpWeightsWeightV2Weight;
  grValue: SpWeightsWeightV2Weight;
  grValueAvailable: SpWeightsWeightV2Weight;
  grSize: SpWeightsWeightV2Weight;
  grRead: SpWeightsWeightV2Weight;
  grReadPerByte: SpWeightsWeightV2Weight;
  grEnvVars: SpWeightsWeightV2Weight;
  grBlockHeight: SpWeightsWeightV2Weight;
  grBlockTimestamp: SpWeightsWeightV2Weight;
  grRandom: SpWeightsWeightV2Weight;
  grReplyDeposit: SpWeightsWeightV2Weight;
  grSend: SpWeightsWeightV2Weight;
  grSendPerByte: SpWeightsWeightV2Weight;
  grSendWgas: SpWeightsWeightV2Weight;
  grSendWgasPerByte: SpWeightsWeightV2Weight;
  grSendInit: SpWeightsWeightV2Weight;
  grSendPush: SpWeightsWeightV2Weight;
  grSendPushPerByte: SpWeightsWeightV2Weight;
  grSendCommit: SpWeightsWeightV2Weight;
  grSendCommitWgas: SpWeightsWeightV2Weight;
  grReservationSend: SpWeightsWeightV2Weight;
  grReservationSendPerByte: SpWeightsWeightV2Weight;
  grReservationSendCommit: SpWeightsWeightV2Weight;
  grReplyCommit: SpWeightsWeightV2Weight;
  grReplyCommitWgas: SpWeightsWeightV2Weight;
  grReservationReply: SpWeightsWeightV2Weight;
  grReservationReplyPerByte: SpWeightsWeightV2Weight;
  grReservationReplyCommit: SpWeightsWeightV2Weight;
  grReplyPush: SpWeightsWeightV2Weight;
  grReply: SpWeightsWeightV2Weight;
  grReplyPerByte: SpWeightsWeightV2Weight;
  grReplyWgas: SpWeightsWeightV2Weight;
  grReplyWgasPerByte: SpWeightsWeightV2Weight;
  grReplyPushPerByte: SpWeightsWeightV2Weight;
  grReplyTo: SpWeightsWeightV2Weight;
  grSignalCode: SpWeightsWeightV2Weight;
  grSignalFrom: SpWeightsWeightV2Weight;
  grReplyInput: SpWeightsWeightV2Weight;
  grReplyInputWgas: SpWeightsWeightV2Weight;
  grReplyPushInput: SpWeightsWeightV2Weight;
  grReplyPushInputPerByte: SpWeightsWeightV2Weight;
  grSendInput: SpWeightsWeightV2Weight;
  grSendInputWgas: SpWeightsWeightV2Weight;
  grSendPushInput: SpWeightsWeightV2Weight;
  grSendPushInputPerByte: SpWeightsWeightV2Weight;
  grDebug: SpWeightsWeightV2Weight;
  grDebugPerByte: SpWeightsWeightV2Weight;
  grReplyCode: SpWeightsWeightV2Weight;
  grExit: SpWeightsWeightV2Weight;
  grLeave: SpWeightsWeightV2Weight;
  grWait: SpWeightsWeightV2Weight;
  grWaitFor: SpWeightsWeightV2Weight;
  grWaitUpTo: SpWeightsWeightV2Weight;
  grWake: SpWeightsWeightV2Weight;
  grCreateProgram: SpWeightsWeightV2Weight;
  grCreateProgramPayloadPerByte: SpWeightsWeightV2Weight;
  grCreateProgramSaltPerByte: SpWeightsWeightV2Weight;
  grCreateProgramWgas: SpWeightsWeightV2Weight;
  grCreateProgramWgasPayloadPerByte: SpWeightsWeightV2Weight;
  grCreateProgramWgasSaltPerByte: SpWeightsWeightV2Weight;
};

export type PalletGearScheduleMemoryWeights = {
  lazyPagesSignalRead: SpWeightsWeightV2Weight;
  lazyPagesSignalWrite: SpWeightsWeightV2Weight;
  lazyPagesSignalWriteAfterRead: SpWeightsWeightV2Weight;
  lazyPagesHostFuncRead: SpWeightsWeightV2Weight;
  lazyPagesHostFuncWrite: SpWeightsWeightV2Weight;
  lazyPagesHostFuncWriteAfterRead: SpWeightsWeightV2Weight;
  loadPageData: SpWeightsWeightV2Weight;
  uploadPageData: SpWeightsWeightV2Weight;
  memGrow: SpWeightsWeightV2Weight;
  memGrowPerPage: SpWeightsWeightV2Weight;
  parachainReadHeuristic: SpWeightsWeightV2Weight;
};

export type PalletGearScheduleRentWeights = {
  waitlist: SpWeightsWeightV2Weight;
  dispatchStash: SpWeightsWeightV2Weight;
  reservation: SpWeightsWeightV2Weight;
  mailbox: SpWeightsWeightV2Weight;
  mailboxThreshold: SpWeightsWeightV2Weight;
};

export type PalletGearScheduleDbWeights = {
  read: SpWeightsWeightV2Weight;
  readPerByte: SpWeightsWeightV2Weight;
  write: SpWeightsWeightV2Weight;
  writePerByte: SpWeightsWeightV2Weight;
};

export type PalletGearScheduleTaskWeights = {
  removeGasReservation: SpWeightsWeightV2Weight;
  sendUserMessageToMailbox: SpWeightsWeightV2Weight;
  sendUserMessage: SpWeightsWeightV2Weight;
  sendDispatch: SpWeightsWeightV2Weight;
  wakeMessage: SpWeightsWeightV2Weight;
  wakeMessageNoWake: SpWeightsWeightV2Weight;
  removeFromWaitlist: SpWeightsWeightV2Weight;
  removeFromMailbox: SpWeightsWeightV2Weight;
};

export type PalletGearScheduleInstantiationWeights = {
  codeSectionPerByte: SpWeightsWeightV2Weight;
  dataSectionPerByte: SpWeightsWeightV2Weight;
  globalSectionPerByte: SpWeightsWeightV2Weight;
  tableSectionPerByte: SpWeightsWeightV2Weight;
  elementSectionPerByte: SpWeightsWeightV2Weight;
  typeSectionPerByte: SpWeightsWeightV2Weight;
};

export type GearCorePercent = number;

/**
 * The `Error` enum of this pallet.
 **/
export type PalletGearError =
  /**
   * Message wasn't found in the mailbox.
   **/
  | 'MessageNotFound'
  /**
   * Not enough balance to execute an action.
   *
   * Usually occurs when the gas_limit specified is such that the origin account can't afford the message.
   **/
  | 'InsufficientBalance'
  /**
   * Gas limit too high.
   *
   * Occurs when an extrinsic's declared `gas_limit` is greater than a block's maximum gas limit.
   **/
  | 'GasLimitTooHigh'
  /**
   * Program already exists.
   *
   * Occurs if a program with some specific program id already exists in program storage.
   **/
  | 'ProgramAlreadyExists'
  /**
   * Program is terminated.
   *
   * Program init failed, so such message destination is no longer unavailable.
   **/
  | 'InactiveProgram'
  /**
   * Message gas tree is not found.
   *
   * When a message claimed from the mailbox has a corrupted or non-extant gas tree associated.
   **/
  | 'NoMessageTree'
  /**
   * Code already exists.
   *
   * Occurs when trying to save to storage a program code that has been saved there.
   **/
  | 'CodeAlreadyExists'
  /**
   * Code does not exist.
   *
   * Occurs when trying to get a program code from storage, that doesn't exist.
   **/
  | 'CodeDoesntExist'
  /**
   * The code supplied to `upload_code` or `upload_program` exceeds the limit specified in the
   * current schedule.
   **/
  | 'CodeTooLarge'
  /**
   * Failed to create a program.
   **/
  | 'ProgramConstructionFailed'
  /**
   * Message queue processing is disabled.
   **/
  | 'MessageQueueProcessingDisabled'
  /**
   * Block count doesn't cover MinimalResumePeriod.
   **/
  | 'ResumePeriodLessThanMinimal'
  /**
   * Program with the specified id is not found.
   **/
  | 'ProgramNotFound'
  /**
   * Gear::run() already included in current block.
   **/
  | 'GearRunAlreadyInBlock'
  /**
   * The program rent logic is disabled.
   **/
  | 'ProgramRentDisabled'
  /**
   * Program is active.
   **/
  | 'ActiveProgram';

/**
 * Error for the staking rewards pallet.
 **/
export type PalletGearStakingRewardsError =
  /**
   * Pool not replenished due to error.
   **/
  | 'FailureToRefillPool'
  /**
   * Failure to withdraw funds from the rewards pool.
   **/
  | 'FailureToWithdrawFromPool';

export type PalletGearVoucherInternalVoucherInfo = {
  owner: AccountId32;
  programs?: Array<GprimitivesActorId> | undefined;
  codeUploading: boolean;
  expiry: number;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletGearVoucherError =
  /**
   * The origin is not eligible to execute call.
   **/
  | 'BadOrigin'
  /**
   * Error trying transfer balance to/from voucher account.
   **/
  | 'BalanceTransfer'
  /**
   * Destination program is not in whitelisted set for voucher.
   **/
  | 'InappropriateDestination'
  /**
   * Voucher with given identifier doesn't exist for given spender id.
   **/
  | 'InexistentVoucher'
  /**
   * Voucher still valid and couldn't be revoked.
   **/
  | 'IrrevocableYet'
  /**
   * Try to whitelist more programs than allowed.
   **/
  | 'MaxProgramsLimitExceeded'
  /**
   * Failed to query destination of the prepaid call.
   **/
  | 'UnknownDestination'
  /**
   * Voucher has expired and couldn't be used.
   **/
  | 'VoucherExpired'
  /**
   * Voucher issue/prolongation duration out of [min; max] constants.
   **/
  | 'DurationOutOfBounds'
  /**
   * Voucher update function tries to cut voucher ability of code upload.
   **/
  | 'CodeUploadingEnabled'
  /**
   * Voucher is disabled for code uploading, but requested.
   **/
  | 'CodeUploadingDisabled';

export type PalletGearBankBankAccount = { gas: bigint; value: bigint };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletGearBankError =
  /**
   * Insufficient user balance.
   **/
  | 'InsufficientBalance'
  /**
   * Insufficient user's bank account gas balance.
   **/
  | 'InsufficientGasBalance'
  /**
   * Insufficient user's bank account gas balance.
   **/
  | 'InsufficientValueBalance'
  /**
   * Insufficient bank account balance.
   * **Must be unreachable in Gear main protocol.**
   **/
  | 'InsufficientBankBalance'
  /**
   * Deposit of funds that will not keep bank account alive.
   * **Must be unreachable in Gear main protocol.**
   **/
  | 'InsufficientDeposit'
  /**
   * Overflow during funds transfer.
   * **Must be unreachable in Gear main protocol.**
   **/
  | 'Overflow';

export type PalletGearStakingRewardsExtensionStakingBlackList = {};

export type FrameSystemExtensionsCheckNonZeroSender = {};

export type FrameSystemExtensionsCheckSpecVersion = {};

export type FrameSystemExtensionsCheckTxVersion = {};

export type FrameSystemExtensionsCheckGenesis = {};

export type FrameSystemExtensionsCheckMortality = Era;

export type VaraRuntimeCustomCheckNonce = number;

export type FrameSystemExtensionsCheckWeight = {};

export type PalletGearPaymentCustomChargeTransactionPayment = PalletTransactionPaymentChargeTransactionPayment;

export type VaraRuntimeRuntime = {};

export type PalletTransactionPaymentChargeTransactionPayment = bigint;

export type FrameMetadataHashExtensionCheckMetadataHash = { mode: FrameMetadataHashExtensionMode };

export type FrameMetadataHashExtensionMode = 'Disabled' | 'Enabled';

export type SpConsensusBabeBabeConfiguration = {
  slotDuration: bigint;
  epochLength: bigint;
  c: [bigint, bigint];
  authorities: Array<[SpConsensusBabeAppPublic, bigint]>;
  randomness: FixedBytes<32>;
  allowedSlots: SpConsensusBabeAllowedSlots;
};

export type SpConsensusBabeEpoch = {
  epochIndex: bigint;
  startSlot: SpConsensusSlotsSlot;
  duration: bigint;
  authorities: Array<[SpConsensusBabeAppPublic, bigint]>;
  randomness: FixedBytes<32>;
  config: SpConsensusBabeBabeEpochConfiguration;
};

export type SpConsensusBabeOpaqueKeyOwnershipProof = Bytes;

export type PalletTransactionPaymentRuntimeDispatchInfo = {
  weight: SpWeightsWeightV2Weight;
  class: FrameSupportDispatchDispatchClass;
  partialFee: bigint;
};

export type PalletTransactionPaymentFeeDetails = {
  inclusionFee?: PalletTransactionPaymentInclusionFee | undefined;
  tip: bigint;
};

export type PalletTransactionPaymentInclusionFee = { baseFee: bigint; lenFee: bigint; adjustedWeightFee: bigint };

export type PalletGearStakingRewardsInflationInfo = { inflation: Perquintill; roi: Perquintill };

export type PalletGearEthBridgeInternalProof = {
  root: H256;
  proof: Array<H256>;
  numberOfLeaves: bigint;
  leafIndex: bigint;
  leaf: H256;
};

export type SpRuntimeBlock = { header: Header; extrinsics: Array<UncheckedExtrinsic> };

export type SpRuntimeExtrinsicInclusionMode = 'AllExtrinsics' | 'OnlyInherents';

export type SpCoreOpaqueMetadata = Bytes;

export type SpRuntimeTransactionValidityTransactionValidityError =
  | { type: 'Invalid'; value: SpRuntimeTransactionValidityInvalidTransaction }
  | { type: 'Unknown'; value: SpRuntimeTransactionValidityUnknownTransaction };

export type SpRuntimeTransactionValidityInvalidTransaction =
  | { type: 'Call' }
  | { type: 'Payment' }
  | { type: 'Future' }
  | { type: 'Stale' }
  | { type: 'BadProof' }
  | { type: 'AncientBirthBlock' }
  | { type: 'ExhaustsResources' }
  | { type: 'Custom'; value: number }
  | { type: 'BadMandatory' }
  | { type: 'MandatoryValidation' }
  | { type: 'BadSigner' };

export type SpRuntimeTransactionValidityUnknownTransaction =
  | { type: 'CannotLookup' }
  | { type: 'NoUnsignedValidator' }
  | { type: 'Custom'; value: number };

export type SpInherentsInherentData = { data: Array<[FixedBytes<8>, Bytes]> };

export type SpInherentsCheckInherentsResult = { okay: boolean; fatalError: boolean; errors: SpInherentsInherentData };

export type SpRuntimeTransactionValidityTransactionSource = 'InBlock' | 'Local' | 'External';

export type SpRuntimeTransactionValidityValidTransaction = {
  priority: bigint;
  requires: Array<Bytes>;
  provides: Array<Bytes>;
  longevity: bigint;
  propagate: boolean;
};

export type SpRuntimeOpaqueValue = Bytes;

export type GearCoreMessageReplyInfo = { payload: Bytes; value: bigint; code: GearCoreErrorsSimpleReplyCode };

export type PalletGearManagerHandleKind =
  | { type: 'Init'; value: Bytes }
  | { type: 'InitByHash'; value: GprimitivesCodeId }
  | { type: 'Handle'; value: GprimitivesActorId }
  | { type: 'Reply'; value: [GprimitivesMessageId, GearCoreErrorsSimpleReplyCode] }
  | { type: 'Signal'; value: [GprimitivesMessageId, GearCoreErrorsSimpleSignalCode] };

export type GearCoreGasGasInfo = {
  minLimit: bigint;
  reserved: bigint;
  burned: bigint;
  mayBeReturned: bigint;
  waited: boolean;
};

export type VaraRuntimeRuntimeError =
  | { pallet: 'System'; palletError: FrameSystemError }
  | { pallet: 'Babe'; palletError: PalletBabeError }
  | { pallet: 'Grandpa'; palletError: PalletGrandpaError }
  | { pallet: 'Balances'; palletError: PalletBalancesError }
  | { pallet: 'Session'; palletError: PalletSessionError }
  | { pallet: 'Utility'; palletError: PalletUtilityError }
  | { pallet: 'Vesting'; palletError: PalletVestingError }
  | { pallet: 'BagsList'; palletError: PalletBagsListError }
  | { pallet: 'ImOnline'; palletError: PalletImOnlineError }
  | { pallet: 'Staking'; palletError: PalletStakingPalletError }
  | { pallet: 'Treasury'; palletError: PalletTreasuryError }
  | { pallet: 'ConvictionVoting'; palletError: PalletConvictionVotingError }
  | { pallet: 'Referenda'; palletError: PalletReferendaError }
  | { pallet: 'FellowshipCollective'; palletError: PalletRankedCollectiveError }
  | { pallet: 'FellowshipReferenda'; palletError: PalletReferendaError }
  | { pallet: 'Whitelist'; palletError: PalletWhitelistError }
  | { pallet: 'Scheduler'; palletError: PalletSchedulerError }
  | { pallet: 'Preimage'; palletError: PalletPreimageError }
  | { pallet: 'Identity'; palletError: PalletIdentityError }
  | { pallet: 'Proxy'; palletError: PalletProxyError }
  | { pallet: 'Multisig'; palletError: PalletMultisigError }
  | { pallet: 'ElectionProviderMultiPhase'; palletError: PalletElectionProviderMultiPhaseError }
  | { pallet: 'Bounties'; palletError: PalletBountiesError }
  | { pallet: 'ChildBounties'; palletError: PalletChildBountiesError }
  | { pallet: 'NominationPools'; palletError: PalletNominationPoolsError }
  | { pallet: 'GearProgram'; palletError: PalletGearProgramError }
  | { pallet: 'GearMessenger'; palletError: PalletGearMessengerError }
  | { pallet: 'GearScheduler'; palletError: PalletGearSchedulerError }
  | { pallet: 'GearGas'; palletError: PalletGearGasError }
  | { pallet: 'Gear'; palletError: PalletGearError }
  | { pallet: 'StakingRewards'; palletError: PalletGearStakingRewardsError }
  | { pallet: 'GearVoucher'; palletError: PalletGearVoucherError }
  | { pallet: 'GearBank'; palletError: PalletGearBankError };
