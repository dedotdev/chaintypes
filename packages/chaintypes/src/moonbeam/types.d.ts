// Generated by dedot cli

import type {
  Phase,
  H256,
  DispatchInfo,
  DispatchError,
  AccountId20,
  FixedBytes,
  Percent,
  Perbill,
  FixedArray,
  Result,
  Bytes,
  H160,
  BytesLike,
  AccountId20Like,
  Data,
  U256,
  FixedI64,
  Era,
  UncheckedExtrinsic,
  Header,
} from 'dedot/codecs';

export type FrameSystemAccountInfo = {
  nonce: number;
  consumers: number;
  providers: number;
  sufficients: number;
  data: PalletBalancesAccountData;
};

export type PalletBalancesAccountData = {
  free: bigint;
  reserved: bigint;
  frozen: bigint;
  flags: PalletBalancesExtraFlags;
};

export type PalletBalancesExtraFlags = bigint;

export type FrameSupportDispatchPerDispatchClass = {
  normal: SpWeightsWeightV2Weight;
  operational: SpWeightsWeightV2Weight;
  mandatory: SpWeightsWeightV2Weight;
};

export type SpWeightsWeightV2Weight = { refTime: bigint; proofSize: bigint };

export type FrameSystemEventRecord = { phase: Phase; event: MoonbeamRuntimeRuntimeEvent; topics: Array<H256> };

export type MoonbeamRuntimeRuntimeEvent =
  | { pallet: 'System'; palletEvent: FrameSystemEvent }
  | { pallet: 'ParachainSystem'; palletEvent: CumulusPalletParachainSystemEvent }
  | { pallet: 'RootTesting'; palletEvent: PalletRootTestingEvent }
  | { pallet: 'Balances'; palletEvent: PalletBalancesEvent }
  | { pallet: 'TransactionPayment'; palletEvent: PalletTransactionPaymentEvent }
  | { pallet: 'ParachainStaking'; palletEvent: PalletParachainStakingEvent }
  | { pallet: 'AuthorFilter'; palletEvent: PalletAuthorSlotFilterEvent }
  | { pallet: 'AuthorMapping'; palletEvent: PalletAuthorMappingEvent }
  | { pallet: 'MoonbeamOrbiters'; palletEvent: PalletMoonbeamOrbitersEvent }
  | { pallet: 'Utility'; palletEvent: PalletUtilityEvent }
  | { pallet: 'Proxy'; palletEvent: PalletProxyEvent }
  | { pallet: 'MaintenanceMode'; palletEvent: PalletMaintenanceModeEvent }
  | { pallet: 'Identity'; palletEvent: PalletIdentityEvent }
  | { pallet: 'Migrations'; palletEvent: PalletMigrationsEvent }
  | { pallet: 'Multisig'; palletEvent: PalletMultisigEvent }
  | { pallet: 'Parameters'; palletEvent: PalletParametersEvent }
  | { pallet: 'Evm'; palletEvent: PalletEvmEvent }
  | { pallet: 'Ethereum'; palletEvent: PalletEthereumEvent }
  | { pallet: 'Scheduler'; palletEvent: PalletSchedulerEvent }
  | { pallet: 'Preimage'; palletEvent: PalletPreimageEvent }
  | { pallet: 'ConvictionVoting'; palletEvent: PalletConvictionVotingEvent }
  | { pallet: 'Referenda'; palletEvent: PalletReferendaEvent }
  | { pallet: 'Whitelist'; palletEvent: PalletWhitelistEvent }
  | { pallet: 'TreasuryCouncilCollective'; palletEvent: PalletCollectiveEvent }
  | { pallet: 'OpenTechCommitteeCollective'; palletEvent: PalletCollectiveEvent }
  | { pallet: 'Treasury'; palletEvent: PalletTreasuryEvent }
  | { pallet: 'CrowdloanRewards'; palletEvent: PalletCrowdloanRewardsEvent }
  | { pallet: 'XcmpQueue'; palletEvent: CumulusPalletXcmpQueueEvent }
  | { pallet: 'CumulusXcm'; palletEvent: CumulusPalletXcmEvent }
  | { pallet: 'PolkadotXcm'; palletEvent: PalletXcmEvent }
  | { pallet: 'Assets'; palletEvent: PalletAssetsEvent }
  | { pallet: 'AssetManager'; palletEvent: PalletAssetManagerEvent }
  | { pallet: 'XcmTransactor'; palletEvent: PalletXcmTransactorEvent }
  | { pallet: 'EthereumXcm'; palletEvent: PalletEthereumXcmEvent }
  | { pallet: 'MessageQueue'; palletEvent: PalletMessageQueueEvent }
  | { pallet: 'EvmForeignAssets'; palletEvent: PalletMoonbeamForeignAssetsEvent }
  | { pallet: 'XcmWeightTrader'; palletEvent: PalletXcmWeightTraderEvent }
  | { pallet: 'EmergencyParaXcm'; palletEvent: PalletEmergencyParaXcmEvent }
  | { pallet: 'Randomness'; palletEvent: PalletRandomnessEvent };

/**
 * Event for the System pallet.
 **/
export type FrameSystemEvent =
  /**
   * An extrinsic completed successfully.
   **/
  | { name: 'ExtrinsicSuccess'; data: { dispatchInfo: DispatchInfo } }
  /**
   * An extrinsic failed.
   **/
  | { name: 'ExtrinsicFailed'; data: { dispatchError: DispatchError; dispatchInfo: DispatchInfo } }
  /**
   * `:code` was updated.
   **/
  | { name: 'CodeUpdated' }
  /**
   * A new account was created.
   **/
  | { name: 'NewAccount'; data: { account: AccountId20 } }
  /**
   * An account was reaped.
   **/
  | { name: 'KilledAccount'; data: { account: AccountId20 } }
  /**
   * On on-chain remark happened.
   **/
  | { name: 'Remarked'; data: { sender: AccountId20; hash: H256 } }
  /**
   * An upgrade was authorized.
   **/
  | { name: 'UpgradeAuthorized'; data: { codeHash: H256; checkVersion: boolean } };

export type FrameSupportDispatchDispatchClass = 'Normal' | 'Operational' | 'Mandatory';

export type FrameSupportDispatchPays = 'Yes' | 'No';

/**
 * The `Event` enum of this pallet
 **/
export type CumulusPalletParachainSystemEvent =
  /**
   * The validation function has been scheduled to apply.
   **/
  | { name: 'ValidationFunctionStored' }
  /**
   * The validation function was applied as of the contained relay chain block number.
   **/
  | { name: 'ValidationFunctionApplied'; data: { relayChainBlockNum: number } }
  /**
   * The relay-chain aborted the upgrade process.
   **/
  | { name: 'ValidationFunctionDiscarded' }
  /**
   * Some downward messages have been received and will be processed.
   **/
  | { name: 'DownwardMessagesReceived'; data: { count: number } }
  /**
   * Downward messages were processed using the given weight.
   **/
  | { name: 'DownwardMessagesProcessed'; data: { weightUsed: SpWeightsWeightV2Weight; dmqHead: H256 } }
  /**
   * An upward message was sent to the relay chain.
   **/
  | { name: 'UpwardMessageSent'; data: { messageHash?: FixedBytes<32> | undefined } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletRootTestingEvent =
  /**
   * Event dispatched when the trigger_defensive extrinsic is called.
   **/
  'DefensiveTestCall';

/**
 * The `Event` enum of this pallet
 **/
export type PalletBalancesEvent =
  /**
   * An account was created with some free balance.
   **/
  | { name: 'Endowed'; data: { account: AccountId20; freeBalance: bigint } }
  /**
   * An account was removed whose balance was non-zero but below ExistentialDeposit,
   * resulting in an outright loss.
   **/
  | { name: 'DustLost'; data: { account: AccountId20; amount: bigint } }
  /**
   * Transfer succeeded.
   **/
  | { name: 'Transfer'; data: { from: AccountId20; to: AccountId20; amount: bigint } }
  /**
   * A balance was set by root.
   **/
  | { name: 'BalanceSet'; data: { who: AccountId20; free: bigint } }
  /**
   * Some balance was reserved (moved from free to reserved).
   **/
  | { name: 'Reserved'; data: { who: AccountId20; amount: bigint } }
  /**
   * Some balance was unreserved (moved from reserved to free).
   **/
  | { name: 'Unreserved'; data: { who: AccountId20; amount: bigint } }
  /**
   * Some balance was moved from the reserve of the first account to the second account.
   * Final argument indicates the destination balance type.
   **/
  | {
      name: 'ReserveRepatriated';
      data: {
        from: AccountId20;
        to: AccountId20;
        amount: bigint;
        destinationStatus: FrameSupportTokensMiscBalanceStatus;
      };
    }
  /**
   * Some amount was deposited (e.g. for transaction fees).
   **/
  | { name: 'Deposit'; data: { who: AccountId20; amount: bigint } }
  /**
   * Some amount was withdrawn from the account (e.g. for transaction fees).
   **/
  | { name: 'Withdraw'; data: { who: AccountId20; amount: bigint } }
  /**
   * Some amount was removed from the account (e.g. for misbehavior).
   **/
  | { name: 'Slashed'; data: { who: AccountId20; amount: bigint } }
  /**
   * Some amount was minted into an account.
   **/
  | { name: 'Minted'; data: { who: AccountId20; amount: bigint } }
  /**
   * Some amount was burned from an account.
   **/
  | { name: 'Burned'; data: { who: AccountId20; amount: bigint } }
  /**
   * Some amount was suspended from an account (it can be restored later).
   **/
  | { name: 'Suspended'; data: { who: AccountId20; amount: bigint } }
  /**
   * Some amount was restored into an account.
   **/
  | { name: 'Restored'; data: { who: AccountId20; amount: bigint } }
  /**
   * An account was upgraded.
   **/
  | { name: 'Upgraded'; data: { who: AccountId20 } }
  /**
   * Total issuance was increased by `amount`, creating a credit to be balanced.
   **/
  | { name: 'Issued'; data: { amount: bigint } }
  /**
   * Total issuance was decreased by `amount`, creating a debt to be balanced.
   **/
  | { name: 'Rescinded'; data: { amount: bigint } }
  /**
   * Some balance was locked.
   **/
  | { name: 'Locked'; data: { who: AccountId20; amount: bigint } }
  /**
   * Some balance was unlocked.
   **/
  | { name: 'Unlocked'; data: { who: AccountId20; amount: bigint } }
  /**
   * Some balance was frozen.
   **/
  | { name: 'Frozen'; data: { who: AccountId20; amount: bigint } }
  /**
   * Some balance was thawed.
   **/
  | { name: 'Thawed'; data: { who: AccountId20; amount: bigint } }
  /**
   * The `TotalIssuance` was forcefully changed.
   **/
  | { name: 'TotalIssuanceForced'; data: { old: bigint; new: bigint } };

export type FrameSupportTokensMiscBalanceStatus = 'Free' | 'Reserved';

/**
 * The `Event` enum of this pallet
 **/
export type PalletTransactionPaymentEvent =
  /**
   * A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,
   * has been paid by `who`.
   **/
  { name: 'TransactionFeePaid'; data: { who: AccountId20; actualFee: bigint; tip: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletParachainStakingEvent =
  /**
   * Started new round.
   **/
  | {
      name: 'NewRound';
      data: { startingBlock: number; round: number; selectedCollatorsNumber: number; totalBalance: bigint };
    }
  /**
   * Account joined the set of collator candidates.
   **/
  | {
      name: 'JoinedCollatorCandidates';
      data: { account: AccountId20; amountLocked: bigint; newTotalAmtLocked: bigint };
    }
  /**
   * Candidate selected for collators. Total Exposed Amount includes all delegations.
   **/
  | { name: 'CollatorChosen'; data: { round: number; collatorAccount: AccountId20; totalExposedAmount: bigint } }
  /**
   * Candidate requested to decrease a self bond.
   **/
  | {
      name: 'CandidateBondLessRequested';
      data: { candidate: AccountId20; amountToDecrease: bigint; executeRound: number };
    }
  /**
   * Candidate has increased a self bond.
   **/
  | { name: 'CandidateBondedMore'; data: { candidate: AccountId20; amount: bigint; newTotalBond: bigint } }
  /**
   * Candidate has decreased a self bond.
   **/
  | { name: 'CandidateBondedLess'; data: { candidate: AccountId20; amount: bigint; newBond: bigint } }
  /**
   * Candidate temporarily leave the set of collator candidates without unbonding.
   **/
  | { name: 'CandidateWentOffline'; data: { candidate: AccountId20 } }
  /**
   * Candidate rejoins the set of collator candidates.
   **/
  | { name: 'CandidateBackOnline'; data: { candidate: AccountId20 } }
  /**
   * Candidate has requested to leave the set of candidates.
   **/
  | {
      name: 'CandidateScheduledExit';
      data: { exitAllowedRound: number; candidate: AccountId20; scheduledExit: number };
    }
  /**
   * Cancelled request to leave the set of candidates.
   **/
  | { name: 'CancelledCandidateExit'; data: { candidate: AccountId20 } }
  /**
   * Cancelled request to decrease candidate's bond.
   **/
  | { name: 'CancelledCandidateBondLess'; data: { candidate: AccountId20; amount: bigint; executeRound: number } }
  /**
   * Candidate has left the set of candidates.
   **/
  | { name: 'CandidateLeft'; data: { exCandidate: AccountId20; unlockedAmount: bigint; newTotalAmtLocked: bigint } }
  /**
   * Delegator requested to decrease a bond for the collator candidate.
   **/
  | {
      name: 'DelegationDecreaseScheduled';
      data: { delegator: AccountId20; candidate: AccountId20; amountToDecrease: bigint; executeRound: number };
    }
  | {
      name: 'DelegationIncreased';
      data: { delegator: AccountId20; candidate: AccountId20; amount: bigint; inTop: boolean };
    }
  | {
      name: 'DelegationDecreased';
      data: { delegator: AccountId20; candidate: AccountId20; amount: bigint; inTop: boolean };
    }
  /**
   * Delegator requested to leave the set of delegators.
   **/
  | { name: 'DelegatorExitScheduled'; data: { round: number; delegator: AccountId20; scheduledExit: number } }
  /**
   * Delegator requested to revoke delegation.
   **/
  | {
      name: 'DelegationRevocationScheduled';
      data: { round: number; delegator: AccountId20; candidate: AccountId20; scheduledExit: number };
    }
  /**
   * Delegator has left the set of delegators.
   **/
  | { name: 'DelegatorLeft'; data: { delegator: AccountId20; unstakedAmount: bigint } }
  /**
   * Delegation revoked.
   **/
  | { name: 'DelegationRevoked'; data: { delegator: AccountId20; candidate: AccountId20; unstakedAmount: bigint } }
  /**
   * Delegation kicked.
   **/
  | { name: 'DelegationKicked'; data: { delegator: AccountId20; candidate: AccountId20; unstakedAmount: bigint } }
  /**
   * Cancelled a pending request to exit the set of delegators.
   **/
  | { name: 'DelegatorExitCancelled'; data: { delegator: AccountId20 } }
  /**
   * Cancelled request to change an existing delegation.
   **/
  | {
      name: 'CancelledDelegationRequest';
      data: {
        delegator: AccountId20;
        cancelledRequest: PalletParachainStakingDelegationRequestsCancelledScheduledRequest;
        collator: AccountId20;
      };
    }
  /**
   * New delegation (increase of the existing one).
   **/
  | {
      name: 'Delegation';
      data: {
        delegator: AccountId20;
        lockedAmount: bigint;
        candidate: AccountId20;
        delegatorPosition: PalletParachainStakingDelegatorAdded;
        autoCompound: Percent;
      };
    }
  /**
   * Delegation from candidate state has been remove.
   **/
  | {
      name: 'DelegatorLeftCandidate';
      data: { delegator: AccountId20; candidate: AccountId20; unstakedAmount: bigint; totalCandidateStaked: bigint };
    }
  /**
   * Paid the account (delegator or collator) the balance as liquid rewards.
   **/
  | { name: 'Rewarded'; data: { account: AccountId20; rewards: bigint } }
  /**
   * Transferred to account which holds funds reserved for parachain bond.
   **/
  | { name: 'InflationDistributed'; data: { index: number; account: AccountId20; value: bigint } }
  | {
      name: 'InflationDistributionConfigUpdated';
      data: {
        old: PalletParachainStakingInflationDistributionConfig;
        new: PalletParachainStakingInflationDistributionConfig;
      };
    }
  /**
   * Annual inflation input (first 3) was used to derive new per-round inflation (last 3)
   **/
  | {
      name: 'InflationSet';
      data: {
        annualMin: Perbill;
        annualIdeal: Perbill;
        annualMax: Perbill;
        roundMin: Perbill;
        roundIdeal: Perbill;
        roundMax: Perbill;
      };
    }
  /**
   * Staking expectations set.
   **/
  | { name: 'StakeExpectationsSet'; data: { expectMin: bigint; expectIdeal: bigint; expectMax: bigint } }
  /**
   * Set total selected candidates to this value.
   **/
  | { name: 'TotalSelectedSet'; data: { old: number; new: number } }
  /**
   * Set collator commission to this value.
   **/
  | { name: 'CollatorCommissionSet'; data: { old: Perbill; new: Perbill } }
  /**
   * Set blocks per round
   **/
  | {
      name: 'BlocksPerRoundSet';
      data: {
        currentRound: number;
        firstBlock: number;
        old: number;
        new: number;
        newPerRoundInflationMin: Perbill;
        newPerRoundInflationIdeal: Perbill;
        newPerRoundInflationMax: Perbill;
      };
    }
  /**
   * Auto-compounding reward percent was set for a delegation.
   **/
  | { name: 'AutoCompoundSet'; data: { candidate: AccountId20; delegator: AccountId20; value: Percent } }
  /**
   * Compounded a portion of rewards towards the delegation.
   **/
  | { name: 'Compounded'; data: { candidate: AccountId20; delegator: AccountId20; amount: bigint } };

export type PalletParachainStakingDelegationRequestsCancelledScheduledRequest = {
  whenExecutable: number;
  action: PalletParachainStakingDelegationRequestsDelegationAction;
};

export type PalletParachainStakingDelegationRequestsDelegationAction =
  | { type: 'Revoke'; value: bigint }
  | { type: 'Decrease'; value: bigint };

export type PalletParachainStakingDelegatorAdded =
  | { type: 'AddedToTop'; value: { newTotal: bigint } }
  | { type: 'AddedToBottom' };

export type PalletParachainStakingInflationDistributionConfig = FixedArray<
  PalletParachainStakingInflationDistributionAccount,
  2
>;

export type PalletParachainStakingInflationDistributionAccount = { account: AccountId20; percent: Percent };

/**
 * The `Event` enum of this pallet
 **/
export type PalletAuthorSlotFilterEvent =
  /**
   * The amount of eligible authors for the filter to select has been changed.
   **/
  { name: 'EligibleUpdated'; data: PalletAuthorSlotFilterNumNonZeroU32 };

export type PalletAuthorSlotFilterNumNonZeroU32 = number;

/**
 * The `Event` enum of this pallet
 **/
export type PalletAuthorMappingEvent =
  /**
   * A NimbusId has been registered and mapped to an AccountId.
   **/
  | {
      name: 'KeysRegistered';
      data: {
        nimbusId: NimbusPrimitivesNimbusCryptoPublic;
        accountId: AccountId20;
        keys: SessionKeysPrimitivesVrfVrfCryptoPublic;
      };
    }
  /**
   * An NimbusId has been de-registered, and its AccountId mapping removed.
   **/
  | {
      name: 'KeysRemoved';
      data: {
        nimbusId: NimbusPrimitivesNimbusCryptoPublic;
        accountId: AccountId20;
        keys: SessionKeysPrimitivesVrfVrfCryptoPublic;
      };
    }
  /**
   * An NimbusId has been registered, replacing a previous registration and its mapping.
   **/
  | {
      name: 'KeysRotated';
      data: {
        newNimbusId: NimbusPrimitivesNimbusCryptoPublic;
        accountId: AccountId20;
        newKeys: SessionKeysPrimitivesVrfVrfCryptoPublic;
      };
    };

export type NimbusPrimitivesNimbusCryptoPublic = FixedBytes<32>;

export type SessionKeysPrimitivesVrfVrfCryptoPublic = FixedBytes<32>;

/**
 * The `Event` enum of this pallet
 **/
export type PalletMoonbeamOrbitersEvent =
  /**
   * An orbiter join a collator pool
   **/
  | { name: 'OrbiterJoinCollatorPool'; data: { collator: AccountId20; orbiter: AccountId20 } }
  /**
   * An orbiter leave a collator pool
   **/
  | { name: 'OrbiterLeaveCollatorPool'; data: { collator: AccountId20; orbiter: AccountId20 } }
  /**
   * Paid the orbiter account the balance as liquid rewards.
   **/
  | { name: 'OrbiterRewarded'; data: { account: AccountId20; rewards: bigint } }
  | {
      name: 'OrbiterRotation';
      data: { collator: AccountId20; oldOrbiter?: AccountId20 | undefined; newOrbiter?: AccountId20 | undefined };
    }
  /**
   * An orbiter has registered
   **/
  | { name: 'OrbiterRegistered'; data: { account: AccountId20; deposit: bigint } }
  /**
   * An orbiter has unregistered
   **/
  | { name: 'OrbiterUnregistered'; data: { account: AccountId20 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletUtilityEvent =
  /**
   * Batch of dispatches did not complete fully. Index of first failing dispatch given, as
   * well as the error.
   **/
  | { name: 'BatchInterrupted'; data: { index: number; error: DispatchError } }
  /**
   * Batch of dispatches completed fully with no error.
   **/
  | { name: 'BatchCompleted' }
  /**
   * Batch of dispatches completed but has errors.
   **/
  | { name: 'BatchCompletedWithErrors' }
  /**
   * A single item within a Batch of dispatches has completed with no error.
   **/
  | { name: 'ItemCompleted' }
  /**
   * A single item within a Batch of dispatches has completed with error.
   **/
  | { name: 'ItemFailed'; data: { error: DispatchError } }
  /**
   * A call was dispatched.
   **/
  | { name: 'DispatchedAs'; data: { result: Result<[], DispatchError> } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletProxyEvent =
  /**
   * A proxy was executed correctly, with the given.
   **/
  | { name: 'ProxyExecuted'; data: { result: Result<[], DispatchError> } }
  /**
   * A pure account has been created by new proxy with given
   * disambiguation index and proxy type.
   **/
  | {
      name: 'PureCreated';
      data: { pure: AccountId20; who: AccountId20; proxyType: MoonbeamRuntimeProxyType; disambiguationIndex: number };
    }
  /**
   * An announcement was placed to make a call in the future.
   **/
  | { name: 'Announced'; data: { real: AccountId20; proxy: AccountId20; callHash: H256 } }
  /**
   * A proxy was added.
   **/
  | {
      name: 'ProxyAdded';
      data: { delegator: AccountId20; delegatee: AccountId20; proxyType: MoonbeamRuntimeProxyType; delay: number };
    }
  /**
   * A proxy was removed.
   **/
  | {
      name: 'ProxyRemoved';
      data: { delegator: AccountId20; delegatee: AccountId20; proxyType: MoonbeamRuntimeProxyType; delay: number };
    };

export type MoonbeamRuntimeProxyType =
  | 'Any'
  | 'NonTransfer'
  | 'Governance'
  | 'Staking'
  | 'CancelProxy'
  | 'Balances'
  | 'AuthorMapping'
  | 'IdentityJudgement';

/**
 * The `Event` enum of this pallet
 **/
export type PalletMaintenanceModeEvent =
  /**
   * The chain was put into Maintenance Mode
   **/
  | { name: 'EnteredMaintenanceMode' }
  /**
   * The chain returned to its normal operating state
   **/
  | { name: 'NormalOperationResumed' }
  /**
   * The call to suspend on_idle XCM execution failed with inner error
   **/
  | { name: 'FailedToSuspendIdleXcmExecution'; data: { error: DispatchError } }
  /**
   * The call to resume on_idle XCM execution failed with inner error
   **/
  | { name: 'FailedToResumeIdleXcmExecution'; data: { error: DispatchError } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletIdentityEvent =
  /**
   * A name was set or reset (which will remove all judgements).
   **/
  | { name: 'IdentitySet'; data: { who: AccountId20 } }
  /**
   * A name was cleared, and the given balance returned.
   **/
  | { name: 'IdentityCleared'; data: { who: AccountId20; deposit: bigint } }
  /**
   * A name was removed and the given balance slashed.
   **/
  | { name: 'IdentityKilled'; data: { who: AccountId20; deposit: bigint } }
  /**
   * A judgement was asked from a registrar.
   **/
  | { name: 'JudgementRequested'; data: { who: AccountId20; registrarIndex: number } }
  /**
   * A judgement request was retracted.
   **/
  | { name: 'JudgementUnrequested'; data: { who: AccountId20; registrarIndex: number } }
  /**
   * A judgement was given by a registrar.
   **/
  | { name: 'JudgementGiven'; data: { target: AccountId20; registrarIndex: number } }
  /**
   * A registrar was added.
   **/
  | { name: 'RegistrarAdded'; data: { registrarIndex: number } }
  /**
   * A sub-identity was added to an identity and the deposit paid.
   **/
  | { name: 'SubIdentityAdded'; data: { sub: AccountId20; main: AccountId20; deposit: bigint } }
  /**
   * A sub-identity was removed from an identity and the deposit freed.
   **/
  | { name: 'SubIdentityRemoved'; data: { sub: AccountId20; main: AccountId20; deposit: bigint } }
  /**
   * A sub-identity was cleared, and the given deposit repatriated from the
   * main identity account to the sub-identity account.
   **/
  | { name: 'SubIdentityRevoked'; data: { sub: AccountId20; main: AccountId20; deposit: bigint } }
  /**
   * A username authority was added.
   **/
  | { name: 'AuthorityAdded'; data: { authority: AccountId20 } }
  /**
   * A username authority was removed.
   **/
  | { name: 'AuthorityRemoved'; data: { authority: AccountId20 } }
  /**
   * A username was set for `who`.
   **/
  | { name: 'UsernameSet'; data: { who: AccountId20; username: Bytes } }
  /**
   * A username was queued, but `who` must accept it prior to `expiration`.
   **/
  | { name: 'UsernameQueued'; data: { who: AccountId20; username: Bytes; expiration: number } }
  /**
   * A queued username passed its expiration without being claimed and was removed.
   **/
  | { name: 'PreapprovalExpired'; data: { whose: AccountId20 } }
  /**
   * A username was set as a primary and can be looked up from `who`.
   **/
  | { name: 'PrimaryUsernameSet'; data: { who: AccountId20; username: Bytes } }
  /**
   * A dangling username (as in, a username corresponding to an account that has removed its
   * identity) has been removed.
   **/
  | { name: 'DanglingUsernameRemoved'; data: { who: AccountId20; username: Bytes } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletMigrationsEvent =
  /**
   * Runtime upgrade started
   **/
  | { name: 'RuntimeUpgradeStarted' }
  /**
   * Runtime upgrade completed
   **/
  | { name: 'RuntimeUpgradeCompleted'; data: { weight: SpWeightsWeightV2Weight } }
  /**
   * Migration started
   **/
  | { name: 'MigrationStarted'; data: { migrationName: Bytes } }
  /**
   * Migration completed
   **/
  | { name: 'MigrationCompleted'; data: { migrationName: Bytes; consumedWeight: SpWeightsWeightV2Weight } }
  /**
   * XCM execution suspension failed with inner error
   **/
  | { name: 'FailedToSuspendIdleXcmExecution'; data: { error: DispatchError } }
  /**
   * XCM execution resume failed with inner error
   **/
  | { name: 'FailedToResumeIdleXcmExecution'; data: { error: DispatchError } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletMultisigEvent =
  /**
   * A new multisig operation has begun.
   **/
  | { name: 'NewMultisig'; data: { approving: AccountId20; multisig: AccountId20; callHash: FixedBytes<32> } }
  /**
   * A multisig operation has been approved by someone.
   **/
  | {
      name: 'MultisigApproval';
      data: {
        approving: AccountId20;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId20;
        callHash: FixedBytes<32>;
      };
    }
  /**
   * A multisig operation has been executed.
   **/
  | {
      name: 'MultisigExecuted';
      data: {
        approving: AccountId20;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId20;
        callHash: FixedBytes<32>;
        result: Result<[], DispatchError>;
      };
    }
  /**
   * A multisig operation has been cancelled.
   **/
  | {
      name: 'MultisigCancelled';
      data: {
        cancelling: AccountId20;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId20;
        callHash: FixedBytes<32>;
      };
    };

export type PalletMultisigTimepoint = { height: number; index: number };

/**
 * The `Event` enum of this pallet
 **/
export type PalletParametersEvent =
  /**
   * A Parameter was set.
   *
   * Is also emitted when the value was not changed.
   **/
  {
    name: 'Updated';
    data: {
      /**
       * The key that was updated.
       **/
      key: MoonbeamRuntimeRuntimeParamsRuntimeParametersKey;

      /**
       * The old value before this call.
       **/
      oldValue?: MoonbeamRuntimeRuntimeParamsRuntimeParametersValue | undefined;

      /**
       * The new value after this call.
       **/
      newValue?: MoonbeamRuntimeRuntimeParamsRuntimeParametersValue | undefined;
    };
  };

export type MoonbeamRuntimeRuntimeParamsRuntimeParametersKey =
  | { type: 'RuntimeConfig'; value: MoonbeamRuntimeRuntimeParamsDynamicParamsRuntimeConfigParametersKey }
  | { type: 'PalletRandomness'; value: MoonbeamRuntimeRuntimeParamsDynamicParamsPalletRandomnessParametersKey };

export type MoonbeamRuntimeRuntimeParamsDynamicParamsRuntimeConfigParametersKey = {
  type: 'FeesTreasuryProportion';
  value: MoonbeamRuntimeRuntimeParamsDynamicParamsRuntimeConfigFeesTreasuryProportion;
};

export type MoonbeamRuntimeRuntimeParamsDynamicParamsRuntimeConfigFeesTreasuryProportion = {};

export type MoonbeamRuntimeRuntimeParamsDynamicParamsPalletRandomnessParametersKey = {
  type: 'Deposit';
  value: MoonbeamRuntimeRuntimeParamsDynamicParamsPalletRandomnessDeposit;
};

export type MoonbeamRuntimeRuntimeParamsDynamicParamsPalletRandomnessDeposit = {};

export type MoonbeamRuntimeRuntimeParamsRuntimeParametersValue =
  | { type: 'RuntimeConfig'; value: MoonbeamRuntimeRuntimeParamsDynamicParamsRuntimeConfigParametersValue }
  | { type: 'PalletRandomness'; value: MoonbeamRuntimeRuntimeParamsDynamicParamsPalletRandomnessParametersValue };

export type MoonbeamRuntimeRuntimeParamsDynamicParamsRuntimeConfigParametersValue = {
  type: 'FeesTreasuryProportion';
  value: Perbill;
};

export type MoonbeamRuntimeRuntimeParamsDynamicParamsPalletRandomnessParametersValue = {
  type: 'Deposit';
  value: MoonbeamRuntimeCommonBoundedU128;
};

export type MoonbeamRuntimeCommonBoundedU128 = bigint;

/**
 * The `Event` enum of this pallet
 **/
export type PalletEvmEvent =
  /**
   * Ethereum events from contracts.
   **/
  | { name: 'Log'; data: { log: EthereumLog } }
  /**
   * A contract has been created at given address.
   **/
  | { name: 'Created'; data: { address: H160 } }
  /**
   * A contract was attempted to be created, but the execution failed.
   **/
  | { name: 'CreatedFailed'; data: { address: H160 } }
  /**
   * A contract has been executed successfully with states applied.
   **/
  | { name: 'Executed'; data: { address: H160 } }
  /**
   * A contract has been executed with errors. States are reverted with only gas fees applied.
   **/
  | { name: 'ExecutedFailed'; data: { address: H160 } };

export type EthereumLog = { address: H160; topics: Array<H256>; data: Bytes };

/**
 * The `Event` enum of this pallet
 **/
export type PalletEthereumEvent =
  /**
   * An ethereum transaction was successfully executed.
   **/
  {
    name: 'Executed';
    data: { from: H160; to: H160; transactionHash: H256; exitReason: EvmCoreErrorExitReason; extraData: Bytes };
  };

export type EvmCoreErrorExitReason =
  | { type: 'Succeed'; value: EvmCoreErrorExitSucceed }
  | { type: 'Error'; value: EvmCoreErrorExitError }
  | { type: 'Revert'; value: EvmCoreErrorExitRevert }
  | { type: 'Fatal'; value: EvmCoreErrorExitFatal };

export type EvmCoreErrorExitSucceed = 'Stopped' | 'Returned' | 'Suicided';

export type EvmCoreErrorExitError =
  | { type: 'StackUnderflow' }
  | { type: 'StackOverflow' }
  | { type: 'InvalidJump' }
  | { type: 'InvalidRange' }
  | { type: 'DesignatedInvalid' }
  | { type: 'CallTooDeep' }
  | { type: 'CreateCollision' }
  | { type: 'CreateContractLimit' }
  | { type: 'InvalidCode'; value: EvmCoreOpcode }
  | { type: 'OutOfOffset' }
  | { type: 'OutOfGas' }
  | { type: 'OutOfFund' }
  | { type: 'PcUnderflow' }
  | { type: 'CreateEmpty' }
  | { type: 'Other'; value: string }
  | { type: 'MaxNonce' };

export type EvmCoreOpcode = number;

export type EvmCoreErrorExitRevert = 'Reverted';

export type EvmCoreErrorExitFatal =
  | { type: 'NotSupported' }
  | { type: 'UnhandledInterrupt' }
  | { type: 'CallErrorAsFatal'; value: EvmCoreErrorExitError }
  | { type: 'Other'; value: string };

/**
 * Events type.
 **/
export type PalletSchedulerEvent =
  /**
   * Scheduled some task.
   **/
  | { name: 'Scheduled'; data: { when: number; index: number } }
  /**
   * Canceled some task.
   **/
  | { name: 'Canceled'; data: { when: number; index: number } }
  /**
   * Dispatched some task.
   **/
  | {
      name: 'Dispatched';
      data: { task: [number, number]; id?: FixedBytes<32> | undefined; result: Result<[], DispatchError> };
    }
  /**
   * Set a retry configuration for some task.
   **/
  | {
      name: 'RetrySet';
      data: { task: [number, number]; id?: FixedBytes<32> | undefined; period: number; retries: number };
    }
  /**
   * Cancel a retry configuration for some task.
   **/
  | { name: 'RetryCancelled'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } }
  /**
   * The call for the provided hash was not found so the task has been aborted.
   **/
  | { name: 'CallUnavailable'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } }
  /**
   * The given task was unable to be renewed since the agenda is full at that block.
   **/
  | { name: 'PeriodicFailed'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } }
  /**
   * The given task was unable to be retried since the agenda is full at that block or there
   * was not enough weight to reschedule it.
   **/
  | { name: 'RetryFailed'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } }
  /**
   * The given task can never be executed since it is overweight.
   **/
  | { name: 'PermanentlyOverweight'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletPreimageEvent =
  /**
   * A preimage has been noted.
   **/
  | { name: 'Noted'; data: { hash: H256 } }
  /**
   * A preimage has been requested.
   **/
  | { name: 'Requested'; data: { hash: H256 } }
  /**
   * A preimage has ben cleared.
   **/
  | { name: 'Cleared'; data: { hash: H256 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletConvictionVotingEvent =
  /**
   * An account has delegated their vote to another account. \[who, target\]
   **/
  | { name: 'Delegated'; data: [AccountId20, AccountId20] }
  /**
   * An \[account\] has cancelled a previous delegation operation.
   **/
  | { name: 'Undelegated'; data: AccountId20 };

/**
 * The `Event` enum of this pallet
 **/
export type PalletReferendaEvent =
  /**
   * A referendum has been submitted.
   **/
  | {
      name: 'Submitted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The track (and by extension proposal dispatch origin) of this referendum.
         **/
        track: number;

        /**
         * The proposal for the referendum.
         **/
        proposal: FrameSupportPreimagesBounded;
      };
    }
  /**
   * The decision deposit has been placed.
   **/
  | {
      name: 'DecisionDepositPlaced';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId20;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * The decision deposit has been refunded.
   **/
  | {
      name: 'DecisionDepositRefunded';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId20;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * A deposit has been slashed.
   **/
  | {
      name: 'DepositSlashed';
      data: {
        /**
         * The account who placed the deposit.
         **/
        who: AccountId20;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * A referendum has moved into the deciding phase.
   **/
  | {
      name: 'DecisionStarted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The track (and by extension proposal dispatch origin) of this referendum.
         **/
        track: number;

        /**
         * The proposal for the referendum.
         **/
        proposal: FrameSupportPreimagesBounded;

        /**
         * The current tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  | {
      name: 'ConfirmStarted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  | {
      name: 'ConfirmAborted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  /**
   * A referendum has ended its confirmation phase and is ready for approval.
   **/
  | {
      name: 'Confirmed';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  /**
   * A referendum has been approved and its proposal has been scheduled.
   **/
  | {
      name: 'Approved';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  /**
   * A proposal has been rejected by referendum.
   **/
  | {
      name: 'Rejected';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  /**
   * A referendum has been timed out without being decided.
   **/
  | {
      name: 'TimedOut';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  /**
   * A referendum has been cancelled.
   **/
  | {
      name: 'Cancelled';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  /**
   * A referendum has been killed.
   **/
  | {
      name: 'Killed';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  /**
   * The submission deposit has been refunded.
   **/
  | {
      name: 'SubmissionDepositRefunded';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId20;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * Metadata for a referendum has been set.
   **/
  | {
      name: 'MetadataSet';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    }
  /**
   * Metadata for a referendum has been cleared.
   **/
  | {
      name: 'MetadataCleared';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    };

export type FrameSupportPreimagesBounded =
  | { type: 'Legacy'; value: { hash: H256 } }
  | { type: 'Inline'; value: Bytes }
  | { type: 'Lookup'; value: { hash: H256; len: number } };

export type MoonbeamRuntimeRuntimeCall =
  | { pallet: 'System'; palletCall: FrameSystemCall }
  | { pallet: 'ParachainSystem'; palletCall: CumulusPalletParachainSystemCall }
  | { pallet: 'Timestamp'; palletCall: PalletTimestampCall }
  | { pallet: 'RootTesting'; palletCall: PalletRootTestingCall }
  | { pallet: 'Balances'; palletCall: PalletBalancesCall }
  | { pallet: 'ParachainStaking'; palletCall: PalletParachainStakingCall }
  | { pallet: 'AuthorInherent'; palletCall: PalletAuthorInherentCall }
  | { pallet: 'AuthorFilter'; palletCall: PalletAuthorSlotFilterCall }
  | { pallet: 'AuthorMapping'; palletCall: PalletAuthorMappingCall }
  | { pallet: 'MoonbeamOrbiters'; palletCall: PalletMoonbeamOrbitersCall }
  | { pallet: 'Utility'; palletCall: PalletUtilityCall }
  | { pallet: 'Proxy'; palletCall: PalletProxyCall }
  | { pallet: 'MaintenanceMode'; palletCall: PalletMaintenanceModeCall }
  | { pallet: 'Identity'; palletCall: PalletIdentityCall }
  | { pallet: 'Multisig'; palletCall: PalletMultisigCall }
  | { pallet: 'MoonbeamLazyMigrations'; palletCall: PalletMoonbeamLazyMigrationsCall }
  | { pallet: 'Parameters'; palletCall: PalletParametersCall }
  | { pallet: 'Evm'; palletCall: PalletEvmCall }
  | { pallet: 'Ethereum'; palletCall: PalletEthereumCall }
  | { pallet: 'Scheduler'; palletCall: PalletSchedulerCall }
  | { pallet: 'Preimage'; palletCall: PalletPreimageCall }
  | { pallet: 'ConvictionVoting'; palletCall: PalletConvictionVotingCall }
  | { pallet: 'Referenda'; palletCall: PalletReferendaCall }
  | { pallet: 'Whitelist'; palletCall: PalletWhitelistCall }
  | { pallet: 'TreasuryCouncilCollective'; palletCall: PalletCollectiveCall }
  | { pallet: 'OpenTechCommitteeCollective'; palletCall: PalletCollectiveCall }
  | { pallet: 'Treasury'; palletCall: PalletTreasuryCall }
  | { pallet: 'CrowdloanRewards'; palletCall: PalletCrowdloanRewardsCall }
  | { pallet: 'PolkadotXcm'; palletCall: PalletXcmCall }
  | { pallet: 'Assets'; palletCall: PalletAssetsCall }
  | { pallet: 'AssetManager'; palletCall: PalletAssetManagerCall }
  | { pallet: 'XcmTransactor'; palletCall: PalletXcmTransactorCall }
  | { pallet: 'EthereumXcm'; palletCall: PalletEthereumXcmCall }
  | { pallet: 'MessageQueue'; palletCall: PalletMessageQueueCall }
  | { pallet: 'EvmForeignAssets'; palletCall: PalletMoonbeamForeignAssetsCall }
  | { pallet: 'XcmWeightTrader'; palletCall: PalletXcmWeightTraderCall }
  | { pallet: 'EmergencyParaXcm'; palletCall: PalletEmergencyParaXcmCall }
  | { pallet: 'Randomness'; palletCall: PalletRandomnessCall };

export type MoonbeamRuntimeRuntimeCallLike =
  | { pallet: 'System'; palletCall: FrameSystemCallLike }
  | { pallet: 'ParachainSystem'; palletCall: CumulusPalletParachainSystemCallLike }
  | { pallet: 'Timestamp'; palletCall: PalletTimestampCallLike }
  | { pallet: 'RootTesting'; palletCall: PalletRootTestingCallLike }
  | { pallet: 'Balances'; palletCall: PalletBalancesCallLike }
  | { pallet: 'ParachainStaking'; palletCall: PalletParachainStakingCallLike }
  | { pallet: 'AuthorInherent'; palletCall: PalletAuthorInherentCallLike }
  | { pallet: 'AuthorFilter'; palletCall: PalletAuthorSlotFilterCallLike }
  | { pallet: 'AuthorMapping'; palletCall: PalletAuthorMappingCallLike }
  | { pallet: 'MoonbeamOrbiters'; palletCall: PalletMoonbeamOrbitersCallLike }
  | { pallet: 'Utility'; palletCall: PalletUtilityCallLike }
  | { pallet: 'Proxy'; palletCall: PalletProxyCallLike }
  | { pallet: 'MaintenanceMode'; palletCall: PalletMaintenanceModeCallLike }
  | { pallet: 'Identity'; palletCall: PalletIdentityCallLike }
  | { pallet: 'Multisig'; palletCall: PalletMultisigCallLike }
  | { pallet: 'MoonbeamLazyMigrations'; palletCall: PalletMoonbeamLazyMigrationsCallLike }
  | { pallet: 'Parameters'; palletCall: PalletParametersCallLike }
  | { pallet: 'Evm'; palletCall: PalletEvmCallLike }
  | { pallet: 'Ethereum'; palletCall: PalletEthereumCallLike }
  | { pallet: 'Scheduler'; palletCall: PalletSchedulerCallLike }
  | { pallet: 'Preimage'; palletCall: PalletPreimageCallLike }
  | { pallet: 'ConvictionVoting'; palletCall: PalletConvictionVotingCallLike }
  | { pallet: 'Referenda'; palletCall: PalletReferendaCallLike }
  | { pallet: 'Whitelist'; palletCall: PalletWhitelistCallLike }
  | { pallet: 'TreasuryCouncilCollective'; palletCall: PalletCollectiveCallLike }
  | { pallet: 'OpenTechCommitteeCollective'; palletCall: PalletCollectiveCallLike }
  | { pallet: 'Treasury'; palletCall: PalletTreasuryCallLike }
  | { pallet: 'CrowdloanRewards'; palletCall: PalletCrowdloanRewardsCallLike }
  | { pallet: 'PolkadotXcm'; palletCall: PalletXcmCallLike }
  | { pallet: 'Assets'; palletCall: PalletAssetsCallLike }
  | { pallet: 'AssetManager'; palletCall: PalletAssetManagerCallLike }
  | { pallet: 'XcmTransactor'; palletCall: PalletXcmTransactorCallLike }
  | { pallet: 'EthereumXcm'; palletCall: PalletEthereumXcmCallLike }
  | { pallet: 'MessageQueue'; palletCall: PalletMessageQueueCallLike }
  | { pallet: 'EvmForeignAssets'; palletCall: PalletMoonbeamForeignAssetsCallLike }
  | { pallet: 'XcmWeightTrader'; palletCall: PalletXcmWeightTraderCallLike }
  | { pallet: 'EmergencyParaXcm'; palletCall: PalletEmergencyParaXcmCallLike }
  | { pallet: 'Randomness'; palletCall: PalletRandomnessCallLike };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type FrameSystemCall =
  /**
   * Make some on-chain remark.
   *
   * Can be executed by every `origin`.
   **/
  | { name: 'Remark'; params: { remark: Bytes } }
  /**
   * Set the number of pages in the WebAssembly environment's heap.
   **/
  | { name: 'SetHeapPages'; params: { pages: bigint } }
  /**
   * Set the new runtime code.
   **/
  | { name: 'SetCode'; params: { code: Bytes } }
  /**
   * Set the new runtime code without doing any checks of the given `code`.
   *
   * Note that runtime upgrades will not run if this is called with a not-increasing spec
   * version!
   **/
  | { name: 'SetCodeWithoutChecks'; params: { code: Bytes } }
  /**
   * Set some items of storage.
   **/
  | { name: 'SetStorage'; params: { items: Array<[Bytes, Bytes]> } }
  /**
   * Kill some items from storage.
   **/
  | { name: 'KillStorage'; params: { keys: Array<Bytes> } }
  /**
   * Kill all storage items with a key that starts with the given prefix.
   *
   * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
   * the prefix we are removing to accurately calculate the weight of this function.
   **/
  | { name: 'KillPrefix'; params: { prefix: Bytes; subkeys: number } }
  /**
   * Make some on-chain remark and emit event.
   **/
  | { name: 'RemarkWithEvent'; params: { remark: Bytes } }
  /**
   * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
   * later.
   *
   * This call requires Root origin.
   **/
  | { name: 'AuthorizeUpgrade'; params: { codeHash: H256 } }
  /**
   * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
   * later.
   *
   * WARNING: This authorizes an upgrade that will take place without any safety checks, for
   * example that the spec name remains the same and that the version number increases. Not
   * recommended for normal use. Use `authorize_upgrade` instead.
   *
   * This call requires Root origin.
   **/
  | { name: 'AuthorizeUpgradeWithoutChecks'; params: { codeHash: H256 } }
  /**
   * Provide the preimage (runtime binary) `code` for an upgrade that has been authorized.
   *
   * If the authorization required a version check, this call will ensure the spec name
   * remains unchanged and that the spec version has increased.
   *
   * Depending on the runtime's `OnSetCode` configuration, this function may directly apply
   * the new `code` in the same block or attempt to schedule the upgrade.
   *
   * All origins are allowed.
   **/
  | { name: 'ApplyAuthorizedUpgrade'; params: { code: Bytes } };

export type FrameSystemCallLike =
  /**
   * Make some on-chain remark.
   *
   * Can be executed by every `origin`.
   **/
  | { name: 'Remark'; params: { remark: BytesLike } }
  /**
   * Set the number of pages in the WebAssembly environment's heap.
   **/
  | { name: 'SetHeapPages'; params: { pages: bigint } }
  /**
   * Set the new runtime code.
   **/
  | { name: 'SetCode'; params: { code: BytesLike } }
  /**
   * Set the new runtime code without doing any checks of the given `code`.
   *
   * Note that runtime upgrades will not run if this is called with a not-increasing spec
   * version!
   **/
  | { name: 'SetCodeWithoutChecks'; params: { code: BytesLike } }
  /**
   * Set some items of storage.
   **/
  | { name: 'SetStorage'; params: { items: Array<[BytesLike, BytesLike]> } }
  /**
   * Kill some items from storage.
   **/
  | { name: 'KillStorage'; params: { keys: Array<BytesLike> } }
  /**
   * Kill all storage items with a key that starts with the given prefix.
   *
   * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
   * the prefix we are removing to accurately calculate the weight of this function.
   **/
  | { name: 'KillPrefix'; params: { prefix: BytesLike; subkeys: number } }
  /**
   * Make some on-chain remark and emit event.
   **/
  | { name: 'RemarkWithEvent'; params: { remark: BytesLike } }
  /**
   * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
   * later.
   *
   * This call requires Root origin.
   **/
  | { name: 'AuthorizeUpgrade'; params: { codeHash: H256 } }
  /**
   * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
   * later.
   *
   * WARNING: This authorizes an upgrade that will take place without any safety checks, for
   * example that the spec name remains the same and that the version number increases. Not
   * recommended for normal use. Use `authorize_upgrade` instead.
   *
   * This call requires Root origin.
   **/
  | { name: 'AuthorizeUpgradeWithoutChecks'; params: { codeHash: H256 } }
  /**
   * Provide the preimage (runtime binary) `code` for an upgrade that has been authorized.
   *
   * If the authorization required a version check, this call will ensure the spec name
   * remains unchanged and that the spec version has increased.
   *
   * Depending on the runtime's `OnSetCode` configuration, this function may directly apply
   * the new `code` in the same block or attempt to schedule the upgrade.
   *
   * All origins are allowed.
   **/
  | { name: 'ApplyAuthorizedUpgrade'; params: { code: BytesLike } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type CumulusPalletParachainSystemCall =
  /**
   * Set the current validation data.
   *
   * This should be invoked exactly once per block. It will panic at the finalization
   * phase if the call was not invoked.
   *
   * The dispatch origin for this call must be `Inherent`
   *
   * As a side effect, this function upgrades the current validation function
   * if the appropriate time has come.
   **/
  | { name: 'SetValidationData'; params: { data: CumulusPrimitivesParachainInherentParachainInherentData } }
  | { name: 'SudoSendUpwardMessage'; params: { message: Bytes } }
  /**
   * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
   * later.
   *
   * The `check_version` parameter sets a boolean flag for whether or not the runtime's spec
   * version and name should be verified on upgrade. Since the authorization only has a hash,
   * it cannot actually perform the verification.
   *
   * This call requires Root origin.
   **/
  | { name: 'AuthorizeUpgrade'; params: { codeHash: H256; checkVersion: boolean } }
  /**
   * Provide the preimage (runtime binary) `code` for an upgrade that has been authorized.
   *
   * If the authorization required a version check, this call will ensure the spec name
   * remains unchanged and that the spec version has increased.
   *
   * Note that this function will not apply the new `code`, but only attempt to schedule the
   * upgrade with the Relay Chain.
   *
   * All origins are allowed.
   **/
  | { name: 'EnactAuthorizedUpgrade'; params: { code: Bytes } };

export type CumulusPalletParachainSystemCallLike =
  /**
   * Set the current validation data.
   *
   * This should be invoked exactly once per block. It will panic at the finalization
   * phase if the call was not invoked.
   *
   * The dispatch origin for this call must be `Inherent`
   *
   * As a side effect, this function upgrades the current validation function
   * if the appropriate time has come.
   **/
  | { name: 'SetValidationData'; params: { data: CumulusPrimitivesParachainInherentParachainInherentData } }
  | { name: 'SudoSendUpwardMessage'; params: { message: BytesLike } }
  /**
   * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
   * later.
   *
   * The `check_version` parameter sets a boolean flag for whether or not the runtime's spec
   * version and name should be verified on upgrade. Since the authorization only has a hash,
   * it cannot actually perform the verification.
   *
   * This call requires Root origin.
   **/
  | { name: 'AuthorizeUpgrade'; params: { codeHash: H256; checkVersion: boolean } }
  /**
   * Provide the preimage (runtime binary) `code` for an upgrade that has been authorized.
   *
   * If the authorization required a version check, this call will ensure the spec name
   * remains unchanged and that the spec version has increased.
   *
   * Note that this function will not apply the new `code`, but only attempt to schedule the
   * upgrade with the Relay Chain.
   *
   * All origins are allowed.
   **/
  | { name: 'EnactAuthorizedUpgrade'; params: { code: BytesLike } };

export type CumulusPrimitivesParachainInherentParachainInherentData = {
  validationData: PolkadotPrimitivesV7PersistedValidationData;
  relayChainState: SpTrieStorageProof;
  downwardMessages: Array<PolkadotCorePrimitivesInboundDownwardMessage>;
  horizontalMessages: Array<[PolkadotParachainPrimitivesPrimitivesId, Array<PolkadotCorePrimitivesInboundHrmpMessage>]>;
};

export type PolkadotPrimitivesV7PersistedValidationData = {
  parentHead: PolkadotParachainPrimitivesPrimitivesHeadData;
  relayParentNumber: number;
  relayParentStorageRoot: H256;
  maxPovSize: number;
};

export type PolkadotParachainPrimitivesPrimitivesHeadData = Bytes;

export type SpTrieStorageProof = { trieNodes: Array<Bytes> };

export type PolkadotCorePrimitivesInboundDownwardMessage = { sentAt: number; msg: Bytes };

export type PolkadotParachainPrimitivesPrimitivesId = number;

export type PolkadotCorePrimitivesInboundHrmpMessage = { sentAt: number; data: Bytes };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTimestampCall =
  /**
   * Set the current time.
   *
   * This call should be invoked exactly once per block. It will panic at the finalization
   * phase, if this call hasn't been invoked by that time.
   *
   * The timestamp should be greater than the previous one by the amount specified by
   * [`Config::MinimumPeriod`].
   *
   * The dispatch origin for this call must be _None_.
   *
   * This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware
   * that changing the complexity of this call could result exhausting the resources in a
   * block to execute any other calls.
   *
   * ## Complexity
   * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
   * - 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in
   * `on_finalize`)
   * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
   **/
  { name: 'Set'; params: { now: bigint } };

export type PalletTimestampCallLike =
  /**
   * Set the current time.
   *
   * This call should be invoked exactly once per block. It will panic at the finalization
   * phase, if this call hasn't been invoked by that time.
   *
   * The timestamp should be greater than the previous one by the amount specified by
   * [`Config::MinimumPeriod`].
   *
   * The dispatch origin for this call must be _None_.
   *
   * This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware
   * that changing the complexity of this call could result exhausting the resources in a
   * block to execute any other calls.
   *
   * ## Complexity
   * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
   * - 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in
   * `on_finalize`)
   * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
   **/
  { name: 'Set'; params: { now: bigint } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletRootTestingCall =
  /**
   * A dispatch that will fill the block weight up to the given ratio.
   **/
  { name: 'FillBlock'; params: { ratio: Perbill } } | { name: 'TriggerDefensive' };

export type PalletRootTestingCallLike =
  /**
   * A dispatch that will fill the block weight up to the given ratio.
   **/
  { name: 'FillBlock'; params: { ratio: Perbill } } | { name: 'TriggerDefensive' };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBalancesCall =
  /**
   * Transfer some liquid free balance to another account.
   *
   * `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
   * If the sender's account is below the existential deposit as a result
   * of the transfer, the account will be reaped.
   *
   * The dispatch origin for this call must be `Signed` by the transactor.
   **/
  | { name: 'TransferAllowDeath'; params: { dest: AccountId20; value: bigint } }
  /**
   * Exactly as `transfer_allow_death`, except the origin must be root and the source account
   * may be specified.
   **/
  | { name: 'ForceTransfer'; params: { source: AccountId20; dest: AccountId20; value: bigint } }
  /**
   * Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
   * kill the origin account.
   *
   * 99% of the time you want [`transfer_allow_death`] instead.
   *
   * [`transfer_allow_death`]: struct.Pallet.html#method.transfer
   **/
  | { name: 'TransferKeepAlive'; params: { dest: AccountId20; value: bigint } }
  /**
   * Transfer the entire transferable balance from the caller account.
   *
   * NOTE: This function only attempts to transfer _transferable_ balances. This means that
   * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
   * transferred by this function. To ensure that this function results in a killed account,
   * you might need to prepare the account by removing any reference counters, storage
   * deposits, etc...
   *
   * The dispatch origin of this call must be Signed.
   *
   * - `dest`: The recipient of the transfer.
   * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
   * of the funds the account has, causing the sender account to be killed (false), or
   * transfer everything except at least the existential deposit, which will guarantee to
   * keep the sender account alive (true).
   **/
  | { name: 'TransferAll'; params: { dest: AccountId20; keepAlive: boolean } }
  /**
   * Unreserve some balance from a user by force.
   *
   * Can only be called by ROOT.
   **/
  | { name: 'ForceUnreserve'; params: { who: AccountId20; amount: bigint } }
  /**
   * Upgrade a specified account.
   *
   * - `origin`: Must be `Signed`.
   * - `who`: The account to be upgraded.
   *
   * This will waive the transaction fee if at least all but 10% of the accounts needed to
   * be upgraded. (We let some not have to be upgraded just in order to allow for the
   * possibility of churn).
   **/
  | { name: 'UpgradeAccounts'; params: { who: Array<AccountId20> } }
  /**
   * Set the regular balance of a given account.
   *
   * The dispatch origin for this call is `root`.
   **/
  | { name: 'ForceSetBalance'; params: { who: AccountId20; newFree: bigint } }
  /**
   * Adjust the total issuance in a saturating way.
   *
   * Can only be called by root and always needs a positive `delta`.
   *
   * # Example
   **/
  | { name: 'ForceAdjustTotalIssuance'; params: { direction: PalletBalancesAdjustmentDirection; delta: bigint } }
  /**
   * Burn the specified liquid free balance from the origin account.
   *
   * If the origin's account ends up below the existential deposit as a result
   * of the burn and `keep_alive` is false, the account will be reaped.
   *
   * Unlike sending funds to a _burn_ address, which merely makes the funds inaccessible,
   * this `burn` operation will reduce total issuance by the amount _burned_.
   **/
  | { name: 'Burn'; params: { value: bigint; keepAlive: boolean } };

export type PalletBalancesCallLike =
  /**
   * Transfer some liquid free balance to another account.
   *
   * `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
   * If the sender's account is below the existential deposit as a result
   * of the transfer, the account will be reaped.
   *
   * The dispatch origin for this call must be `Signed` by the transactor.
   **/
  | { name: 'TransferAllowDeath'; params: { dest: AccountId20Like; value: bigint } }
  /**
   * Exactly as `transfer_allow_death`, except the origin must be root and the source account
   * may be specified.
   **/
  | { name: 'ForceTransfer'; params: { source: AccountId20Like; dest: AccountId20Like; value: bigint } }
  /**
   * Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
   * kill the origin account.
   *
   * 99% of the time you want [`transfer_allow_death`] instead.
   *
   * [`transfer_allow_death`]: struct.Pallet.html#method.transfer
   **/
  | { name: 'TransferKeepAlive'; params: { dest: AccountId20Like; value: bigint } }
  /**
   * Transfer the entire transferable balance from the caller account.
   *
   * NOTE: This function only attempts to transfer _transferable_ balances. This means that
   * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
   * transferred by this function. To ensure that this function results in a killed account,
   * you might need to prepare the account by removing any reference counters, storage
   * deposits, etc...
   *
   * The dispatch origin of this call must be Signed.
   *
   * - `dest`: The recipient of the transfer.
   * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
   * of the funds the account has, causing the sender account to be killed (false), or
   * transfer everything except at least the existential deposit, which will guarantee to
   * keep the sender account alive (true).
   **/
  | { name: 'TransferAll'; params: { dest: AccountId20Like; keepAlive: boolean } }
  /**
   * Unreserve some balance from a user by force.
   *
   * Can only be called by ROOT.
   **/
  | { name: 'ForceUnreserve'; params: { who: AccountId20Like; amount: bigint } }
  /**
   * Upgrade a specified account.
   *
   * - `origin`: Must be `Signed`.
   * - `who`: The account to be upgraded.
   *
   * This will waive the transaction fee if at least all but 10% of the accounts needed to
   * be upgraded. (We let some not have to be upgraded just in order to allow for the
   * possibility of churn).
   **/
  | { name: 'UpgradeAccounts'; params: { who: Array<AccountId20Like> } }
  /**
   * Set the regular balance of a given account.
   *
   * The dispatch origin for this call is `root`.
   **/
  | { name: 'ForceSetBalance'; params: { who: AccountId20Like; newFree: bigint } }
  /**
   * Adjust the total issuance in a saturating way.
   *
   * Can only be called by root and always needs a positive `delta`.
   *
   * # Example
   **/
  | { name: 'ForceAdjustTotalIssuance'; params: { direction: PalletBalancesAdjustmentDirection; delta: bigint } }
  /**
   * Burn the specified liquid free balance from the origin account.
   *
   * If the origin's account ends up below the existential deposit as a result
   * of the burn and `keep_alive` is false, the account will be reaped.
   *
   * Unlike sending funds to a _burn_ address, which merely makes the funds inaccessible,
   * this `burn` operation will reduce total issuance by the amount _burned_.
   **/
  | { name: 'Burn'; params: { value: bigint; keepAlive: boolean } };

export type PalletBalancesAdjustmentDirection = 'Increase' | 'Decrease';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletParachainStakingCall =
  /**
   * Set the expectations for total staked. These expectations determine the issuance for
   * the round according to logic in `fn compute_issuance`
   **/
  | { name: 'SetStakingExpectations'; params: { expectations: { min: bigint; ideal: bigint; max: bigint } } }
  /**
   * Set the annual inflation rate to derive per-round inflation
   **/
  | { name: 'SetInflation'; params: { schedule: { min: Perbill; ideal: Perbill; max: Perbill } } }
  /**
   * Deprecated: please use `set_inflation_distribution_config` instead.
   *
   * Set the account that will hold funds set aside for parachain bond
   **/
  | { name: 'SetParachainBondAccount'; params: { new: AccountId20 } }
  /**
   * Deprecated: please use `set_inflation_distribution_config` instead.
   *
   * Set the percent of inflation set aside for parachain bond
   **/
  | { name: 'SetParachainBondReservePercent'; params: { new: Percent } }
  /**
   * Set the total number of collator candidates selected per round
   * - changes are not applied until the start of the next round
   **/
  | { name: 'SetTotalSelected'; params: { new: number } }
  /**
   * Set the commission for all collators
   **/
  | { name: 'SetCollatorCommission'; params: { new: Perbill } }
  /**
   * Set blocks per round
   * - if called with `new` less than length of current round, will transition immediately
   * in the next block
   * - also updates per-round inflation config
   **/
  | { name: 'SetBlocksPerRound'; params: { new: number } }
  /**
   * Join the set of collator candidates
   **/
  | { name: 'JoinCandidates'; params: { bond: bigint; candidateCount: number } }
  /**
   * Request to leave the set of candidates. If successful, the account is immediately
   * removed from the candidate pool to prevent selection as a collator.
   **/
  | { name: 'ScheduleLeaveCandidates'; params: { candidateCount: number } }
  /**
   * Execute leave candidates request
   **/
  | { name: 'ExecuteLeaveCandidates'; params: { candidate: AccountId20; candidateDelegationCount: number } }
  /**
   * Cancel open request to leave candidates
   * - only callable by collator account
   * - result upon successful call is the candidate is active in the candidate pool
   **/
  | { name: 'CancelLeaveCandidates'; params: { candidateCount: number } }
  /**
   * Temporarily leave the set of collator candidates without unbonding
   **/
  | { name: 'GoOffline' }
  /**
   * Rejoin the set of collator candidates if previously had called `go_offline`
   **/
  | { name: 'GoOnline' }
  /**
   * Increase collator candidate self bond by `more`
   **/
  | { name: 'CandidateBondMore'; params: { more: bigint } }
  /**
   * Request by collator candidate to decrease self bond by `less`
   **/
  | { name: 'ScheduleCandidateBondLess'; params: { less: bigint } }
  /**
   * Execute pending request to adjust the collator candidate self bond
   **/
  | { name: 'ExecuteCandidateBondLess'; params: { candidate: AccountId20 } }
  /**
   * Cancel pending request to adjust the collator candidate self bond
   **/
  | { name: 'CancelCandidateBondLess' }
  /**
   * DEPRECATED use delegateWithAutoCompound
   * If caller is not a delegator and not a collator, then join the set of delegators
   * If caller is a delegator, then makes delegation to change their delegation state
   **/
  | {
      name: 'Delegate';
      params: { candidate: AccountId20; amount: bigint; candidateDelegationCount: number; delegationCount: number };
    }
  /**
   * If caller is not a delegator and not a collator, then join the set of delegators
   * If caller is a delegator, then makes delegation to change their delegation state
   * Sets the auto-compound config for the delegation
   **/
  | {
      name: 'DelegateWithAutoCompound';
      params: {
        candidate: AccountId20;
        amount: bigint;
        autoCompound: Percent;
        candidateDelegationCount: number;
        candidateAutoCompoundingDelegationCount: number;
        delegationCount: number;
      };
    }
  /**
   * REMOVED, was schedule_leave_delegators
   **/
  | { name: 'RemovedCall19' }
  /**
   * REMOVED, was execute_leave_delegators
   **/
  | { name: 'RemovedCall20' }
  /**
   * REMOVED, was cancel_leave_delegators
   **/
  | { name: 'RemovedCall21' }
  /**
   * Request to revoke an existing delegation. If successful, the delegation is scheduled
   * to be allowed to be revoked via the `execute_delegation_request` extrinsic.
   * The delegation receives no rewards for the rounds while a revoke is pending.
   * A revoke may not be performed if any other scheduled request is pending.
   **/
  | { name: 'ScheduleRevokeDelegation'; params: { collator: AccountId20 } }
  /**
   * Bond more for delegators wrt a specific collator candidate.
   **/
  | { name: 'DelegatorBondMore'; params: { candidate: AccountId20; more: bigint } }
  /**
   * Request bond less for delegators wrt a specific collator candidate. The delegation's
   * rewards for rounds while the request is pending use the reduced bonded amount.
   * A bond less may not be performed if any other scheduled request is pending.
   **/
  | { name: 'ScheduleDelegatorBondLess'; params: { candidate: AccountId20; less: bigint } }
  /**
   * Execute pending request to change an existing delegation
   **/
  | { name: 'ExecuteDelegationRequest'; params: { delegator: AccountId20; candidate: AccountId20 } }
  /**
   * Cancel request to change an existing delegation.
   **/
  | { name: 'CancelDelegationRequest'; params: { candidate: AccountId20 } }
  /**
   * Sets the auto-compounding reward percentage for a delegation.
   **/
  | {
      name: 'SetAutoCompound';
      params: {
        candidate: AccountId20;
        value: Percent;
        candidateAutoCompoundingDelegationCountHint: number;
        delegationCountHint: number;
      };
    }
  /**
   * Hotfix to remove existing empty entries for candidates that have left.
   **/
  | { name: 'HotfixRemoveDelegationRequestsExitedCandidates'; params: { candidates: Array<AccountId20> } }
  /**
   * Notify a collator is inactive during MaxOfflineRounds
   **/
  | { name: 'NotifyInactiveCollator'; params: { collator: AccountId20 } }
  /**
   * Enable/Disable marking offline feature
   **/
  | { name: 'EnableMarkingOffline'; params: { value: boolean } }
  /**
   * Force join the set of collator candidates.
   * It will skip the minimum required bond check.
   **/
  | { name: 'ForceJoinCandidates'; params: { account: AccountId20; bond: bigint; candidateCount: number } }
  /**
   * Set the inflation distribution configuration.
   **/
  | { name: 'SetInflationDistributionConfig'; params: { new: PalletParachainStakingInflationDistributionConfig } };

export type PalletParachainStakingCallLike =
  /**
   * Set the expectations for total staked. These expectations determine the issuance for
   * the round according to logic in `fn compute_issuance`
   **/
  | { name: 'SetStakingExpectations'; params: { expectations: { min: bigint; ideal: bigint; max: bigint } } }
  /**
   * Set the annual inflation rate to derive per-round inflation
   **/
  | { name: 'SetInflation'; params: { schedule: { min: Perbill; ideal: Perbill; max: Perbill } } }
  /**
   * Deprecated: please use `set_inflation_distribution_config` instead.
   *
   * Set the account that will hold funds set aside for parachain bond
   **/
  | { name: 'SetParachainBondAccount'; params: { new: AccountId20Like } }
  /**
   * Deprecated: please use `set_inflation_distribution_config` instead.
   *
   * Set the percent of inflation set aside for parachain bond
   **/
  | { name: 'SetParachainBondReservePercent'; params: { new: Percent } }
  /**
   * Set the total number of collator candidates selected per round
   * - changes are not applied until the start of the next round
   **/
  | { name: 'SetTotalSelected'; params: { new: number } }
  /**
   * Set the commission for all collators
   **/
  | { name: 'SetCollatorCommission'; params: { new: Perbill } }
  /**
   * Set blocks per round
   * - if called with `new` less than length of current round, will transition immediately
   * in the next block
   * - also updates per-round inflation config
   **/
  | { name: 'SetBlocksPerRound'; params: { new: number } }
  /**
   * Join the set of collator candidates
   **/
  | { name: 'JoinCandidates'; params: { bond: bigint; candidateCount: number } }
  /**
   * Request to leave the set of candidates. If successful, the account is immediately
   * removed from the candidate pool to prevent selection as a collator.
   **/
  | { name: 'ScheduleLeaveCandidates'; params: { candidateCount: number } }
  /**
   * Execute leave candidates request
   **/
  | { name: 'ExecuteLeaveCandidates'; params: { candidate: AccountId20Like; candidateDelegationCount: number } }
  /**
   * Cancel open request to leave candidates
   * - only callable by collator account
   * - result upon successful call is the candidate is active in the candidate pool
   **/
  | { name: 'CancelLeaveCandidates'; params: { candidateCount: number } }
  /**
   * Temporarily leave the set of collator candidates without unbonding
   **/
  | { name: 'GoOffline' }
  /**
   * Rejoin the set of collator candidates if previously had called `go_offline`
   **/
  | { name: 'GoOnline' }
  /**
   * Increase collator candidate self bond by `more`
   **/
  | { name: 'CandidateBondMore'; params: { more: bigint } }
  /**
   * Request by collator candidate to decrease self bond by `less`
   **/
  | { name: 'ScheduleCandidateBondLess'; params: { less: bigint } }
  /**
   * Execute pending request to adjust the collator candidate self bond
   **/
  | { name: 'ExecuteCandidateBondLess'; params: { candidate: AccountId20Like } }
  /**
   * Cancel pending request to adjust the collator candidate self bond
   **/
  | { name: 'CancelCandidateBondLess' }
  /**
   * DEPRECATED use delegateWithAutoCompound
   * If caller is not a delegator and not a collator, then join the set of delegators
   * If caller is a delegator, then makes delegation to change their delegation state
   **/
  | {
      name: 'Delegate';
      params: { candidate: AccountId20Like; amount: bigint; candidateDelegationCount: number; delegationCount: number };
    }
  /**
   * If caller is not a delegator and not a collator, then join the set of delegators
   * If caller is a delegator, then makes delegation to change their delegation state
   * Sets the auto-compound config for the delegation
   **/
  | {
      name: 'DelegateWithAutoCompound';
      params: {
        candidate: AccountId20Like;
        amount: bigint;
        autoCompound: Percent;
        candidateDelegationCount: number;
        candidateAutoCompoundingDelegationCount: number;
        delegationCount: number;
      };
    }
  /**
   * REMOVED, was schedule_leave_delegators
   **/
  | { name: 'RemovedCall19' }
  /**
   * REMOVED, was execute_leave_delegators
   **/
  | { name: 'RemovedCall20' }
  /**
   * REMOVED, was cancel_leave_delegators
   **/
  | { name: 'RemovedCall21' }
  /**
   * Request to revoke an existing delegation. If successful, the delegation is scheduled
   * to be allowed to be revoked via the `execute_delegation_request` extrinsic.
   * The delegation receives no rewards for the rounds while a revoke is pending.
   * A revoke may not be performed if any other scheduled request is pending.
   **/
  | { name: 'ScheduleRevokeDelegation'; params: { collator: AccountId20Like } }
  /**
   * Bond more for delegators wrt a specific collator candidate.
   **/
  | { name: 'DelegatorBondMore'; params: { candidate: AccountId20Like; more: bigint } }
  /**
   * Request bond less for delegators wrt a specific collator candidate. The delegation's
   * rewards for rounds while the request is pending use the reduced bonded amount.
   * A bond less may not be performed if any other scheduled request is pending.
   **/
  | { name: 'ScheduleDelegatorBondLess'; params: { candidate: AccountId20Like; less: bigint } }
  /**
   * Execute pending request to change an existing delegation
   **/
  | { name: 'ExecuteDelegationRequest'; params: { delegator: AccountId20Like; candidate: AccountId20Like } }
  /**
   * Cancel request to change an existing delegation.
   **/
  | { name: 'CancelDelegationRequest'; params: { candidate: AccountId20Like } }
  /**
   * Sets the auto-compounding reward percentage for a delegation.
   **/
  | {
      name: 'SetAutoCompound';
      params: {
        candidate: AccountId20Like;
        value: Percent;
        candidateAutoCompoundingDelegationCountHint: number;
        delegationCountHint: number;
      };
    }
  /**
   * Hotfix to remove existing empty entries for candidates that have left.
   **/
  | { name: 'HotfixRemoveDelegationRequestsExitedCandidates'; params: { candidates: Array<AccountId20Like> } }
  /**
   * Notify a collator is inactive during MaxOfflineRounds
   **/
  | { name: 'NotifyInactiveCollator'; params: { collator: AccountId20Like } }
  /**
   * Enable/Disable marking offline feature
   **/
  | { name: 'EnableMarkingOffline'; params: { value: boolean } }
  /**
   * Force join the set of collator candidates.
   * It will skip the minimum required bond check.
   **/
  | { name: 'ForceJoinCandidates'; params: { account: AccountId20Like; bond: bigint; candidateCount: number } }
  /**
   * Set the inflation distribution configuration.
   **/
  | { name: 'SetInflationDistributionConfig'; params: { new: PalletParachainStakingInflationDistributionConfig } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletAuthorInherentCall =
  /**
   * This inherent is a workaround to run code after the "real" inherents have executed,
   * but before transactions are executed.
   **/
  'KickOffAuthorshipValidation';

export type PalletAuthorInherentCallLike =
  /**
   * This inherent is a workaround to run code after the "real" inherents have executed,
   * but before transactions are executed.
   **/
  'KickOffAuthorshipValidation';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletAuthorSlotFilterCall =
  /**
   * Update the eligible count. Intended to be called by governance.
   **/
  { name: 'SetEligible'; params: { new: PalletAuthorSlotFilterNumNonZeroU32 } };

export type PalletAuthorSlotFilterCallLike =
  /**
   * Update the eligible count. Intended to be called by governance.
   **/
  { name: 'SetEligible'; params: { new: PalletAuthorSlotFilterNumNonZeroU32 } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletAuthorMappingCall =
  /**
   * Register your NimbusId onchain so blocks you author are associated with your account.
   *
   * Users who have been (or will soon be) elected active collators in staking,
   * should submit this extrinsic to have their blocks accepted and earn rewards.
   **/
  | { name: 'AddAssociation'; params: { nimbusId: NimbusPrimitivesNimbusCryptoPublic } }
  /**
   * Change your Mapping.
   *
   * This is useful for normal key rotation or for when switching from one physical collator
   * machine to another. No new security deposit is required.
   * This sets keys to new_nimbus_id.into() by default.
   **/
  | {
      name: 'UpdateAssociation';
      params: { oldNimbusId: NimbusPrimitivesNimbusCryptoPublic; newNimbusId: NimbusPrimitivesNimbusCryptoPublic };
    }
  /**
   * Clear your Mapping.
   *
   * This is useful when you are no longer an author and would like to re-claim your security
   * deposit.
   **/
  | { name: 'ClearAssociation'; params: { nimbusId: NimbusPrimitivesNimbusCryptoPublic } }
  /**
   * Remove your Mapping.
   *
   * This is useful when you are no longer an author and would like to re-claim your security
   * deposit.
   **/
  | { name: 'RemoveKeys' }
  /**
   * Set association and session keys at once.
   *
   * This is useful for key rotation to update Nimbus and VRF keys in one call.
   * No new security deposit is required. Will replace `update_association` which is kept
   * now for backwards compatibility reasons.
   **/
  | { name: 'SetKeys'; params: { keys: Bytes } };

export type PalletAuthorMappingCallLike =
  /**
   * Register your NimbusId onchain so blocks you author are associated with your account.
   *
   * Users who have been (or will soon be) elected active collators in staking,
   * should submit this extrinsic to have their blocks accepted and earn rewards.
   **/
  | { name: 'AddAssociation'; params: { nimbusId: NimbusPrimitivesNimbusCryptoPublic } }
  /**
   * Change your Mapping.
   *
   * This is useful for normal key rotation or for when switching from one physical collator
   * machine to another. No new security deposit is required.
   * This sets keys to new_nimbus_id.into() by default.
   **/
  | {
      name: 'UpdateAssociation';
      params: { oldNimbusId: NimbusPrimitivesNimbusCryptoPublic; newNimbusId: NimbusPrimitivesNimbusCryptoPublic };
    }
  /**
   * Clear your Mapping.
   *
   * This is useful when you are no longer an author and would like to re-claim your security
   * deposit.
   **/
  | { name: 'ClearAssociation'; params: { nimbusId: NimbusPrimitivesNimbusCryptoPublic } }
  /**
   * Remove your Mapping.
   *
   * This is useful when you are no longer an author and would like to re-claim your security
   * deposit.
   **/
  | { name: 'RemoveKeys' }
  /**
   * Set association and session keys at once.
   *
   * This is useful for key rotation to update Nimbus and VRF keys in one call.
   * No new security deposit is required. Will replace `update_association` which is kept
   * now for backwards compatibility reasons.
   **/
  | { name: 'SetKeys'; params: { keys: BytesLike } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMoonbeamOrbitersCall =
  /**
   * Add an orbiter in a collator pool
   **/
  | { name: 'CollatorAddOrbiter'; params: { orbiter: AccountId20 } }
  /**
   * Remove an orbiter from the caller collator pool
   **/
  | { name: 'CollatorRemoveOrbiter'; params: { orbiter: AccountId20 } }
  /**
   * Remove the caller from the specified collator pool
   **/
  | { name: 'OrbiterLeaveCollatorPool'; params: { collator: AccountId20 } }
  /**
   * Registering as an orbiter
   **/
  | { name: 'OrbiterRegister' }
  /**
   * Deregistering from orbiters
   **/
  | { name: 'OrbiterUnregister'; params: { collatorsPoolCount: number } }
  /**
   * Add a collator to orbiters program.
   **/
  | { name: 'AddCollator'; params: { collator: AccountId20 } }
  /**
   * Remove a collator from orbiters program.
   **/
  | { name: 'RemoveCollator'; params: { collator: AccountId20 } };

export type PalletMoonbeamOrbitersCallLike =
  /**
   * Add an orbiter in a collator pool
   **/
  | { name: 'CollatorAddOrbiter'; params: { orbiter: AccountId20Like } }
  /**
   * Remove an orbiter from the caller collator pool
   **/
  | { name: 'CollatorRemoveOrbiter'; params: { orbiter: AccountId20Like } }
  /**
   * Remove the caller from the specified collator pool
   **/
  | { name: 'OrbiterLeaveCollatorPool'; params: { collator: AccountId20Like } }
  /**
   * Registering as an orbiter
   **/
  | { name: 'OrbiterRegister' }
  /**
   * Deregistering from orbiters
   **/
  | { name: 'OrbiterUnregister'; params: { collatorsPoolCount: number } }
  /**
   * Add a collator to orbiters program.
   **/
  | { name: 'AddCollator'; params: { collator: AccountId20Like } }
  /**
   * Remove a collator from orbiters program.
   **/
  | { name: 'RemoveCollator'; params: { collator: AccountId20Like } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletUtilityCall =
  /**
   * Send a batch of dispatch calls.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatched without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   *
   * This will return `Ok` in all circumstances. To determine the success of the batch, an
   * event is deposited. If a call failed and the batch was interrupted, then the
   * `BatchInterrupted` event is deposited, along with the number of successful calls made
   * and the error of the failed call. If all were successful, then the `BatchCompleted`
   * event is deposited.
   **/
  | { name: 'Batch'; params: { calls: Array<MoonbeamRuntimeRuntimeCall> } }
  /**
   * Send a call through an indexed pseudonym of the sender.
   *
   * Filter from origin are passed along. The call will be dispatched with an origin which
   * use the same filter as the origin of this call.
   *
   * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
   * because you expect `proxy` to have been used prior in the call stack and you do not want
   * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
   * in the Multisig pallet instead.
   *
   * NOTE: Prior to version *12, this was called `as_limited_sub`.
   *
   * The dispatch origin for this call must be _Signed_.
   **/
  | { name: 'AsDerivative'; params: { index: number; call: MoonbeamRuntimeRuntimeCall } }
  /**
   * Send a batch of dispatch calls and atomically execute them.
   * The whole transaction will rollback and fail if any of the calls failed.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatched without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   **/
  | { name: 'BatchAll'; params: { calls: Array<MoonbeamRuntimeRuntimeCall> } }
  /**
   * Dispatches a function call with a provided origin.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'DispatchAs'; params: { asOrigin: MoonbeamRuntimeOriginCaller; call: MoonbeamRuntimeRuntimeCall } }
  /**
   * Send a batch of dispatch calls.
   * Unlike `batch`, it allows errors and won't interrupt.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatch without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   **/
  | { name: 'ForceBatch'; params: { calls: Array<MoonbeamRuntimeRuntimeCall> } }
  /**
   * Dispatch a function call with a specified weight.
   *
   * This function does not check the weight of the call, and instead allows the
   * Root origin to specify the weight of the call.
   *
   * The dispatch origin for this call must be _Root_.
   **/
  | { name: 'WithWeight'; params: { call: MoonbeamRuntimeRuntimeCall; weight: SpWeightsWeightV2Weight } };

export type PalletUtilityCallLike =
  /**
   * Send a batch of dispatch calls.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatched without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   *
   * This will return `Ok` in all circumstances. To determine the success of the batch, an
   * event is deposited. If a call failed and the batch was interrupted, then the
   * `BatchInterrupted` event is deposited, along with the number of successful calls made
   * and the error of the failed call. If all were successful, then the `BatchCompleted`
   * event is deposited.
   **/
  | { name: 'Batch'; params: { calls: Array<MoonbeamRuntimeRuntimeCallLike> } }
  /**
   * Send a call through an indexed pseudonym of the sender.
   *
   * Filter from origin are passed along. The call will be dispatched with an origin which
   * use the same filter as the origin of this call.
   *
   * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
   * because you expect `proxy` to have been used prior in the call stack and you do not want
   * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
   * in the Multisig pallet instead.
   *
   * NOTE: Prior to version *12, this was called `as_limited_sub`.
   *
   * The dispatch origin for this call must be _Signed_.
   **/
  | { name: 'AsDerivative'; params: { index: number; call: MoonbeamRuntimeRuntimeCallLike } }
  /**
   * Send a batch of dispatch calls and atomically execute them.
   * The whole transaction will rollback and fail if any of the calls failed.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatched without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   **/
  | { name: 'BatchAll'; params: { calls: Array<MoonbeamRuntimeRuntimeCallLike> } }
  /**
   * Dispatches a function call with a provided origin.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'DispatchAs'; params: { asOrigin: MoonbeamRuntimeOriginCaller; call: MoonbeamRuntimeRuntimeCallLike } }
  /**
   * Send a batch of dispatch calls.
   * Unlike `batch`, it allows errors and won't interrupt.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatch without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   **/
  | { name: 'ForceBatch'; params: { calls: Array<MoonbeamRuntimeRuntimeCallLike> } }
  /**
   * Dispatch a function call with a specified weight.
   *
   * This function does not check the weight of the call, and instead allows the
   * Root origin to specify the weight of the call.
   *
   * The dispatch origin for this call must be _Root_.
   **/
  | { name: 'WithWeight'; params: { call: MoonbeamRuntimeRuntimeCallLike; weight: SpWeightsWeightV2Weight } };

export type MoonbeamRuntimeOriginCaller =
  | { type: 'System'; value: FrameSupportDispatchRawOrigin }
  | { type: 'Ethereum'; value: PalletEthereumRawOrigin }
  | { type: 'Origins'; value: MoonbeamRuntimeGovernanceOriginsCustomOriginsOrigin }
  | { type: 'TreasuryCouncilCollective'; value: PalletCollectiveRawOrigin }
  | { type: 'OpenTechCommitteeCollective'; value: PalletCollectiveRawOrigin }
  | { type: 'CumulusXcm'; value: CumulusPalletXcmOrigin }
  | { type: 'PolkadotXcm'; value: PalletXcmOrigin }
  | { type: 'EthereumXcm'; value: PalletEthereumXcmRawOrigin }
  | { type: 'Void'; value: SpCoreVoid };

export type FrameSupportDispatchRawOrigin =
  | { type: 'Root' }
  | { type: 'Signed'; value: AccountId20 }
  | { type: 'None' };

export type PalletEthereumRawOrigin = { type: 'EthereumTransaction'; value: H160 };

export type MoonbeamRuntimeGovernanceOriginsCustomOriginsOrigin =
  | 'WhitelistedCaller'
  | 'GeneralAdmin'
  | 'ReferendumCanceller'
  | 'ReferendumKiller'
  | 'FastGeneralAdmin';

export type PalletCollectiveRawOrigin =
  | { type: 'Members'; value: [number, number] }
  | { type: 'Member'; value: AccountId20 }
  | { type: 'Phantom' };

export type CumulusPalletXcmOrigin =
  | { type: 'Relay' }
  | { type: 'SiblingParachain'; value: PolkadotParachainPrimitivesPrimitivesId };

export type PalletXcmOrigin =
  | { type: 'Xcm'; value: StagingXcmV4Location }
  | { type: 'Response'; value: StagingXcmV4Location };

export type StagingXcmV4Location = { parents: number; interior: StagingXcmV4Junctions };

export type StagingXcmV4Junctions =
  | { type: 'Here' }
  | { type: 'X1'; value: FixedArray<StagingXcmV4Junction, 1> }
  | { type: 'X2'; value: FixedArray<StagingXcmV4Junction, 2> }
  | { type: 'X3'; value: FixedArray<StagingXcmV4Junction, 3> }
  | { type: 'X4'; value: FixedArray<StagingXcmV4Junction, 4> }
  | { type: 'X5'; value: FixedArray<StagingXcmV4Junction, 5> }
  | { type: 'X6'; value: FixedArray<StagingXcmV4Junction, 6> }
  | { type: 'X7'; value: FixedArray<StagingXcmV4Junction, 7> }
  | { type: 'X8'; value: FixedArray<StagingXcmV4Junction, 8> };

export type StagingXcmV4Junction =
  | { type: 'Parachain'; value: number }
  | { type: 'AccountId32'; value: { network?: StagingXcmV4JunctionNetworkId | undefined; id: FixedBytes<32> } }
  | { type: 'AccountIndex64'; value: { network?: StagingXcmV4JunctionNetworkId | undefined; index: bigint } }
  | { type: 'AccountKey20'; value: { network?: StagingXcmV4JunctionNetworkId | undefined; key: FixedBytes<20> } }
  | { type: 'PalletInstance'; value: number }
  | { type: 'GeneralIndex'; value: bigint }
  | { type: 'GeneralKey'; value: { length: number; data: FixedBytes<32> } }
  | { type: 'OnlyChild' }
  | { type: 'Plurality'; value: { id: XcmV3JunctionBodyId; part: XcmV3JunctionBodyPart } }
  | { type: 'GlobalConsensus'; value: StagingXcmV4JunctionNetworkId };

export type StagingXcmV4JunctionNetworkId =
  | { type: 'ByGenesis'; value: FixedBytes<32> }
  | { type: 'ByFork'; value: { blockNumber: bigint; blockHash: FixedBytes<32> } }
  | { type: 'Polkadot' }
  | { type: 'Kusama' }
  | { type: 'Westend' }
  | { type: 'Rococo' }
  | { type: 'Wococo' }
  | { type: 'Ethereum'; value: { chainId: bigint } }
  | { type: 'BitcoinCore' }
  | { type: 'BitcoinCash' }
  | { type: 'PolkadotBulletin' };

export type XcmV3JunctionBodyId =
  | { type: 'Unit' }
  | { type: 'Moniker'; value: FixedBytes<4> }
  | { type: 'Index'; value: number }
  | { type: 'Executive' }
  | { type: 'Technical' }
  | { type: 'Legislative' }
  | { type: 'Judicial' }
  | { type: 'Defense' }
  | { type: 'Administration' }
  | { type: 'Treasury' };

export type XcmV3JunctionBodyPart =
  | { type: 'Voice' }
  | { type: 'Members'; value: { count: number } }
  | { type: 'Fraction'; value: { nom: number; denom: number } }
  | { type: 'AtLeastProportion'; value: { nom: number; denom: number } }
  | { type: 'MoreThanProportion'; value: { nom: number; denom: number } };

export type PalletEthereumXcmRawOrigin = { type: 'XcmEthereumTransaction'; value: H160 };

export type SpCoreVoid = null;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletProxyCall =
  /**
   * Dispatch the given `call` from an account that the sender is authorised for through
   * `add_proxy`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
   * - `call`: The call to be made by the `real` account.
   **/
  | {
      name: 'Proxy';
      params: {
        real: AccountId20;
        forceProxyType?: MoonbeamRuntimeProxyType | undefined;
        call: MoonbeamRuntimeRuntimeCall;
      };
    }
  /**
   * Register a proxy account for the sender that is able to make calls on its behalf.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `proxy`: The account that the `caller` would like to make a proxy.
   * - `proxy_type`: The permissions allowed for this proxy account.
   * - `delay`: The announcement period required of the initial proxy. Will generally be
   * zero.
   **/
  | { name: 'AddProxy'; params: { delegate: AccountId20; proxyType: MoonbeamRuntimeProxyType; delay: number } }
  /**
   * Unregister a proxy account for the sender.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `proxy`: The account that the `caller` would like to remove as a proxy.
   * - `proxy_type`: The permissions currently enabled for the removed proxy account.
   **/
  | { name: 'RemoveProxy'; params: { delegate: AccountId20; proxyType: MoonbeamRuntimeProxyType; delay: number } }
  /**
   * Unregister all proxy accounts for the sender.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * WARNING: This may be called on accounts created by `pure`, however if done, then
   * the unreserved fees will be inaccessible. **All access to this account will be lost.**
   **/
  | { name: 'RemoveProxies' }
  /**
   * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
   * initialize it with a proxy of `proxy_type` for `origin` sender.
   *
   * Requires a `Signed` origin.
   *
   * - `proxy_type`: The type of the proxy that the sender will be registered as over the
   * new account. This will almost always be the most permissive `ProxyType` possible to
   * allow for maximum flexibility.
   * - `index`: A disambiguation index, in case this is called multiple times in the same
   * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
   * want to use `0`.
   * - `delay`: The announcement period required of the initial proxy. Will generally be
   * zero.
   *
   * Fails with `Duplicate` if this has already been called in this transaction, from the
   * same sender, with the same parameters.
   *
   * Fails if there are insufficient funds to pay for deposit.
   **/
  | { name: 'CreatePure'; params: { proxyType: MoonbeamRuntimeProxyType; delay: number; index: number } }
  /**
   * Removes a previously spawned pure proxy.
   *
   * WARNING: **All access to this account will be lost.** Any funds held in it will be
   * inaccessible.
   *
   * Requires a `Signed` origin, and the sender account must have been created by a call to
   * `pure` with corresponding parameters.
   *
   * - `spawner`: The account that originally called `pure` to create this account.
   * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
   * - `proxy_type`: The proxy type originally passed to `pure`.
   * - `height`: The height of the chain when the call to `pure` was processed.
   * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
   *
   * Fails with `NoPermission` in case the caller is not a previously created pure
   * account whose `pure` call has corresponding parameters.
   **/
  | {
      name: 'KillPure';
      params: {
        spawner: AccountId20;
        proxyType: MoonbeamRuntimeProxyType;
        index: number;
        height: number;
        extIndex: number;
      };
    }
  /**
   * Publish the hash of a proxy-call that will be made in the future.
   *
   * This must be called some number of blocks before the corresponding `proxy` is attempted
   * if the delay associated with the proxy relationship is greater than zero.
   *
   * No more than `MaxPending` announcements may be made at any one time.
   *
   * This will take a deposit of `AnnouncementDepositFactor` as well as
   * `AnnouncementDepositBase` if there are no other pending announcements.
   *
   * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `call_hash`: The hash of the call to be made by the `real` account.
   **/
  | { name: 'Announce'; params: { real: AccountId20; callHash: H256 } }
  /**
   * Remove a given announcement.
   *
   * May be called by a proxy account to remove a call they previously announced and return
   * the deposit.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `call_hash`: The hash of the call to be made by the `real` account.
   **/
  | { name: 'RemoveAnnouncement'; params: { real: AccountId20; callHash: H256 } }
  /**
   * Remove the given announcement of a delegate.
   *
   * May be called by a target (proxied) account to remove a call that one of their delegates
   * (`delegate`) has announced they want to execute. The deposit is returned.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `delegate`: The account that previously announced the call.
   * - `call_hash`: The hash of the call to be made.
   **/
  | { name: 'RejectAnnouncement'; params: { delegate: AccountId20; callHash: H256 } }
  /**
   * Dispatch the given `call` from an account that the sender is authorized for through
   * `add_proxy`.
   *
   * Removes any corresponding announcement(s).
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
   * - `call`: The call to be made by the `real` account.
   **/
  | {
      name: 'ProxyAnnounced';
      params: {
        delegate: AccountId20;
        real: AccountId20;
        forceProxyType?: MoonbeamRuntimeProxyType | undefined;
        call: MoonbeamRuntimeRuntimeCall;
      };
    };

export type PalletProxyCallLike =
  /**
   * Dispatch the given `call` from an account that the sender is authorised for through
   * `add_proxy`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
   * - `call`: The call to be made by the `real` account.
   **/
  | {
      name: 'Proxy';
      params: {
        real: AccountId20Like;
        forceProxyType?: MoonbeamRuntimeProxyType | undefined;
        call: MoonbeamRuntimeRuntimeCallLike;
      };
    }
  /**
   * Register a proxy account for the sender that is able to make calls on its behalf.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `proxy`: The account that the `caller` would like to make a proxy.
   * - `proxy_type`: The permissions allowed for this proxy account.
   * - `delay`: The announcement period required of the initial proxy. Will generally be
   * zero.
   **/
  | { name: 'AddProxy'; params: { delegate: AccountId20Like; proxyType: MoonbeamRuntimeProxyType; delay: number } }
  /**
   * Unregister a proxy account for the sender.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `proxy`: The account that the `caller` would like to remove as a proxy.
   * - `proxy_type`: The permissions currently enabled for the removed proxy account.
   **/
  | { name: 'RemoveProxy'; params: { delegate: AccountId20Like; proxyType: MoonbeamRuntimeProxyType; delay: number } }
  /**
   * Unregister all proxy accounts for the sender.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * WARNING: This may be called on accounts created by `pure`, however if done, then
   * the unreserved fees will be inaccessible. **All access to this account will be lost.**
   **/
  | { name: 'RemoveProxies' }
  /**
   * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
   * initialize it with a proxy of `proxy_type` for `origin` sender.
   *
   * Requires a `Signed` origin.
   *
   * - `proxy_type`: The type of the proxy that the sender will be registered as over the
   * new account. This will almost always be the most permissive `ProxyType` possible to
   * allow for maximum flexibility.
   * - `index`: A disambiguation index, in case this is called multiple times in the same
   * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
   * want to use `0`.
   * - `delay`: The announcement period required of the initial proxy. Will generally be
   * zero.
   *
   * Fails with `Duplicate` if this has already been called in this transaction, from the
   * same sender, with the same parameters.
   *
   * Fails if there are insufficient funds to pay for deposit.
   **/
  | { name: 'CreatePure'; params: { proxyType: MoonbeamRuntimeProxyType; delay: number; index: number } }
  /**
   * Removes a previously spawned pure proxy.
   *
   * WARNING: **All access to this account will be lost.** Any funds held in it will be
   * inaccessible.
   *
   * Requires a `Signed` origin, and the sender account must have been created by a call to
   * `pure` with corresponding parameters.
   *
   * - `spawner`: The account that originally called `pure` to create this account.
   * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
   * - `proxy_type`: The proxy type originally passed to `pure`.
   * - `height`: The height of the chain when the call to `pure` was processed.
   * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
   *
   * Fails with `NoPermission` in case the caller is not a previously created pure
   * account whose `pure` call has corresponding parameters.
   **/
  | {
      name: 'KillPure';
      params: {
        spawner: AccountId20Like;
        proxyType: MoonbeamRuntimeProxyType;
        index: number;
        height: number;
        extIndex: number;
      };
    }
  /**
   * Publish the hash of a proxy-call that will be made in the future.
   *
   * This must be called some number of blocks before the corresponding `proxy` is attempted
   * if the delay associated with the proxy relationship is greater than zero.
   *
   * No more than `MaxPending` announcements may be made at any one time.
   *
   * This will take a deposit of `AnnouncementDepositFactor` as well as
   * `AnnouncementDepositBase` if there are no other pending announcements.
   *
   * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `call_hash`: The hash of the call to be made by the `real` account.
   **/
  | { name: 'Announce'; params: { real: AccountId20Like; callHash: H256 } }
  /**
   * Remove a given announcement.
   *
   * May be called by a proxy account to remove a call they previously announced and return
   * the deposit.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `call_hash`: The hash of the call to be made by the `real` account.
   **/
  | { name: 'RemoveAnnouncement'; params: { real: AccountId20Like; callHash: H256 } }
  /**
   * Remove the given announcement of a delegate.
   *
   * May be called by a target (proxied) account to remove a call that one of their delegates
   * (`delegate`) has announced they want to execute. The deposit is returned.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `delegate`: The account that previously announced the call.
   * - `call_hash`: The hash of the call to be made.
   **/
  | { name: 'RejectAnnouncement'; params: { delegate: AccountId20Like; callHash: H256 } }
  /**
   * Dispatch the given `call` from an account that the sender is authorized for through
   * `add_proxy`.
   *
   * Removes any corresponding announcement(s).
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
   * - `call`: The call to be made by the `real` account.
   **/
  | {
      name: 'ProxyAnnounced';
      params: {
        delegate: AccountId20Like;
        real: AccountId20Like;
        forceProxyType?: MoonbeamRuntimeProxyType | undefined;
        call: MoonbeamRuntimeRuntimeCallLike;
      };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMaintenanceModeCall =
  /**
   * Place the chain in maintenance mode
   *
   * Weight cost is:
   * * One DB read to ensure we're not already in maintenance mode
   * * Three DB writes - 1 for the mode, 1 for suspending xcm execution, 1 for the event
   **/
  | 'EnterMaintenanceMode'
  /**
   * Return the chain to normal operating mode
   *
   * Weight cost is:
   * * One DB read to ensure we're in maintenance mode
   * * Three DB writes - 1 for the mode, 1 for resuming xcm execution, 1 for the event
   **/
  | 'ResumeNormalOperation';

export type PalletMaintenanceModeCallLike =
  /**
   * Place the chain in maintenance mode
   *
   * Weight cost is:
   * * One DB read to ensure we're not already in maintenance mode
   * * Three DB writes - 1 for the mode, 1 for suspending xcm execution, 1 for the event
   **/
  | 'EnterMaintenanceMode'
  /**
   * Return the chain to normal operating mode
   *
   * Weight cost is:
   * * One DB read to ensure we're in maintenance mode
   * * Three DB writes - 1 for the mode, 1 for resuming xcm execution, 1 for the event
   **/
  | 'ResumeNormalOperation';

/**
 * Identity pallet declaration.
 **/
export type PalletIdentityCall =
  /**
   * Add a registrar to the system.
   *
   * The dispatch origin for this call must be `T::RegistrarOrigin`.
   *
   * - `account`: the account of the registrar.
   *
   * Emits `RegistrarAdded` if successful.
   **/
  | { name: 'AddRegistrar'; params: { account: AccountId20 } }
  /**
   * Set an account's identity information and reserve the appropriate deposit.
   *
   * If the account already has identity information, the deposit is taken as part payment
   * for the new deposit.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `info`: The identity information.
   *
   * Emits `IdentitySet` if successful.
   **/
  | { name: 'SetIdentity'; params: { info: PalletIdentityLegacyIdentityInfo } }
  /**
   * Set the sub-accounts of the sender.
   *
   * Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
   * and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * identity.
   *
   * - `subs`: The identity's (new) sub-accounts.
   **/
  | { name: 'SetSubs'; params: { subs: Array<[AccountId20, Data]> } }
  /**
   * Clear an account's identity info and all sub-accounts and return all deposits.
   *
   * Payment: All reserved balances on the account are returned.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * identity.
   *
   * Emits `IdentityCleared` if successful.
   **/
  | { name: 'ClearIdentity' }
  /**
   * Request a judgement from a registrar.
   *
   * Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
   * given.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a
   * registered identity.
   *
   * - `reg_index`: The index of the registrar whose judgement is requested.
   * - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
   *
   * ```nocompile
   * Self::registrars().get(reg_index).unwrap().fee
   * ```
   *
   * Emits `JudgementRequested` if successful.
   **/
  | { name: 'RequestJudgement'; params: { regIndex: number; maxFee: bigint } }
  /**
   * Cancel a previous request.
   *
   * Payment: A previously reserved deposit is returned on success.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a
   * registered identity.
   *
   * - `reg_index`: The index of the registrar whose judgement is no longer requested.
   *
   * Emits `JudgementUnrequested` if successful.
   **/
  | { name: 'CancelRequest'; params: { regIndex: number } }
  /**
   * Set the fee required for a judgement to be requested from a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `fee`: the new fee.
   **/
  | { name: 'SetFee'; params: { index: number; fee: bigint } }
  /**
   * Change the account associated with a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `new`: the new account ID.
   **/
  | { name: 'SetAccountId'; params: { index: number; new: AccountId20 } }
  /**
   * Set the field information for a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `fields`: the fields that the registrar concerns themselves with.
   **/
  | { name: 'SetFields'; params: { index: number; fields: bigint } }
  /**
   * Provide a judgement for an account's identity.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `reg_index`.
   *
   * - `reg_index`: the index of the registrar whose judgement is being made.
   * - `target`: the account whose identity the judgement is upon. This must be an account
   * with a registered identity.
   * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
   * - `identity`: The hash of the [`IdentityInformationProvider`] for that the judgement is
   * provided.
   *
   * Note: Judgements do not apply to a username.
   *
   * Emits `JudgementGiven` if successful.
   **/
  | {
      name: 'ProvideJudgement';
      params: { regIndex: number; target: AccountId20; judgement: PalletIdentityJudgement; identity: H256 };
    }
  /**
   * Remove an account's identity and sub-account information and slash the deposits.
   *
   * Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
   * `Slash`. Verification request deposits are not returned; they should be cancelled
   * manually using `cancel_request`.
   *
   * The dispatch origin for this call must match `T::ForceOrigin`.
   *
   * - `target`: the account whose identity the judgement is upon. This must be an account
   * with a registered identity.
   *
   * Emits `IdentityKilled` if successful.
   **/
  | { name: 'KillIdentity'; params: { target: AccountId20 } }
  /**
   * Add the given account to the sender's subs.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'AddSub'; params: { sub: AccountId20; data: Data } }
  /**
   * Alter the associated name of the given sub-account.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'RenameSub'; params: { sub: AccountId20; data: Data } }
  /**
   * Remove the given account from the sender's subs.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'RemoveSub'; params: { sub: AccountId20 } }
  /**
   * Remove the sender as a sub-account.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender (*not* the original depositor).
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * super-identity.
   *
   * NOTE: This should not normally be used, but is provided in the case that the non-
   * controller of an account is maliciously registered as a sub-account.
   **/
  | { name: 'QuitSub' }
  /**
   * Add an `AccountId` with permission to grant usernames with a given `suffix` appended.
   *
   * The authority can grant up to `allocation` usernames. To top up their allocation, they
   * should just issue (or request via governance) a new `add_username_authority` call.
   **/
  | { name: 'AddUsernameAuthority'; params: { authority: AccountId20; suffix: Bytes; allocation: number } }
  /**
   * Remove `authority` from the username authorities.
   **/
  | { name: 'RemoveUsernameAuthority'; params: { authority: AccountId20 } }
  /**
   * Set the username for `who`. Must be called by a username authority.
   *
   * The authority must have an `allocation`. Users can either pre-sign their usernames or
   * accept them later.
   *
   * Usernames must:
   * - Only contain lowercase ASCII characters or digits.
   * - When combined with the suffix of the issuing authority be _less than_ the
   * `MaxUsernameLength`.
   **/
  | {
      name: 'SetUsernameFor';
      params: { who: AccountId20; username: Bytes; signature?: AccountEthereumSignature | undefined };
    }
  /**
   * Accept a given username that an `authority` granted. The call must include the full
   * username, as in `username.suffix`.
   **/
  | { name: 'AcceptUsername'; params: { username: Bytes } }
  /**
   * Remove an expired username approval. The username was approved by an authority but never
   * accepted by the user and must now be beyond its expiration. The call must include the
   * full username, as in `username.suffix`.
   **/
  | { name: 'RemoveExpiredApproval'; params: { username: Bytes } }
  /**
   * Set a given username as the primary. The username should include the suffix.
   **/
  | { name: 'SetPrimaryUsername'; params: { username: Bytes } }
  /**
   * Remove a username that corresponds to an account with no identity. Exists when a user
   * gets a username but then calls `clear_identity`.
   **/
  | { name: 'RemoveDanglingUsername'; params: { username: Bytes } };

export type PalletIdentityCallLike =
  /**
   * Add a registrar to the system.
   *
   * The dispatch origin for this call must be `T::RegistrarOrigin`.
   *
   * - `account`: the account of the registrar.
   *
   * Emits `RegistrarAdded` if successful.
   **/
  | { name: 'AddRegistrar'; params: { account: AccountId20Like } }
  /**
   * Set an account's identity information and reserve the appropriate deposit.
   *
   * If the account already has identity information, the deposit is taken as part payment
   * for the new deposit.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `info`: The identity information.
   *
   * Emits `IdentitySet` if successful.
   **/
  | { name: 'SetIdentity'; params: { info: PalletIdentityLegacyIdentityInfo } }
  /**
   * Set the sub-accounts of the sender.
   *
   * Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
   * and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * identity.
   *
   * - `subs`: The identity's (new) sub-accounts.
   **/
  | { name: 'SetSubs'; params: { subs: Array<[AccountId20Like, Data]> } }
  /**
   * Clear an account's identity info and all sub-accounts and return all deposits.
   *
   * Payment: All reserved balances on the account are returned.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * identity.
   *
   * Emits `IdentityCleared` if successful.
   **/
  | { name: 'ClearIdentity' }
  /**
   * Request a judgement from a registrar.
   *
   * Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
   * given.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a
   * registered identity.
   *
   * - `reg_index`: The index of the registrar whose judgement is requested.
   * - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
   *
   * ```nocompile
   * Self::registrars().get(reg_index).unwrap().fee
   * ```
   *
   * Emits `JudgementRequested` if successful.
   **/
  | { name: 'RequestJudgement'; params: { regIndex: number; maxFee: bigint } }
  /**
   * Cancel a previous request.
   *
   * Payment: A previously reserved deposit is returned on success.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a
   * registered identity.
   *
   * - `reg_index`: The index of the registrar whose judgement is no longer requested.
   *
   * Emits `JudgementUnrequested` if successful.
   **/
  | { name: 'CancelRequest'; params: { regIndex: number } }
  /**
   * Set the fee required for a judgement to be requested from a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `fee`: the new fee.
   **/
  | { name: 'SetFee'; params: { index: number; fee: bigint } }
  /**
   * Change the account associated with a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `new`: the new account ID.
   **/
  | { name: 'SetAccountId'; params: { index: number; new: AccountId20Like } }
  /**
   * Set the field information for a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `fields`: the fields that the registrar concerns themselves with.
   **/
  | { name: 'SetFields'; params: { index: number; fields: bigint } }
  /**
   * Provide a judgement for an account's identity.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `reg_index`.
   *
   * - `reg_index`: the index of the registrar whose judgement is being made.
   * - `target`: the account whose identity the judgement is upon. This must be an account
   * with a registered identity.
   * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
   * - `identity`: The hash of the [`IdentityInformationProvider`] for that the judgement is
   * provided.
   *
   * Note: Judgements do not apply to a username.
   *
   * Emits `JudgementGiven` if successful.
   **/
  | {
      name: 'ProvideJudgement';
      params: { regIndex: number; target: AccountId20Like; judgement: PalletIdentityJudgement; identity: H256 };
    }
  /**
   * Remove an account's identity and sub-account information and slash the deposits.
   *
   * Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
   * `Slash`. Verification request deposits are not returned; they should be cancelled
   * manually using `cancel_request`.
   *
   * The dispatch origin for this call must match `T::ForceOrigin`.
   *
   * - `target`: the account whose identity the judgement is upon. This must be an account
   * with a registered identity.
   *
   * Emits `IdentityKilled` if successful.
   **/
  | { name: 'KillIdentity'; params: { target: AccountId20Like } }
  /**
   * Add the given account to the sender's subs.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'AddSub'; params: { sub: AccountId20Like; data: Data } }
  /**
   * Alter the associated name of the given sub-account.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'RenameSub'; params: { sub: AccountId20Like; data: Data } }
  /**
   * Remove the given account from the sender's subs.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'RemoveSub'; params: { sub: AccountId20Like } }
  /**
   * Remove the sender as a sub-account.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender (*not* the original depositor).
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * super-identity.
   *
   * NOTE: This should not normally be used, but is provided in the case that the non-
   * controller of an account is maliciously registered as a sub-account.
   **/
  | { name: 'QuitSub' }
  /**
   * Add an `AccountId` with permission to grant usernames with a given `suffix` appended.
   *
   * The authority can grant up to `allocation` usernames. To top up their allocation, they
   * should just issue (or request via governance) a new `add_username_authority` call.
   **/
  | { name: 'AddUsernameAuthority'; params: { authority: AccountId20Like; suffix: BytesLike; allocation: number } }
  /**
   * Remove `authority` from the username authorities.
   **/
  | { name: 'RemoveUsernameAuthority'; params: { authority: AccountId20Like } }
  /**
   * Set the username for `who`. Must be called by a username authority.
   *
   * The authority must have an `allocation`. Users can either pre-sign their usernames or
   * accept them later.
   *
   * Usernames must:
   * - Only contain lowercase ASCII characters or digits.
   * - When combined with the suffix of the issuing authority be _less than_ the
   * `MaxUsernameLength`.
   **/
  | {
      name: 'SetUsernameFor';
      params: { who: AccountId20Like; username: BytesLike; signature?: AccountEthereumSignature | undefined };
    }
  /**
   * Accept a given username that an `authority` granted. The call must include the full
   * username, as in `username.suffix`.
   **/
  | { name: 'AcceptUsername'; params: { username: BytesLike } }
  /**
   * Remove an expired username approval. The username was approved by an authority but never
   * accepted by the user and must now be beyond its expiration. The call must include the
   * full username, as in `username.suffix`.
   **/
  | { name: 'RemoveExpiredApproval'; params: { username: BytesLike } }
  /**
   * Set a given username as the primary. The username should include the suffix.
   **/
  | { name: 'SetPrimaryUsername'; params: { username: BytesLike } }
  /**
   * Remove a username that corresponds to an account with no identity. Exists when a user
   * gets a username but then calls `clear_identity`.
   **/
  | { name: 'RemoveDanglingUsername'; params: { username: BytesLike } };

export type PalletIdentityLegacyIdentityInfo = {
  additional: Array<[Data, Data]>;
  display: Data;
  legal: Data;
  web: Data;
  riot: Data;
  email: Data;
  pgpFingerprint?: FixedBytes<20> | undefined;
  image: Data;
  twitter: Data;
};

export type PalletIdentityJudgement =
  | { type: 'Unknown' }
  | { type: 'FeePaid'; value: bigint }
  | { type: 'Reasonable' }
  | { type: 'KnownGood' }
  | { type: 'OutOfDate' }
  | { type: 'LowQuality' }
  | { type: 'Erroneous' };

export type AccountEthereumSignature = FixedBytes<65>;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMultisigCall =
  /**
   * Immediately dispatch a multi-signature call using a single approval from the caller.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `other_signatories`: The accounts (other than the sender) who are part of the
   * multi-signature, but do not participate in the approval process.
   * - `call`: The call to be executed.
   *
   * Result is equivalent to the dispatched result.
   *
   * ## Complexity
   * O(Z + C) where Z is the length of the call and C its execution weight.
   **/
  | { name: 'AsMultiThreshold1'; params: { otherSignatories: Array<AccountId20>; call: MoonbeamRuntimeRuntimeCall } }
  /**
   * Register approval for a dispatch to be made from a deterministic composite account if
   * approved by a total of `threshold - 1` of `other_signatories`.
   *
   * If there are enough, then dispatch the call.
   *
   * Payment: `DepositBase` will be reserved if this is the first approval, plus
   * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
   * is cancelled.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
   * not the first approval, then it must be `Some`, with the timepoint (block number and
   * transaction index) of the first approval transaction.
   * - `call`: The call to be executed.
   *
   * NOTE: Unless this is the final approval, you will generally want to use
   * `approve_as_multi` instead, since it only requires a hash of the call.
   *
   * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
   * on success, result is `Ok` and the result from the interior call, if it was executed,
   * may be found in the deposited `MultisigExecuted` event.
   *
   * ## Complexity
   * - `O(S + Z + Call)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
   * - One encode & hash, both of complexity `O(S)`.
   * - Up to one binary search and insert (`O(logS + S)`).
   * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
   * - One event.
   * - The weight of the `call`.
   * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
   * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
   **/
  | {
      name: 'AsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId20>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        call: MoonbeamRuntimeRuntimeCall;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Register approval for a dispatch to be made from a deterministic composite account if
   * approved by a total of `threshold - 1` of `other_signatories`.
   *
   * Payment: `DepositBase` will be reserved if this is the first approval, plus
   * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
   * is cancelled.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
   * not the first approval, then it must be `Some`, with the timepoint (block number and
   * transaction index) of the first approval transaction.
   * - `call_hash`: The hash of the call to be executed.
   *
   * NOTE: If this is the final approval, you will want to use `as_multi` instead.
   *
   * ## Complexity
   * - `O(S)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One encode & hash, both of complexity `O(S)`.
   * - Up to one binary search and insert (`O(logS + S)`).
   * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
   * - One event.
   * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
   * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
   **/
  | {
      name: 'ApproveAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId20>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        callHash: FixedBytes<32>;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
   * for this operation will be unreserved on success.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `timepoint`: The timepoint (block number and transaction index) of the first approval
   * transaction for this dispatch.
   * - `call_hash`: The hash of the call to be executed.
   *
   * ## Complexity
   * - `O(S)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One encode & hash, both of complexity `O(S)`.
   * - One event.
   * - I/O: 1 read `O(S)`, one remove.
   * - Storage: removes one item.
   **/
  | {
      name: 'CancelAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId20>;
        timepoint: PalletMultisigTimepoint;
        callHash: FixedBytes<32>;
      };
    };

export type PalletMultisigCallLike =
  /**
   * Immediately dispatch a multi-signature call using a single approval from the caller.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `other_signatories`: The accounts (other than the sender) who are part of the
   * multi-signature, but do not participate in the approval process.
   * - `call`: The call to be executed.
   *
   * Result is equivalent to the dispatched result.
   *
   * ## Complexity
   * O(Z + C) where Z is the length of the call and C its execution weight.
   **/
  | {
      name: 'AsMultiThreshold1';
      params: { otherSignatories: Array<AccountId20Like>; call: MoonbeamRuntimeRuntimeCallLike };
    }
  /**
   * Register approval for a dispatch to be made from a deterministic composite account if
   * approved by a total of `threshold - 1` of `other_signatories`.
   *
   * If there are enough, then dispatch the call.
   *
   * Payment: `DepositBase` will be reserved if this is the first approval, plus
   * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
   * is cancelled.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
   * not the first approval, then it must be `Some`, with the timepoint (block number and
   * transaction index) of the first approval transaction.
   * - `call`: The call to be executed.
   *
   * NOTE: Unless this is the final approval, you will generally want to use
   * `approve_as_multi` instead, since it only requires a hash of the call.
   *
   * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
   * on success, result is `Ok` and the result from the interior call, if it was executed,
   * may be found in the deposited `MultisigExecuted` event.
   *
   * ## Complexity
   * - `O(S + Z + Call)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
   * - One encode & hash, both of complexity `O(S)`.
   * - Up to one binary search and insert (`O(logS + S)`).
   * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
   * - One event.
   * - The weight of the `call`.
   * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
   * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
   **/
  | {
      name: 'AsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId20Like>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        call: MoonbeamRuntimeRuntimeCallLike;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Register approval for a dispatch to be made from a deterministic composite account if
   * approved by a total of `threshold - 1` of `other_signatories`.
   *
   * Payment: `DepositBase` will be reserved if this is the first approval, plus
   * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
   * is cancelled.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
   * not the first approval, then it must be `Some`, with the timepoint (block number and
   * transaction index) of the first approval transaction.
   * - `call_hash`: The hash of the call to be executed.
   *
   * NOTE: If this is the final approval, you will want to use `as_multi` instead.
   *
   * ## Complexity
   * - `O(S)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One encode & hash, both of complexity `O(S)`.
   * - Up to one binary search and insert (`O(logS + S)`).
   * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
   * - One event.
   * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
   * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
   **/
  | {
      name: 'ApproveAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId20Like>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        callHash: FixedBytes<32>;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
   * for this operation will be unreserved on success.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `timepoint`: The timepoint (block number and transaction index) of the first approval
   * transaction for this dispatch.
   * - `call_hash`: The hash of the call to be executed.
   *
   * ## Complexity
   * - `O(S)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One encode & hash, both of complexity `O(S)`.
   * - One event.
   * - I/O: 1 read `O(S)`, one remove.
   * - Storage: removes one item.
   **/
  | {
      name: 'CancelAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId20Like>;
        timepoint: PalletMultisigTimepoint;
        callHash: FixedBytes<32>;
      };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMoonbeamLazyMigrationsCall =
  | { name: 'ClearSuicidedStorage'; params: { addresses: Array<H160>; limit: number } }
  | { name: 'CreateContractMetadata'; params: { address: H160 } };

export type PalletMoonbeamLazyMigrationsCallLike =
  | { name: 'ClearSuicidedStorage'; params: { addresses: Array<H160>; limit: number } }
  | { name: 'CreateContractMetadata'; params: { address: H160 } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletParametersCall =
  /**
   * Set the value of a parameter.
   *
   * The dispatch origin of this call must be `AdminOrigin` for the given `key`. Values be
   * deleted by setting them to `None`.
   **/
  { name: 'SetParameter'; params: { keyValue: MoonbeamRuntimeRuntimeParamsRuntimeParameters } };

export type PalletParametersCallLike =
  /**
   * Set the value of a parameter.
   *
   * The dispatch origin of this call must be `AdminOrigin` for the given `key`. Values be
   * deleted by setting them to `None`.
   **/
  { name: 'SetParameter'; params: { keyValue: MoonbeamRuntimeRuntimeParamsRuntimeParameters } };

export type MoonbeamRuntimeRuntimeParamsRuntimeParameters =
  | { type: 'RuntimeConfig'; value: MoonbeamRuntimeRuntimeParamsDynamicParamsRuntimeConfigParameters }
  | { type: 'PalletRandomness'; value: MoonbeamRuntimeRuntimeParamsDynamicParamsPalletRandomnessParameters };

export type MoonbeamRuntimeRuntimeParamsDynamicParamsRuntimeConfigParameters = {
  type: 'FeesTreasuryProportion';
  value: [MoonbeamRuntimeRuntimeParamsDynamicParamsRuntimeConfigFeesTreasuryProportion, Perbill | undefined];
};

export type MoonbeamRuntimeRuntimeParamsDynamicParamsPalletRandomnessParameters = {
  type: 'Deposit';
  value: [
    MoonbeamRuntimeRuntimeParamsDynamicParamsPalletRandomnessDeposit,
    MoonbeamRuntimeCommonBoundedU128 | undefined,
  ];
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletEvmCall =
  /**
   * Withdraw balance from EVM into currency/balances pallet.
   **/
  | { name: 'Withdraw'; params: { address: H160; value: bigint } }
  /**
   * Issue an EVM call operation. This is similar to a message call transaction in Ethereum.
   **/
  | {
      name: 'Call';
      params: {
        source: H160;
        target: H160;
        input: Bytes;
        value: U256;
        gasLimit: bigint;
        maxFeePerGas: U256;
        maxPriorityFeePerGas?: U256 | undefined;
        nonce?: U256 | undefined;
        accessList: Array<[H160, Array<H256>]>;
      };
    }
  /**
   * Issue an EVM create operation. This is similar to a contract creation transaction in
   * Ethereum.
   **/
  | {
      name: 'Create';
      params: {
        source: H160;
        init: Bytes;
        value: U256;
        gasLimit: bigint;
        maxFeePerGas: U256;
        maxPriorityFeePerGas?: U256 | undefined;
        nonce?: U256 | undefined;
        accessList: Array<[H160, Array<H256>]>;
      };
    }
  /**
   * Issue an EVM create2 operation.
   **/
  | {
      name: 'Create2';
      params: {
        source: H160;
        init: Bytes;
        salt: H256;
        value: U256;
        gasLimit: bigint;
        maxFeePerGas: U256;
        maxPriorityFeePerGas?: U256 | undefined;
        nonce?: U256 | undefined;
        accessList: Array<[H160, Array<H256>]>;
      };
    };

export type PalletEvmCallLike =
  /**
   * Withdraw balance from EVM into currency/balances pallet.
   **/
  | { name: 'Withdraw'; params: { address: H160; value: bigint } }
  /**
   * Issue an EVM call operation. This is similar to a message call transaction in Ethereum.
   **/
  | {
      name: 'Call';
      params: {
        source: H160;
        target: H160;
        input: BytesLike;
        value: U256;
        gasLimit: bigint;
        maxFeePerGas: U256;
        maxPriorityFeePerGas?: U256 | undefined;
        nonce?: U256 | undefined;
        accessList: Array<[H160, Array<H256>]>;
      };
    }
  /**
   * Issue an EVM create operation. This is similar to a contract creation transaction in
   * Ethereum.
   **/
  | {
      name: 'Create';
      params: {
        source: H160;
        init: BytesLike;
        value: U256;
        gasLimit: bigint;
        maxFeePerGas: U256;
        maxPriorityFeePerGas?: U256 | undefined;
        nonce?: U256 | undefined;
        accessList: Array<[H160, Array<H256>]>;
      };
    }
  /**
   * Issue an EVM create2 operation.
   **/
  | {
      name: 'Create2';
      params: {
        source: H160;
        init: BytesLike;
        salt: H256;
        value: U256;
        gasLimit: bigint;
        maxFeePerGas: U256;
        maxPriorityFeePerGas?: U256 | undefined;
        nonce?: U256 | undefined;
        accessList: Array<[H160, Array<H256>]>;
      };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletEthereumCall =
  /**
   * Transact an Ethereum transaction.
   **/
  { name: 'Transact'; params: { transaction: EthereumTransactionTransactionV2 } };

export type PalletEthereumCallLike =
  /**
   * Transact an Ethereum transaction.
   **/
  { name: 'Transact'; params: { transaction: EthereumTransactionTransactionV2 } };

export type EthereumTransactionTransactionV2 =
  | { type: 'Legacy'; value: EthereumTransactionLegacyTransaction }
  | { type: 'Eip2930'; value: EthereumTransactionEip2930Transaction }
  | { type: 'Eip1559'; value: EthereumTransactionEip1559Transaction };

export type EthereumTransactionLegacyTransaction = {
  nonce: U256;
  gasPrice: U256;
  gasLimit: U256;
  action: EthereumTransactionTransactionAction;
  value: U256;
  input: Bytes;
  signature: EthereumTransactionTransactionSignature;
};

export type EthereumTransactionTransactionAction = { type: 'Call'; value: H160 } | { type: 'Create' };

export type EthereumTransactionTransactionSignature = { v: EthereumTransactionTransactionRecoveryId; r: H256; s: H256 };

export type EthereumTransactionTransactionRecoveryId = bigint;

export type EthereumTransactionEip2930Transaction = {
  chainId: bigint;
  nonce: U256;
  gasPrice: U256;
  gasLimit: U256;
  action: EthereumTransactionTransactionAction;
  value: U256;
  input: Bytes;
  accessList: Array<EthereumTransactionAccessListItem>;
  oddYParity: boolean;
  r: H256;
  s: H256;
};

export type EthereumTransactionAccessListItem = { address: H160; storageKeys: Array<H256> };

export type EthereumTransactionEip1559Transaction = {
  chainId: bigint;
  nonce: U256;
  maxPriorityFeePerGas: U256;
  maxFeePerGas: U256;
  gasLimit: U256;
  action: EthereumTransactionTransactionAction;
  value: U256;
  input: Bytes;
  accessList: Array<EthereumTransactionAccessListItem>;
  oddYParity: boolean;
  r: H256;
  s: H256;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSchedulerCall =
  /**
   * Anonymously schedule a task.
   **/
  | {
      name: 'Schedule';
      params: {
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: MoonbeamRuntimeRuntimeCall;
      };
    }
  /**
   * Cancel an anonymously scheduled task.
   **/
  | { name: 'Cancel'; params: { when: number; index: number } }
  /**
   * Schedule a named task.
   **/
  | {
      name: 'ScheduleNamed';
      params: {
        id: FixedBytes<32>;
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: MoonbeamRuntimeRuntimeCall;
      };
    }
  /**
   * Cancel a named scheduled task.
   **/
  | { name: 'CancelNamed'; params: { id: FixedBytes<32> } }
  /**
   * Anonymously schedule a task after a delay.
   **/
  | {
      name: 'ScheduleAfter';
      params: {
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: MoonbeamRuntimeRuntimeCall;
      };
    }
  /**
   * Schedule a named task after a delay.
   **/
  | {
      name: 'ScheduleNamedAfter';
      params: {
        id: FixedBytes<32>;
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: MoonbeamRuntimeRuntimeCall;
      };
    }
  /**
   * Set a retry configuration for a task so that, in case its scheduled run fails, it will
   * be retried after `period` blocks, for a total amount of `retries` retries or until it
   * succeeds.
   *
   * Tasks which need to be scheduled for a retry are still subject to weight metering and
   * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
   * normally while the task is retrying.
   *
   * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
   * clones of the original task. Their retry configuration will be derived from the
   * original task's configuration, but will have a lower value for `remaining` than the
   * original `total_retries`.
   **/
  | { name: 'SetRetry'; params: { task: [number, number]; retries: number; period: number } }
  /**
   * Set a retry configuration for a named task so that, in case its scheduled run fails, it
   * will be retried after `period` blocks, for a total amount of `retries` retries or until
   * it succeeds.
   *
   * Tasks which need to be scheduled for a retry are still subject to weight metering and
   * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
   * normally while the task is retrying.
   *
   * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
   * clones of the original task. Their retry configuration will be derived from the
   * original task's configuration, but will have a lower value for `remaining` than the
   * original `total_retries`.
   **/
  | { name: 'SetRetryNamed'; params: { id: FixedBytes<32>; retries: number; period: number } }
  /**
   * Removes the retry configuration of a task.
   **/
  | { name: 'CancelRetry'; params: { task: [number, number] } }
  /**
   * Cancel the retry configuration of a named task.
   **/
  | { name: 'CancelRetryNamed'; params: { id: FixedBytes<32> } };

export type PalletSchedulerCallLike =
  /**
   * Anonymously schedule a task.
   **/
  | {
      name: 'Schedule';
      params: {
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: MoonbeamRuntimeRuntimeCallLike;
      };
    }
  /**
   * Cancel an anonymously scheduled task.
   **/
  | { name: 'Cancel'; params: { when: number; index: number } }
  /**
   * Schedule a named task.
   **/
  | {
      name: 'ScheduleNamed';
      params: {
        id: FixedBytes<32>;
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: MoonbeamRuntimeRuntimeCallLike;
      };
    }
  /**
   * Cancel a named scheduled task.
   **/
  | { name: 'CancelNamed'; params: { id: FixedBytes<32> } }
  /**
   * Anonymously schedule a task after a delay.
   **/
  | {
      name: 'ScheduleAfter';
      params: {
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: MoonbeamRuntimeRuntimeCallLike;
      };
    }
  /**
   * Schedule a named task after a delay.
   **/
  | {
      name: 'ScheduleNamedAfter';
      params: {
        id: FixedBytes<32>;
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: MoonbeamRuntimeRuntimeCallLike;
      };
    }
  /**
   * Set a retry configuration for a task so that, in case its scheduled run fails, it will
   * be retried after `period` blocks, for a total amount of `retries` retries or until it
   * succeeds.
   *
   * Tasks which need to be scheduled for a retry are still subject to weight metering and
   * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
   * normally while the task is retrying.
   *
   * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
   * clones of the original task. Their retry configuration will be derived from the
   * original task's configuration, but will have a lower value for `remaining` than the
   * original `total_retries`.
   **/
  | { name: 'SetRetry'; params: { task: [number, number]; retries: number; period: number } }
  /**
   * Set a retry configuration for a named task so that, in case its scheduled run fails, it
   * will be retried after `period` blocks, for a total amount of `retries` retries or until
   * it succeeds.
   *
   * Tasks which need to be scheduled for a retry are still subject to weight metering and
   * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
   * normally while the task is retrying.
   *
   * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
   * clones of the original task. Their retry configuration will be derived from the
   * original task's configuration, but will have a lower value for `remaining` than the
   * original `total_retries`.
   **/
  | { name: 'SetRetryNamed'; params: { id: FixedBytes<32>; retries: number; period: number } }
  /**
   * Removes the retry configuration of a task.
   **/
  | { name: 'CancelRetry'; params: { task: [number, number] } }
  /**
   * Cancel the retry configuration of a named task.
   **/
  | { name: 'CancelRetryNamed'; params: { id: FixedBytes<32> } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletPreimageCall =
  /**
   * Register a preimage on-chain.
   *
   * If the preimage was previously requested, no fees or deposits are taken for providing
   * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
   **/
  | { name: 'NotePreimage'; params: { bytes: Bytes } }
  /**
   * Clear an unrequested preimage from the runtime storage.
   *
   * If `len` is provided, then it will be a much cheaper operation.
   *
   * - `hash`: The hash of the preimage to be removed from the store.
   * - `len`: The length of the preimage of `hash`.
   **/
  | { name: 'UnnotePreimage'; params: { hash: H256 } }
  /**
   * Request a preimage be uploaded to the chain without paying any fees or deposits.
   *
   * If the preimage requests has already been provided on-chain, we unreserve any deposit
   * a user may have paid, and take the control of the preimage out of their hands.
   **/
  | { name: 'RequestPreimage'; params: { hash: H256 } }
  /**
   * Clear a previously made request for a preimage.
   *
   * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
   **/
  | { name: 'UnrequestPreimage'; params: { hash: H256 } }
  /**
   * Ensure that the a bulk of pre-images is upgraded.
   *
   * The caller pays no fee if at least 90% of pre-images were successfully updated.
   **/
  | { name: 'EnsureUpdated'; params: { hashes: Array<H256> } };

export type PalletPreimageCallLike =
  /**
   * Register a preimage on-chain.
   *
   * If the preimage was previously requested, no fees or deposits are taken for providing
   * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
   **/
  | { name: 'NotePreimage'; params: { bytes: BytesLike } }
  /**
   * Clear an unrequested preimage from the runtime storage.
   *
   * If `len` is provided, then it will be a much cheaper operation.
   *
   * - `hash`: The hash of the preimage to be removed from the store.
   * - `len`: The length of the preimage of `hash`.
   **/
  | { name: 'UnnotePreimage'; params: { hash: H256 } }
  /**
   * Request a preimage be uploaded to the chain without paying any fees or deposits.
   *
   * If the preimage requests has already been provided on-chain, we unreserve any deposit
   * a user may have paid, and take the control of the preimage out of their hands.
   **/
  | { name: 'RequestPreimage'; params: { hash: H256 } }
  /**
   * Clear a previously made request for a preimage.
   *
   * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
   **/
  | { name: 'UnrequestPreimage'; params: { hash: H256 } }
  /**
   * Ensure that the a bulk of pre-images is upgraded.
   *
   * The caller pays no fee if at least 90% of pre-images were successfully updated.
   **/
  | { name: 'EnsureUpdated'; params: { hashes: Array<H256> } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletConvictionVotingCall =
  /**
   * Vote in a poll. If `vote.is_aye()`, the vote is to enact the proposal;
   * otherwise it is a vote to keep the status quo.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `poll_index`: The index of the poll to vote for.
   * - `vote`: The vote configuration.
   *
   * Weight: `O(R)` where R is the number of polls the voter has voted on.
   **/
  | { name: 'Vote'; params: { pollIndex: number; vote: PalletConvictionVotingVoteAccountVote } }
  /**
   * Delegate the voting power (with some given conviction) of the sending account for a
   * particular class of polls.
   *
   * The balance delegated is locked for as long as it's delegated, and thereafter for the
   * time appropriate for the conviction's lock period.
   *
   * The dispatch origin of this call must be _Signed_, and the signing account must either:
   * - be delegating already; or
   * - have no voting activity (if there is, then it will need to be removed through
   * `remove_vote`).
   *
   * - `to`: The account whose voting the `target` account's voting power will follow.
   * - `class`: The class of polls to delegate. To delegate multiple classes, multiple calls
   * to this function are required.
   * - `conviction`: The conviction that will be attached to the delegated votes. When the
   * account is undelegated, the funds will be locked for the corresponding period.
   * - `balance`: The amount of the account's balance to be used in delegating. This must not
   * be more than the account's current balance.
   *
   * Emits `Delegated`.
   *
   * Weight: `O(R)` where R is the number of polls the voter delegating to has
   * voted on. Weight is initially charged as if maximum votes, but is refunded later.
   **/
  | {
      name: 'Delegate';
      params: { class: number; to: AccountId20; conviction: PalletConvictionVotingConviction; balance: bigint };
    }
  /**
   * Undelegate the voting power of the sending account for a particular class of polls.
   *
   * Tokens may be unlocked following once an amount of time consistent with the lock period
   * of the conviction with which the delegation was issued has passed.
   *
   * The dispatch origin of this call must be _Signed_ and the signing account must be
   * currently delegating.
   *
   * - `class`: The class of polls to remove the delegation from.
   *
   * Emits `Undelegated`.
   *
   * Weight: `O(R)` where R is the number of polls the voter delegating to has
   * voted on. Weight is initially charged as if maximum votes, but is refunded later.
   **/
  | { name: 'Undelegate'; params: { class: number } }
  /**
   * Remove the lock caused by prior voting/delegating which has expired within a particular
   * class.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `class`: The class of polls to unlock.
   * - `target`: The account to remove the lock on.
   *
   * Weight: `O(R)` with R number of vote of target.
   **/
  | { name: 'Unlock'; params: { class: number; target: AccountId20 } }
  /**
   * Remove a vote for a poll.
   *
   * If:
   * - the poll was cancelled, or
   * - the poll is ongoing, or
   * - the poll has ended such that
   * - the vote of the account was in opposition to the result; or
   * - there was no conviction to the account's vote; or
   * - the account made a split vote
   * ...then the vote is removed cleanly and a following call to `unlock` may result in more
   * funds being available.
   *
   * If, however, the poll has ended and:
   * - it finished corresponding to the vote of the account, and
   * - the account made a standard vote with conviction, and
   * - the lock period of the conviction is not over
   * ...then the lock will be aggregated into the overall account's lock, which may involve
   * *overlocking* (where the two locks are combined into a single lock that is the maximum
   * of both the amount locked and the time is it locked for).
   *
   * The dispatch origin of this call must be _Signed_, and the signer must have a vote
   * registered for poll `index`.
   *
   * - `index`: The index of poll of the vote to be removed.
   * - `class`: Optional parameter, if given it indicates the class of the poll. For polls
   * which have finished or are cancelled, this must be `Some`.
   *
   * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: 'RemoveVote'; params: { class?: number | undefined; index: number } }
  /**
   * Remove a vote for a poll.
   *
   * If the `target` is equal to the signer, then this function is exactly equivalent to
   * `remove_vote`. If not equal to the signer, then the vote must have expired,
   * either because the poll was cancelled, because the voter lost the poll or
   * because the conviction period is over.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `target`: The account of the vote to be removed; this account must have voted for poll
   * `index`.
   * - `index`: The index of poll of the vote to be removed.
   * - `class`: The class of the poll.
   *
   * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: 'RemoveOtherVote'; params: { target: AccountId20; class: number; index: number } };

export type PalletConvictionVotingCallLike =
  /**
   * Vote in a poll. If `vote.is_aye()`, the vote is to enact the proposal;
   * otherwise it is a vote to keep the status quo.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `poll_index`: The index of the poll to vote for.
   * - `vote`: The vote configuration.
   *
   * Weight: `O(R)` where R is the number of polls the voter has voted on.
   **/
  | { name: 'Vote'; params: { pollIndex: number; vote: PalletConvictionVotingVoteAccountVote } }
  /**
   * Delegate the voting power (with some given conviction) of the sending account for a
   * particular class of polls.
   *
   * The balance delegated is locked for as long as it's delegated, and thereafter for the
   * time appropriate for the conviction's lock period.
   *
   * The dispatch origin of this call must be _Signed_, and the signing account must either:
   * - be delegating already; or
   * - have no voting activity (if there is, then it will need to be removed through
   * `remove_vote`).
   *
   * - `to`: The account whose voting the `target` account's voting power will follow.
   * - `class`: The class of polls to delegate. To delegate multiple classes, multiple calls
   * to this function are required.
   * - `conviction`: The conviction that will be attached to the delegated votes. When the
   * account is undelegated, the funds will be locked for the corresponding period.
   * - `balance`: The amount of the account's balance to be used in delegating. This must not
   * be more than the account's current balance.
   *
   * Emits `Delegated`.
   *
   * Weight: `O(R)` where R is the number of polls the voter delegating to has
   * voted on. Weight is initially charged as if maximum votes, but is refunded later.
   **/
  | {
      name: 'Delegate';
      params: { class: number; to: AccountId20Like; conviction: PalletConvictionVotingConviction; balance: bigint };
    }
  /**
   * Undelegate the voting power of the sending account for a particular class of polls.
   *
   * Tokens may be unlocked following once an amount of time consistent with the lock period
   * of the conviction with which the delegation was issued has passed.
   *
   * The dispatch origin of this call must be _Signed_ and the signing account must be
   * currently delegating.
   *
   * - `class`: The class of polls to remove the delegation from.
   *
   * Emits `Undelegated`.
   *
   * Weight: `O(R)` where R is the number of polls the voter delegating to has
   * voted on. Weight is initially charged as if maximum votes, but is refunded later.
   **/
  | { name: 'Undelegate'; params: { class: number } }
  /**
   * Remove the lock caused by prior voting/delegating which has expired within a particular
   * class.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `class`: The class of polls to unlock.
   * - `target`: The account to remove the lock on.
   *
   * Weight: `O(R)` with R number of vote of target.
   **/
  | { name: 'Unlock'; params: { class: number; target: AccountId20Like } }
  /**
   * Remove a vote for a poll.
   *
   * If:
   * - the poll was cancelled, or
   * - the poll is ongoing, or
   * - the poll has ended such that
   * - the vote of the account was in opposition to the result; or
   * - there was no conviction to the account's vote; or
   * - the account made a split vote
   * ...then the vote is removed cleanly and a following call to `unlock` may result in more
   * funds being available.
   *
   * If, however, the poll has ended and:
   * - it finished corresponding to the vote of the account, and
   * - the account made a standard vote with conviction, and
   * - the lock period of the conviction is not over
   * ...then the lock will be aggregated into the overall account's lock, which may involve
   * *overlocking* (where the two locks are combined into a single lock that is the maximum
   * of both the amount locked and the time is it locked for).
   *
   * The dispatch origin of this call must be _Signed_, and the signer must have a vote
   * registered for poll `index`.
   *
   * - `index`: The index of poll of the vote to be removed.
   * - `class`: Optional parameter, if given it indicates the class of the poll. For polls
   * which have finished or are cancelled, this must be `Some`.
   *
   * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: 'RemoveVote'; params: { class?: number | undefined; index: number } }
  /**
   * Remove a vote for a poll.
   *
   * If the `target` is equal to the signer, then this function is exactly equivalent to
   * `remove_vote`. If not equal to the signer, then the vote must have expired,
   * either because the poll was cancelled, because the voter lost the poll or
   * because the conviction period is over.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `target`: The account of the vote to be removed; this account must have voted for poll
   * `index`.
   * - `index`: The index of poll of the vote to be removed.
   * - `class`: The class of the poll.
   *
   * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: 'RemoveOtherVote'; params: { target: AccountId20Like; class: number; index: number } };

export type PalletConvictionVotingVoteAccountVote =
  | { type: 'Standard'; value: { vote: PalletConvictionVotingVote; balance: bigint } }
  | { type: 'Split'; value: { aye: bigint; nay: bigint } }
  | { type: 'SplitAbstain'; value: { aye: bigint; nay: bigint; abstain: bigint } };

export type PalletConvictionVotingVote = number;

export type PalletConvictionVotingConviction =
  | 'None'
  | 'Locked1x'
  | 'Locked2x'
  | 'Locked3x'
  | 'Locked4x'
  | 'Locked5x'
  | 'Locked6x';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletReferendaCall =
  /**
   * Propose a referendum on a privileged action.
   *
   * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
   * available.
   * - `proposal_origin`: The origin from which the proposal should be executed.
   * - `proposal`: The proposal.
   * - `enactment_moment`: The moment that the proposal should be enacted.
   *
   * Emits `Submitted`.
   **/
  | {
      name: 'Submit';
      params: {
        proposalOrigin: MoonbeamRuntimeOriginCaller;
        proposal: FrameSupportPreimagesBounded;
        enactmentMoment: FrameSupportScheduleDispatchTime;
      };
    }
  /**
   * Post the Decision Deposit for a referendum.
   *
   * - `origin`: must be `Signed` and the account must have funds available for the
   * referendum's track's Decision Deposit.
   * - `index`: The index of the submitted referendum whose Decision Deposit is yet to be
   * posted.
   *
   * Emits `DecisionDepositPlaced`.
   **/
  | { name: 'PlaceDecisionDeposit'; params: { index: number } }
  /**
   * Refund the Decision Deposit for a closed referendum back to the depositor.
   *
   * - `origin`: must be `Signed` or `Root`.
   * - `index`: The index of a closed referendum whose Decision Deposit has not yet been
   * refunded.
   *
   * Emits `DecisionDepositRefunded`.
   **/
  | { name: 'RefundDecisionDeposit'; params: { index: number } }
  /**
   * Cancel an ongoing referendum.
   *
   * - `origin`: must be the `CancelOrigin`.
   * - `index`: The index of the referendum to be cancelled.
   *
   * Emits `Cancelled`.
   **/
  | { name: 'Cancel'; params: { index: number } }
  /**
   * Cancel an ongoing referendum and slash the deposits.
   *
   * - `origin`: must be the `KillOrigin`.
   * - `index`: The index of the referendum to be cancelled.
   *
   * Emits `Killed` and `DepositSlashed`.
   **/
  | { name: 'Kill'; params: { index: number } }
  /**
   * Advance a referendum onto its next logical state. Only used internally.
   *
   * - `origin`: must be `Root`.
   * - `index`: the referendum to be advanced.
   **/
  | { name: 'NudgeReferendum'; params: { index: number } }
  /**
   * Advance a track onto its next logical state. Only used internally.
   *
   * - `origin`: must be `Root`.
   * - `track`: the track to be advanced.
   *
   * Action item for when there is now one fewer referendum in the deciding phase and the
   * `DecidingCount` is not yet updated. This means that we should either:
   * - begin deciding another referendum (and leave `DecidingCount` alone); or
   * - decrement `DecidingCount`.
   **/
  | { name: 'OneFewerDeciding'; params: { track: number } }
  /**
   * Refund the Submission Deposit for a closed referendum back to the depositor.
   *
   * - `origin`: must be `Signed` or `Root`.
   * - `index`: The index of a closed referendum whose Submission Deposit has not yet been
   * refunded.
   *
   * Emits `SubmissionDepositRefunded`.
   **/
  | { name: 'RefundSubmissionDeposit'; params: { index: number } }
  /**
   * Set or clear metadata of a referendum.
   *
   * Parameters:
   * - `origin`: Must be `Signed` by a creator of a referendum or by anyone to clear a
   * metadata of a finished referendum.
   * - `index`: The index of a referendum to set or clear metadata for.
   * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
   **/
  | { name: 'SetMetadata'; params: { index: number; maybeHash?: H256 | undefined } };

export type PalletReferendaCallLike =
  /**
   * Propose a referendum on a privileged action.
   *
   * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
   * available.
   * - `proposal_origin`: The origin from which the proposal should be executed.
   * - `proposal`: The proposal.
   * - `enactment_moment`: The moment that the proposal should be enacted.
   *
   * Emits `Submitted`.
   **/
  | {
      name: 'Submit';
      params: {
        proposalOrigin: MoonbeamRuntimeOriginCaller;
        proposal: FrameSupportPreimagesBounded;
        enactmentMoment: FrameSupportScheduleDispatchTime;
      };
    }
  /**
   * Post the Decision Deposit for a referendum.
   *
   * - `origin`: must be `Signed` and the account must have funds available for the
   * referendum's track's Decision Deposit.
   * - `index`: The index of the submitted referendum whose Decision Deposit is yet to be
   * posted.
   *
   * Emits `DecisionDepositPlaced`.
   **/
  | { name: 'PlaceDecisionDeposit'; params: { index: number } }
  /**
   * Refund the Decision Deposit for a closed referendum back to the depositor.
   *
   * - `origin`: must be `Signed` or `Root`.
   * - `index`: The index of a closed referendum whose Decision Deposit has not yet been
   * refunded.
   *
   * Emits `DecisionDepositRefunded`.
   **/
  | { name: 'RefundDecisionDeposit'; params: { index: number } }
  /**
   * Cancel an ongoing referendum.
   *
   * - `origin`: must be the `CancelOrigin`.
   * - `index`: The index of the referendum to be cancelled.
   *
   * Emits `Cancelled`.
   **/
  | { name: 'Cancel'; params: { index: number } }
  /**
   * Cancel an ongoing referendum and slash the deposits.
   *
   * - `origin`: must be the `KillOrigin`.
   * - `index`: The index of the referendum to be cancelled.
   *
   * Emits `Killed` and `DepositSlashed`.
   **/
  | { name: 'Kill'; params: { index: number } }
  /**
   * Advance a referendum onto its next logical state. Only used internally.
   *
   * - `origin`: must be `Root`.
   * - `index`: the referendum to be advanced.
   **/
  | { name: 'NudgeReferendum'; params: { index: number } }
  /**
   * Advance a track onto its next logical state. Only used internally.
   *
   * - `origin`: must be `Root`.
   * - `track`: the track to be advanced.
   *
   * Action item for when there is now one fewer referendum in the deciding phase and the
   * `DecidingCount` is not yet updated. This means that we should either:
   * - begin deciding another referendum (and leave `DecidingCount` alone); or
   * - decrement `DecidingCount`.
   **/
  | { name: 'OneFewerDeciding'; params: { track: number } }
  /**
   * Refund the Submission Deposit for a closed referendum back to the depositor.
   *
   * - `origin`: must be `Signed` or `Root`.
   * - `index`: The index of a closed referendum whose Submission Deposit has not yet been
   * refunded.
   *
   * Emits `SubmissionDepositRefunded`.
   **/
  | { name: 'RefundSubmissionDeposit'; params: { index: number } }
  /**
   * Set or clear metadata of a referendum.
   *
   * Parameters:
   * - `origin`: Must be `Signed` by a creator of a referendum or by anyone to clear a
   * metadata of a finished referendum.
   * - `index`: The index of a referendum to set or clear metadata for.
   * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
   **/
  | { name: 'SetMetadata'; params: { index: number; maybeHash?: H256 | undefined } };

export type FrameSupportScheduleDispatchTime = { type: 'At'; value: number } | { type: 'After'; value: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletWhitelistCall =
  | { name: 'WhitelistCall'; params: { callHash: H256 } }
  | { name: 'RemoveWhitelistedCall'; params: { callHash: H256 } }
  | {
      name: 'DispatchWhitelistedCall';
      params: { callHash: H256; callEncodedLen: number; callWeightWitness: SpWeightsWeightV2Weight };
    }
  | { name: 'DispatchWhitelistedCallWithPreimage'; params: { call: MoonbeamRuntimeRuntimeCall } };

export type PalletWhitelistCallLike =
  | { name: 'WhitelistCall'; params: { callHash: H256 } }
  | { name: 'RemoveWhitelistedCall'; params: { callHash: H256 } }
  | {
      name: 'DispatchWhitelistedCall';
      params: { callHash: H256; callEncodedLen: number; callWeightWitness: SpWeightsWeightV2Weight };
    }
  | { name: 'DispatchWhitelistedCallWithPreimage'; params: { call: MoonbeamRuntimeRuntimeCallLike } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletCollectiveCall =
  /**
   * Set the collective's membership.
   *
   * - `new_members`: The new member list. Be nice to the chain and provide it sorted.
   * - `prime`: The prime member whose vote sets the default.
   * - `old_count`: The upper bound for the previous number of members in storage. Used for
   * weight estimation.
   *
   * The dispatch of this call must be `SetMembersOrigin`.
   *
   * NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
   * the weight estimations rely on it to estimate dispatchable weight.
   *
   * # WARNING:
   *
   * The `pallet-collective` can also be managed by logic outside of the pallet through the
   * implementation of the trait [`ChangeMembers`].
   * Any call to `set_members` must be careful that the member set doesn't get out of sync
   * with other logic managing the member set.
   *
   * ## Complexity:
   * - `O(MP + N)` where:
   * - `M` old-members-count (code- and governance-bounded)
   * - `N` new-members-count (code- and governance-bounded)
   * - `P` proposals-count (code-bounded)
   **/
  | {
      name: 'SetMembers';
      params: { newMembers: Array<AccountId20>; prime?: AccountId20 | undefined; oldCount: number };
    }
  /**
   * Dispatch a proposal from a member using the `Member` origin.
   *
   * Origin must be a member of the collective.
   *
   * ## Complexity:
   * - `O(B + M + P)` where:
   * - `B` is `proposal` size in bytes (length-fee-bounded)
   * - `M` members-count (code-bounded)
   * - `P` complexity of dispatching `proposal`
   **/
  | { name: 'Execute'; params: { proposal: MoonbeamRuntimeRuntimeCall; lengthBound: number } }
  /**
   * Add a new proposal to either be voted on or executed directly.
   *
   * Requires the sender to be member.
   *
   * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
   * or put up for voting.
   *
   * ## Complexity
   * - `O(B + M + P1)` or `O(B + M + P2)` where:
   * - `B` is `proposal` size in bytes (length-fee-bounded)
   * - `M` is members-count (code- and governance-bounded)
   * - branching is influenced by `threshold` where:
   * - `P1` is proposal execution complexity (`threshold < 2`)
   * - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
   **/
  | { name: 'Propose'; params: { threshold: number; proposal: MoonbeamRuntimeRuntimeCall; lengthBound: number } }
  /**
   * Add an aye or nay vote for the sender to the given proposal.
   *
   * Requires the sender to be a member.
   *
   * Transaction fees will be waived if the member is voting on any particular proposal
   * for the first time and the call is successful. Subsequent vote changes will charge a
   * fee.
   * ## Complexity
   * - `O(M)` where `M` is members-count (code- and governance-bounded)
   **/
  | { name: 'Vote'; params: { proposal: H256; index: number; approve: boolean } }
  /**
   * Disapprove a proposal, close, and remove it from the system, regardless of its current
   * state.
   *
   * Must be called by the Root origin.
   *
   * Parameters:
   * * `proposal_hash`: The hash of the proposal that should be disapproved.
   *
   * ## Complexity
   * O(P) where P is the number of max proposals
   **/
  | { name: 'DisapproveProposal'; params: { proposalHash: H256 } }
  /**
   * Close a vote that is either approved, disapproved or whose voting period has ended.
   *
   * May be called by any signed account in order to finish voting and close the proposal.
   *
   * If called before the end of the voting period it will only close the vote if it is
   * has enough votes to be approved or disapproved.
   *
   * If called after the end of the voting period abstentions are counted as rejections
   * unless there is a prime member set and the prime member cast an approval.
   *
   * If the close operation completes successfully with disapproval, the transaction fee will
   * be waived. Otherwise execution of the approved operation will be charged to the caller.
   *
   * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
   * proposal.
   * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
   * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
   *
   * ## Complexity
   * - `O(B + M + P1 + P2)` where:
   * - `B` is `proposal` size in bytes (length-fee-bounded)
   * - `M` is members-count (code- and governance-bounded)
   * - `P1` is the complexity of `proposal` preimage.
   * - `P2` is proposal-count (code-bounded)
   **/
  | {
      name: 'Close';
      params: { proposalHash: H256; index: number; proposalWeightBound: SpWeightsWeightV2Weight; lengthBound: number };
    };

export type PalletCollectiveCallLike =
  /**
   * Set the collective's membership.
   *
   * - `new_members`: The new member list. Be nice to the chain and provide it sorted.
   * - `prime`: The prime member whose vote sets the default.
   * - `old_count`: The upper bound for the previous number of members in storage. Used for
   * weight estimation.
   *
   * The dispatch of this call must be `SetMembersOrigin`.
   *
   * NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
   * the weight estimations rely on it to estimate dispatchable weight.
   *
   * # WARNING:
   *
   * The `pallet-collective` can also be managed by logic outside of the pallet through the
   * implementation of the trait [`ChangeMembers`].
   * Any call to `set_members` must be careful that the member set doesn't get out of sync
   * with other logic managing the member set.
   *
   * ## Complexity:
   * - `O(MP + N)` where:
   * - `M` old-members-count (code- and governance-bounded)
   * - `N` new-members-count (code- and governance-bounded)
   * - `P` proposals-count (code-bounded)
   **/
  | {
      name: 'SetMembers';
      params: { newMembers: Array<AccountId20Like>; prime?: AccountId20Like | undefined; oldCount: number };
    }
  /**
   * Dispatch a proposal from a member using the `Member` origin.
   *
   * Origin must be a member of the collective.
   *
   * ## Complexity:
   * - `O(B + M + P)` where:
   * - `B` is `proposal` size in bytes (length-fee-bounded)
   * - `M` members-count (code-bounded)
   * - `P` complexity of dispatching `proposal`
   **/
  | { name: 'Execute'; params: { proposal: MoonbeamRuntimeRuntimeCallLike; lengthBound: number } }
  /**
   * Add a new proposal to either be voted on or executed directly.
   *
   * Requires the sender to be member.
   *
   * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
   * or put up for voting.
   *
   * ## Complexity
   * - `O(B + M + P1)` or `O(B + M + P2)` where:
   * - `B` is `proposal` size in bytes (length-fee-bounded)
   * - `M` is members-count (code- and governance-bounded)
   * - branching is influenced by `threshold` where:
   * - `P1` is proposal execution complexity (`threshold < 2`)
   * - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
   **/
  | { name: 'Propose'; params: { threshold: number; proposal: MoonbeamRuntimeRuntimeCallLike; lengthBound: number } }
  /**
   * Add an aye or nay vote for the sender to the given proposal.
   *
   * Requires the sender to be a member.
   *
   * Transaction fees will be waived if the member is voting on any particular proposal
   * for the first time and the call is successful. Subsequent vote changes will charge a
   * fee.
   * ## Complexity
   * - `O(M)` where `M` is members-count (code- and governance-bounded)
   **/
  | { name: 'Vote'; params: { proposal: H256; index: number; approve: boolean } }
  /**
   * Disapprove a proposal, close, and remove it from the system, regardless of its current
   * state.
   *
   * Must be called by the Root origin.
   *
   * Parameters:
   * * `proposal_hash`: The hash of the proposal that should be disapproved.
   *
   * ## Complexity
   * O(P) where P is the number of max proposals
   **/
  | { name: 'DisapproveProposal'; params: { proposalHash: H256 } }
  /**
   * Close a vote that is either approved, disapproved or whose voting period has ended.
   *
   * May be called by any signed account in order to finish voting and close the proposal.
   *
   * If called before the end of the voting period it will only close the vote if it is
   * has enough votes to be approved or disapproved.
   *
   * If called after the end of the voting period abstentions are counted as rejections
   * unless there is a prime member set and the prime member cast an approval.
   *
   * If the close operation completes successfully with disapproval, the transaction fee will
   * be waived. Otherwise execution of the approved operation will be charged to the caller.
   *
   * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
   * proposal.
   * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
   * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
   *
   * ## Complexity
   * - `O(B + M + P1 + P2)` where:
   * - `B` is `proposal` size in bytes (length-fee-bounded)
   * - `M` is members-count (code- and governance-bounded)
   * - `P1` is the complexity of `proposal` preimage.
   * - `P2` is proposal-count (code-bounded)
   **/
  | {
      name: 'Close';
      params: { proposalHash: H256; index: number; proposalWeightBound: SpWeightsWeightV2Weight; lengthBound: number };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTreasuryCall =
  /**
   * Propose and approve a spend of treasury funds.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::SpendOrigin`] with the `Success` value being at least `amount`.
   *
   * ### Details
   * NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
   * beneficiary.
   *
   * ### Parameters
   * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
   * - `beneficiary`: The destination account for the transfer.
   *
   * ## Events
   *
   * Emits [`Event::SpendApproved`] if successful.
   **/
  | { name: 'SpendLocal'; params: { amount: bigint; beneficiary: AccountId20 } }
  /**
   * Force a previously approved proposal to be removed from the approval queue.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::RejectOrigin`].
   *
   * ## Details
   *
   * The original deposit will no longer be returned.
   *
   * ### Parameters
   * - `proposal_id`: The index of a proposal
   *
   * ### Complexity
   * - O(A) where `A` is the number of approvals
   *
   * ### Errors
   * - [`Error::ProposalNotApproved`]: The `proposal_id` supplied was not found in the
   * approval queue, i.e., the proposal has not been approved. This could also mean the
   * proposal does not exist altogether, thus there is no way it would have been approved
   * in the first place.
   **/
  | { name: 'RemoveApproval'; params: { proposalId: number } }
  /**
   * Propose and approve a spend of treasury funds.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::SpendOrigin`] with the `Success` value being at least
   * `amount` of `asset_kind` in the native asset. The amount of `asset_kind` is converted
   * for assertion using the [`Config::BalanceConverter`].
   *
   * ## Details
   *
   * Create an approved spend for transferring a specific `amount` of `asset_kind` to a
   * designated beneficiary. The spend must be claimed using the `payout` dispatchable within
   * the [`Config::PayoutPeriod`].
   *
   * ### Parameters
   * - `asset_kind`: An indicator of the specific asset class to be spent.
   * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
   * - `beneficiary`: The beneficiary of the spend.
   * - `valid_from`: The block number from which the spend can be claimed. It can refer to
   * the past if the resulting spend has not yet expired according to the
   * [`Config::PayoutPeriod`]. If `None`, the spend can be claimed immediately after
   * approval.
   *
   * ## Events
   *
   * Emits [`Event::AssetSpendApproved`] if successful.
   **/
  | {
      name: 'Spend';
      params: { assetKind: []; amount: bigint; beneficiary: AccountId20; validFrom?: number | undefined };
    }
  /**
   * Claim a spend.
   *
   * ## Dispatch Origin
   *
   * Must be signed
   *
   * ## Details
   *
   * Spends must be claimed within some temporal bounds. A spend may be claimed within one
   * [`Config::PayoutPeriod`] from the `valid_from` block.
   * In case of a payout failure, the spend status must be updated with the `check_status`
   * dispatchable before retrying with the current function.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::Paid`] if successful.
   **/
  | { name: 'Payout'; params: { index: number } }
  /**
   * Check the status of the spend and remove it from the storage if processed.
   *
   * ## Dispatch Origin
   *
   * Must be signed.
   *
   * ## Details
   *
   * The status check is a prerequisite for retrying a failed payout.
   * If a spend has either succeeded or expired, it is removed from the storage by this
   * function. In such instances, transaction fees are refunded.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::PaymentFailed`] if the spend payout has failed.
   * Emits [`Event::SpendProcessed`] if the spend payout has succeed.
   **/
  | { name: 'CheckStatus'; params: { index: number } }
  /**
   * Void previously approved spend.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::RejectOrigin`].
   *
   * ## Details
   *
   * A spend void is only possible if the payout has not been attempted yet.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::AssetSpendVoided`] if successful.
   **/
  | { name: 'VoidSpend'; params: { index: number } };

export type PalletTreasuryCallLike =
  /**
   * Propose and approve a spend of treasury funds.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::SpendOrigin`] with the `Success` value being at least `amount`.
   *
   * ### Details
   * NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
   * beneficiary.
   *
   * ### Parameters
   * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
   * - `beneficiary`: The destination account for the transfer.
   *
   * ## Events
   *
   * Emits [`Event::SpendApproved`] if successful.
   **/
  | { name: 'SpendLocal'; params: { amount: bigint; beneficiary: AccountId20Like } }
  /**
   * Force a previously approved proposal to be removed from the approval queue.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::RejectOrigin`].
   *
   * ## Details
   *
   * The original deposit will no longer be returned.
   *
   * ### Parameters
   * - `proposal_id`: The index of a proposal
   *
   * ### Complexity
   * - O(A) where `A` is the number of approvals
   *
   * ### Errors
   * - [`Error::ProposalNotApproved`]: The `proposal_id` supplied was not found in the
   * approval queue, i.e., the proposal has not been approved. This could also mean the
   * proposal does not exist altogether, thus there is no way it would have been approved
   * in the first place.
   **/
  | { name: 'RemoveApproval'; params: { proposalId: number } }
  /**
   * Propose and approve a spend of treasury funds.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::SpendOrigin`] with the `Success` value being at least
   * `amount` of `asset_kind` in the native asset. The amount of `asset_kind` is converted
   * for assertion using the [`Config::BalanceConverter`].
   *
   * ## Details
   *
   * Create an approved spend for transferring a specific `amount` of `asset_kind` to a
   * designated beneficiary. The spend must be claimed using the `payout` dispatchable within
   * the [`Config::PayoutPeriod`].
   *
   * ### Parameters
   * - `asset_kind`: An indicator of the specific asset class to be spent.
   * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
   * - `beneficiary`: The beneficiary of the spend.
   * - `valid_from`: The block number from which the spend can be claimed. It can refer to
   * the past if the resulting spend has not yet expired according to the
   * [`Config::PayoutPeriod`]. If `None`, the spend can be claimed immediately after
   * approval.
   *
   * ## Events
   *
   * Emits [`Event::AssetSpendApproved`] if successful.
   **/
  | {
      name: 'Spend';
      params: { assetKind: []; amount: bigint; beneficiary: AccountId20Like; validFrom?: number | undefined };
    }
  /**
   * Claim a spend.
   *
   * ## Dispatch Origin
   *
   * Must be signed
   *
   * ## Details
   *
   * Spends must be claimed within some temporal bounds. A spend may be claimed within one
   * [`Config::PayoutPeriod`] from the `valid_from` block.
   * In case of a payout failure, the spend status must be updated with the `check_status`
   * dispatchable before retrying with the current function.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::Paid`] if successful.
   **/
  | { name: 'Payout'; params: { index: number } }
  /**
   * Check the status of the spend and remove it from the storage if processed.
   *
   * ## Dispatch Origin
   *
   * Must be signed.
   *
   * ## Details
   *
   * The status check is a prerequisite for retrying a failed payout.
   * If a spend has either succeeded or expired, it is removed from the storage by this
   * function. In such instances, transaction fees are refunded.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::PaymentFailed`] if the spend payout has failed.
   * Emits [`Event::SpendProcessed`] if the spend payout has succeed.
   **/
  | { name: 'CheckStatus'; params: { index: number } }
  /**
   * Void previously approved spend.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::RejectOrigin`].
   *
   * ## Details
   *
   * A spend void is only possible if the payout has not been attempted yet.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::AssetSpendVoided`] if successful.
   **/
  | { name: 'VoidSpend'; params: { index: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletCrowdloanRewardsCall =
  /**
   * Associate a native rewards_destination identity with a crowdloan contribution.
   *
   * The caller needs to provide the unassociated relay account and a proof to succeed
   * with the association
   * The proof is nothing but a signature over the reward_address using the relay keys
   **/
  | {
      name: 'AssociateNativeIdentity';
      params: { rewardAccount: AccountId20; relayAccount: FixedBytes<32>; proof: SpRuntimeMultiSignature };
    }
  /**
   * Change reward account by submitting proofs from relay accounts
   *
   * The number of valid proofs needs to be bigger than 'RewardAddressRelayVoteThreshold'
   * The account to be changed needs to be submitted as 'previous_account'
   * Origin must be RewardAddressChangeOrigin
   **/
  | {
      name: 'ChangeAssociationWithRelayKeys';
      params: {
        rewardAccount: AccountId20;
        previousAccount: AccountId20;
        proofs: Array<[FixedBytes<32>, SpRuntimeMultiSignature]>;
      };
    }
  /**
   * Collect whatever portion of your reward are currently vested.
   **/
  | { name: 'Claim' }
  /**
   * Update reward address, proving that the caller owns the current native key
   **/
  | { name: 'UpdateRewardAddress'; params: { newRewardAccount: AccountId20 } }
  /**
   * This extrinsic completes the initialization if some checks are fullfiled. These checks are:
   * -The reward contribution money matches the crowdloan pot
   * -The end vesting block is higher than the init vesting block
   * -The initialization has not complete yet
   **/
  | { name: 'CompleteInitialization'; params: { leaseEndingBlock: number } }
  /**
   * Initialize the reward distribution storage. It shortcuts whenever an error is found
   * This does not enforce any checks other than making sure we dont go over funds
   * complete_initialization should perform any additional
   **/
  | { name: 'InitializeRewardVec'; params: { rewards: Array<[FixedBytes<32>, AccountId20 | undefined, bigint]> } };

export type PalletCrowdloanRewardsCallLike =
  /**
   * Associate a native rewards_destination identity with a crowdloan contribution.
   *
   * The caller needs to provide the unassociated relay account and a proof to succeed
   * with the association
   * The proof is nothing but a signature over the reward_address using the relay keys
   **/
  | {
      name: 'AssociateNativeIdentity';
      params: { rewardAccount: AccountId20Like; relayAccount: FixedBytes<32>; proof: SpRuntimeMultiSignature };
    }
  /**
   * Change reward account by submitting proofs from relay accounts
   *
   * The number of valid proofs needs to be bigger than 'RewardAddressRelayVoteThreshold'
   * The account to be changed needs to be submitted as 'previous_account'
   * Origin must be RewardAddressChangeOrigin
   **/
  | {
      name: 'ChangeAssociationWithRelayKeys';
      params: {
        rewardAccount: AccountId20Like;
        previousAccount: AccountId20Like;
        proofs: Array<[FixedBytes<32>, SpRuntimeMultiSignature]>;
      };
    }
  /**
   * Collect whatever portion of your reward are currently vested.
   **/
  | { name: 'Claim' }
  /**
   * Update reward address, proving that the caller owns the current native key
   **/
  | { name: 'UpdateRewardAddress'; params: { newRewardAccount: AccountId20Like } }
  /**
   * This extrinsic completes the initialization if some checks are fullfiled. These checks are:
   * -The reward contribution money matches the crowdloan pot
   * -The end vesting block is higher than the init vesting block
   * -The initialization has not complete yet
   **/
  | { name: 'CompleteInitialization'; params: { leaseEndingBlock: number } }
  /**
   * Initialize the reward distribution storage. It shortcuts whenever an error is found
   * This does not enforce any checks other than making sure we dont go over funds
   * complete_initialization should perform any additional
   **/
  | { name: 'InitializeRewardVec'; params: { rewards: Array<[FixedBytes<32>, AccountId20Like | undefined, bigint]> } };

export type SpRuntimeMultiSignature =
  | { type: 'Ed25519'; value: FixedBytes<64> }
  | { type: 'Sr25519'; value: FixedBytes<64> }
  | { type: 'Ecdsa'; value: FixedBytes<65> };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletXcmCall =
  | { name: 'Send'; params: { dest: XcmVersionedLocation; message: XcmVersionedXcm } }
  /**
   * Teleport some assets from the local chain to some destination chain.
   *
   * **This function is deprecated: Use `limited_teleport_assets` instead.**
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
   * with all fees taken as needed from the asset.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` chain.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   **/
  | {
      name: 'TeleportAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
      };
    }
  /**
   * Transfer some assets from the local chain to the destination chain through their local,
   * destination or remote reserve.
   *
   * `assets` must have same reserve location and may not be teleportable to `dest`.
   * - `assets` have local reserve: transfer assets to sovereign account of destination
   * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
   * assets to `beneficiary`.
   * - `assets` have destination reserve: burn local assets and forward a notification to
   * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
   * deposit them to `beneficiary`.
   * - `assets` have remote reserve: burn local assets, forward XCM to reserve chain to move
   * reserves from this chain's SA to `dest` chain's SA, and forward another XCM to `dest`
   * to mint and deposit reserve-based assets to `beneficiary`.
   *
   * **This function is deprecated: Use `limited_reserve_transfer_assets` instead.**
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
   * with all fees taken as needed from the asset.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` (and possibly reserve) chains.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   **/
  | {
      name: 'ReserveTransferAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
      };
    }
  /**
   * Execute an XCM message from a local, signed, origin.
   *
   * An event is deposited indicating whether `msg` could be executed completely or only
   * partially.
   *
   * No more than `max_weight` will be used in its attempted execution. If this is less than
   * the maximum amount of weight that the message could take to be executed, then no
   * execution attempt will be made.
   **/
  | { name: 'Execute'; params: { message: XcmVersionedXcm; maxWeight: SpWeightsWeightV2Weight } }
  /**
   * Extoll that a particular destination can be communicated with through a particular
   * version of XCM.
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `location`: The destination that is being described.
   * - `xcm_version`: The latest version of XCM that `location` supports.
   **/
  | { name: 'ForceXcmVersion'; params: { location: StagingXcmV4Location; version: number } }
  /**
   * Set a safe XCM version (the version that XCM should be encoded with if the most recent
   * version a destination can accept is unknown).
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `maybe_xcm_version`: The default XCM encoding version, or `None` to disable.
   **/
  | { name: 'ForceDefaultXcmVersion'; params: { maybeXcmVersion?: number | undefined } }
  /**
   * Ask a location to notify us regarding their XCM version and any changes to it.
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `location`: The location to which we should subscribe for XCM version notifications.
   **/
  | { name: 'ForceSubscribeVersionNotify'; params: { location: XcmVersionedLocation } }
  /**
   * Require that a particular destination should no longer notify us regarding any XCM
   * version changes.
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `location`: The location to which we are currently subscribed for XCM version
   * notifications which we no longer desire.
   **/
  | { name: 'ForceUnsubscribeVersionNotify'; params: { location: XcmVersionedLocation } }
  /**
   * Transfer some assets from the local chain to the destination chain through their local,
   * destination or remote reserve.
   *
   * `assets` must have same reserve location and may not be teleportable to `dest`.
   * - `assets` have local reserve: transfer assets to sovereign account of destination
   * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
   * assets to `beneficiary`.
   * - `assets` have destination reserve: burn local assets and forward a notification to
   * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
   * deposit them to `beneficiary`.
   * - `assets` have remote reserve: burn local assets, forward XCM to reserve chain to move
   * reserves from this chain's SA to `dest` chain's SA, and forward another XCM to `dest`
   * to mint and deposit reserve-based assets to `beneficiary`.
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
   * is needed than `weight_limit`, then the operation will fail and the sent assets may be
   * at risk.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` (and possibly reserve) chains.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
   **/
  | {
      name: 'LimitedReserveTransferAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * Teleport some assets from the local chain to some destination chain.
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
   * is needed than `weight_limit`, then the operation will fail and the sent assets may be
   * at risk.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` chain.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
   **/
  | {
      name: 'LimitedTeleportAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * Set or unset the global suspension state of the XCM executor.
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `suspended`: `true` to suspend, `false` to resume.
   **/
  | { name: 'ForceSuspension'; params: { suspended: boolean } }
  /**
   * Transfer some assets from the local chain to the destination chain through their local,
   * destination or remote reserve, or through teleports.
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item` (hence referred to as `fees`), up to enough to pay for
   * `weight_limit` of weight. If more weight is needed than `weight_limit`, then the
   * operation will fail and the sent assets may be at risk.
   *
   * `assets` (excluding `fees`) must have same reserve location or otherwise be teleportable
   * to `dest`, no limitations imposed on `fees`.
   * - for local reserve: transfer assets to sovereign account of destination chain and
   * forward a notification XCM to `dest` to mint and deposit reserve-based assets to
   * `beneficiary`.
   * - for destination reserve: burn local assets and forward a notification to `dest` chain
   * to withdraw the reserve assets from this chain's sovereign account and deposit them
   * to `beneficiary`.
   * - for remote reserve: burn local assets, forward XCM to reserve chain to move reserves
   * from this chain's SA to `dest` chain's SA, and forward another XCM to `dest` to mint
   * and deposit reserve-based assets to `beneficiary`.
   * - for teleports: burn local assets and forward XCM to `dest` chain to mint/teleport
   * assets and deposit them to `beneficiary`.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `X2(Parent,
   * Parachain(..))` to send from parachain to parachain, or `X1(Parachain(..))` to send
   * from relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` (and possibly reserve) chains.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
   **/
  | {
      name: 'TransferAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * Claims assets trapped on this pallet because of leftover assets during XCM execution.
   *
   * - `origin`: Anyone can call this extrinsic.
   * - `assets`: The exact assets that were trapped. Use the version to specify what version
   * was the latest when they were trapped.
   * - `beneficiary`: The location/account where the claimed assets will be deposited.
   **/
  | { name: 'ClaimAssets'; params: { assets: XcmVersionedAssets; beneficiary: XcmVersionedLocation } }
  /**
   * Transfer assets from the local chain to the destination chain using explicit transfer
   * types for assets and fees.
   *
   * `assets` must have same reserve location or may be teleportable to `dest`. Caller must
   * provide the `assets_transfer_type` to be used for `assets`:
   * - `TransferType::LocalReserve`: transfer assets to sovereign account of destination
   * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
   * assets to `beneficiary`.
   * - `TransferType::DestinationReserve`: burn local assets and forward a notification to
   * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
   * deposit them to `beneficiary`.
   * - `TransferType::RemoteReserve(reserve)`: burn local assets, forward XCM to `reserve`
   * chain to move reserves from this chain's SA to `dest` chain's SA, and forward another
   * XCM to `dest` to mint and deposit reserve-based assets to `beneficiary`. Typically
   * the remote `reserve` is Asset Hub.
   * - `TransferType::Teleport`: burn local assets and forward XCM to `dest` chain to
   * mint/teleport assets and deposit them to `beneficiary`.
   *
   * On the destination chain, as well as any intermediary hops, `BuyExecution` is used to
   * buy execution using transferred `assets` identified by `remote_fees_id`.
   * Make sure enough of the specified `remote_fees_id` asset is included in the given list
   * of `assets`. `remote_fees_id` should be enough to pay for `weight_limit`. If more weight
   * is needed than `weight_limit`, then the operation will fail and the sent assets may be
   * at risk.
   *
   * `remote_fees_id` may use different transfer type than rest of `assets` and can be
   * specified through `fees_transfer_type`.
   *
   * The caller needs to specify what should happen to the transferred assets once they reach
   * the `dest` chain. This is done through the `custom_xcm_on_dest` parameter, which
   * contains the instructions to execute on `dest` as a final step.
   * This is usually as simple as:
   * `Xcm(vec![DepositAsset { assets: Wild(AllCounted(assets.len())), beneficiary }])`,
   * but could be something more exotic like sending the `assets` even further.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain, or `(parents: 2, (GlobalConsensus(..), ..))` to send from
   * parachain across a bridge to another ecosystem destination.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` (and possibly reserve) chains.
   * - `assets_transfer_type`: The XCM `TransferType` used to transfer the `assets`.
   * - `remote_fees_id`: One of the included `assets` to be used to pay fees.
   * - `fees_transfer_type`: The XCM `TransferType` used to transfer the `fees` assets.
   * - `custom_xcm_on_dest`: The XCM to be executed on `dest` chain as the last step of the
   * transfer, which also determines what happens to the assets on the destination chain.
   * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
   **/
  | {
      name: 'TransferAssetsUsingTypeAndThen';
      params: {
        dest: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        assetsTransferType: StagingXcmExecutorAssetTransferTransferType;
        remoteFeesId: XcmVersionedAssetId;
        feesTransferType: StagingXcmExecutorAssetTransferTransferType;
        customXcmOnDest: XcmVersionedXcm;
        weightLimit: XcmV3WeightLimit;
      };
    };

export type PalletXcmCallLike =
  | { name: 'Send'; params: { dest: XcmVersionedLocation; message: XcmVersionedXcm } }
  /**
   * Teleport some assets from the local chain to some destination chain.
   *
   * **This function is deprecated: Use `limited_teleport_assets` instead.**
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
   * with all fees taken as needed from the asset.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` chain.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   **/
  | {
      name: 'TeleportAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
      };
    }
  /**
   * Transfer some assets from the local chain to the destination chain through their local,
   * destination or remote reserve.
   *
   * `assets` must have same reserve location and may not be teleportable to `dest`.
   * - `assets` have local reserve: transfer assets to sovereign account of destination
   * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
   * assets to `beneficiary`.
   * - `assets` have destination reserve: burn local assets and forward a notification to
   * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
   * deposit them to `beneficiary`.
   * - `assets` have remote reserve: burn local assets, forward XCM to reserve chain to move
   * reserves from this chain's SA to `dest` chain's SA, and forward another XCM to `dest`
   * to mint and deposit reserve-based assets to `beneficiary`.
   *
   * **This function is deprecated: Use `limited_reserve_transfer_assets` instead.**
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
   * with all fees taken as needed from the asset.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` (and possibly reserve) chains.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   **/
  | {
      name: 'ReserveTransferAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
      };
    }
  /**
   * Execute an XCM message from a local, signed, origin.
   *
   * An event is deposited indicating whether `msg` could be executed completely or only
   * partially.
   *
   * No more than `max_weight` will be used in its attempted execution. If this is less than
   * the maximum amount of weight that the message could take to be executed, then no
   * execution attempt will be made.
   **/
  | { name: 'Execute'; params: { message: XcmVersionedXcm; maxWeight: SpWeightsWeightV2Weight } }
  /**
   * Extoll that a particular destination can be communicated with through a particular
   * version of XCM.
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `location`: The destination that is being described.
   * - `xcm_version`: The latest version of XCM that `location` supports.
   **/
  | { name: 'ForceXcmVersion'; params: { location: StagingXcmV4Location; version: number } }
  /**
   * Set a safe XCM version (the version that XCM should be encoded with if the most recent
   * version a destination can accept is unknown).
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `maybe_xcm_version`: The default XCM encoding version, or `None` to disable.
   **/
  | { name: 'ForceDefaultXcmVersion'; params: { maybeXcmVersion?: number | undefined } }
  /**
   * Ask a location to notify us regarding their XCM version and any changes to it.
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `location`: The location to which we should subscribe for XCM version notifications.
   **/
  | { name: 'ForceSubscribeVersionNotify'; params: { location: XcmVersionedLocation } }
  /**
   * Require that a particular destination should no longer notify us regarding any XCM
   * version changes.
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `location`: The location to which we are currently subscribed for XCM version
   * notifications which we no longer desire.
   **/
  | { name: 'ForceUnsubscribeVersionNotify'; params: { location: XcmVersionedLocation } }
  /**
   * Transfer some assets from the local chain to the destination chain through their local,
   * destination or remote reserve.
   *
   * `assets` must have same reserve location and may not be teleportable to `dest`.
   * - `assets` have local reserve: transfer assets to sovereign account of destination
   * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
   * assets to `beneficiary`.
   * - `assets` have destination reserve: burn local assets and forward a notification to
   * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
   * deposit them to `beneficiary`.
   * - `assets` have remote reserve: burn local assets, forward XCM to reserve chain to move
   * reserves from this chain's SA to `dest` chain's SA, and forward another XCM to `dest`
   * to mint and deposit reserve-based assets to `beneficiary`.
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
   * is needed than `weight_limit`, then the operation will fail and the sent assets may be
   * at risk.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` (and possibly reserve) chains.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
   **/
  | {
      name: 'LimitedReserveTransferAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * Teleport some assets from the local chain to some destination chain.
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
   * is needed than `weight_limit`, then the operation will fail and the sent assets may be
   * at risk.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` chain.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
   **/
  | {
      name: 'LimitedTeleportAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * Set or unset the global suspension state of the XCM executor.
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `suspended`: `true` to suspend, `false` to resume.
   **/
  | { name: 'ForceSuspension'; params: { suspended: boolean } }
  /**
   * Transfer some assets from the local chain to the destination chain through their local,
   * destination or remote reserve, or through teleports.
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item` (hence referred to as `fees`), up to enough to pay for
   * `weight_limit` of weight. If more weight is needed than `weight_limit`, then the
   * operation will fail and the sent assets may be at risk.
   *
   * `assets` (excluding `fees`) must have same reserve location or otherwise be teleportable
   * to `dest`, no limitations imposed on `fees`.
   * - for local reserve: transfer assets to sovereign account of destination chain and
   * forward a notification XCM to `dest` to mint and deposit reserve-based assets to
   * `beneficiary`.
   * - for destination reserve: burn local assets and forward a notification to `dest` chain
   * to withdraw the reserve assets from this chain's sovereign account and deposit them
   * to `beneficiary`.
   * - for remote reserve: burn local assets, forward XCM to reserve chain to move reserves
   * from this chain's SA to `dest` chain's SA, and forward another XCM to `dest` to mint
   * and deposit reserve-based assets to `beneficiary`.
   * - for teleports: burn local assets and forward XCM to `dest` chain to mint/teleport
   * assets and deposit them to `beneficiary`.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `X2(Parent,
   * Parachain(..))` to send from parachain to parachain, or `X1(Parachain(..))` to send
   * from relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` (and possibly reserve) chains.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
   **/
  | {
      name: 'TransferAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * Claims assets trapped on this pallet because of leftover assets during XCM execution.
   *
   * - `origin`: Anyone can call this extrinsic.
   * - `assets`: The exact assets that were trapped. Use the version to specify what version
   * was the latest when they were trapped.
   * - `beneficiary`: The location/account where the claimed assets will be deposited.
   **/
  | { name: 'ClaimAssets'; params: { assets: XcmVersionedAssets; beneficiary: XcmVersionedLocation } }
  /**
   * Transfer assets from the local chain to the destination chain using explicit transfer
   * types for assets and fees.
   *
   * `assets` must have same reserve location or may be teleportable to `dest`. Caller must
   * provide the `assets_transfer_type` to be used for `assets`:
   * - `TransferType::LocalReserve`: transfer assets to sovereign account of destination
   * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
   * assets to `beneficiary`.
   * - `TransferType::DestinationReserve`: burn local assets and forward a notification to
   * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
   * deposit them to `beneficiary`.
   * - `TransferType::RemoteReserve(reserve)`: burn local assets, forward XCM to `reserve`
   * chain to move reserves from this chain's SA to `dest` chain's SA, and forward another
   * XCM to `dest` to mint and deposit reserve-based assets to `beneficiary`. Typically
   * the remote `reserve` is Asset Hub.
   * - `TransferType::Teleport`: burn local assets and forward XCM to `dest` chain to
   * mint/teleport assets and deposit them to `beneficiary`.
   *
   * On the destination chain, as well as any intermediary hops, `BuyExecution` is used to
   * buy execution using transferred `assets` identified by `remote_fees_id`.
   * Make sure enough of the specified `remote_fees_id` asset is included in the given list
   * of `assets`. `remote_fees_id` should be enough to pay for `weight_limit`. If more weight
   * is needed than `weight_limit`, then the operation will fail and the sent assets may be
   * at risk.
   *
   * `remote_fees_id` may use different transfer type than rest of `assets` and can be
   * specified through `fees_transfer_type`.
   *
   * The caller needs to specify what should happen to the transferred assets once they reach
   * the `dest` chain. This is done through the `custom_xcm_on_dest` parameter, which
   * contains the instructions to execute on `dest` as a final step.
   * This is usually as simple as:
   * `Xcm(vec![DepositAsset { assets: Wild(AllCounted(assets.len())), beneficiary }])`,
   * but could be something more exotic like sending the `assets` even further.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain, or `(parents: 2, (GlobalConsensus(..), ..))` to send from
   * parachain across a bridge to another ecosystem destination.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` (and possibly reserve) chains.
   * - `assets_transfer_type`: The XCM `TransferType` used to transfer the `assets`.
   * - `remote_fees_id`: One of the included `assets` to be used to pay fees.
   * - `fees_transfer_type`: The XCM `TransferType` used to transfer the `fees` assets.
   * - `custom_xcm_on_dest`: The XCM to be executed on `dest` chain as the last step of the
   * transfer, which also determines what happens to the assets on the destination chain.
   * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
   **/
  | {
      name: 'TransferAssetsUsingTypeAndThen';
      params: {
        dest: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        assetsTransferType: StagingXcmExecutorAssetTransferTransferType;
        remoteFeesId: XcmVersionedAssetId;
        feesTransferType: StagingXcmExecutorAssetTransferTransferType;
        customXcmOnDest: XcmVersionedXcm;
        weightLimit: XcmV3WeightLimit;
      };
    };

export type XcmVersionedLocation =
  | { type: 'V2'; value: XcmV2MultilocationMultiLocation }
  | { type: 'V3'; value: StagingXcmV3MultilocationMultiLocation }
  | { type: 'V4'; value: StagingXcmV4Location };

export type XcmV2MultilocationMultiLocation = { parents: number; interior: XcmV2MultilocationJunctions };

export type XcmV2MultilocationJunctions =
  | { type: 'Here' }
  | { type: 'X1'; value: XcmV2Junction }
  | { type: 'X2'; value: [XcmV2Junction, XcmV2Junction] }
  | { type: 'X3'; value: [XcmV2Junction, XcmV2Junction, XcmV2Junction] }
  | { type: 'X4'; value: [XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction] }
  | { type: 'X5'; value: [XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction] }
  | { type: 'X6'; value: [XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction] }
  | {
      type: 'X7';
      value: [XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction];
    }
  | {
      type: 'X8';
      value: [
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
      ];
    };

export type XcmV2Junction =
  | { type: 'Parachain'; value: number }
  | { type: 'AccountId32'; value: { network: XcmV2NetworkId; id: FixedBytes<32> } }
  | { type: 'AccountIndex64'; value: { network: XcmV2NetworkId; index: bigint } }
  | { type: 'AccountKey20'; value: { network: XcmV2NetworkId; key: FixedBytes<20> } }
  | { type: 'PalletInstance'; value: number }
  | { type: 'GeneralIndex'; value: bigint }
  | { type: 'GeneralKey'; value: Bytes }
  | { type: 'OnlyChild' }
  | { type: 'Plurality'; value: { id: XcmV2BodyId; part: XcmV2BodyPart } };

export type XcmV2NetworkId =
  | { type: 'Any' }
  | { type: 'Named'; value: Bytes }
  | { type: 'Polkadot' }
  | { type: 'Kusama' };

export type XcmV2BodyId =
  | { type: 'Unit' }
  | { type: 'Named'; value: Bytes }
  | { type: 'Index'; value: number }
  | { type: 'Executive' }
  | { type: 'Technical' }
  | { type: 'Legislative' }
  | { type: 'Judicial' }
  | { type: 'Defense' }
  | { type: 'Administration' }
  | { type: 'Treasury' };

export type XcmV2BodyPart =
  | { type: 'Voice' }
  | { type: 'Members'; value: { count: number } }
  | { type: 'Fraction'; value: { nom: number; denom: number } }
  | { type: 'AtLeastProportion'; value: { nom: number; denom: number } }
  | { type: 'MoreThanProportion'; value: { nom: number; denom: number } };

export type StagingXcmV3MultilocationMultiLocation = { parents: number; interior: XcmV3Junctions };

export type XcmV3Junctions =
  | { type: 'Here' }
  | { type: 'X1'; value: XcmV3Junction }
  | { type: 'X2'; value: [XcmV3Junction, XcmV3Junction] }
  | { type: 'X3'; value: [XcmV3Junction, XcmV3Junction, XcmV3Junction] }
  | { type: 'X4'; value: [XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction] }
  | { type: 'X5'; value: [XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction] }
  | { type: 'X6'; value: [XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction] }
  | {
      type: 'X7';
      value: [XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction];
    }
  | {
      type: 'X8';
      value: [
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
      ];
    };

export type XcmV3Junction =
  | { type: 'Parachain'; value: number }
  | { type: 'AccountId32'; value: { network?: XcmV3JunctionNetworkId | undefined; id: FixedBytes<32> } }
  | { type: 'AccountIndex64'; value: { network?: XcmV3JunctionNetworkId | undefined; index: bigint } }
  | { type: 'AccountKey20'; value: { network?: XcmV3JunctionNetworkId | undefined; key: FixedBytes<20> } }
  | { type: 'PalletInstance'; value: number }
  | { type: 'GeneralIndex'; value: bigint }
  | { type: 'GeneralKey'; value: { length: number; data: FixedBytes<32> } }
  | { type: 'OnlyChild' }
  | { type: 'Plurality'; value: { id: XcmV3JunctionBodyId; part: XcmV3JunctionBodyPart } }
  | { type: 'GlobalConsensus'; value: XcmV3JunctionNetworkId };

export type XcmV3JunctionNetworkId =
  | { type: 'ByGenesis'; value: FixedBytes<32> }
  | { type: 'ByFork'; value: { blockNumber: bigint; blockHash: FixedBytes<32> } }
  | { type: 'Polkadot' }
  | { type: 'Kusama' }
  | { type: 'Westend' }
  | { type: 'Rococo' }
  | { type: 'Wococo' }
  | { type: 'Ethereum'; value: { chainId: bigint } }
  | { type: 'BitcoinCore' }
  | { type: 'BitcoinCash' }
  | { type: 'PolkadotBulletin' };

export type XcmVersionedXcm =
  | { type: 'V2'; value: XcmV2Xcm }
  | { type: 'V3'; value: XcmV3Xcm }
  | { type: 'V4'; value: StagingXcmV4Xcm };

export type XcmV2Xcm = Array<XcmV2Instruction>;

export type XcmV2Instruction =
  | { type: 'WithdrawAsset'; value: XcmV2MultiassetMultiAssets }
  | { type: 'ReserveAssetDeposited'; value: XcmV2MultiassetMultiAssets }
  | { type: 'ReceiveTeleportedAsset'; value: XcmV2MultiassetMultiAssets }
  | { type: 'QueryResponse'; value: { queryId: bigint; response: XcmV2Response; maxWeight: bigint } }
  | {
      type: 'TransferAsset';
      value: { assets: XcmV2MultiassetMultiAssets; beneficiary: XcmV2MultilocationMultiLocation };
    }
  | {
      type: 'TransferReserveAsset';
      value: { assets: XcmV2MultiassetMultiAssets; dest: XcmV2MultilocationMultiLocation; xcm: XcmV2Xcm };
    }
  | { type: 'Transact'; value: { originType: XcmV2OriginKind; requireWeightAtMost: bigint; call: XcmDoubleEncoded } }
  | { type: 'HrmpNewChannelOpenRequest'; value: { sender: number; maxMessageSize: number; maxCapacity: number } }
  | { type: 'HrmpChannelAccepted'; value: { recipient: number } }
  | { type: 'HrmpChannelClosing'; value: { initiator: number; sender: number; recipient: number } }
  | { type: 'ClearOrigin' }
  | { type: 'DescendOrigin'; value: XcmV2MultilocationJunctions }
  | {
      type: 'ReportError';
      value: { queryId: bigint; dest: XcmV2MultilocationMultiLocation; maxResponseWeight: bigint };
    }
  | {
      type: 'DepositAsset';
      value: {
        assets: XcmV2MultiassetMultiAssetFilter;
        maxAssets: number;
        beneficiary: XcmV2MultilocationMultiLocation;
      };
    }
  | {
      type: 'DepositReserveAsset';
      value: {
        assets: XcmV2MultiassetMultiAssetFilter;
        maxAssets: number;
        dest: XcmV2MultilocationMultiLocation;
        xcm: XcmV2Xcm;
      };
    }
  | { type: 'ExchangeAsset'; value: { give: XcmV2MultiassetMultiAssetFilter; receive: XcmV2MultiassetMultiAssets } }
  | {
      type: 'InitiateReserveWithdraw';
      value: { assets: XcmV2MultiassetMultiAssetFilter; reserve: XcmV2MultilocationMultiLocation; xcm: XcmV2Xcm };
    }
  | {
      type: 'InitiateTeleport';
      value: { assets: XcmV2MultiassetMultiAssetFilter; dest: XcmV2MultilocationMultiLocation; xcm: XcmV2Xcm };
    }
  | {
      type: 'QueryHolding';
      value: {
        queryId: bigint;
        dest: XcmV2MultilocationMultiLocation;
        assets: XcmV2MultiassetMultiAssetFilter;
        maxResponseWeight: bigint;
      };
    }
  | { type: 'BuyExecution'; value: { fees: XcmV2MultiassetMultiAsset; weightLimit: XcmV2WeightLimit } }
  | { type: 'RefundSurplus' }
  | { type: 'SetErrorHandler'; value: XcmV2Xcm }
  | { type: 'SetAppendix'; value: XcmV2Xcm }
  | { type: 'ClearError' }
  | { type: 'ClaimAsset'; value: { assets: XcmV2MultiassetMultiAssets; ticket: XcmV2MultilocationMultiLocation } }
  | { type: 'Trap'; value: bigint }
  | { type: 'SubscribeVersion'; value: { queryId: bigint; maxResponseWeight: bigint } }
  | { type: 'UnsubscribeVersion' };

export type XcmV2MultiassetMultiAssets = Array<XcmV2MultiassetMultiAsset>;

export type XcmV2MultiassetMultiAsset = { id: XcmV2MultiassetAssetId; fun: XcmV2MultiassetFungibility };

export type XcmV2MultiassetAssetId =
  | { type: 'Concrete'; value: XcmV2MultilocationMultiLocation }
  | { type: 'Abstract'; value: Bytes };

export type XcmV2MultiassetFungibility =
  | { type: 'Fungible'; value: bigint }
  | { type: 'NonFungible'; value: XcmV2MultiassetAssetInstance };

export type XcmV2MultiassetAssetInstance =
  | { type: 'Undefined' }
  | { type: 'Index'; value: bigint }
  | { type: 'Array4'; value: FixedBytes<4> }
  | { type: 'Array8'; value: FixedBytes<8> }
  | { type: 'Array16'; value: FixedBytes<16> }
  | { type: 'Array32'; value: FixedBytes<32> }
  | { type: 'Blob'; value: Bytes };

export type XcmV2Response =
  | { type: 'Null' }
  | { type: 'Assets'; value: XcmV2MultiassetMultiAssets }
  | { type: 'ExecutionResult'; value?: [number, XcmV2TraitsError] | undefined }
  | { type: 'Version'; value: number };

export type XcmV2TraitsError =
  | { type: 'Overflow' }
  | { type: 'Unimplemented' }
  | { type: 'UntrustedReserveLocation' }
  | { type: 'UntrustedTeleportLocation' }
  | { type: 'MultiLocationFull' }
  | { type: 'MultiLocationNotInvertible' }
  | { type: 'BadOrigin' }
  | { type: 'InvalidLocation' }
  | { type: 'AssetNotFound' }
  | { type: 'FailedToTransactAsset' }
  | { type: 'NotWithdrawable' }
  | { type: 'LocationCannotHold' }
  | { type: 'ExceedsMaxMessageSize' }
  | { type: 'DestinationUnsupported' }
  | { type: 'Transport' }
  | { type: 'Unroutable' }
  | { type: 'UnknownClaim' }
  | { type: 'FailedToDecode' }
  | { type: 'MaxWeightInvalid' }
  | { type: 'NotHoldingFees' }
  | { type: 'TooExpensive' }
  | { type: 'Trap'; value: bigint }
  | { type: 'UnhandledXcmVersion' }
  | { type: 'WeightLimitReached'; value: bigint }
  | { type: 'Barrier' }
  | { type: 'WeightNotComputable' };

export type XcmV2OriginKind = 'Native' | 'SovereignAccount' | 'Superuser' | 'Xcm';

export type XcmDoubleEncoded = { encoded: Bytes };

export type XcmV2MultiassetMultiAssetFilter =
  | { type: 'Definite'; value: XcmV2MultiassetMultiAssets }
  | { type: 'Wild'; value: XcmV2MultiassetWildMultiAsset };

export type XcmV2MultiassetWildMultiAsset =
  | { type: 'All' }
  | { type: 'AllOf'; value: { id: XcmV2MultiassetAssetId; fun: XcmV2MultiassetWildFungibility } };

export type XcmV2MultiassetWildFungibility = 'Fungible' | 'NonFungible';

export type XcmV2WeightLimit = { type: 'Unlimited' } | { type: 'Limited'; value: bigint };

export type XcmV3Xcm = Array<XcmV3Instruction>;

export type XcmV3Instruction =
  | { type: 'WithdrawAsset'; value: XcmV3MultiassetMultiAssets }
  | { type: 'ReserveAssetDeposited'; value: XcmV3MultiassetMultiAssets }
  | { type: 'ReceiveTeleportedAsset'; value: XcmV3MultiassetMultiAssets }
  | {
      type: 'QueryResponse';
      value: {
        queryId: bigint;
        response: XcmV3Response;
        maxWeight: SpWeightsWeightV2Weight;
        querier?: StagingXcmV3MultilocationMultiLocation | undefined;
      };
    }
  | {
      type: 'TransferAsset';
      value: { assets: XcmV3MultiassetMultiAssets; beneficiary: StagingXcmV3MultilocationMultiLocation };
    }
  | {
      type: 'TransferReserveAsset';
      value: { assets: XcmV3MultiassetMultiAssets; dest: StagingXcmV3MultilocationMultiLocation; xcm: XcmV3Xcm };
    }
  | {
      type: 'Transact';
      value: { originKind: XcmV3OriginKind; requireWeightAtMost: SpWeightsWeightV2Weight; call: XcmDoubleEncoded };
    }
  | { type: 'HrmpNewChannelOpenRequest'; value: { sender: number; maxMessageSize: number; maxCapacity: number } }
  | { type: 'HrmpChannelAccepted'; value: { recipient: number } }
  | { type: 'HrmpChannelClosing'; value: { initiator: number; sender: number; recipient: number } }
  | { type: 'ClearOrigin' }
  | { type: 'DescendOrigin'; value: XcmV3Junctions }
  | { type: 'ReportError'; value: XcmV3QueryResponseInfo }
  | {
      type: 'DepositAsset';
      value: { assets: XcmV3MultiassetMultiAssetFilter; beneficiary: StagingXcmV3MultilocationMultiLocation };
    }
  | {
      type: 'DepositReserveAsset';
      value: { assets: XcmV3MultiassetMultiAssetFilter; dest: StagingXcmV3MultilocationMultiLocation; xcm: XcmV3Xcm };
    }
  | {
      type: 'ExchangeAsset';
      value: { give: XcmV3MultiassetMultiAssetFilter; want: XcmV3MultiassetMultiAssets; maximal: boolean };
    }
  | {
      type: 'InitiateReserveWithdraw';
      value: {
        assets: XcmV3MultiassetMultiAssetFilter;
        reserve: StagingXcmV3MultilocationMultiLocation;
        xcm: XcmV3Xcm;
      };
    }
  | {
      type: 'InitiateTeleport';
      value: { assets: XcmV3MultiassetMultiAssetFilter; dest: StagingXcmV3MultilocationMultiLocation; xcm: XcmV3Xcm };
    }
  | { type: 'ReportHolding'; value: { responseInfo: XcmV3QueryResponseInfo; assets: XcmV3MultiassetMultiAssetFilter } }
  | { type: 'BuyExecution'; value: { fees: XcmV3MultiassetMultiAsset; weightLimit: XcmV3WeightLimit } }
  | { type: 'RefundSurplus' }
  | { type: 'SetErrorHandler'; value: XcmV3Xcm }
  | { type: 'SetAppendix'; value: XcmV3Xcm }
  | { type: 'ClearError' }
  | {
      type: 'ClaimAsset';
      value: { assets: XcmV3MultiassetMultiAssets; ticket: StagingXcmV3MultilocationMultiLocation };
    }
  | { type: 'Trap'; value: bigint }
  | { type: 'SubscribeVersion'; value: { queryId: bigint; maxResponseWeight: SpWeightsWeightV2Weight } }
  | { type: 'UnsubscribeVersion' }
  | { type: 'BurnAsset'; value: XcmV3MultiassetMultiAssets }
  | { type: 'ExpectAsset'; value: XcmV3MultiassetMultiAssets }
  | { type: 'ExpectOrigin'; value?: StagingXcmV3MultilocationMultiLocation | undefined }
  | { type: 'ExpectError'; value?: [number, XcmV3TraitsError] | undefined }
  | { type: 'ExpectTransactStatus'; value: XcmV3MaybeErrorCode }
  | { type: 'QueryPallet'; value: { moduleName: Bytes; responseInfo: XcmV3QueryResponseInfo } }
  | {
      type: 'ExpectPallet';
      value: { index: number; name: Bytes; moduleName: Bytes; crateMajor: number; minCrateMinor: number };
    }
  | { type: 'ReportTransactStatus'; value: XcmV3QueryResponseInfo }
  | { type: 'ClearTransactStatus' }
  | { type: 'UniversalOrigin'; value: XcmV3Junction }
  | { type: 'ExportMessage'; value: { network: XcmV3JunctionNetworkId; destination: XcmV3Junctions; xcm: XcmV3Xcm } }
  | { type: 'LockAsset'; value: { asset: XcmV3MultiassetMultiAsset; unlocker: StagingXcmV3MultilocationMultiLocation } }
  | { type: 'UnlockAsset'; value: { asset: XcmV3MultiassetMultiAsset; target: StagingXcmV3MultilocationMultiLocation } }
  | {
      type: 'NoteUnlockable';
      value: { asset: XcmV3MultiassetMultiAsset; owner: StagingXcmV3MultilocationMultiLocation };
    }
  | {
      type: 'RequestUnlock';
      value: { asset: XcmV3MultiassetMultiAsset; locker: StagingXcmV3MultilocationMultiLocation };
    }
  | { type: 'SetFeesMode'; value: { jitWithdraw: boolean } }
  | { type: 'SetTopic'; value: FixedBytes<32> }
  | { type: 'ClearTopic' }
  | { type: 'AliasOrigin'; value: StagingXcmV3MultilocationMultiLocation }
  | {
      type: 'UnpaidExecution';
      value: { weightLimit: XcmV3WeightLimit; checkOrigin?: StagingXcmV3MultilocationMultiLocation | undefined };
    };

export type XcmV3MultiassetMultiAssets = Array<XcmV3MultiassetMultiAsset>;

export type XcmV3MultiassetMultiAsset = { id: XcmV3MultiassetAssetId; fun: XcmV3MultiassetFungibility };

export type XcmV3MultiassetAssetId =
  | { type: 'Concrete'; value: StagingXcmV3MultilocationMultiLocation }
  | { type: 'Abstract'; value: FixedBytes<32> };

export type XcmV3MultiassetFungibility =
  | { type: 'Fungible'; value: bigint }
  | { type: 'NonFungible'; value: XcmV3MultiassetAssetInstance };

export type XcmV3MultiassetAssetInstance =
  | { type: 'Undefined' }
  | { type: 'Index'; value: bigint }
  | { type: 'Array4'; value: FixedBytes<4> }
  | { type: 'Array8'; value: FixedBytes<8> }
  | { type: 'Array16'; value: FixedBytes<16> }
  | { type: 'Array32'; value: FixedBytes<32> };

export type XcmV3Response =
  | { type: 'Null' }
  | { type: 'Assets'; value: XcmV3MultiassetMultiAssets }
  | { type: 'ExecutionResult'; value?: [number, XcmV3TraitsError] | undefined }
  | { type: 'Version'; value: number }
  | { type: 'PalletsInfo'; value: Array<XcmV3PalletInfo> }
  | { type: 'DispatchResult'; value: XcmV3MaybeErrorCode };

export type XcmV3TraitsError =
  | { type: 'Overflow' }
  | { type: 'Unimplemented' }
  | { type: 'UntrustedReserveLocation' }
  | { type: 'UntrustedTeleportLocation' }
  | { type: 'LocationFull' }
  | { type: 'LocationNotInvertible' }
  | { type: 'BadOrigin' }
  | { type: 'InvalidLocation' }
  | { type: 'AssetNotFound' }
  | { type: 'FailedToTransactAsset' }
  | { type: 'NotWithdrawable' }
  | { type: 'LocationCannotHold' }
  | { type: 'ExceedsMaxMessageSize' }
  | { type: 'DestinationUnsupported' }
  | { type: 'Transport' }
  | { type: 'Unroutable' }
  | { type: 'UnknownClaim' }
  | { type: 'FailedToDecode' }
  | { type: 'MaxWeightInvalid' }
  | { type: 'NotHoldingFees' }
  | { type: 'TooExpensive' }
  | { type: 'Trap'; value: bigint }
  | { type: 'ExpectationFalse' }
  | { type: 'PalletNotFound' }
  | { type: 'NameMismatch' }
  | { type: 'VersionIncompatible' }
  | { type: 'HoldingWouldOverflow' }
  | { type: 'ExportError' }
  | { type: 'ReanchorFailed' }
  | { type: 'NoDeal' }
  | { type: 'FeesNotMet' }
  | { type: 'LockError' }
  | { type: 'NoPermission' }
  | { type: 'Unanchored' }
  | { type: 'NotDepositable' }
  | { type: 'UnhandledXcmVersion' }
  | { type: 'WeightLimitReached'; value: SpWeightsWeightV2Weight }
  | { type: 'Barrier' }
  | { type: 'WeightNotComputable' }
  | { type: 'ExceedsStackLimit' };

export type XcmV3PalletInfo = {
  index: number;
  name: Bytes;
  moduleName: Bytes;
  major: number;
  minor: number;
  patch: number;
};

export type XcmV3MaybeErrorCode =
  | { type: 'Success' }
  | { type: 'Error'; value: Bytes }
  | { type: 'TruncatedError'; value: Bytes };

export type XcmV3OriginKind = 'Native' | 'SovereignAccount' | 'Superuser' | 'Xcm';

export type XcmV3QueryResponseInfo = {
  destination: StagingXcmV3MultilocationMultiLocation;
  queryId: bigint;
  maxWeight: SpWeightsWeightV2Weight;
};

export type XcmV3MultiassetMultiAssetFilter =
  | { type: 'Definite'; value: XcmV3MultiassetMultiAssets }
  | { type: 'Wild'; value: XcmV3MultiassetWildMultiAsset };

export type XcmV3MultiassetWildMultiAsset =
  | { type: 'All' }
  | { type: 'AllOf'; value: { id: XcmV3MultiassetAssetId; fun: XcmV3MultiassetWildFungibility } }
  | { type: 'AllCounted'; value: number }
  | { type: 'AllOfCounted'; value: { id: XcmV3MultiassetAssetId; fun: XcmV3MultiassetWildFungibility; count: number } };

export type XcmV3MultiassetWildFungibility = 'Fungible' | 'NonFungible';

export type XcmV3WeightLimit = { type: 'Unlimited' } | { type: 'Limited'; value: SpWeightsWeightV2Weight };

export type StagingXcmV4Xcm = Array<StagingXcmV4Instruction>;

export type StagingXcmV4Instruction =
  | { type: 'WithdrawAsset'; value: StagingXcmV4AssetAssets }
  | { type: 'ReserveAssetDeposited'; value: StagingXcmV4AssetAssets }
  | { type: 'ReceiveTeleportedAsset'; value: StagingXcmV4AssetAssets }
  | {
      type: 'QueryResponse';
      value: {
        queryId: bigint;
        response: StagingXcmV4Response;
        maxWeight: SpWeightsWeightV2Weight;
        querier?: StagingXcmV4Location | undefined;
      };
    }
  | { type: 'TransferAsset'; value: { assets: StagingXcmV4AssetAssets; beneficiary: StagingXcmV4Location } }
  | {
      type: 'TransferReserveAsset';
      value: { assets: StagingXcmV4AssetAssets; dest: StagingXcmV4Location; xcm: StagingXcmV4Xcm };
    }
  | {
      type: 'Transact';
      value: { originKind: XcmV3OriginKind; requireWeightAtMost: SpWeightsWeightV2Weight; call: XcmDoubleEncoded };
    }
  | { type: 'HrmpNewChannelOpenRequest'; value: { sender: number; maxMessageSize: number; maxCapacity: number } }
  | { type: 'HrmpChannelAccepted'; value: { recipient: number } }
  | { type: 'HrmpChannelClosing'; value: { initiator: number; sender: number; recipient: number } }
  | { type: 'ClearOrigin' }
  | { type: 'DescendOrigin'; value: StagingXcmV4Junctions }
  | { type: 'ReportError'; value: StagingXcmV4QueryResponseInfo }
  | { type: 'DepositAsset'; value: { assets: StagingXcmV4AssetAssetFilter; beneficiary: StagingXcmV4Location } }
  | {
      type: 'DepositReserveAsset';
      value: { assets: StagingXcmV4AssetAssetFilter; dest: StagingXcmV4Location; xcm: StagingXcmV4Xcm };
    }
  | {
      type: 'ExchangeAsset';
      value: { give: StagingXcmV4AssetAssetFilter; want: StagingXcmV4AssetAssets; maximal: boolean };
    }
  | {
      type: 'InitiateReserveWithdraw';
      value: { assets: StagingXcmV4AssetAssetFilter; reserve: StagingXcmV4Location; xcm: StagingXcmV4Xcm };
    }
  | {
      type: 'InitiateTeleport';
      value: { assets: StagingXcmV4AssetAssetFilter; dest: StagingXcmV4Location; xcm: StagingXcmV4Xcm };
    }
  | {
      type: 'ReportHolding';
      value: { responseInfo: StagingXcmV4QueryResponseInfo; assets: StagingXcmV4AssetAssetFilter };
    }
  | { type: 'BuyExecution'; value: { fees: StagingXcmV4Asset; weightLimit: XcmV3WeightLimit } }
  | { type: 'RefundSurplus' }
  | { type: 'SetErrorHandler'; value: StagingXcmV4Xcm }
  | { type: 'SetAppendix'; value: StagingXcmV4Xcm }
  | { type: 'ClearError' }
  | { type: 'ClaimAsset'; value: { assets: StagingXcmV4AssetAssets; ticket: StagingXcmV4Location } }
  | { type: 'Trap'; value: bigint }
  | { type: 'SubscribeVersion'; value: { queryId: bigint; maxResponseWeight: SpWeightsWeightV2Weight } }
  | { type: 'UnsubscribeVersion' }
  | { type: 'BurnAsset'; value: StagingXcmV4AssetAssets }
  | { type: 'ExpectAsset'; value: StagingXcmV4AssetAssets }
  | { type: 'ExpectOrigin'; value?: StagingXcmV4Location | undefined }
  | { type: 'ExpectError'; value?: [number, XcmV3TraitsError] | undefined }
  | { type: 'ExpectTransactStatus'; value: XcmV3MaybeErrorCode }
  | { type: 'QueryPallet'; value: { moduleName: Bytes; responseInfo: StagingXcmV4QueryResponseInfo } }
  | {
      type: 'ExpectPallet';
      value: { index: number; name: Bytes; moduleName: Bytes; crateMajor: number; minCrateMinor: number };
    }
  | { type: 'ReportTransactStatus'; value: StagingXcmV4QueryResponseInfo }
  | { type: 'ClearTransactStatus' }
  | { type: 'UniversalOrigin'; value: StagingXcmV4Junction }
  | {
      type: 'ExportMessage';
      value: { network: StagingXcmV4JunctionNetworkId; destination: StagingXcmV4Junctions; xcm: StagingXcmV4Xcm };
    }
  | { type: 'LockAsset'; value: { asset: StagingXcmV4Asset; unlocker: StagingXcmV4Location } }
  | { type: 'UnlockAsset'; value: { asset: StagingXcmV4Asset; target: StagingXcmV4Location } }
  | { type: 'NoteUnlockable'; value: { asset: StagingXcmV4Asset; owner: StagingXcmV4Location } }
  | { type: 'RequestUnlock'; value: { asset: StagingXcmV4Asset; locker: StagingXcmV4Location } }
  | { type: 'SetFeesMode'; value: { jitWithdraw: boolean } }
  | { type: 'SetTopic'; value: FixedBytes<32> }
  | { type: 'ClearTopic' }
  | { type: 'AliasOrigin'; value: StagingXcmV4Location }
  | {
      type: 'UnpaidExecution';
      value: { weightLimit: XcmV3WeightLimit; checkOrigin?: StagingXcmV4Location | undefined };
    };

export type StagingXcmV4AssetAssets = Array<StagingXcmV4Asset>;

export type StagingXcmV4Asset = { id: StagingXcmV4AssetAssetId; fun: StagingXcmV4AssetFungibility };

export type StagingXcmV4AssetAssetId = StagingXcmV4Location;

export type StagingXcmV4AssetFungibility =
  | { type: 'Fungible'; value: bigint }
  | { type: 'NonFungible'; value: StagingXcmV4AssetAssetInstance };

export type StagingXcmV4AssetAssetInstance =
  | { type: 'Undefined' }
  | { type: 'Index'; value: bigint }
  | { type: 'Array4'; value: FixedBytes<4> }
  | { type: 'Array8'; value: FixedBytes<8> }
  | { type: 'Array16'; value: FixedBytes<16> }
  | { type: 'Array32'; value: FixedBytes<32> };

export type StagingXcmV4Response =
  | { type: 'Null' }
  | { type: 'Assets'; value: StagingXcmV4AssetAssets }
  | { type: 'ExecutionResult'; value?: [number, XcmV3TraitsError] | undefined }
  | { type: 'Version'; value: number }
  | { type: 'PalletsInfo'; value: Array<StagingXcmV4PalletInfo> }
  | { type: 'DispatchResult'; value: XcmV3MaybeErrorCode };

export type StagingXcmV4PalletInfo = {
  index: number;
  name: Bytes;
  moduleName: Bytes;
  major: number;
  minor: number;
  patch: number;
};

export type StagingXcmV4QueryResponseInfo = {
  destination: StagingXcmV4Location;
  queryId: bigint;
  maxWeight: SpWeightsWeightV2Weight;
};

export type StagingXcmV4AssetAssetFilter =
  | { type: 'Definite'; value: StagingXcmV4AssetAssets }
  | { type: 'Wild'; value: StagingXcmV4AssetWildAsset };

export type StagingXcmV4AssetWildAsset =
  | { type: 'All' }
  | { type: 'AllOf'; value: { id: StagingXcmV4AssetAssetId; fun: StagingXcmV4AssetWildFungibility } }
  | { type: 'AllCounted'; value: number }
  | {
      type: 'AllOfCounted';
      value: { id: StagingXcmV4AssetAssetId; fun: StagingXcmV4AssetWildFungibility; count: number };
    };

export type StagingXcmV4AssetWildFungibility = 'Fungible' | 'NonFungible';

export type XcmVersionedAssets =
  | { type: 'V2'; value: XcmV2MultiassetMultiAssets }
  | { type: 'V3'; value: XcmV3MultiassetMultiAssets }
  | { type: 'V4'; value: StagingXcmV4AssetAssets };

export type StagingXcmExecutorAssetTransferTransferType =
  | { type: 'Teleport' }
  | { type: 'LocalReserve' }
  | { type: 'DestinationReserve' }
  | { type: 'RemoteReserve'; value: XcmVersionedLocation };

export type XcmVersionedAssetId =
  | { type: 'V3'; value: XcmV3MultiassetAssetId }
  | { type: 'V4'; value: StagingXcmV4AssetAssetId };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletAssetsCall =
  /**
   * Issue a new class of fungible assets from a public origin.
   *
   * This new asset class has no assets initially and its owner is the origin.
   *
   * The origin must conform to the configured `CreateOrigin` and have sufficient funds free.
   *
   * Funds of sender are reserved by `AssetDeposit`.
   *
   * Parameters:
   * - `id`: The identifier of the new asset. This must not be currently in use to identify
   * an existing asset. If [`NextAssetId`] is set, then this must be equal to it.
   * - `admin`: The admin of this class of assets. The admin is the initial address of each
   * member of the asset class's admin team.
   * - `min_balance`: The minimum balance of this new asset that any single account must
   * have. If an account's balance is reduced below this, then it collapses to zero.
   *
   * Emits `Created` event when successful.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Create'; params: { id: bigint; admin: AccountId20; minBalance: bigint } }
  /**
   * Issue a new class of fungible assets from a privileged origin.
   *
   * This new asset class has no assets initially.
   *
   * The origin must conform to `ForceOrigin`.
   *
   * Unlike `create`, no funds are reserved.
   *
   * - `id`: The identifier of the new asset. This must not be currently in use to identify
   * an existing asset. If [`NextAssetId`] is set, then this must be equal to it.
   * - `owner`: The owner of this class of assets. The owner has full superuser permissions
   * over this asset, but may later change and configure the permissions using
   * `transfer_ownership` and `set_team`.
   * - `min_balance`: The minimum balance of this new asset that any single account must
   * have. If an account's balance is reduced below this, then it collapses to zero.
   *
   * Emits `ForceCreated` event when successful.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ForceCreate'; params: { id: bigint; owner: AccountId20; isSufficient: boolean; minBalance: bigint } }
  /**
   * Start the process of destroying a fungible asset class.
   *
   * `start_destroy` is the first in a series of extrinsics that should be called, to allow
   * destruction of an asset class.
   *
   * The origin must conform to `ForceOrigin` or must be `Signed` by the asset's `owner`.
   *
   * - `id`: The identifier of the asset to be destroyed. This must identify an existing
   * asset.
   *
   * The asset class must be frozen before calling `start_destroy`.
   **/
  | { name: 'StartDestroy'; params: { id: bigint } }
  /**
   * Destroy all accounts associated with a given asset.
   *
   * `destroy_accounts` should only be called after `start_destroy` has been called, and the
   * asset is in a `Destroying` state.
   *
   * Due to weight restrictions, this function may need to be called multiple times to fully
   * destroy all accounts. It will destroy `RemoveItemsLimit` accounts at a time.
   *
   * - `id`: The identifier of the asset to be destroyed. This must identify an existing
   * asset.
   *
   * Each call emits the `Event::DestroyedAccounts` event.
   **/
  | { name: 'DestroyAccounts'; params: { id: bigint } }
  /**
   * Destroy all approvals associated with a given asset up to the max (T::RemoveItemsLimit).
   *
   * `destroy_approvals` should only be called after `start_destroy` has been called, and the
   * asset is in a `Destroying` state.
   *
   * Due to weight restrictions, this function may need to be called multiple times to fully
   * destroy all approvals. It will destroy `RemoveItemsLimit` approvals at a time.
   *
   * - `id`: The identifier of the asset to be destroyed. This must identify an existing
   * asset.
   *
   * Each call emits the `Event::DestroyedApprovals` event.
   **/
  | { name: 'DestroyApprovals'; params: { id: bigint } }
  /**
   * Complete destroying asset and unreserve currency.
   *
   * `finish_destroy` should only be called after `start_destroy` has been called, and the
   * asset is in a `Destroying` state. All accounts or approvals should be destroyed before
   * hand.
   *
   * - `id`: The identifier of the asset to be destroyed. This must identify an existing
   * asset.
   *
   * Each successful call emits the `Event::Destroyed` event.
   **/
  | { name: 'FinishDestroy'; params: { id: bigint } }
  /**
   * Mint assets of a particular class.
   *
   * The origin must be Signed and the sender must be the Issuer of the asset `id`.
   *
   * - `id`: The identifier of the asset to have some amount minted.
   * - `beneficiary`: The account to be credited with the minted assets.
   * - `amount`: The amount of the asset to be minted.
   *
   * Emits `Issued` event when successful.
   *
   * Weight: `O(1)`
   * Modes: Pre-existing balance of `beneficiary`; Account pre-existence of `beneficiary`.
   **/
  | { name: 'Mint'; params: { id: bigint; beneficiary: AccountId20; amount: bigint } }
  /**
   * Reduce the balance of `who` by as much as possible up to `amount` assets of `id`.
   *
   * Origin must be Signed and the sender should be the Manager of the asset `id`.
   *
   * Bails with `NoAccount` if the `who` is already dead.
   *
   * - `id`: The identifier of the asset to have some amount burned.
   * - `who`: The account to be debited from.
   * - `amount`: The maximum amount by which `who`'s balance should be reduced.
   *
   * Emits `Burned` with the actual amount burned. If this takes the balance to below the
   * minimum for the asset, then the amount burned is increased to take it to zero.
   *
   * Weight: `O(1)`
   * Modes: Post-existence of `who`; Pre & post Zombie-status of `who`.
   **/
  | { name: 'Burn'; params: { id: bigint; who: AccountId20; amount: bigint } }
  /**
   * Move some assets from the sender account to another.
   *
   * Origin must be Signed.
   *
   * - `id`: The identifier of the asset to have some amount transferred.
   * - `target`: The account to be credited.
   * - `amount`: The amount by which the sender's balance of assets should be reduced and
   * `target`'s balance increased. The amount actually transferred may be slightly greater in
   * the case that the transfer would otherwise take the sender balance above zero but below
   * the minimum balance. Must be greater than zero.
   *
   * Emits `Transferred` with the actual amount transferred. If this takes the source balance
   * to below the minimum for the asset, then the amount transferred is increased to take it
   * to zero.
   *
   * Weight: `O(1)`
   * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
   * `target`.
   **/
  | { name: 'Transfer'; params: { id: bigint; target: AccountId20; amount: bigint } }
  /**
   * Move some assets from the sender account to another, keeping the sender account alive.
   *
   * Origin must be Signed.
   *
   * - `id`: The identifier of the asset to have some amount transferred.
   * - `target`: The account to be credited.
   * - `amount`: The amount by which the sender's balance of assets should be reduced and
   * `target`'s balance increased. The amount actually transferred may be slightly greater in
   * the case that the transfer would otherwise take the sender balance above zero but below
   * the minimum balance. Must be greater than zero.
   *
   * Emits `Transferred` with the actual amount transferred. If this takes the source balance
   * to below the minimum for the asset, then the amount transferred is increased to take it
   * to zero.
   *
   * Weight: `O(1)`
   * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
   * `target`.
   **/
  | { name: 'TransferKeepAlive'; params: { id: bigint; target: AccountId20; amount: bigint } }
  /**
   * Move some assets from one account to another.
   *
   * Origin must be Signed and the sender should be the Admin of the asset `id`.
   *
   * - `id`: The identifier of the asset to have some amount transferred.
   * - `source`: The account to be debited.
   * - `dest`: The account to be credited.
   * - `amount`: The amount by which the `source`'s balance of assets should be reduced and
   * `dest`'s balance increased. The amount actually transferred may be slightly greater in
   * the case that the transfer would otherwise take the `source` balance above zero but
   * below the minimum balance. Must be greater than zero.
   *
   * Emits `Transferred` with the actual amount transferred. If this takes the source balance
   * to below the minimum for the asset, then the amount transferred is increased to take it
   * to zero.
   *
   * Weight: `O(1)`
   * Modes: Pre-existence of `dest`; Post-existence of `source`; Account pre-existence of
   * `dest`.
   **/
  | { name: 'ForceTransfer'; params: { id: bigint; source: AccountId20; dest: AccountId20; amount: bigint } }
  /**
   * Disallow further unprivileged transfers of an asset `id` from an account `who`. `who`
   * must already exist as an entry in `Account`s of the asset. If you want to freeze an
   * account that does not have an entry, use `touch_other` first.
   *
   * Origin must be Signed and the sender should be the Freezer of the asset `id`.
   *
   * - `id`: The identifier of the asset to be frozen.
   * - `who`: The account to be frozen.
   *
   * Emits `Frozen`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Freeze'; params: { id: bigint; who: AccountId20 } }
  /**
   * Allow unprivileged transfers to and from an account again.
   *
   * Origin must be Signed and the sender should be the Admin of the asset `id`.
   *
   * - `id`: The identifier of the asset to be frozen.
   * - `who`: The account to be unfrozen.
   *
   * Emits `Thawed`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Thaw'; params: { id: bigint; who: AccountId20 } }
  /**
   * Disallow further unprivileged transfers for the asset class.
   *
   * Origin must be Signed and the sender should be the Freezer of the asset `id`.
   *
   * - `id`: The identifier of the asset to be frozen.
   *
   * Emits `Frozen`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'FreezeAsset'; params: { id: bigint } }
  /**
   * Allow unprivileged transfers for the asset again.
   *
   * Origin must be Signed and the sender should be the Admin of the asset `id`.
   *
   * - `id`: The identifier of the asset to be thawed.
   *
   * Emits `Thawed`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ThawAsset'; params: { id: bigint } }
  /**
   * Change the Owner of an asset.
   *
   * Origin must be Signed and the sender should be the Owner of the asset `id`.
   *
   * - `id`: The identifier of the asset.
   * - `owner`: The new Owner of this asset.
   *
   * Emits `OwnerChanged`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'TransferOwnership'; params: { id: bigint; owner: AccountId20 } }
  /**
   * Change the Issuer, Admin and Freezer of an asset.
   *
   * Origin must be Signed and the sender should be the Owner of the asset `id`.
   *
   * - `id`: The identifier of the asset to be frozen.
   * - `issuer`: The new Issuer of this asset.
   * - `admin`: The new Admin of this asset.
   * - `freezer`: The new Freezer of this asset.
   *
   * Emits `TeamChanged`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'SetTeam'; params: { id: bigint; issuer: AccountId20; admin: AccountId20; freezer: AccountId20 } }
  /**
   * Set the metadata for an asset.
   *
   * Origin must be Signed and the sender should be the Owner of the asset `id`.
   *
   * Funds of sender are reserved according to the formula:
   * `MetadataDepositBase + MetadataDepositPerByte * (name.len + symbol.len)` taking into
   * account any already reserved funds.
   *
   * - `id`: The identifier of the asset to update.
   * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
   * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
   * - `decimals`: The number of decimals this asset uses to represent one unit.
   *
   * Emits `MetadataSet`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'SetMetadata'; params: { id: bigint; name: Bytes; symbol: Bytes; decimals: number } }
  /**
   * Clear the metadata for an asset.
   *
   * Origin must be Signed and the sender should be the Owner of the asset `id`.
   *
   * Any deposit is freed for the asset owner.
   *
   * - `id`: The identifier of the asset to clear.
   *
   * Emits `MetadataCleared`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ClearMetadata'; params: { id: bigint } }
  /**
   * Force the metadata for an asset to some value.
   *
   * Origin must be ForceOrigin.
   *
   * Any deposit is left alone.
   *
   * - `id`: The identifier of the asset to update.
   * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
   * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
   * - `decimals`: The number of decimals this asset uses to represent one unit.
   *
   * Emits `MetadataSet`.
   *
   * Weight: `O(N + S)` where N and S are the length of the name and symbol respectively.
   **/
  | {
      name: 'ForceSetMetadata';
      params: { id: bigint; name: Bytes; symbol: Bytes; decimals: number; isFrozen: boolean };
    }
  /**
   * Clear the metadata for an asset.
   *
   * Origin must be ForceOrigin.
   *
   * Any deposit is returned.
   *
   * - `id`: The identifier of the asset to clear.
   *
   * Emits `MetadataCleared`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ForceClearMetadata'; params: { id: bigint } }
  /**
   * Alter the attributes of a given asset.
   *
   * Origin must be `ForceOrigin`.
   *
   * - `id`: The identifier of the asset.
   * - `owner`: The new Owner of this asset.
   * - `issuer`: The new Issuer of this asset.
   * - `admin`: The new Admin of this asset.
   * - `freezer`: The new Freezer of this asset.
   * - `min_balance`: The minimum balance of this new asset that any single account must
   * have. If an account's balance is reduced below this, then it collapses to zero.
   * - `is_sufficient`: Whether a non-zero balance of this asset is deposit of sufficient
   * value to account for the state bloat associated with its balance storage. If set to
   * `true`, then non-zero balances may be stored without a `consumer` reference (and thus
   * an ED in the Balances pallet or whatever else is used to control user-account state
   * growth).
   * - `is_frozen`: Whether this asset class is frozen except for permissioned/admin
   * instructions.
   *
   * Emits `AssetStatusChanged` with the identity of the asset.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'ForceAssetStatus';
      params: {
        id: bigint;
        owner: AccountId20;
        issuer: AccountId20;
        admin: AccountId20;
        freezer: AccountId20;
        minBalance: bigint;
        isSufficient: boolean;
        isFrozen: boolean;
      };
    }
  /**
   * Approve an amount of asset for transfer by a delegated third-party account.
   *
   * Origin must be Signed.
   *
   * Ensures that `ApprovalDeposit` worth of `Currency` is reserved from signing account
   * for the purpose of holding the approval. If some non-zero amount of assets is already
   * approved from signing account to `delegate`, then it is topped up or unreserved to
   * meet the right value.
   *
   * NOTE: The signing account does not need to own `amount` of assets at the point of
   * making this call.
   *
   * - `id`: The identifier of the asset.
   * - `delegate`: The account to delegate permission to transfer asset.
   * - `amount`: The amount of asset that may be transferred by `delegate`. If there is
   * already an approval in place, then this acts additively.
   *
   * Emits `ApprovedTransfer` on success.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ApproveTransfer'; params: { id: bigint; delegate: AccountId20; amount: bigint } }
  /**
   * Cancel all of some asset approved for delegated transfer by a third-party account.
   *
   * Origin must be Signed and there must be an approval in place between signer and
   * `delegate`.
   *
   * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
   *
   * - `id`: The identifier of the asset.
   * - `delegate`: The account delegated permission to transfer asset.
   *
   * Emits `ApprovalCancelled` on success.
   *
   * Weight: `O(1)`
   **/
  | { name: 'CancelApproval'; params: { id: bigint; delegate: AccountId20 } }
  /**
   * Cancel all of some asset approved for delegated transfer by a third-party account.
   *
   * Origin must be either ForceOrigin or Signed origin with the signer being the Admin
   * account of the asset `id`.
   *
   * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
   *
   * - `id`: The identifier of the asset.
   * - `delegate`: The account delegated permission to transfer asset.
   *
   * Emits `ApprovalCancelled` on success.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ForceCancelApproval'; params: { id: bigint; owner: AccountId20; delegate: AccountId20 } }
  /**
   * Transfer some asset balance from a previously delegated account to some third-party
   * account.
   *
   * Origin must be Signed and there must be an approval in place by the `owner` to the
   * signer.
   *
   * If the entire amount approved for transfer is transferred, then any deposit previously
   * reserved by `approve_transfer` is unreserved.
   *
   * - `id`: The identifier of the asset.
   * - `owner`: The account which previously approved for a transfer of at least `amount` and
   * from which the asset balance will be withdrawn.
   * - `destination`: The account to which the asset balance of `amount` will be transferred.
   * - `amount`: The amount of assets to transfer.
   *
   * Emits `TransferredApproved` on success.
   *
   * Weight: `O(1)`
   **/
  | { name: 'TransferApproved'; params: { id: bigint; owner: AccountId20; destination: AccountId20; amount: bigint } }
  /**
   * Create an asset account for non-provider assets.
   *
   * A deposit will be taken from the signer account.
   *
   * - `origin`: Must be Signed; the signer account must have sufficient funds for a deposit
   * to be taken.
   * - `id`: The identifier of the asset for the account to be created.
   *
   * Emits `Touched` event when successful.
   **/
  | { name: 'Touch'; params: { id: bigint } }
  /**
   * Return the deposit (if any) of an asset account or a consumer reference (if any) of an
   * account.
   *
   * The origin must be Signed.
   *
   * - `id`: The identifier of the asset for which the caller would like the deposit
   * refunded.
   * - `allow_burn`: If `true` then assets may be destroyed in order to complete the refund.
   *
   * Emits `Refunded` event when successful.
   **/
  | { name: 'Refund'; params: { id: bigint; allowBurn: boolean } }
  /**
   * Sets the minimum balance of an asset.
   *
   * Only works if there aren't any accounts that are holding the asset or if
   * the new value of `min_balance` is less than the old one.
   *
   * Origin must be Signed and the sender has to be the Owner of the
   * asset `id`.
   *
   * - `id`: The identifier of the asset.
   * - `min_balance`: The new value of `min_balance`.
   *
   * Emits `AssetMinBalanceChanged` event when successful.
   **/
  | { name: 'SetMinBalance'; params: { id: bigint; minBalance: bigint } }
  /**
   * Create an asset account for `who`.
   *
   * A deposit will be taken from the signer account.
   *
   * - `origin`: Must be Signed by `Freezer` or `Admin` of the asset `id`; the signer account
   * must have sufficient funds for a deposit to be taken.
   * - `id`: The identifier of the asset for the account to be created.
   * - `who`: The account to be created.
   *
   * Emits `Touched` event when successful.
   **/
  | { name: 'TouchOther'; params: { id: bigint; who: AccountId20 } }
  /**
   * Return the deposit (if any) of a target asset account. Useful if you are the depositor.
   *
   * The origin must be Signed and either the account owner, depositor, or asset `Admin`. In
   * order to burn a non-zero balance of the asset, the caller must be the account and should
   * use `refund`.
   *
   * - `id`: The identifier of the asset for the account holding a deposit.
   * - `who`: The account to refund.
   *
   * Emits `Refunded` event when successful.
   **/
  | { name: 'RefundOther'; params: { id: bigint; who: AccountId20 } }
  /**
   * Disallow further unprivileged transfers of an asset `id` to and from an account `who`.
   *
   * Origin must be Signed and the sender should be the Freezer of the asset `id`.
   *
   * - `id`: The identifier of the account's asset.
   * - `who`: The account to be unblocked.
   *
   * Emits `Blocked`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Block'; params: { id: bigint; who: AccountId20 } };

export type PalletAssetsCallLike =
  /**
   * Issue a new class of fungible assets from a public origin.
   *
   * This new asset class has no assets initially and its owner is the origin.
   *
   * The origin must conform to the configured `CreateOrigin` and have sufficient funds free.
   *
   * Funds of sender are reserved by `AssetDeposit`.
   *
   * Parameters:
   * - `id`: The identifier of the new asset. This must not be currently in use to identify
   * an existing asset. If [`NextAssetId`] is set, then this must be equal to it.
   * - `admin`: The admin of this class of assets. The admin is the initial address of each
   * member of the asset class's admin team.
   * - `min_balance`: The minimum balance of this new asset that any single account must
   * have. If an account's balance is reduced below this, then it collapses to zero.
   *
   * Emits `Created` event when successful.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Create'; params: { id: bigint; admin: AccountId20Like; minBalance: bigint } }
  /**
   * Issue a new class of fungible assets from a privileged origin.
   *
   * This new asset class has no assets initially.
   *
   * The origin must conform to `ForceOrigin`.
   *
   * Unlike `create`, no funds are reserved.
   *
   * - `id`: The identifier of the new asset. This must not be currently in use to identify
   * an existing asset. If [`NextAssetId`] is set, then this must be equal to it.
   * - `owner`: The owner of this class of assets. The owner has full superuser permissions
   * over this asset, but may later change and configure the permissions using
   * `transfer_ownership` and `set_team`.
   * - `min_balance`: The minimum balance of this new asset that any single account must
   * have. If an account's balance is reduced below this, then it collapses to zero.
   *
   * Emits `ForceCreated` event when successful.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ForceCreate'; params: { id: bigint; owner: AccountId20Like; isSufficient: boolean; minBalance: bigint } }
  /**
   * Start the process of destroying a fungible asset class.
   *
   * `start_destroy` is the first in a series of extrinsics that should be called, to allow
   * destruction of an asset class.
   *
   * The origin must conform to `ForceOrigin` or must be `Signed` by the asset's `owner`.
   *
   * - `id`: The identifier of the asset to be destroyed. This must identify an existing
   * asset.
   *
   * The asset class must be frozen before calling `start_destroy`.
   **/
  | { name: 'StartDestroy'; params: { id: bigint } }
  /**
   * Destroy all accounts associated with a given asset.
   *
   * `destroy_accounts` should only be called after `start_destroy` has been called, and the
   * asset is in a `Destroying` state.
   *
   * Due to weight restrictions, this function may need to be called multiple times to fully
   * destroy all accounts. It will destroy `RemoveItemsLimit` accounts at a time.
   *
   * - `id`: The identifier of the asset to be destroyed. This must identify an existing
   * asset.
   *
   * Each call emits the `Event::DestroyedAccounts` event.
   **/
  | { name: 'DestroyAccounts'; params: { id: bigint } }
  /**
   * Destroy all approvals associated with a given asset up to the max (T::RemoveItemsLimit).
   *
   * `destroy_approvals` should only be called after `start_destroy` has been called, and the
   * asset is in a `Destroying` state.
   *
   * Due to weight restrictions, this function may need to be called multiple times to fully
   * destroy all approvals. It will destroy `RemoveItemsLimit` approvals at a time.
   *
   * - `id`: The identifier of the asset to be destroyed. This must identify an existing
   * asset.
   *
   * Each call emits the `Event::DestroyedApprovals` event.
   **/
  | { name: 'DestroyApprovals'; params: { id: bigint } }
  /**
   * Complete destroying asset and unreserve currency.
   *
   * `finish_destroy` should only be called after `start_destroy` has been called, and the
   * asset is in a `Destroying` state. All accounts or approvals should be destroyed before
   * hand.
   *
   * - `id`: The identifier of the asset to be destroyed. This must identify an existing
   * asset.
   *
   * Each successful call emits the `Event::Destroyed` event.
   **/
  | { name: 'FinishDestroy'; params: { id: bigint } }
  /**
   * Mint assets of a particular class.
   *
   * The origin must be Signed and the sender must be the Issuer of the asset `id`.
   *
   * - `id`: The identifier of the asset to have some amount minted.
   * - `beneficiary`: The account to be credited with the minted assets.
   * - `amount`: The amount of the asset to be minted.
   *
   * Emits `Issued` event when successful.
   *
   * Weight: `O(1)`
   * Modes: Pre-existing balance of `beneficiary`; Account pre-existence of `beneficiary`.
   **/
  | { name: 'Mint'; params: { id: bigint; beneficiary: AccountId20Like; amount: bigint } }
  /**
   * Reduce the balance of `who` by as much as possible up to `amount` assets of `id`.
   *
   * Origin must be Signed and the sender should be the Manager of the asset `id`.
   *
   * Bails with `NoAccount` if the `who` is already dead.
   *
   * - `id`: The identifier of the asset to have some amount burned.
   * - `who`: The account to be debited from.
   * - `amount`: The maximum amount by which `who`'s balance should be reduced.
   *
   * Emits `Burned` with the actual amount burned. If this takes the balance to below the
   * minimum for the asset, then the amount burned is increased to take it to zero.
   *
   * Weight: `O(1)`
   * Modes: Post-existence of `who`; Pre & post Zombie-status of `who`.
   **/
  | { name: 'Burn'; params: { id: bigint; who: AccountId20Like; amount: bigint } }
  /**
   * Move some assets from the sender account to another.
   *
   * Origin must be Signed.
   *
   * - `id`: The identifier of the asset to have some amount transferred.
   * - `target`: The account to be credited.
   * - `amount`: The amount by which the sender's balance of assets should be reduced and
   * `target`'s balance increased. The amount actually transferred may be slightly greater in
   * the case that the transfer would otherwise take the sender balance above zero but below
   * the minimum balance. Must be greater than zero.
   *
   * Emits `Transferred` with the actual amount transferred. If this takes the source balance
   * to below the minimum for the asset, then the amount transferred is increased to take it
   * to zero.
   *
   * Weight: `O(1)`
   * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
   * `target`.
   **/
  | { name: 'Transfer'; params: { id: bigint; target: AccountId20Like; amount: bigint } }
  /**
   * Move some assets from the sender account to another, keeping the sender account alive.
   *
   * Origin must be Signed.
   *
   * - `id`: The identifier of the asset to have some amount transferred.
   * - `target`: The account to be credited.
   * - `amount`: The amount by which the sender's balance of assets should be reduced and
   * `target`'s balance increased. The amount actually transferred may be slightly greater in
   * the case that the transfer would otherwise take the sender balance above zero but below
   * the minimum balance. Must be greater than zero.
   *
   * Emits `Transferred` with the actual amount transferred. If this takes the source balance
   * to below the minimum for the asset, then the amount transferred is increased to take it
   * to zero.
   *
   * Weight: `O(1)`
   * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
   * `target`.
   **/
  | { name: 'TransferKeepAlive'; params: { id: bigint; target: AccountId20Like; amount: bigint } }
  /**
   * Move some assets from one account to another.
   *
   * Origin must be Signed and the sender should be the Admin of the asset `id`.
   *
   * - `id`: The identifier of the asset to have some amount transferred.
   * - `source`: The account to be debited.
   * - `dest`: The account to be credited.
   * - `amount`: The amount by which the `source`'s balance of assets should be reduced and
   * `dest`'s balance increased. The amount actually transferred may be slightly greater in
   * the case that the transfer would otherwise take the `source` balance above zero but
   * below the minimum balance. Must be greater than zero.
   *
   * Emits `Transferred` with the actual amount transferred. If this takes the source balance
   * to below the minimum for the asset, then the amount transferred is increased to take it
   * to zero.
   *
   * Weight: `O(1)`
   * Modes: Pre-existence of `dest`; Post-existence of `source`; Account pre-existence of
   * `dest`.
   **/
  | { name: 'ForceTransfer'; params: { id: bigint; source: AccountId20Like; dest: AccountId20Like; amount: bigint } }
  /**
   * Disallow further unprivileged transfers of an asset `id` from an account `who`. `who`
   * must already exist as an entry in `Account`s of the asset. If you want to freeze an
   * account that does not have an entry, use `touch_other` first.
   *
   * Origin must be Signed and the sender should be the Freezer of the asset `id`.
   *
   * - `id`: The identifier of the asset to be frozen.
   * - `who`: The account to be frozen.
   *
   * Emits `Frozen`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Freeze'; params: { id: bigint; who: AccountId20Like } }
  /**
   * Allow unprivileged transfers to and from an account again.
   *
   * Origin must be Signed and the sender should be the Admin of the asset `id`.
   *
   * - `id`: The identifier of the asset to be frozen.
   * - `who`: The account to be unfrozen.
   *
   * Emits `Thawed`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Thaw'; params: { id: bigint; who: AccountId20Like } }
  /**
   * Disallow further unprivileged transfers for the asset class.
   *
   * Origin must be Signed and the sender should be the Freezer of the asset `id`.
   *
   * - `id`: The identifier of the asset to be frozen.
   *
   * Emits `Frozen`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'FreezeAsset'; params: { id: bigint } }
  /**
   * Allow unprivileged transfers for the asset again.
   *
   * Origin must be Signed and the sender should be the Admin of the asset `id`.
   *
   * - `id`: The identifier of the asset to be thawed.
   *
   * Emits `Thawed`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ThawAsset'; params: { id: bigint } }
  /**
   * Change the Owner of an asset.
   *
   * Origin must be Signed and the sender should be the Owner of the asset `id`.
   *
   * - `id`: The identifier of the asset.
   * - `owner`: The new Owner of this asset.
   *
   * Emits `OwnerChanged`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'TransferOwnership'; params: { id: bigint; owner: AccountId20Like } }
  /**
   * Change the Issuer, Admin and Freezer of an asset.
   *
   * Origin must be Signed and the sender should be the Owner of the asset `id`.
   *
   * - `id`: The identifier of the asset to be frozen.
   * - `issuer`: The new Issuer of this asset.
   * - `admin`: The new Admin of this asset.
   * - `freezer`: The new Freezer of this asset.
   *
   * Emits `TeamChanged`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'SetTeam';
      params: { id: bigint; issuer: AccountId20Like; admin: AccountId20Like; freezer: AccountId20Like };
    }
  /**
   * Set the metadata for an asset.
   *
   * Origin must be Signed and the sender should be the Owner of the asset `id`.
   *
   * Funds of sender are reserved according to the formula:
   * `MetadataDepositBase + MetadataDepositPerByte * (name.len + symbol.len)` taking into
   * account any already reserved funds.
   *
   * - `id`: The identifier of the asset to update.
   * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
   * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
   * - `decimals`: The number of decimals this asset uses to represent one unit.
   *
   * Emits `MetadataSet`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'SetMetadata'; params: { id: bigint; name: BytesLike; symbol: BytesLike; decimals: number } }
  /**
   * Clear the metadata for an asset.
   *
   * Origin must be Signed and the sender should be the Owner of the asset `id`.
   *
   * Any deposit is freed for the asset owner.
   *
   * - `id`: The identifier of the asset to clear.
   *
   * Emits `MetadataCleared`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ClearMetadata'; params: { id: bigint } }
  /**
   * Force the metadata for an asset to some value.
   *
   * Origin must be ForceOrigin.
   *
   * Any deposit is left alone.
   *
   * - `id`: The identifier of the asset to update.
   * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
   * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
   * - `decimals`: The number of decimals this asset uses to represent one unit.
   *
   * Emits `MetadataSet`.
   *
   * Weight: `O(N + S)` where N and S are the length of the name and symbol respectively.
   **/
  | {
      name: 'ForceSetMetadata';
      params: { id: bigint; name: BytesLike; symbol: BytesLike; decimals: number; isFrozen: boolean };
    }
  /**
   * Clear the metadata for an asset.
   *
   * Origin must be ForceOrigin.
   *
   * Any deposit is returned.
   *
   * - `id`: The identifier of the asset to clear.
   *
   * Emits `MetadataCleared`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ForceClearMetadata'; params: { id: bigint } }
  /**
   * Alter the attributes of a given asset.
   *
   * Origin must be `ForceOrigin`.
   *
   * - `id`: The identifier of the asset.
   * - `owner`: The new Owner of this asset.
   * - `issuer`: The new Issuer of this asset.
   * - `admin`: The new Admin of this asset.
   * - `freezer`: The new Freezer of this asset.
   * - `min_balance`: The minimum balance of this new asset that any single account must
   * have. If an account's balance is reduced below this, then it collapses to zero.
   * - `is_sufficient`: Whether a non-zero balance of this asset is deposit of sufficient
   * value to account for the state bloat associated with its balance storage. If set to
   * `true`, then non-zero balances may be stored without a `consumer` reference (and thus
   * an ED in the Balances pallet or whatever else is used to control user-account state
   * growth).
   * - `is_frozen`: Whether this asset class is frozen except for permissioned/admin
   * instructions.
   *
   * Emits `AssetStatusChanged` with the identity of the asset.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'ForceAssetStatus';
      params: {
        id: bigint;
        owner: AccountId20Like;
        issuer: AccountId20Like;
        admin: AccountId20Like;
        freezer: AccountId20Like;
        minBalance: bigint;
        isSufficient: boolean;
        isFrozen: boolean;
      };
    }
  /**
   * Approve an amount of asset for transfer by a delegated third-party account.
   *
   * Origin must be Signed.
   *
   * Ensures that `ApprovalDeposit` worth of `Currency` is reserved from signing account
   * for the purpose of holding the approval. If some non-zero amount of assets is already
   * approved from signing account to `delegate`, then it is topped up or unreserved to
   * meet the right value.
   *
   * NOTE: The signing account does not need to own `amount` of assets at the point of
   * making this call.
   *
   * - `id`: The identifier of the asset.
   * - `delegate`: The account to delegate permission to transfer asset.
   * - `amount`: The amount of asset that may be transferred by `delegate`. If there is
   * already an approval in place, then this acts additively.
   *
   * Emits `ApprovedTransfer` on success.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ApproveTransfer'; params: { id: bigint; delegate: AccountId20Like; amount: bigint } }
  /**
   * Cancel all of some asset approved for delegated transfer by a third-party account.
   *
   * Origin must be Signed and there must be an approval in place between signer and
   * `delegate`.
   *
   * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
   *
   * - `id`: The identifier of the asset.
   * - `delegate`: The account delegated permission to transfer asset.
   *
   * Emits `ApprovalCancelled` on success.
   *
   * Weight: `O(1)`
   **/
  | { name: 'CancelApproval'; params: { id: bigint; delegate: AccountId20Like } }
  /**
   * Cancel all of some asset approved for delegated transfer by a third-party account.
   *
   * Origin must be either ForceOrigin or Signed origin with the signer being the Admin
   * account of the asset `id`.
   *
   * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
   *
   * - `id`: The identifier of the asset.
   * - `delegate`: The account delegated permission to transfer asset.
   *
   * Emits `ApprovalCancelled` on success.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ForceCancelApproval'; params: { id: bigint; owner: AccountId20Like; delegate: AccountId20Like } }
  /**
   * Transfer some asset balance from a previously delegated account to some third-party
   * account.
   *
   * Origin must be Signed and there must be an approval in place by the `owner` to the
   * signer.
   *
   * If the entire amount approved for transfer is transferred, then any deposit previously
   * reserved by `approve_transfer` is unreserved.
   *
   * - `id`: The identifier of the asset.
   * - `owner`: The account which previously approved for a transfer of at least `amount` and
   * from which the asset balance will be withdrawn.
   * - `destination`: The account to which the asset balance of `amount` will be transferred.
   * - `amount`: The amount of assets to transfer.
   *
   * Emits `TransferredApproved` on success.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'TransferApproved';
      params: { id: bigint; owner: AccountId20Like; destination: AccountId20Like; amount: bigint };
    }
  /**
   * Create an asset account for non-provider assets.
   *
   * A deposit will be taken from the signer account.
   *
   * - `origin`: Must be Signed; the signer account must have sufficient funds for a deposit
   * to be taken.
   * - `id`: The identifier of the asset for the account to be created.
   *
   * Emits `Touched` event when successful.
   **/
  | { name: 'Touch'; params: { id: bigint } }
  /**
   * Return the deposit (if any) of an asset account or a consumer reference (if any) of an
   * account.
   *
   * The origin must be Signed.
   *
   * - `id`: The identifier of the asset for which the caller would like the deposit
   * refunded.
   * - `allow_burn`: If `true` then assets may be destroyed in order to complete the refund.
   *
   * Emits `Refunded` event when successful.
   **/
  | { name: 'Refund'; params: { id: bigint; allowBurn: boolean } }
  /**
   * Sets the minimum balance of an asset.
   *
   * Only works if there aren't any accounts that are holding the asset or if
   * the new value of `min_balance` is less than the old one.
   *
   * Origin must be Signed and the sender has to be the Owner of the
   * asset `id`.
   *
   * - `id`: The identifier of the asset.
   * - `min_balance`: The new value of `min_balance`.
   *
   * Emits `AssetMinBalanceChanged` event when successful.
   **/
  | { name: 'SetMinBalance'; params: { id: bigint; minBalance: bigint } }
  /**
   * Create an asset account for `who`.
   *
   * A deposit will be taken from the signer account.
   *
   * - `origin`: Must be Signed by `Freezer` or `Admin` of the asset `id`; the signer account
   * must have sufficient funds for a deposit to be taken.
   * - `id`: The identifier of the asset for the account to be created.
   * - `who`: The account to be created.
   *
   * Emits `Touched` event when successful.
   **/
  | { name: 'TouchOther'; params: { id: bigint; who: AccountId20Like } }
  /**
   * Return the deposit (if any) of a target asset account. Useful if you are the depositor.
   *
   * The origin must be Signed and either the account owner, depositor, or asset `Admin`. In
   * order to burn a non-zero balance of the asset, the caller must be the account and should
   * use `refund`.
   *
   * - `id`: The identifier of the asset for the account holding a deposit.
   * - `who`: The account to refund.
   *
   * Emits `Refunded` event when successful.
   **/
  | { name: 'RefundOther'; params: { id: bigint; who: AccountId20Like } }
  /**
   * Disallow further unprivileged transfers of an asset `id` to and from an account `who`.
   *
   * Origin must be Signed and the sender should be the Freezer of the asset `id`.
   *
   * - `id`: The identifier of the account's asset.
   * - `who`: The account to be unblocked.
   *
   * Emits `Blocked`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Block'; params: { id: bigint; who: AccountId20Like } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletAssetManagerCall =
  /**
   * Register new asset with the asset manager
   **/
  | {
      name: 'RegisterForeignAsset';
      params: {
        asset: MoonbeamRuntimeXcmConfigAssetType;
        metadata: MoonbeamRuntimeAssetConfigAssetRegistrarMetadata;
        minAmount: bigint;
        isSufficient: boolean;
      };
    }
  /**
   * Change the xcm type mapping for a given assetId
   * We also change this if the previous units per second where pointing at the old
   * assetType
   **/
  | {
      name: 'ChangeExistingAssetType';
      params: { assetId: bigint; newAssetType: MoonbeamRuntimeXcmConfigAssetType; numAssetsWeightHint: number };
    }
  /**
   * Remove a given assetId -> assetType association
   **/
  | { name: 'RemoveExistingAssetType'; params: { assetId: bigint; numAssetsWeightHint: number } }
  /**
   * Destroy a given foreign assetId
   * The weight in this case is the one returned by the trait
   * plus the db writes and reads from removing all the associated
   * data
   **/
  | { name: 'DestroyForeignAsset'; params: { assetId: bigint; numAssetsWeightHint: number } };

export type PalletAssetManagerCallLike =
  /**
   * Register new asset with the asset manager
   **/
  | {
      name: 'RegisterForeignAsset';
      params: {
        asset: MoonbeamRuntimeXcmConfigAssetType;
        metadata: MoonbeamRuntimeAssetConfigAssetRegistrarMetadata;
        minAmount: bigint;
        isSufficient: boolean;
      };
    }
  /**
   * Change the xcm type mapping for a given assetId
   * We also change this if the previous units per second where pointing at the old
   * assetType
   **/
  | {
      name: 'ChangeExistingAssetType';
      params: { assetId: bigint; newAssetType: MoonbeamRuntimeXcmConfigAssetType; numAssetsWeightHint: number };
    }
  /**
   * Remove a given assetId -> assetType association
   **/
  | { name: 'RemoveExistingAssetType'; params: { assetId: bigint; numAssetsWeightHint: number } }
  /**
   * Destroy a given foreign assetId
   * The weight in this case is the one returned by the trait
   * plus the db writes and reads from removing all the associated
   * data
   **/
  | { name: 'DestroyForeignAsset'; params: { assetId: bigint; numAssetsWeightHint: number } };

export type MoonbeamRuntimeXcmConfigAssetType = { type: 'Xcm'; value: StagingXcmV3MultilocationMultiLocation };

export type MoonbeamRuntimeAssetConfigAssetRegistrarMetadata = {
  name: Bytes;
  symbol: Bytes;
  decimals: number;
  isFrozen: boolean;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletXcmTransactorCall =
  /**
   * Register a derivative index for an account id. Dispatchable by
   * DerivativeAddressRegistrationOrigin
   *
   * We do not store the derivative address, but only the index. We do not need to store
   * the derivative address to issue calls, only the index is enough
   *
   * For now an index is registered for all possible destinations and not per-destination.
   * We can change this in the future although it would just make things more complicated
   **/
  | { name: 'Register'; params: { who: AccountId20; index: number } }
  /**
   * De-Register a derivative index. This prevents an account to use a derivative address
   * (represented by an index) from our of our sovereign accounts anymore
   **/
  | { name: 'Deregister'; params: { index: number } }
  /**
   * Transact the inner call through a derivative account in a destination chain,
   * using 'fee_location' to pay for the fees. This fee_location is given as a multilocation
   *
   * The caller needs to have the index registered in this pallet. The fee multiasset needs
   * to be a reserve asset for the destination transactor::multilocation.
   **/
  | {
      name: 'TransactThroughDerivative';
      params: {
        dest: MoonbeamRuntimeXcmConfigTransactors;
        index: number;
        fee: PalletXcmTransactorCurrencyPayment;
        innerCall: Bytes;
        weightInfo: PalletXcmTransactorTransactWeights;
        refund: boolean;
      };
    }
  /**
   * Transact the call through the sovereign account in a destination chain,
   * 'fee_payer' pays for the fee
   *
   * SovereignAccountDispatcherOrigin callable only
   **/
  | {
      name: 'TransactThroughSovereign';
      params: {
        dest: XcmVersionedLocation;
        feePayer?: AccountId20 | undefined;
        fee: PalletXcmTransactorCurrencyPayment;
        call: Bytes;
        originKind: XcmV3OriginKind;
        weightInfo: PalletXcmTransactorTransactWeights;
        refund: boolean;
      };
    }
  /**
   * Change the transact info of a location
   **/
  | {
      name: 'SetTransactInfo';
      params: {
        location: XcmVersionedLocation;
        transactExtraWeight: SpWeightsWeightV2Weight;
        maxWeight: SpWeightsWeightV2Weight;
        transactExtraWeightSigned?: SpWeightsWeightV2Weight | undefined;
      };
    }
  /**
   * Remove the transact info of a location
   **/
  | { name: 'RemoveTransactInfo'; params: { location: XcmVersionedLocation } }
  /**
   * Transact the call through the a signed origin in this chain
   * that should be converted to a transaction dispatch account in the destination chain
   * by any method implemented in the destination chains runtime
   *
   * This time we are giving the currency as a currencyId instead of multilocation
   **/
  | {
      name: 'TransactThroughSigned';
      params: {
        dest: XcmVersionedLocation;
        fee: PalletXcmTransactorCurrencyPayment;
        call: Bytes;
        weightInfo: PalletXcmTransactorTransactWeights;
        refund: boolean;
      };
    }
  /**
   * Set the fee per second of an asset on its reserve chain
   **/
  | { name: 'SetFeePerSecond'; params: { assetLocation: XcmVersionedLocation; feePerSecond: bigint } }
  /**
   * Remove the fee per second of an asset on its reserve chain
   **/
  | { name: 'RemoveFeePerSecond'; params: { assetLocation: XcmVersionedLocation } }
  /**
   * Manage HRMP operations
   **/
  | {
      name: 'HrmpManage';
      params: {
        action: PalletXcmTransactorHrmpOperation;
        fee: PalletXcmTransactorCurrencyPayment;
        weightInfo: PalletXcmTransactorTransactWeights;
      };
    };

export type PalletXcmTransactorCallLike =
  /**
   * Register a derivative index for an account id. Dispatchable by
   * DerivativeAddressRegistrationOrigin
   *
   * We do not store the derivative address, but only the index. We do not need to store
   * the derivative address to issue calls, only the index is enough
   *
   * For now an index is registered for all possible destinations and not per-destination.
   * We can change this in the future although it would just make things more complicated
   **/
  | { name: 'Register'; params: { who: AccountId20Like; index: number } }
  /**
   * De-Register a derivative index. This prevents an account to use a derivative address
   * (represented by an index) from our of our sovereign accounts anymore
   **/
  | { name: 'Deregister'; params: { index: number } }
  /**
   * Transact the inner call through a derivative account in a destination chain,
   * using 'fee_location' to pay for the fees. This fee_location is given as a multilocation
   *
   * The caller needs to have the index registered in this pallet. The fee multiasset needs
   * to be a reserve asset for the destination transactor::multilocation.
   **/
  | {
      name: 'TransactThroughDerivative';
      params: {
        dest: MoonbeamRuntimeXcmConfigTransactors;
        index: number;
        fee: PalletXcmTransactorCurrencyPayment;
        innerCall: BytesLike;
        weightInfo: PalletXcmTransactorTransactWeights;
        refund: boolean;
      };
    }
  /**
   * Transact the call through the sovereign account in a destination chain,
   * 'fee_payer' pays for the fee
   *
   * SovereignAccountDispatcherOrigin callable only
   **/
  | {
      name: 'TransactThroughSovereign';
      params: {
        dest: XcmVersionedLocation;
        feePayer?: AccountId20Like | undefined;
        fee: PalletXcmTransactorCurrencyPayment;
        call: BytesLike;
        originKind: XcmV3OriginKind;
        weightInfo: PalletXcmTransactorTransactWeights;
        refund: boolean;
      };
    }
  /**
   * Change the transact info of a location
   **/
  | {
      name: 'SetTransactInfo';
      params: {
        location: XcmVersionedLocation;
        transactExtraWeight: SpWeightsWeightV2Weight;
        maxWeight: SpWeightsWeightV2Weight;
        transactExtraWeightSigned?: SpWeightsWeightV2Weight | undefined;
      };
    }
  /**
   * Remove the transact info of a location
   **/
  | { name: 'RemoveTransactInfo'; params: { location: XcmVersionedLocation } }
  /**
   * Transact the call through the a signed origin in this chain
   * that should be converted to a transaction dispatch account in the destination chain
   * by any method implemented in the destination chains runtime
   *
   * This time we are giving the currency as a currencyId instead of multilocation
   **/
  | {
      name: 'TransactThroughSigned';
      params: {
        dest: XcmVersionedLocation;
        fee: PalletXcmTransactorCurrencyPayment;
        call: BytesLike;
        weightInfo: PalletXcmTransactorTransactWeights;
        refund: boolean;
      };
    }
  /**
   * Set the fee per second of an asset on its reserve chain
   **/
  | { name: 'SetFeePerSecond'; params: { assetLocation: XcmVersionedLocation; feePerSecond: bigint } }
  /**
   * Remove the fee per second of an asset on its reserve chain
   **/
  | { name: 'RemoveFeePerSecond'; params: { assetLocation: XcmVersionedLocation } }
  /**
   * Manage HRMP operations
   **/
  | {
      name: 'HrmpManage';
      params: {
        action: PalletXcmTransactorHrmpOperation;
        fee: PalletXcmTransactorCurrencyPayment;
        weightInfo: PalletXcmTransactorTransactWeights;
      };
    };

export type MoonbeamRuntimeXcmConfigTransactors = 'Relay';

export type PalletXcmTransactorCurrencyPayment = {
  currency: PalletXcmTransactorCurrency;
  feeAmount?: bigint | undefined;
};

export type MoonbeamRuntimeXcmConfigCurrencyId =
  | { type: 'SelfReserve' }
  | { type: 'ForeignAsset'; value: bigint }
  | { type: 'Erc20'; value: { contractAddress: H160 } };

export type PalletXcmTransactorCurrency =
  | { type: 'AsCurrencyId'; value: MoonbeamRuntimeXcmConfigCurrencyId }
  | { type: 'AsMultiLocation'; value: XcmVersionedLocation };

export type PalletXcmTransactorTransactWeights = {
  transactRequiredWeightAtMost: SpWeightsWeightV2Weight;
  overallWeight?: XcmV3WeightLimit | undefined;
};

export type PalletXcmTransactorHrmpOperation =
  | { type: 'InitOpen'; value: PalletXcmTransactorHrmpInitParams }
  | { type: 'Accept'; value: { paraId: PolkadotParachainPrimitivesPrimitivesId } }
  | { type: 'Close'; value: PolkadotParachainPrimitivesPrimitivesHrmpChannelId }
  | { type: 'Cancel'; value: { channelId: PolkadotParachainPrimitivesPrimitivesHrmpChannelId; openRequests: number } };

export type PalletXcmTransactorHrmpInitParams = {
  paraId: PolkadotParachainPrimitivesPrimitivesId;
  proposedMaxCapacity: number;
  proposedMaxMessageSize: number;
};

export type PolkadotParachainPrimitivesPrimitivesHrmpChannelId = {
  sender: PolkadotParachainPrimitivesPrimitivesId;
  recipient: PolkadotParachainPrimitivesPrimitivesId;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletEthereumXcmCall =
  /**
   * Xcm Transact an Ethereum transaction.
   * Weight: Gas limit plus the db read involving the suspension check
   **/
  | { name: 'Transact'; params: { xcmTransaction: XcmPrimitivesEthereumXcmEthereumXcmTransaction } }
  /**
   * Xcm Transact an Ethereum transaction through proxy.
   * Weight: Gas limit plus the db reads involving the suspension and proxy checks
   **/
  | {
      name: 'TransactThroughProxy';
      params: { transactAs: H160; xcmTransaction: XcmPrimitivesEthereumXcmEthereumXcmTransaction };
    }
  /**
   * Suspends all Ethereum executions from XCM.
   *
   * - `origin`: Must pass `ControllerOrigin`.
   **/
  | { name: 'SuspendEthereumXcmExecution' }
  /**
   * Resumes all Ethereum executions from XCM.
   *
   * - `origin`: Must pass `ControllerOrigin`.
   **/
  | { name: 'ResumeEthereumXcmExecution' }
  /**
   * Xcm Transact an Ethereum transaction, but allow to force the caller and create address.
   * This call should be restricted (callable only by the runtime or governance).
   * Weight: Gas limit plus the db reads involving the suspension and proxy checks
   **/
  | {
      name: 'ForceTransactAs';
      params: {
        transactAs: H160;
        xcmTransaction: XcmPrimitivesEthereumXcmEthereumXcmTransaction;
        forceCreateAddress?: H160 | undefined;
      };
    };

export type PalletEthereumXcmCallLike =
  /**
   * Xcm Transact an Ethereum transaction.
   * Weight: Gas limit plus the db read involving the suspension check
   **/
  | { name: 'Transact'; params: { xcmTransaction: XcmPrimitivesEthereumXcmEthereumXcmTransaction } }
  /**
   * Xcm Transact an Ethereum transaction through proxy.
   * Weight: Gas limit plus the db reads involving the suspension and proxy checks
   **/
  | {
      name: 'TransactThroughProxy';
      params: { transactAs: H160; xcmTransaction: XcmPrimitivesEthereumXcmEthereumXcmTransaction };
    }
  /**
   * Suspends all Ethereum executions from XCM.
   *
   * - `origin`: Must pass `ControllerOrigin`.
   **/
  | { name: 'SuspendEthereumXcmExecution' }
  /**
   * Resumes all Ethereum executions from XCM.
   *
   * - `origin`: Must pass `ControllerOrigin`.
   **/
  | { name: 'ResumeEthereumXcmExecution' }
  /**
   * Xcm Transact an Ethereum transaction, but allow to force the caller and create address.
   * This call should be restricted (callable only by the runtime or governance).
   * Weight: Gas limit plus the db reads involving the suspension and proxy checks
   **/
  | {
      name: 'ForceTransactAs';
      params: {
        transactAs: H160;
        xcmTransaction: XcmPrimitivesEthereumXcmEthereumXcmTransaction;
        forceCreateAddress?: H160 | undefined;
      };
    };

export type XcmPrimitivesEthereumXcmEthereumXcmTransaction =
  | { type: 'V1'; value: XcmPrimitivesEthereumXcmEthereumXcmTransactionV1 }
  | { type: 'V2'; value: XcmPrimitivesEthereumXcmEthereumXcmTransactionV2 };

export type XcmPrimitivesEthereumXcmEthereumXcmTransactionV1 = {
  gasLimit: U256;
  feePayment: XcmPrimitivesEthereumXcmEthereumXcmFee;
  action: EthereumTransactionTransactionAction;
  value: U256;
  input: Bytes;
  accessList?: Array<[H160, Array<H256>]> | undefined;
};

export type XcmPrimitivesEthereumXcmEthereumXcmFee =
  | { type: 'Manual'; value: XcmPrimitivesEthereumXcmManualEthereumXcmFee }
  | { type: 'Auto' };

export type XcmPrimitivesEthereumXcmManualEthereumXcmFee = {
  gasPrice?: U256 | undefined;
  maxFeePerGas?: U256 | undefined;
};

export type XcmPrimitivesEthereumXcmEthereumXcmTransactionV2 = {
  gasLimit: U256;
  action: EthereumTransactionTransactionAction;
  value: U256;
  input: Bytes;
  accessList?: Array<[H160, Array<H256>]> | undefined;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMessageQueueCall =
  /**
   * Remove a page which has no more messages remaining to be processed or is stale.
   **/
  | { name: 'ReapPage'; params: { messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin; pageIndex: number } }
  /**
   * Execute an overweight message.
   *
   * Temporary processing errors will be propagated whereas permanent errors are treated
   * as success condition.
   *
   * - `origin`: Must be `Signed`.
   * - `message_origin`: The origin from which the message to be executed arrived.
   * - `page`: The page in the queue in which the message to be executed is sitting.
   * - `index`: The index into the queue of the message to be executed.
   * - `weight_limit`: The maximum amount of weight allowed to be consumed in the execution
   * of the message.
   *
   * Benchmark complexity considerations: O(index + weight_limit).
   **/
  | {
      name: 'ExecuteOverweight';
      params: {
        messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin;
        page: number;
        index: number;
        weightLimit: SpWeightsWeightV2Weight;
      };
    };

export type PalletMessageQueueCallLike =
  /**
   * Remove a page which has no more messages remaining to be processed or is stale.
   **/
  | { name: 'ReapPage'; params: { messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin; pageIndex: number } }
  /**
   * Execute an overweight message.
   *
   * Temporary processing errors will be propagated whereas permanent errors are treated
   * as success condition.
   *
   * - `origin`: Must be `Signed`.
   * - `message_origin`: The origin from which the message to be executed arrived.
   * - `page`: The page in the queue in which the message to be executed is sitting.
   * - `index`: The index into the queue of the message to be executed.
   * - `weight_limit`: The maximum amount of weight allowed to be consumed in the execution
   * of the message.
   *
   * Benchmark complexity considerations: O(index + weight_limit).
   **/
  | {
      name: 'ExecuteOverweight';
      params: {
        messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin;
        page: number;
        index: number;
        weightLimit: SpWeightsWeightV2Weight;
      };
    };

export type CumulusPrimitivesCoreAggregateMessageOrigin =
  | { type: 'Here' }
  | { type: 'Parent' }
  | { type: 'Sibling'; value: PolkadotParachainPrimitivesPrimitivesId };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMoonbeamForeignAssetsCall =
  /**
   * Create new asset with the ForeignAssetCreator
   **/
  | {
      name: 'CreateForeignAsset';
      params: { assetId: bigint; xcmLocation: StagingXcmV4Location; decimals: number; symbol: Bytes; name: Bytes };
    }
  /**
   * Change the xcm type mapping for a given assetId
   * We also change this if the previous units per second where pointing at the old
   * assetType
   **/
  | { name: 'ChangeXcmLocation'; params: { assetId: bigint; newXcmLocation: StagingXcmV4Location } }
  /**
   * Freeze a given foreign assetId
   **/
  | { name: 'FreezeForeignAsset'; params: { assetId: bigint; allowXcmDeposit: boolean } }
  /**
   * Unfreeze a given foreign assetId
   **/
  | { name: 'UnfreezeForeignAsset'; params: { assetId: bigint } };

export type PalletMoonbeamForeignAssetsCallLike =
  /**
   * Create new asset with the ForeignAssetCreator
   **/
  | {
      name: 'CreateForeignAsset';
      params: {
        assetId: bigint;
        xcmLocation: StagingXcmV4Location;
        decimals: number;
        symbol: BytesLike;
        name: BytesLike;
      };
    }
  /**
   * Change the xcm type mapping for a given assetId
   * We also change this if the previous units per second where pointing at the old
   * assetType
   **/
  | { name: 'ChangeXcmLocation'; params: { assetId: bigint; newXcmLocation: StagingXcmV4Location } }
  /**
   * Freeze a given foreign assetId
   **/
  | { name: 'FreezeForeignAsset'; params: { assetId: bigint; allowXcmDeposit: boolean } }
  /**
   * Unfreeze a given foreign assetId
   **/
  | { name: 'UnfreezeForeignAsset'; params: { assetId: bigint } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletXcmWeightTraderCall =
  | { name: 'AddAsset'; params: { location: StagingXcmV4Location; relativePrice: bigint } }
  | { name: 'EditAsset'; params: { location: StagingXcmV4Location; relativePrice: bigint } }
  | { name: 'PauseAssetSupport'; params: { location: StagingXcmV4Location } }
  | { name: 'ResumeAssetSupport'; params: { location: StagingXcmV4Location } }
  | { name: 'RemoveAsset'; params: { location: StagingXcmV4Location } };

export type PalletXcmWeightTraderCallLike =
  | { name: 'AddAsset'; params: { location: StagingXcmV4Location; relativePrice: bigint } }
  | { name: 'EditAsset'; params: { location: StagingXcmV4Location; relativePrice: bigint } }
  | { name: 'PauseAssetSupport'; params: { location: StagingXcmV4Location } }
  | { name: 'ResumeAssetSupport'; params: { location: StagingXcmV4Location } }
  | { name: 'RemoveAsset'; params: { location: StagingXcmV4Location } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletEmergencyParaXcmCall =
  /**
   * Resume `Normal` mode
   **/
  | { name: 'PausedToNormal' }
  /**
   * Authorize a runtime upgrade. Only callable in `Paused` mode
   **/
  | { name: 'FastAuthorizeUpgrade'; params: { codeHash: H256 } };

export type PalletEmergencyParaXcmCallLike =
  /**
   * Resume `Normal` mode
   **/
  | { name: 'PausedToNormal' }
  /**
   * Authorize a runtime upgrade. Only callable in `Paused` mode
   **/
  | { name: 'FastAuthorizeUpgrade'; params: { codeHash: H256 } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletRandomnessCall =
  /**
   * Populates `RandomnessResults` due this epoch with BABE epoch randomness
   **/
  'SetBabeRandomnessResults';

export type PalletRandomnessCallLike =
  /**
   * Populates `RandomnessResults` due this epoch with BABE epoch randomness
   **/
  'SetBabeRandomnessResults';

export type SpRuntimeBlakeTwo256 = {};

export type PalletConvictionVotingTally = { ayes: bigint; nays: bigint; support: bigint };

/**
 * The `Event` enum of this pallet
 **/
export type PalletWhitelistEvent =
  | { name: 'CallWhitelisted'; data: { callHash: H256 } }
  | { name: 'WhitelistedCallRemoved'; data: { callHash: H256 } }
  | {
      name: 'WhitelistedCallDispatched';
      data: {
        callHash: H256;
        result: Result<FrameSupportDispatchPostDispatchInfo, SpRuntimeDispatchErrorWithPostInfo>;
      };
    };

export type FrameSupportDispatchPostDispatchInfo = {
  actualWeight?: SpWeightsWeightV2Weight | undefined;
  paysFee: FrameSupportDispatchPays;
};

export type SpRuntimeDispatchErrorWithPostInfo = {
  postInfo: FrameSupportDispatchPostDispatchInfo;
  error: DispatchError;
};

/**
 * The `Event` enum of this pallet
 **/
export type PalletCollectiveEvent =
  /**
   * A motion (given hash) has been proposed (by given account) with a threshold (given
   * `MemberCount`).
   **/
  | { name: 'Proposed'; data: { account: AccountId20; proposalIndex: number; proposalHash: H256; threshold: number } }
  /**
   * A motion (given hash) has been voted on by given account, leaving
   * a tally (yes votes and no votes given respectively as `MemberCount`).
   **/
  | { name: 'Voted'; data: { account: AccountId20; proposalHash: H256; voted: boolean; yes: number; no: number } }
  /**
   * A motion was approved by the required threshold.
   **/
  | { name: 'Approved'; data: { proposalHash: H256 } }
  /**
   * A motion was not approved by the required threshold.
   **/
  | { name: 'Disapproved'; data: { proposalHash: H256 } }
  /**
   * A motion was executed; result will be `Ok` if it returned without error.
   **/
  | { name: 'Executed'; data: { proposalHash: H256; result: Result<[], DispatchError> } }
  /**
   * A single member did some action; result will be `Ok` if it returned without error.
   **/
  | { name: 'MemberExecuted'; data: { proposalHash: H256; result: Result<[], DispatchError> } }
  /**
   * A proposal was closed because its threshold was reached or after its duration was up.
   **/
  | { name: 'Closed'; data: { proposalHash: H256; yes: number; no: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletTreasuryEvent =
  /**
   * We have ended a spend period and will now allocate funds.
   **/
  | { name: 'Spending'; data: { budgetRemaining: bigint } }
  /**
   * Some funds have been allocated.
   **/
  | { name: 'Awarded'; data: { proposalIndex: number; award: bigint; account: AccountId20 } }
  /**
   * Some of our funds have been burnt.
   **/
  | { name: 'Burnt'; data: { burntFunds: bigint } }
  /**
   * Spending has finished; this is the amount that rolls over until next spend.
   **/
  | { name: 'Rollover'; data: { rolloverBalance: bigint } }
  /**
   * Some funds have been deposited.
   **/
  | { name: 'Deposit'; data: { value: bigint } }
  /**
   * A new spend proposal has been approved.
   **/
  | { name: 'SpendApproved'; data: { proposalIndex: number; amount: bigint; beneficiary: AccountId20 } }
  /**
   * The inactive funds of the pallet have been updated.
   **/
  | { name: 'UpdatedInactive'; data: { reactivated: bigint; deactivated: bigint } }
  /**
   * A new asset spend proposal has been approved.
   **/
  | {
      name: 'AssetSpendApproved';
      data: {
        index: number;
        assetKind: [];
        amount: bigint;
        beneficiary: AccountId20;
        validFrom: number;
        expireAt: number;
      };
    }
  /**
   * An approved spend was voided.
   **/
  | { name: 'AssetSpendVoided'; data: { index: number } }
  /**
   * A payment happened.
   **/
  | { name: 'Paid'; data: { index: number; paymentId: [] } }
  /**
   * A payment failed and can be retried.
   **/
  | { name: 'PaymentFailed'; data: { index: number; paymentId: [] } }
  /**
   * A spend was processed and removed from the storage. It might have been successfully
   * paid or it may have expired.
   **/
  | { name: 'SpendProcessed'; data: { index: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletCrowdloanRewardsEvent =
  /**
   * The initial payment of InitializationPayment % was paid
   **/
  | { name: 'InitialPaymentMade'; data: [AccountId20, bigint] }
  /**
   * Someone has proven they made a contribution and associated a native identity with it.
   * Data is the relay account, native account and the total amount of _rewards_ that will be paid
   **/
  | { name: 'NativeIdentityAssociated'; data: [FixedBytes<32>, AccountId20, bigint] }
  /**
   * A contributor has claimed some rewards.
   * Data is the account getting paid and the amount of rewards paid.
   **/
  | { name: 'RewardsPaid'; data: [AccountId20, bigint] }
  /**
   * A contributor has updated the reward address.
   **/
  | { name: 'RewardAddressUpdated'; data: [AccountId20, AccountId20] }
  /**
   * When initializing the reward vec an already initialized account was found
   **/
  | { name: 'InitializedAlreadyInitializedAccount'; data: [FixedBytes<32>, AccountId20 | undefined, bigint] }
  /**
   * When initializing the reward vec an already initialized account was found
   **/
  | { name: 'InitializedAccountWithNotEnoughContribution'; data: [FixedBytes<32>, AccountId20 | undefined, bigint] };

/**
 * The `Event` enum of this pallet
 **/
export type CumulusPalletXcmpQueueEvent =
  /**
   * An HRMP message was sent to a sibling parachain.
   **/
  { name: 'XcmpMessageSent'; data: { messageHash: FixedBytes<32> } };

/**
 * The `Event` enum of this pallet
 **/
export type CumulusPalletXcmEvent =
  /**
   * Downward message is invalid XCM.
   * \[ id \]
   **/
  | { name: 'InvalidFormat'; data: FixedBytes<32> }
  /**
   * Downward message is unsupported version of XCM.
   * \[ id \]
   **/
  | { name: 'UnsupportedVersion'; data: FixedBytes<32> }
  /**
   * Downward message executed with the given outcome.
   * \[ id, outcome \]
   **/
  | { name: 'ExecutedDownward'; data: [FixedBytes<32>, StagingXcmV4TraitsOutcome] };

export type StagingXcmV4TraitsOutcome =
  | { type: 'Complete'; value: { used: SpWeightsWeightV2Weight } }
  | { type: 'Incomplete'; value: { used: SpWeightsWeightV2Weight; error: XcmV3TraitsError } }
  | { type: 'Error'; value: { error: XcmV3TraitsError } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletXcmEvent =
  /**
   * Execution of an XCM message was attempted.
   **/
  | { name: 'Attempted'; data: { outcome: StagingXcmV4TraitsOutcome } }
  /**
   * A XCM message was sent.
   **/
  | {
      name: 'Sent';
      data: {
        origin: StagingXcmV4Location;
        destination: StagingXcmV4Location;
        message: StagingXcmV4Xcm;
        messageId: FixedBytes<32>;
      };
    }
  /**
   * Query response received which does not match a registered query. This may be because a
   * matching query was never registered, it may be because it is a duplicate response, or
   * because the query timed out.
   **/
  | { name: 'UnexpectedResponse'; data: { origin: StagingXcmV4Location; queryId: bigint } }
  /**
   * Query response has been received and is ready for taking with `take_response`. There is
   * no registered notification call.
   **/
  | { name: 'ResponseReady'; data: { queryId: bigint; response: StagingXcmV4Response } }
  /**
   * Query response has been received and query is removed. The registered notification has
   * been dispatched and executed successfully.
   **/
  | { name: 'Notified'; data: { queryId: bigint; palletIndex: number; callIndex: number } }
  /**
   * Query response has been received and query is removed. The registered notification
   * could not be dispatched because the dispatch weight is greater than the maximum weight
   * originally budgeted by this runtime for the query result.
   **/
  | {
      name: 'NotifyOverweight';
      data: {
        queryId: bigint;
        palletIndex: number;
        callIndex: number;
        actualWeight: SpWeightsWeightV2Weight;
        maxBudgetedWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Query response has been received and query is removed. There was a general error with
   * dispatching the notification call.
   **/
  | { name: 'NotifyDispatchError'; data: { queryId: bigint; palletIndex: number; callIndex: number } }
  /**
   * Query response has been received and query is removed. The dispatch was unable to be
   * decoded into a `Call`; this might be due to dispatch function having a signature which
   * is not `(origin, QueryId, Response)`.
   **/
  | { name: 'NotifyDecodeFailed'; data: { queryId: bigint; palletIndex: number; callIndex: number } }
  /**
   * Expected query response has been received but the origin location of the response does
   * not match that expected. The query remains registered for a later, valid, response to
   * be received and acted upon.
   **/
  | {
      name: 'InvalidResponder';
      data: { origin: StagingXcmV4Location; queryId: bigint; expectedLocation?: StagingXcmV4Location | undefined };
    }
  /**
   * Expected query response has been received but the expected origin location placed in
   * storage by this runtime previously cannot be decoded. The query remains registered.
   *
   * This is unexpected (since a location placed in storage in a previously executing
   * runtime should be readable prior to query timeout) and dangerous since the possibly
   * valid response will be dropped. Manual governance intervention is probably going to be
   * needed.
   **/
  | { name: 'InvalidResponderVersion'; data: { origin: StagingXcmV4Location; queryId: bigint } }
  /**
   * Received query response has been read and removed.
   **/
  | { name: 'ResponseTaken'; data: { queryId: bigint } }
  /**
   * Some assets have been placed in an asset trap.
   **/
  | { name: 'AssetsTrapped'; data: { hash: H256; origin: StagingXcmV4Location; assets: XcmVersionedAssets } }
  /**
   * An XCM version change notification message has been attempted to be sent.
   *
   * The cost of sending it (borne by the chain) is included.
   **/
  | {
      name: 'VersionChangeNotified';
      data: {
        destination: StagingXcmV4Location;
        result: number;
        cost: StagingXcmV4AssetAssets;
        messageId: FixedBytes<32>;
      };
    }
  /**
   * The supported version of a location has been changed. This might be through an
   * automatic notification or a manual intervention.
   **/
  | { name: 'SupportedVersionChanged'; data: { location: StagingXcmV4Location; version: number } }
  /**
   * A given location which had a version change subscription was dropped owing to an error
   * sending the notification to it.
   **/
  | { name: 'NotifyTargetSendFail'; data: { location: StagingXcmV4Location; queryId: bigint; error: XcmV3TraitsError } }
  /**
   * A given location which had a version change subscription was dropped owing to an error
   * migrating the location to our new XCM format.
   **/
  | { name: 'NotifyTargetMigrationFail'; data: { location: XcmVersionedLocation; queryId: bigint } }
  /**
   * Expected query response has been received but the expected querier location placed in
   * storage by this runtime previously cannot be decoded. The query remains registered.
   *
   * This is unexpected (since a location placed in storage in a previously executing
   * runtime should be readable prior to query timeout) and dangerous since the possibly
   * valid response will be dropped. Manual governance intervention is probably going to be
   * needed.
   **/
  | { name: 'InvalidQuerierVersion'; data: { origin: StagingXcmV4Location; queryId: bigint } }
  /**
   * Expected query response has been received but the querier location of the response does
   * not match the expected. The query remains registered for a later, valid, response to
   * be received and acted upon.
   **/
  | {
      name: 'InvalidQuerier';
      data: {
        origin: StagingXcmV4Location;
        queryId: bigint;
        expectedQuerier: StagingXcmV4Location;
        maybeActualQuerier?: StagingXcmV4Location | undefined;
      };
    }
  /**
   * A remote has requested XCM version change notification from us and we have honored it.
   * A version information message is sent to them and its cost is included.
   **/
  | {
      name: 'VersionNotifyStarted';
      data: { destination: StagingXcmV4Location; cost: StagingXcmV4AssetAssets; messageId: FixedBytes<32> };
    }
  /**
   * We have requested that a remote chain send us XCM version change notifications.
   **/
  | {
      name: 'VersionNotifyRequested';
      data: { destination: StagingXcmV4Location; cost: StagingXcmV4AssetAssets; messageId: FixedBytes<32> };
    }
  /**
   * We have requested that a remote chain stops sending us XCM version change
   * notifications.
   **/
  | {
      name: 'VersionNotifyUnrequested';
      data: { destination: StagingXcmV4Location; cost: StagingXcmV4AssetAssets; messageId: FixedBytes<32> };
    }
  /**
   * Fees were paid from a location for an operation (often for using `SendXcm`).
   **/
  | { name: 'FeesPaid'; data: { paying: StagingXcmV4Location; fees: StagingXcmV4AssetAssets } }
  /**
   * Some assets have been claimed from an asset trap
   **/
  | { name: 'AssetsClaimed'; data: { hash: H256; origin: StagingXcmV4Location; assets: XcmVersionedAssets } }
  /**
   * A XCM version migration finished.
   **/
  | { name: 'VersionMigrationFinished'; data: { version: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletAssetsEvent =
  /**
   * Some asset class was created.
   **/
  | { name: 'Created'; data: { assetId: bigint; creator: AccountId20; owner: AccountId20 } }
  /**
   * Some assets were issued.
   **/
  | { name: 'Issued'; data: { assetId: bigint; owner: AccountId20; amount: bigint } }
  /**
   * Some assets were transferred.
   **/
  | { name: 'Transferred'; data: { assetId: bigint; from: AccountId20; to: AccountId20; amount: bigint } }
  /**
   * Some assets were destroyed.
   **/
  | { name: 'Burned'; data: { assetId: bigint; owner: AccountId20; balance: bigint } }
  /**
   * The management team changed.
   **/
  | { name: 'TeamChanged'; data: { assetId: bigint; issuer: AccountId20; admin: AccountId20; freezer: AccountId20 } }
  /**
   * The owner changed.
   **/
  | { name: 'OwnerChanged'; data: { assetId: bigint; owner: AccountId20 } }
  /**
   * Some account `who` was frozen.
   **/
  | { name: 'Frozen'; data: { assetId: bigint; who: AccountId20 } }
  /**
   * Some account `who` was thawed.
   **/
  | { name: 'Thawed'; data: { assetId: bigint; who: AccountId20 } }
  /**
   * Some asset `asset_id` was frozen.
   **/
  | { name: 'AssetFrozen'; data: { assetId: bigint } }
  /**
   * Some asset `asset_id` was thawed.
   **/
  | { name: 'AssetThawed'; data: { assetId: bigint } }
  /**
   * Accounts were destroyed for given asset.
   **/
  | { name: 'AccountsDestroyed'; data: { assetId: bigint; accountsDestroyed: number; accountsRemaining: number } }
  /**
   * Approvals were destroyed for given asset.
   **/
  | { name: 'ApprovalsDestroyed'; data: { assetId: bigint; approvalsDestroyed: number; approvalsRemaining: number } }
  /**
   * An asset class is in the process of being destroyed.
   **/
  | { name: 'DestructionStarted'; data: { assetId: bigint } }
  /**
   * An asset class was destroyed.
   **/
  | { name: 'Destroyed'; data: { assetId: bigint } }
  /**
   * Some asset class was force-created.
   **/
  | { name: 'ForceCreated'; data: { assetId: bigint; owner: AccountId20 } }
  /**
   * New metadata has been set for an asset.
   **/
  | { name: 'MetadataSet'; data: { assetId: bigint; name: Bytes; symbol: Bytes; decimals: number; isFrozen: boolean } }
  /**
   * Metadata has been cleared for an asset.
   **/
  | { name: 'MetadataCleared'; data: { assetId: bigint } }
  /**
   * (Additional) funds have been approved for transfer to a destination account.
   **/
  | { name: 'ApprovedTransfer'; data: { assetId: bigint; source: AccountId20; delegate: AccountId20; amount: bigint } }
  /**
   * An approval for account `delegate` was cancelled by `owner`.
   **/
  | { name: 'ApprovalCancelled'; data: { assetId: bigint; owner: AccountId20; delegate: AccountId20 } }
  /**
   * An `amount` was transferred in its entirety from `owner` to `destination` by
   * the approved `delegate`.
   **/
  | {
      name: 'TransferredApproved';
      data: { assetId: bigint; owner: AccountId20; delegate: AccountId20; destination: AccountId20; amount: bigint };
    }
  /**
   * An asset has had its attributes changed by the `Force` origin.
   **/
  | { name: 'AssetStatusChanged'; data: { assetId: bigint } }
  /**
   * The min_balance of an asset has been updated by the asset owner.
   **/
  | { name: 'AssetMinBalanceChanged'; data: { assetId: bigint; newMinBalance: bigint } }
  /**
   * Some account `who` was created with a deposit from `depositor`.
   **/
  | { name: 'Touched'; data: { assetId: bigint; who: AccountId20; depositor: AccountId20 } }
  /**
   * Some account `who` was blocked.
   **/
  | { name: 'Blocked'; data: { assetId: bigint; who: AccountId20 } }
  /**
   * Some assets were deposited (e.g. for transaction fees).
   **/
  | { name: 'Deposited'; data: { assetId: bigint; who: AccountId20; amount: bigint } }
  /**
   * Some assets were withdrawn from the account (e.g. for transaction fees).
   **/
  | { name: 'Withdrawn'; data: { assetId: bigint; who: AccountId20; amount: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletAssetManagerEvent =
  /**
   * New asset with the asset manager is registered
   **/
  | {
      name: 'ForeignAssetRegistered';
      data: {
        assetId: bigint;
        asset: MoonbeamRuntimeXcmConfigAssetType;
        metadata: MoonbeamRuntimeAssetConfigAssetRegistrarMetadata;
      };
    }
  /**
   * Changed the amount of units we are charging per execution second for a given asset
   **/
  | { name: 'UnitsPerSecondChanged' }
  /**
   * Changed the xcm type mapping for a given asset id
   **/
  | {
      name: 'ForeignAssetXcmLocationChanged';
      data: { assetId: bigint; newAssetType: MoonbeamRuntimeXcmConfigAssetType };
    }
  /**
   * Removed all information related to an assetId
   **/
  | { name: 'ForeignAssetRemoved'; data: { assetId: bigint; assetType: MoonbeamRuntimeXcmConfigAssetType } }
  /**
   * Supported asset type for fee payment removed
   **/
  | { name: 'SupportedAssetRemoved'; data: { assetType: MoonbeamRuntimeXcmConfigAssetType } }
  /**
   * Removed all information related to an assetId and destroyed asset
   **/
  | { name: 'ForeignAssetDestroyed'; data: { assetId: bigint; assetType: MoonbeamRuntimeXcmConfigAssetType } }
  /**
   * Removed all information related to an assetId and destroyed asset
   **/
  | { name: 'LocalAssetDestroyed'; data: { assetId: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletXcmTransactorEvent =
  /**
   * Transacted the inner call through a derivative account in a destination chain.
   **/
  | {
      name: 'TransactedDerivative';
      data: { accountId: AccountId20; dest: StagingXcmV4Location; call: Bytes; index: number };
    }
  /**
   * Transacted the call through the sovereign account in a destination chain.
   **/
  | {
      name: 'TransactedSovereign';
      data: { feePayer?: AccountId20 | undefined; dest: StagingXcmV4Location; call: Bytes };
    }
  /**
   * Transacted the call through a signed account in a destination chain.
   **/
  | { name: 'TransactedSigned'; data: { feePayer: AccountId20; dest: StagingXcmV4Location; call: Bytes } }
  /**
   * Registered a derivative index for an account id.
   **/
  | { name: 'RegisteredDerivative'; data: { accountId: AccountId20; index: number } }
  | { name: 'DeRegisteredDerivative'; data: { index: number } }
  /**
   * Transact failed
   **/
  | { name: 'TransactFailed'; data: { error: XcmV3TraitsError } }
  /**
   * Changed the transact info of a location
   **/
  | {
      name: 'TransactInfoChanged';
      data: { location: StagingXcmV4Location; remoteInfo: PalletXcmTransactorRemoteTransactInfoWithMaxWeight };
    }
  /**
   * Removed the transact info of a location
   **/
  | { name: 'TransactInfoRemoved'; data: { location: StagingXcmV4Location } }
  /**
   * Set dest fee per second
   **/
  | { name: 'DestFeePerSecondChanged'; data: { location: StagingXcmV4Location; feePerSecond: bigint } }
  /**
   * Remove dest fee per second
   **/
  | { name: 'DestFeePerSecondRemoved'; data: { location: StagingXcmV4Location } }
  /**
   * HRMP manage action succesfully sent
   **/
  | { name: 'HrmpManagementSent'; data: { action: PalletXcmTransactorHrmpOperation } };

export type PalletXcmTransactorRemoteTransactInfoWithMaxWeight = {
  transactExtraWeight: SpWeightsWeightV2Weight;
  maxWeight: SpWeightsWeightV2Weight;
  transactExtraWeightSigned?: SpWeightsWeightV2Weight | undefined;
};

/**
 * The `Event` enum of this pallet
 **/
export type PalletEthereumXcmEvent =
  /**
   * Ethereum transaction executed from XCM
   **/
  { name: 'ExecutedFromXcm'; data: { xcmMsgHash: H256; ethTxHash: H256 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletMessageQueueEvent =
  /**
   * Message discarded due to an error in the `MessageProcessor` (usually a format error).
   **/
  | {
      name: 'ProcessingFailed';
      data: {
        /**
         * The `blake2_256` hash of the message.
         **/
        id: H256;

        /**
         * The queue of the message.
         **/
        origin: CumulusPrimitivesCoreAggregateMessageOrigin;

        /**
         * The error that occurred.
         *
         * This error is pretty opaque. More fine-grained errors need to be emitted as events
         * by the `MessageProcessor`.
         **/
        error: FrameSupportMessagesProcessMessageError;
      };
    }
  /**
   * Message is processed.
   **/
  | {
      name: 'Processed';
      data: {
        /**
         * The `blake2_256` hash of the message.
         **/
        id: H256;

        /**
         * The queue of the message.
         **/
        origin: CumulusPrimitivesCoreAggregateMessageOrigin;

        /**
         * How much weight was used to process the message.
         **/
        weightUsed: SpWeightsWeightV2Weight;

        /**
         * Whether the message was processed.
         *
         * Note that this does not mean that the underlying `MessageProcessor` was internally
         * successful. It *solely* means that the MQ pallet will treat this as a success
         * condition and discard the message. Any internal error needs to be emitted as events
         * by the `MessageProcessor`.
         **/
        success: boolean;
      };
    }
  /**
   * Message placed in overweight queue.
   **/
  | {
      name: 'OverweightEnqueued';
      data: {
        /**
         * The `blake2_256` hash of the message.
         **/
        id: FixedBytes<32>;

        /**
         * The queue of the message.
         **/
        origin: CumulusPrimitivesCoreAggregateMessageOrigin;

        /**
         * The page of the message.
         **/
        pageIndex: number;

        /**
         * The index of the message within the page.
         **/
        messageIndex: number;
      };
    }
  /**
   * This page was reaped.
   **/
  | {
      name: 'PageReaped';
      data: {
        /**
         * The queue of the page.
         **/
        origin: CumulusPrimitivesCoreAggregateMessageOrigin;

        /**
         * The index of the page.
         **/
        index: number;
      };
    };

export type FrameSupportMessagesProcessMessageError =
  | { type: 'BadFormat' }
  | { type: 'Corrupt' }
  | { type: 'Unsupported' }
  | { type: 'Overweight'; value: SpWeightsWeightV2Weight }
  | { type: 'Yield' }
  | { type: 'StackLimitReached' };

/**
 * The `Event` enum of this pallet
 **/
export type PalletMoonbeamForeignAssetsEvent =
  /**
   * New asset with the asset manager is registered
   **/
  | { name: 'ForeignAssetCreated'; data: { contractAddress: H160; assetId: bigint; xcmLocation: StagingXcmV4Location } }
  /**
   * Changed the xcm type mapping for a given asset id
   **/
  | { name: 'ForeignAssetXcmLocationChanged'; data: { assetId: bigint; newXcmLocation: StagingXcmV4Location } }
  | { name: 'ForeignAssetFrozen'; data: { assetId: bigint; xcmLocation: StagingXcmV4Location } }
  | { name: 'ForeignAssetUnfrozen'; data: { assetId: bigint; xcmLocation: StagingXcmV4Location } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletXcmWeightTraderEvent =
  /**
   * New supported asset is registered
   **/
  | { name: 'SupportedAssetAdded'; data: { location: StagingXcmV4Location; relativePrice: bigint } }
  /**
   * Changed the amount of units we are charging per execution second for a given asset
   **/
  | { name: 'SupportedAssetEdited'; data: { location: StagingXcmV4Location; relativePrice: bigint } }
  /**
   * Pause support for a given asset
   **/
  | { name: 'PauseAssetSupport'; data: { location: StagingXcmV4Location } }
  /**
   * Resume support for a given asset
   **/
  | { name: 'ResumeAssetSupport'; data: { location: StagingXcmV4Location } }
  /**
   * Supported asset type for fee payment removed
   **/
  | { name: 'SupportedAssetRemoved'; data: { location: StagingXcmV4Location } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletEmergencyParaXcmEvent =
  /**
   * The XCM incoming execution was Paused
   **/
  | 'EnteredPausedXcmMode'
  /**
   * The XCM incoming execution returned to normal operation
   **/
  | 'NormalXcmOperationResumed';

/**
 * The `Event` enum of this pallet
 **/
export type PalletRandomnessEvent =
  | {
      name: 'RandomnessRequestedBabeEpoch';
      data: {
        id: bigint;
        refundAddress: H160;
        contractAddress: H160;
        fee: bigint;
        gasLimit: bigint;
        numWords: number;
        salt: H256;
        earliestEpoch: bigint;
      };
    }
  | {
      name: 'RandomnessRequestedLocal';
      data: {
        id: bigint;
        refundAddress: H160;
        contractAddress: H160;
        fee: bigint;
        gasLimit: bigint;
        numWords: number;
        salt: H256;
        earliestBlock: number;
      };
    }
  | { name: 'RequestFulfilled'; data: { id: bigint } }
  | { name: 'RequestFeeIncreased'; data: { id: bigint; newFee: bigint } }
  | { name: 'RequestExpirationExecuted'; data: { id: bigint } };

export type FrameSystemLastRuntimeUpgradeInfo = { specVersion: number; specName: string };

export type FrameSystemCodeUpgradeAuthorization = { codeHash: H256; checkVersion: boolean };

export type FrameSystemLimitsBlockWeights = {
  baseBlock: SpWeightsWeightV2Weight;
  maxBlock: SpWeightsWeightV2Weight;
  perClass: FrameSupportDispatchPerDispatchClassWeightsPerClass;
};

export type FrameSupportDispatchPerDispatchClassWeightsPerClass = {
  normal: FrameSystemLimitsWeightsPerClass;
  operational: FrameSystemLimitsWeightsPerClass;
  mandatory: FrameSystemLimitsWeightsPerClass;
};

export type FrameSystemLimitsWeightsPerClass = {
  baseExtrinsic: SpWeightsWeightV2Weight;
  maxExtrinsic?: SpWeightsWeightV2Weight | undefined;
  maxTotal?: SpWeightsWeightV2Weight | undefined;
  reserved?: SpWeightsWeightV2Weight | undefined;
};

export type FrameSystemLimitsBlockLength = { max: FrameSupportDispatchPerDispatchClassU32 };

export type FrameSupportDispatchPerDispatchClassU32 = { normal: number; operational: number; mandatory: number };

export type SpWeightsRuntimeDbWeight = { read: bigint; write: bigint };

/**
 * Error for the System pallet
 **/
export type FrameSystemError =
  /**
   * The name of specification does not match between the current runtime
   * and the new runtime.
   **/
  | 'InvalidSpecName'
  /**
   * The specification version is not allowed to decrease between the current runtime
   * and the new runtime.
   **/
  | 'SpecVersionNeedsToIncrease'
  /**
   * Failed to extract the runtime version from the new runtime.
   *
   * Either calling `Core_version` or decoding `RuntimeVersion` failed.
   **/
  | 'FailedToExtractRuntimeVersion'
  /**
   * Suicide called when the account has non-default composite data.
   **/
  | 'NonDefaultComposite'
  /**
   * There is a non-zero reference count preventing the account from being purged.
   **/
  | 'NonZeroRefCount'
  /**
   * The origin filter prevent the call to be dispatched.
   **/
  | 'CallFiltered'
  /**
   * A multi-block migration is ongoing and prevents the current code from being replaced.
   **/
  | 'MultiBlockMigrationsOngoing'
  /**
   * No upgrade authorized.
   **/
  | 'NothingAuthorized'
  /**
   * The submitted code is not authorized.
   **/
  | 'Unauthorized';

export type CumulusPalletParachainSystemUnincludedSegmentAncestor = {
  usedBandwidth: CumulusPalletParachainSystemUnincludedSegmentUsedBandwidth;
  paraHeadHash?: H256 | undefined;
  consumedGoAheadSignal?: PolkadotPrimitivesV7UpgradeGoAhead | undefined;
};

export type CumulusPalletParachainSystemUnincludedSegmentUsedBandwidth = {
  umpMsgCount: number;
  umpTotalBytes: number;
  hrmpOutgoing: Array<
    [PolkadotParachainPrimitivesPrimitivesId, CumulusPalletParachainSystemUnincludedSegmentHrmpChannelUpdate]
  >;
};

export type CumulusPalletParachainSystemUnincludedSegmentHrmpChannelUpdate = { msgCount: number; totalBytes: number };

export type PolkadotPrimitivesV7UpgradeGoAhead = 'Abort' | 'GoAhead';

export type CumulusPalletParachainSystemUnincludedSegmentSegmentTracker = {
  usedBandwidth: CumulusPalletParachainSystemUnincludedSegmentUsedBandwidth;
  hrmpWatermark?: number | undefined;
  consumedGoAheadSignal?: PolkadotPrimitivesV7UpgradeGoAhead | undefined;
};

export type PolkadotPrimitivesV7UpgradeRestriction = 'Present';

export type CumulusPalletParachainSystemRelayStateSnapshotMessagingStateSnapshot = {
  dmqMqcHead: H256;
  relayDispatchQueueRemainingCapacity: CumulusPalletParachainSystemRelayStateSnapshotRelayDispatchQueueRemainingCapacity;
  ingressChannels: Array<[PolkadotParachainPrimitivesPrimitivesId, PolkadotPrimitivesV7AbridgedHrmpChannel]>;
  egressChannels: Array<[PolkadotParachainPrimitivesPrimitivesId, PolkadotPrimitivesV7AbridgedHrmpChannel]>;
};

export type CumulusPalletParachainSystemRelayStateSnapshotRelayDispatchQueueRemainingCapacity = {
  remainingCount: number;
  remainingSize: number;
};

export type PolkadotPrimitivesV7AbridgedHrmpChannel = {
  maxCapacity: number;
  maxTotalSize: number;
  maxMessageSize: number;
  msgCount: number;
  totalSize: number;
  mqcHead?: H256 | undefined;
};

export type PolkadotPrimitivesV7AbridgedHostConfiguration = {
  maxCodeSize: number;
  maxHeadDataSize: number;
  maxUpwardQueueCount: number;
  maxUpwardQueueSize: number;
  maxUpwardMessageSize: number;
  maxUpwardMessageNumPerCandidate: number;
  hrmpMaxMessageNumPerCandidate: number;
  validationUpgradeCooldown: number;
  validationUpgradeDelay: number;
  asyncBackingParams: PolkadotPrimitivesV7AsyncBackingAsyncBackingParams;
};

export type PolkadotPrimitivesV7AsyncBackingAsyncBackingParams = {
  maxCandidateDepth: number;
  allowedAncestryLen: number;
};

export type CumulusPrimitivesParachainInherentMessageQueueChain = H256;

export type PolkadotCorePrimitivesOutboundHrmpMessage = {
  recipient: PolkadotParachainPrimitivesPrimitivesId;
  data: Bytes;
};

/**
 * The `Error` enum of this pallet.
 **/
export type CumulusPalletParachainSystemError =
  /**
   * Attempt to upgrade validation function while existing upgrade pending.
   **/
  | 'OverlappingUpgrades'
  /**
   * Polkadot currently prohibits this parachain from upgrading its validation function.
   **/
  | 'ProhibitedByPolkadot'
  /**
   * The supplied validation function has compiled into a blob larger than Polkadot is
   * willing to run.
   **/
  | 'TooBig'
  /**
   * The inherent which supplies the validation data did not run this block.
   **/
  | 'ValidationDataNotAvailable'
  /**
   * The inherent which supplies the host configuration did not run this block.
   **/
  | 'HostConfigurationNotAvailable'
  /**
   * No validation function upgrade is currently scheduled.
   **/
  | 'NotScheduled'
  /**
   * No code upgrade has been authorized.
   **/
  | 'NothingAuthorized'
  /**
   * The given code upgrade has not been authorized.
   **/
  | 'Unauthorized';

export type PalletBalancesBalanceLock = { id: FixedBytes<8>; amount: bigint; reasons: PalletBalancesReasons };

export type PalletBalancesReasons = 'Fee' | 'Misc' | 'All';

export type PalletBalancesReserveData = { id: FixedBytes<4>; amount: bigint };

export type FrameSupportTokensMiscIdAmount = { id: MoonbeamRuntimeRuntimeHoldReason; amount: bigint };

export type MoonbeamRuntimeRuntimeHoldReason = { type: 'Preimage'; value: PalletPreimageHoldReason };

export type PalletPreimageHoldReason = 'Preimage';

export type FrameSupportTokensMiscIdAmount002 = { id: []; amount: bigint };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBalancesError =
  /**
   * Vesting balance too high to send value.
   **/
  | 'VestingBalance'
  /**
   * Account liquidity restrictions prevent withdrawal.
   **/
  | 'LiquidityRestrictions'
  /**
   * Balance too low to send value.
   **/
  | 'InsufficientBalance'
  /**
   * Value too low to create account due to existential deposit.
   **/
  | 'ExistentialDeposit'
  /**
   * Transfer/payment would kill account.
   **/
  | 'Expendability'
  /**
   * A vesting schedule already exists for this account.
   **/
  | 'ExistingVestingSchedule'
  /**
   * Beneficiary account must pre-exist.
   **/
  | 'DeadAccount'
  /**
   * Number of named reserves exceed `MaxReserves`.
   **/
  | 'TooManyReserves'
  /**
   * Number of holds exceed `VariantCountOf<T::RuntimeHoldReason>`.
   **/
  | 'TooManyHolds'
  /**
   * Number of freezes exceed `MaxFreezes`.
   **/
  | 'TooManyFreezes'
  /**
   * The issuance cannot be modified since it is already deactivated.
   **/
  | 'IssuanceDeactivated'
  /**
   * The delta cannot be zero.
   **/
  | 'DeltaZero';

export type PalletTransactionPaymentReleases = 'V1Ancient' | 'V2';

export type PalletParachainStakingRoundInfo = { current: number; first: number; length: number; firstSlot: bigint };

export type PalletParachainStakingDelegator = {
  id: AccountId20;
  delegations: PalletParachainStakingSetOrderedSet;
  total: bigint;
  lessTotal: bigint;
  status: PalletParachainStakingDelegatorStatus;
};

export type PalletParachainStakingSetOrderedSet = Array<PalletParachainStakingBond>;

export type PalletParachainStakingBond = { owner: AccountId20; amount: bigint };

export type PalletParachainStakingDelegatorStatus = { type: 'Active' } | { type: 'Leaving'; value: number };

export type PalletParachainStakingCandidateMetadata = {
  bond: bigint;
  delegationCount: number;
  totalCounted: bigint;
  lowestTopDelegationAmount: bigint;
  highestBottomDelegationAmount: bigint;
  lowestBottomDelegationAmount: bigint;
  topCapacity: PalletParachainStakingCapacityStatus;
  bottomCapacity: PalletParachainStakingCapacityStatus;
  request?: PalletParachainStakingCandidateBondLessRequest | undefined;
  status: PalletParachainStakingCollatorStatus;
};

export type PalletParachainStakingCapacityStatus = 'Full' | 'Empty' | 'Partial';

export type PalletParachainStakingCandidateBondLessRequest = { amount: bigint; whenExecutable: number };

export type PalletParachainStakingCollatorStatus =
  | { type: 'Active' }
  | { type: 'Idle' }
  | { type: 'Leaving'; value: number };

export type PalletParachainStakingDelegationRequestsScheduledRequest = {
  delegator: AccountId20;
  whenExecutable: number;
  action: PalletParachainStakingDelegationRequestsDelegationAction;
};

export type PalletParachainStakingAutoCompoundAutoCompoundConfig = { delegator: AccountId20; value: Percent };

export type PalletParachainStakingDelegations = { delegations: Array<PalletParachainStakingBond>; total: bigint };

export type PalletParachainStakingSetBoundedOrderedSet = Array<PalletParachainStakingBond>;

export type PalletParachainStakingCollatorSnapshot = {
  bond: bigint;
  delegations: Array<PalletParachainStakingBondWithAutoCompound>;
  total: bigint;
};

export type PalletParachainStakingBondWithAutoCompound = { owner: AccountId20; amount: bigint; autoCompound: Percent };

export type PalletParachainStakingDelayedPayout = {
  roundIssuance: bigint;
  totalStakingReward: bigint;
  collatorCommission: Perbill;
};

export type PalletParachainStakingInflationInflationInfo = {
  expect: { min: bigint; ideal: bigint; max: bigint };
  annual: { min: Perbill; ideal: Perbill; max: Perbill };
  round: { min: Perbill; ideal: Perbill; max: Perbill };
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletParachainStakingError =
  | 'DelegatorDNE'
  | 'DelegatorDNEinTopNorBottom'
  | 'DelegatorDNEInDelegatorSet'
  | 'CandidateDNE'
  | 'DelegationDNE'
  | 'DelegatorExists'
  | 'CandidateExists'
  | 'CandidateBondBelowMin'
  | 'InsufficientBalance'
  | 'DelegatorBondBelowMin'
  | 'DelegationBelowMin'
  | 'AlreadyOffline'
  | 'AlreadyActive'
  | 'DelegatorAlreadyLeaving'
  | 'DelegatorNotLeaving'
  | 'DelegatorCannotLeaveYet'
  | 'CannotDelegateIfLeaving'
  | 'CandidateAlreadyLeaving'
  | 'CandidateNotLeaving'
  | 'CandidateCannotLeaveYet'
  | 'CannotGoOnlineIfLeaving'
  | 'ExceedMaxDelegationsPerDelegator'
  | 'AlreadyDelegatedCandidate'
  | 'InvalidSchedule'
  | 'CannotSetBelowMin'
  | 'RoundLengthMustBeGreaterThanTotalSelectedCollators'
  | 'NoWritingSameValue'
  | 'TotalInflationDistributionPercentExceeds100'
  | 'TooLowCandidateCountWeightHintJoinCandidates'
  | 'TooLowCandidateCountWeightHintCancelLeaveCandidates'
  | 'TooLowCandidateCountToLeaveCandidates'
  | 'TooLowDelegationCountToDelegate'
  | 'TooLowCandidateDelegationCountToDelegate'
  | 'TooLowCandidateDelegationCountToLeaveCandidates'
  | 'TooLowDelegationCountToLeaveDelegators'
  | 'PendingCandidateRequestsDNE'
  | 'PendingCandidateRequestAlreadyExists'
  | 'PendingCandidateRequestNotDueYet'
  | 'PendingDelegationRequestDNE'
  | 'PendingDelegationRequestAlreadyExists'
  | 'PendingDelegationRequestNotDueYet'
  | 'CannotDelegateLessThanOrEqualToLowestBottomWhenFull'
  | 'PendingDelegationRevoke'
  | 'TooLowDelegationCountToAutoCompound'
  | 'TooLowCandidateAutoCompoundingDelegationCountToAutoCompound'
  | 'TooLowCandidateAutoCompoundingDelegationCountToDelegate'
  | 'TooLowCollatorCountToNotifyAsInactive'
  | 'CannotBeNotifiedAsInactive'
  | 'TooLowCandidateAutoCompoundingDelegationCountToLeaveCandidates'
  | 'TooLowCandidateCountWeightHint'
  | 'TooLowCandidateCountWeightHintGoOffline'
  | 'CandidateLimitReached'
  | 'CannotSetAboveMaxCandidates'
  | 'RemovedCall'
  | 'MarkingOfflineNotEnabled'
  | 'CurrentRoundTooLow';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletAuthorInherentError =
  /**
   * Author already set in block.
   **/
  | 'AuthorAlreadySet'
  /**
   * No AccountId was found to be associated with this author
   **/
  | 'NoAccountId'
  /**
   * The author in the inherent is not an eligible author.
   **/
  | 'CannotBeAuthor';

export type PalletAuthorMappingRegistrationInfo = {
  account: AccountId20;
  deposit: bigint;
  keys: SessionKeysPrimitivesVrfVrfCryptoPublic;
};

/**
 * An error that can occur while executing the mapping pallet's logic.
 **/
export type PalletAuthorMappingError =
  /**
   * The association can't be cleared because it is not found.
   **/
  | 'AssociationNotFound'
  /**
   * The association can't be cleared because it belongs to another account.
   **/
  | 'NotYourAssociation'
  /**
   * This account cannot set an author because it cannon afford the security deposit
   **/
  | 'CannotAffordSecurityDeposit'
  /**
   * The NimbusId in question is already associated and cannot be overwritten
   **/
  | 'AlreadyAssociated'
  /**
   * No existing NimbusId can be found for the account
   **/
  | 'OldAuthorIdNotFound'
  /**
   * Keys have wrong size
   **/
  | 'WrongKeySize'
  /**
   * Failed to decode NimbusId for `set_keys`
   **/
  | 'DecodeNimbusFailed'
  /**
   * Failed to decode T::Keys for `set_keys`
   **/
  | 'DecodeKeysFailed';

export type PalletMoonbeamOrbitersCollatorPoolInfo = {
  orbiters: Array<AccountId20>;
  maybeCurrentOrbiter?: PalletMoonbeamOrbitersCurrentOrbiter | undefined;
  nextOrbiter: number;
};

export type PalletMoonbeamOrbitersCurrentOrbiter = { accountId: AccountId20; removed: boolean };

/**
 * An error that can occur while executing this pallet's extrinsics.
 **/
export type PalletMoonbeamOrbitersError =
  /**
   * The collator is already added in orbiters program.
   **/
  | 'CollatorAlreadyAdded'
  /**
   * This collator is not in orbiters program.
   **/
  | 'CollatorNotFound'
  /**
   * There are already too many orbiters associated with this collator.
   **/
  | 'CollatorPoolTooLarge'
  /**
   * There are more collator pools than the number specified in the parameter.
   **/
  | 'CollatorsPoolCountTooLow'
  /**
   * The minimum deposit required to register as an orbiter has not yet been included in the
   * onchain storage
   **/
  | 'MinOrbiterDepositNotSet'
  /**
   * This orbiter is already associated with this collator.
   **/
  | 'OrbiterAlreadyInPool'
  /**
   * This orbiter has not made a deposit
   **/
  | 'OrbiterDepositNotFound'
  /**
   * This orbiter is not found
   **/
  | 'OrbiterNotFound'
  /**
   * The orbiter is still at least in one pool
   **/
  | 'OrbiterStillInAPool';

export type SpConsensusSlotsSlot = bigint;

/**
 * The `Error` enum of this pallet.
 **/
export type PalletUtilityError =
  /**
   * Too many calls batched.
   **/
  'TooManyCalls';

export type PalletProxyProxyDefinition = { delegate: AccountId20; proxyType: MoonbeamRuntimeProxyType; delay: number };

export type PalletProxyAnnouncement = { real: AccountId20; callHash: H256; height: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletProxyError =
  /**
   * There are too many proxies registered or too many announcements pending.
   **/
  | 'TooMany'
  /**
   * Proxy registration not found.
   **/
  | 'NotFound'
  /**
   * Sender is not a proxy of the account to be proxied.
   **/
  | 'NotProxy'
  /**
   * A call which is incompatible with the proxy type's filter was attempted.
   **/
  | 'Unproxyable'
  /**
   * Account is already a proxy.
   **/
  | 'Duplicate'
  /**
   * Call may not be made by proxy because it may escalate its privileges.
   **/
  | 'NoPermission'
  /**
   * Announcement, if made at all, was made too recently.
   **/
  | 'Unannounced'
  /**
   * Cannot add self as proxy.
   **/
  | 'NoSelfProxy';

/**
 * An error that can occur while executing this pallet's extrinsics.
 **/
export type PalletMaintenanceModeError =
  /**
   * The chain cannot enter maintenance mode because it is already in maintenance mode
   **/
  | 'AlreadyInMaintenanceMode'
  /**
   * The chain cannot resume normal operation because it is not in maintenance mode
   **/
  | 'NotInMaintenanceMode';

export type PalletIdentityRegistration = {
  judgements: Array<[number, PalletIdentityJudgement]>;
  deposit: bigint;
  info: PalletIdentityLegacyIdentityInfo;
};

export type PalletIdentityRegistrarInfo = { account: AccountId20; fee: bigint; fields: bigint };

export type PalletIdentityAuthorityProperties = { suffix: Bytes; allocation: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletIdentityError =
  /**
   * Too many subs-accounts.
   **/
  | 'TooManySubAccounts'
  /**
   * Account isn't found.
   **/
  | 'NotFound'
  /**
   * Account isn't named.
   **/
  | 'NotNamed'
  /**
   * Empty index.
   **/
  | 'EmptyIndex'
  /**
   * Fee is changed.
   **/
  | 'FeeChanged'
  /**
   * No identity found.
   **/
  | 'NoIdentity'
  /**
   * Sticky judgement.
   **/
  | 'StickyJudgement'
  /**
   * Judgement given.
   **/
  | 'JudgementGiven'
  /**
   * Invalid judgement.
   **/
  | 'InvalidJudgement'
  /**
   * The index is invalid.
   **/
  | 'InvalidIndex'
  /**
   * The target is invalid.
   **/
  | 'InvalidTarget'
  /**
   * Maximum amount of registrars reached. Cannot add any more.
   **/
  | 'TooManyRegistrars'
  /**
   * Account ID is already named.
   **/
  | 'AlreadyClaimed'
  /**
   * Sender is not a sub-account.
   **/
  | 'NotSub'
  /**
   * Sub-account isn't owned by sender.
   **/
  | 'NotOwned'
  /**
   * The provided judgement was for a different identity.
   **/
  | 'JudgementForDifferentIdentity'
  /**
   * Error that occurs when there is an issue paying for judgement.
   **/
  | 'JudgementPaymentFailed'
  /**
   * The provided suffix is too long.
   **/
  | 'InvalidSuffix'
  /**
   * The sender does not have permission to issue a username.
   **/
  | 'NotUsernameAuthority'
  /**
   * The authority cannot allocate any more usernames.
   **/
  | 'NoAllocation'
  /**
   * The signature on a username was not valid.
   **/
  | 'InvalidSignature'
  /**
   * Setting this username requires a signature, but none was provided.
   **/
  | 'RequiresSignature'
  /**
   * The username does not meet the requirements.
   **/
  | 'InvalidUsername'
  /**
   * The username is already taken.
   **/
  | 'UsernameTaken'
  /**
   * The requested username does not exist.
   **/
  | 'NoUsername'
  /**
   * The username cannot be forcefully removed because it can still be accepted.
   **/
  | 'NotExpired';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletMigrationsError =
  /**
   * Missing preimage in original democracy storage
   **/
  | 'PreimageMissing'
  /**
   * Provided upper bound is too low.
   **/
  | 'WrongUpperBound'
  /**
   * Preimage is larger than the new max size.
   **/
  | 'PreimageIsTooBig'
  /**
   * Preimage already exists in the new storage.
   **/
  | 'PreimageAlreadyExists';

export type PalletMultisigMultisig = {
  when: PalletMultisigTimepoint;
  deposit: bigint;
  depositor: AccountId20;
  approvals: Array<AccountId20>;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletMultisigError =
  /**
   * Threshold must be 2 or greater.
   **/
  | 'MinimumThreshold'
  /**
   * Call is already approved by this signatory.
   **/
  | 'AlreadyApproved'
  /**
   * Call doesn't need any (more) approvals.
   **/
  | 'NoApprovalsNeeded'
  /**
   * There are too few signatories in the list.
   **/
  | 'TooFewSignatories'
  /**
   * There are too many signatories in the list.
   **/
  | 'TooManySignatories'
  /**
   * The signatories were provided out of order; they should be ordered.
   **/
  | 'SignatoriesOutOfOrder'
  /**
   * The sender was contained in the other signatories; it shouldn't be.
   **/
  | 'SenderInSignatories'
  /**
   * Multisig operation not found when attempting to cancel.
   **/
  | 'NotFound'
  /**
   * Only the account that originally created the multisig is able to cancel it.
   **/
  | 'NotOwner'
  /**
   * No timepoint was given, yet the multisig operation is already underway.
   **/
  | 'NoTimepoint'
  /**
   * A different timepoint was given to the multisig operation that is underway.
   **/
  | 'WrongTimepoint'
  /**
   * A timepoint was given, yet no multisig operation is underway.
   **/
  | 'UnexpectedTimepoint'
  /**
   * The maximum weight information provided was too low.
   **/
  | 'MaxWeightTooLow'
  /**
   * The data to be stored is already stored.
   **/
  | 'AlreadyStored';

export type PalletMoonbeamLazyMigrationsStateMigrationStatus =
  | { type: 'NotStarted' }
  | { type: 'Started'; value: Bytes }
  | { type: 'Error'; value: Bytes }
  | { type: 'Complete' };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletMoonbeamLazyMigrationsError =
  /**
   * The limit cannot be zero
   **/
  | 'LimitCannotBeZero'
  /**
   * There must be at least one address
   **/
  | 'AddressesLengthCannotBeZero'
  /**
   * The contract is not corrupted (Still exist or properly suicided)
   **/
  | 'ContractNotCorrupted'
  /**
   * The contract already have metadata
   **/
  | 'ContractMetadataAlreadySet'
  /**
   * Contract not exist
   **/
  | 'ContractNotExist'
  /**
   * The key lengths exceeds the maximum allowed
   **/
  | 'KeyTooLong';

export type PalletEvmCodeMetadata = { size: bigint; hash: H256 };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletEvmError =
  /**
   * Not enough balance to perform action
   **/
  | 'BalanceLow'
  /**
   * Calculating total fee overflowed
   **/
  | 'FeeOverflow'
  /**
   * Calculating total payment overflowed
   **/
  | 'PaymentOverflow'
  /**
   * Withdraw fee failed
   **/
  | 'WithdrawFailed'
  /**
   * Gas price is too low.
   **/
  | 'GasPriceTooLow'
  /**
   * Nonce is invalid
   **/
  | 'InvalidNonce'
  /**
   * Gas limit is too low.
   **/
  | 'GasLimitTooLow'
  /**
   * Gas limit is too high.
   **/
  | 'GasLimitTooHigh'
  /**
   * The chain id is invalid.
   **/
  | 'InvalidChainId'
  /**
   * the signature is invalid.
   **/
  | 'InvalidSignature'
  /**
   * EVM reentrancy
   **/
  | 'Reentrancy'
  /**
   * EIP-3607,
   **/
  | 'TransactionMustComeFromEOA'
  /**
   * Undefined error.
   **/
  | 'Undefined';

export type FpRpcTransactionStatus = {
  transactionHash: H256;
  transactionIndex: number;
  from: H160;
  to?: H160 | undefined;
  contractAddress?: H160 | undefined;
  logs: Array<EthereumLog>;
  logsBloom: EthbloomBloom;
};

export type EthbloomBloom = FixedBytes<256>;

export type EthereumReceiptReceiptV3 =
  | { type: 'Legacy'; value: EthereumReceiptEip658ReceiptData }
  | { type: 'Eip2930'; value: EthereumReceiptEip658ReceiptData }
  | { type: 'Eip1559'; value: EthereumReceiptEip658ReceiptData };

export type EthereumReceiptEip658ReceiptData = {
  statusCode: number;
  usedGas: U256;
  logsBloom: EthbloomBloom;
  logs: Array<EthereumLog>;
};

export type EthereumBlock = {
  header: EthereumHeader;
  transactions: Array<EthereumTransactionTransactionV2>;
  ommers: Array<EthereumHeader>;
};

export type EthereumHeader = {
  parentHash: H256;
  ommersHash: H256;
  beneficiary: H160;
  stateRoot: H256;
  transactionsRoot: H256;
  receiptsRoot: H256;
  logsBloom: EthbloomBloom;
  difficulty: U256;
  number: U256;
  gasLimit: U256;
  gasUsed: U256;
  timestamp: bigint;
  extraData: Bytes;
  mixHash: H256;
  nonce: EthereumTypesHashH64;
};

export type EthereumTypesHashH64 = FixedBytes<8>;

/**
 * The `Error` enum of this pallet.
 **/
export type PalletEthereumError =
  /**
   * Signature is invalid.
   **/
  | 'InvalidSignature'
  /**
   * Pre-log is present, therefore transact is not allowed.
   **/
  | 'PreLogExists';

export type PalletSchedulerScheduled = {
  maybeId?: FixedBytes<32> | undefined;
  priority: number;
  call: FrameSupportPreimagesBounded;
  maybePeriodic?: [number, number] | undefined;
  origin: MoonbeamRuntimeOriginCaller;
};

export type PalletSchedulerRetryConfig = { totalRetries: number; remaining: number; period: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletSchedulerError =
  /**
   * Failed to schedule a call
   **/
  | 'FailedToSchedule'
  /**
   * Cannot find the scheduled call.
   **/
  | 'NotFound'
  /**
   * Given target block number is in the past.
   **/
  | 'TargetBlockNumberInPast'
  /**
   * Reschedule failed because it does not change scheduled time.
   **/
  | 'RescheduleNoChange'
  /**
   * Attempt to use a non-named function on a named task.
   **/
  | 'Named';

export type PalletPreimageOldRequestStatus =
  | { type: 'Unrequested'; value: { deposit: [AccountId20, bigint]; len: number } }
  | {
      type: 'Requested';
      value: { deposit?: [AccountId20, bigint] | undefined; count: number; len?: number | undefined };
    };

export type PalletPreimageRequestStatus =
  | { type: 'Unrequested'; value: { ticket: [AccountId20, FrameSupportTokensFungibleHoldConsideration]; len: number } }
  | {
      type: 'Requested';
      value: {
        maybeTicket?: [AccountId20, FrameSupportTokensFungibleHoldConsideration] | undefined;
        count: number;
        maybeLen?: number | undefined;
      };
    };

export type FrameSupportTokensFungibleHoldConsideration = bigint;

/**
 * The `Error` enum of this pallet.
 **/
export type PalletPreimageError =
  /**
   * Preimage is too large to store on-chain.
   **/
  | 'TooBig'
  /**
   * Preimage has already been noted on-chain.
   **/
  | 'AlreadyNoted'
  /**
   * The user is not authorized to perform this action.
   **/
  | 'NotAuthorized'
  /**
   * The preimage cannot be removed since it has not yet been noted.
   **/
  | 'NotNoted'
  /**
   * A preimage may not be removed when there are outstanding requests.
   **/
  | 'Requested'
  /**
   * The preimage request cannot be removed since no outstanding requests exist.
   **/
  | 'NotRequested'
  /**
   * More than `MAX_HASH_UPGRADE_BULK_COUNT` hashes were requested to be upgraded at once.
   **/
  | 'TooMany'
  /**
   * Too few hashes were requested to be upgraded (i.e. zero).
   **/
  | 'TooFew'
  /**
   * No ticket with a cost was returned by [`Config::Consideration`] to store the preimage.
   **/
  | 'NoCost';

export type PalletConvictionVotingVoteVoting =
  | { type: 'Casting'; value: PalletConvictionVotingVoteCasting }
  | { type: 'Delegating'; value: PalletConvictionVotingVoteDelegating };

export type PalletConvictionVotingVoteCasting = {
  votes: Array<[number, PalletConvictionVotingVoteAccountVote]>;
  delegations: PalletConvictionVotingDelegations;
  prior: PalletConvictionVotingVotePriorLock;
};

export type PalletConvictionVotingDelegations = { votes: bigint; capital: bigint };

export type PalletConvictionVotingVotePriorLock = [number, bigint];

export type PalletConvictionVotingVoteDelegating = {
  balance: bigint;
  target: AccountId20;
  conviction: PalletConvictionVotingConviction;
  delegations: PalletConvictionVotingDelegations;
  prior: PalletConvictionVotingVotePriorLock;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletConvictionVotingError =
  /**
   * Poll is not ongoing.
   **/
  | 'NotOngoing'
  /**
   * The given account did not vote on the poll.
   **/
  | 'NotVoter'
  /**
   * The actor has no permission to conduct the action.
   **/
  | 'NoPermission'
  /**
   * The actor has no permission to conduct the action right now but will do in the future.
   **/
  | 'NoPermissionYet'
  /**
   * The account is already delegating.
   **/
  | 'AlreadyDelegating'
  /**
   * The account currently has votes attached to it and the operation cannot succeed until
   * these are removed through `remove_vote`.
   **/
  | 'AlreadyVoting'
  /**
   * Too high a balance was provided that the account cannot afford.
   **/
  | 'InsufficientFunds'
  /**
   * The account is not currently delegating.
   **/
  | 'NotDelegating'
  /**
   * Delegation to oneself makes no sense.
   **/
  | 'Nonsense'
  /**
   * Maximum number of votes reached.
   **/
  | 'MaxVotesReached'
  /**
   * The class must be supplied since it is not easily determinable from the state.
   **/
  | 'ClassNeeded'
  /**
   * The class ID supplied is invalid.
   **/
  | 'BadClass';

export type PalletReferendaReferendumInfo =
  | { type: 'Ongoing'; value: PalletReferendaReferendumStatus }
  | { type: 'Approved'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { type: 'Rejected'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { type: 'Cancelled'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { type: 'TimedOut'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { type: 'Killed'; value: number };

export type PalletReferendaReferendumStatus = {
  track: number;
  origin: MoonbeamRuntimeOriginCaller;
  proposal: FrameSupportPreimagesBounded;
  enactment: FrameSupportScheduleDispatchTime;
  submitted: number;
  submissionDeposit: PalletReferendaDeposit;
  decisionDeposit?: PalletReferendaDeposit | undefined;
  deciding?: PalletReferendaDecidingStatus | undefined;
  tally: PalletConvictionVotingTally;
  inQueue: boolean;
  alarm?: [number, [number, number]] | undefined;
};

export type PalletReferendaDeposit = { who: AccountId20; amount: bigint };

export type PalletReferendaDecidingStatus = { since: number; confirming?: number | undefined };

export type PalletReferendaTrackInfo = {
  name: string;
  maxDeciding: number;
  decisionDeposit: bigint;
  preparePeriod: number;
  decisionPeriod: number;
  confirmPeriod: number;
  minEnactmentPeriod: number;
  minApproval: PalletReferendaCurve;
  minSupport: PalletReferendaCurve;
};

export type PalletReferendaCurve =
  | { type: 'LinearDecreasing'; value: { length: Perbill; floor: Perbill; ceil: Perbill } }
  | { type: 'SteppedDecreasing'; value: { begin: Perbill; end: Perbill; step: Perbill; period: Perbill } }
  | { type: 'Reciprocal'; value: { factor: FixedI64; xOffset: FixedI64; yOffset: FixedI64 } };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletReferendaError =
  /**
   * Referendum is not ongoing.
   **/
  | 'NotOngoing'
  /**
   * Referendum's decision deposit is already paid.
   **/
  | 'HasDeposit'
  /**
   * The track identifier given was invalid.
   **/
  | 'BadTrack'
  /**
   * There are already a full complement of referenda in progress for this track.
   **/
  | 'Full'
  /**
   * The queue of the track is empty.
   **/
  | 'QueueEmpty'
  /**
   * The referendum index provided is invalid in this context.
   **/
  | 'BadReferendum'
  /**
   * There was nothing to do in the advancement.
   **/
  | 'NothingToDo'
  /**
   * No track exists for the proposal origin.
   **/
  | 'NoTrack'
  /**
   * Any deposit cannot be refunded until after the decision is over.
   **/
  | 'Unfinished'
  /**
   * The deposit refunder is not the depositor.
   **/
  | 'NoPermission'
  /**
   * The deposit cannot be refunded since none was made.
   **/
  | 'NoDeposit'
  /**
   * The referendum status is invalid for this operation.
   **/
  | 'BadStatus'
  /**
   * The preimage does not exist.
   **/
  | 'PreimageNotExist'
  /**
   * The preimage is stored with a different length than the one provided.
   **/
  | 'PreimageStoredWithDifferentLength';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletWhitelistError =
  /**
   * The preimage of the call hash could not be loaded.
   **/
  | 'UnavailablePreImage'
  /**
   * The call could not be decoded.
   **/
  | 'UndecodableCall'
  /**
   * The weight of the decoded call was higher than the witness.
   **/
  | 'InvalidCallWeightWitness'
  /**
   * The call was not whitelisted.
   **/
  | 'CallIsNotWhitelisted'
  /**
   * The call was already whitelisted; No-Op.
   **/
  | 'CallAlreadyWhitelisted';

export type PalletCollectiveVotes = {
  index: number;
  threshold: number;
  ayes: Array<AccountId20>;
  nays: Array<AccountId20>;
  end: number;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletCollectiveError =
  /**
   * Account is not a member
   **/
  | 'NotMember'
  /**
   * Duplicate proposals not allowed
   **/
  | 'DuplicateProposal'
  /**
   * Proposal must exist
   **/
  | 'ProposalMissing'
  /**
   * Mismatched index
   **/
  | 'WrongIndex'
  /**
   * Duplicate vote ignored
   **/
  | 'DuplicateVote'
  /**
   * Members are already initialized!
   **/
  | 'AlreadyInitialized'
  /**
   * The close call was made too early, before the end of the voting.
   **/
  | 'TooEarly'
  /**
   * There can only be a maximum of `MaxProposals` active proposals.
   **/
  | 'TooManyProposals'
  /**
   * The given weight bound for the proposal was too low.
   **/
  | 'WrongProposalWeight'
  /**
   * The given length bound for the proposal was too low.
   **/
  | 'WrongProposalLength'
  /**
   * Prime account is not a member
   **/
  | 'PrimeAccountNotMember';

export type PalletTreasuryProposal = { proposer: AccountId20; value: bigint; beneficiary: AccountId20; bond: bigint };

export type PalletTreasurySpendStatus = {
  assetKind: [];
  amount: bigint;
  beneficiary: AccountId20;
  validFrom: number;
  expireAt: number;
  status: PalletTreasuryPaymentState;
};

export type PalletTreasuryPaymentState =
  | { type: 'Pending' }
  | { type: 'Attempted'; value: { id: [] } }
  | { type: 'Failed' };

export type FrameSupportPalletId = FixedBytes<8>;

/**
 * Error for the treasury pallet.
 **/
export type PalletTreasuryError =
  /**
   * No proposal, bounty or spend at that index.
   **/
  | 'InvalidIndex'
  /**
   * Too many approvals in the queue.
   **/
  | 'TooManyApprovals'
  /**
   * The spend origin is valid but the amount it is allowed to spend is lower than the
   * amount to be spent.
   **/
  | 'InsufficientPermission'
  /**
   * Proposal has not been approved.
   **/
  | 'ProposalNotApproved'
  /**
   * The balance of the asset kind is not convertible to the balance of the native asset.
   **/
  | 'FailedToConvertBalance'
  /**
   * The spend has expired and cannot be claimed.
   **/
  | 'SpendExpired'
  /**
   * The spend is not yet eligible for payout.
   **/
  | 'EarlyPayout'
  /**
   * The payment has already been attempted.
   **/
  | 'AlreadyAttempted'
  /**
   * There was some issue with the mechanism of payment.
   **/
  | 'PayoutError'
  /**
   * The payout was not yet attempted/claimed.
   **/
  | 'NotAttempted'
  /**
   * The payment has neither failed nor succeeded yet.
   **/
  | 'Inconclusive';

export type PalletCrowdloanRewardsRewardInfo = {
  totalReward: bigint;
  claimedReward: bigint;
  contributedRelayAddresses: Array<FixedBytes<32>>;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletCrowdloanRewardsError =
  /**
   * User trying to associate a native identity with a relay chain identity for posterior
   * reward claiming provided an already associated relay chain identity
   **/
  | 'AlreadyAssociated'
  /**
   * Trying to introduce a batch that goes beyond the limits of the funds
   **/
  | 'BatchBeyondFundPot'
  /**
   * First claim already done
   **/
  | 'FirstClaimAlreadyDone'
  /**
   * The contribution is not high enough to be eligible for rewards
   **/
  | 'RewardNotHighEnough'
  /**
   * User trying to associate a native identity with a relay chain identity for posterior
   * reward claiming provided a wrong signature
   **/
  | 'InvalidClaimSignature'
  /**
   * User trying to claim the first free reward provided the wrong signature
   **/
  | 'InvalidFreeClaimSignature'
  /**
   * User trying to claim an award did not have an claim associated with it. This may mean
   * they did not contribute to the crowdloan, or they have not yet associated a native id
   * with their contribution
   **/
  | 'NoAssociatedClaim'
  /**
   * User trying to claim rewards has already claimed all rewards associated with its
   * identity and contribution
   **/
  | 'RewardsAlreadyClaimed'
  /**
   * Reward vec has already been initialized
   **/
  | 'RewardVecAlreadyInitialized'
  /**
   * Reward vec has not yet been fully initialized
   **/
  | 'RewardVecNotFullyInitializedYet'
  /**
   * Rewards should match funds of the pallet
   **/
  | 'RewardsDoNotMatchFund'
  /**
   * Initialize_reward_vec received too many contributors
   **/
  | 'TooManyContributors'
  /**
   * Provided vesting period is not valid
   **/
  | 'VestingPeriodNonValid'
  /**
   * User provided a signature from a non-contributor relay account
   **/
  | 'NonContributedAddressProvided'
  /**
   * User submitted an unsifficient number of proofs to change the reward address
   **/
  | 'InsufficientNumberOfValidProofs';

export type CumulusPalletXcmpQueueOutboundChannelDetails = {
  recipient: PolkadotParachainPrimitivesPrimitivesId;
  state: CumulusPalletXcmpQueueOutboundState;
  signalsExist: boolean;
  firstIndex: number;
  lastIndex: number;
};

export type CumulusPalletXcmpQueueOutboundState = 'Ok' | 'Suspended';

export type CumulusPalletXcmpQueueQueueConfigData = {
  suspendThreshold: number;
  dropThreshold: number;
  resumeThreshold: number;
};

/**
 * The `Error` enum of this pallet.
 **/
export type CumulusPalletXcmpQueueError =
  /**
   * Setting the queue config failed since one of its values was invalid.
   **/
  | 'BadQueueConfig'
  /**
   * The execution is already suspended.
   **/
  | 'AlreadySuspended'
  /**
   * The execution is already resumed.
   **/
  | 'AlreadyResumed'
  /**
   * There are too many active outbound channels.
   **/
  | 'TooManyActiveOutboundChannels'
  /**
   * The message is too big.
   **/
  | 'TooBig';

export type PalletXcmQueryStatus =
  | {
      type: 'Pending';
      value: {
        responder: XcmVersionedLocation;
        maybeMatchQuerier?: XcmVersionedLocation | undefined;
        maybeNotify?: [number, number] | undefined;
        timeout: number;
      };
    }
  | { type: 'VersionNotifier'; value: { origin: XcmVersionedLocation; isActive: boolean } }
  | { type: 'Ready'; value: { response: XcmVersionedResponse; at: number } };

export type XcmVersionedResponse =
  | { type: 'V2'; value: XcmV2Response }
  | { type: 'V3'; value: XcmV3Response }
  | { type: 'V4'; value: StagingXcmV4Response };

export type PalletXcmVersionMigrationStage =
  | { type: 'MigrateSupportedVersion' }
  | { type: 'MigrateVersionNotifiers' }
  | { type: 'NotifyCurrentTargets'; value?: Bytes | undefined }
  | { type: 'MigrateAndNotifyOldTargets' };

export type PalletXcmRemoteLockedFungibleRecord = {
  amount: bigint;
  owner: XcmVersionedLocation;
  locker: XcmVersionedLocation;
  consumers: Array<[[], bigint]>;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletXcmError =
  /**
   * The desired destination was unreachable, generally because there is a no way of routing
   * to it.
   **/
  | 'Unreachable'
  /**
   * There was some other issue (i.e. not to do with routing) in sending the message.
   * Perhaps a lack of space for buffering the message.
   **/
  | 'SendFailure'
  /**
   * The message execution fails the filter.
   **/
  | 'Filtered'
  /**
   * The message's weight could not be determined.
   **/
  | 'UnweighableMessage'
  /**
   * The destination `Location` provided cannot be inverted.
   **/
  | 'DestinationNotInvertible'
  /**
   * The assets to be sent are empty.
   **/
  | 'Empty'
  /**
   * Could not re-anchor the assets to declare the fees for the destination chain.
   **/
  | 'CannotReanchor'
  /**
   * Too many assets have been attempted for transfer.
   **/
  | 'TooManyAssets'
  /**
   * Origin is invalid for sending.
   **/
  | 'InvalidOrigin'
  /**
   * The version of the `Versioned` value used is not able to be interpreted.
   **/
  | 'BadVersion'
  /**
   * The given location could not be used (e.g. because it cannot be expressed in the
   * desired version of XCM).
   **/
  | 'BadLocation'
  /**
   * The referenced subscription could not be found.
   **/
  | 'NoSubscription'
  /**
   * The location is invalid since it already has a subscription from us.
   **/
  | 'AlreadySubscribed'
  /**
   * Could not check-out the assets for teleportation to the destination chain.
   **/
  | 'CannotCheckOutTeleport'
  /**
   * The owner does not own (all) of the asset that they wish to do the operation on.
   **/
  | 'LowBalance'
  /**
   * The asset owner has too many locks on the asset.
   **/
  | 'TooManyLocks'
  /**
   * The given account is not an identifiable sovereign account for any location.
   **/
  | 'AccountNotSovereign'
  /**
   * The operation required fees to be paid which the initiator could not meet.
   **/
  | 'FeesNotMet'
  /**
   * A remote lock with the corresponding data could not be found.
   **/
  | 'LockNotFound'
  /**
   * The unlock operation cannot succeed because there are still consumers of the lock.
   **/
  | 'InUse'
  /**
   * Invalid asset, reserve chain could not be determined for it.
   **/
  | 'InvalidAssetUnknownReserve'
  /**
   * Invalid asset, do not support remote asset reserves with different fees reserves.
   **/
  | 'InvalidAssetUnsupportedReserve'
  /**
   * Too many assets with different reserve locations have been attempted for transfer.
   **/
  | 'TooManyReserves'
  /**
   * Local XCM execution incomplete.
   **/
  | 'LocalExecutionIncomplete';

export type PalletAssetsAssetDetails = {
  owner: AccountId20;
  issuer: AccountId20;
  admin: AccountId20;
  freezer: AccountId20;
  supply: bigint;
  deposit: bigint;
  minBalance: bigint;
  isSufficient: boolean;
  accounts: number;
  sufficients: number;
  approvals: number;
  status: PalletAssetsAssetStatus;
};

export type PalletAssetsAssetStatus = 'Live' | 'Frozen' | 'Destroying';

export type PalletAssetsAssetAccount = {
  balance: bigint;
  status: PalletAssetsAccountStatus;
  reason: PalletAssetsExistenceReason;
  extra: [];
};

export type PalletAssetsAccountStatus = 'Liquid' | 'Frozen' | 'Blocked';

export type PalletAssetsExistenceReason =
  | { type: 'Consumer' }
  | { type: 'Sufficient' }
  | { type: 'DepositHeld'; value: bigint }
  | { type: 'DepositRefunded' }
  | { type: 'DepositFrom'; value: [AccountId20, bigint] };

export type PalletAssetsApproval = { amount: bigint; deposit: bigint };

export type PalletAssetsAssetMetadata = {
  deposit: bigint;
  name: Bytes;
  symbol: Bytes;
  decimals: number;
  isFrozen: boolean;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletAssetsError =
  /**
   * Account balance must be greater than or equal to the transfer amount.
   **/
  | 'BalanceLow'
  /**
   * The account to alter does not exist.
   **/
  | 'NoAccount'
  /**
   * The signing account has no permission to do the operation.
   **/
  | 'NoPermission'
  /**
   * The given asset ID is unknown.
   **/
  | 'Unknown'
  /**
   * The origin account is frozen.
   **/
  | 'Frozen'
  /**
   * The asset ID is already taken.
   **/
  | 'InUse'
  /**
   * Invalid witness data given.
   **/
  | 'BadWitness'
  /**
   * Minimum balance should be non-zero.
   **/
  | 'MinBalanceZero'
  /**
   * Unable to increment the consumer reference counters on the account. Either no provider
   * reference exists to allow a non-zero balance of a non-self-sufficient asset, or one
   * fewer then the maximum number of consumers has been reached.
   **/
  | 'UnavailableConsumer'
  /**
   * Invalid metadata given.
   **/
  | 'BadMetadata'
  /**
   * No approval exists that would allow the transfer.
   **/
  | 'Unapproved'
  /**
   * The source account would not survive the transfer and it needs to stay alive.
   **/
  | 'WouldDie'
  /**
   * The asset-account already exists.
   **/
  | 'AlreadyExists'
  /**
   * The asset-account doesn't have an associated deposit.
   **/
  | 'NoDeposit'
  /**
   * The operation would result in funds being burned.
   **/
  | 'WouldBurn'
  /**
   * The asset is a live asset and is actively being used. Usually emit for operations such
   * as `start_destroy` which require the asset to be in a destroying state.
   **/
  | 'LiveAsset'
  /**
   * The asset is not live, and likely being destroyed.
   **/
  | 'AssetNotLive'
  /**
   * The asset status is not the expected status.
   **/
  | 'IncorrectStatus'
  /**
   * The asset should be frozen before the given operation.
   **/
  | 'NotFrozen'
  /**
   * Callback action resulted in error
   **/
  | 'CallbackFailed'
  /**
   * The asset ID must be equal to the [`NextAssetId`].
   **/
  | 'BadAssetId';

/**
 * An error that can occur while executing the mapping pallet's logic.
 **/
export type PalletAssetManagerError =
  | 'ErrorCreatingAsset'
  | 'AssetAlreadyExists'
  | 'AssetDoesNotExist'
  | 'TooLowNumAssetsWeightHint'
  | 'LocalAssetLimitReached'
  | 'ErrorDestroyingAsset'
  | 'NotSufficientDeposit'
  | 'NonExistentLocalAsset';

export type PalletXcmTransactorRelayIndicesRelayChainIndices = {
  staking: number;
  utility: number;
  hrmp: number;
  bond: number;
  bondExtra: number;
  unbond: number;
  withdrawUnbonded: number;
  validate: number;
  nominate: number;
  chill: number;
  setPayee: number;
  setController: number;
  rebond: number;
  asDerivative: number;
  initOpenChannel: number;
  acceptOpenChannel: number;
  closeChannel: number;
  cancelOpenRequest: number;
};

/**
 * An error that can occur while executing the mapping pallet's logic.
 **/
export type PalletXcmTransactorError =
  | 'IndexAlreadyClaimed'
  | 'UnclaimedIndex'
  | 'NotOwner'
  | 'UnweighableMessage'
  | 'CannotReanchor'
  | 'AssetHasNoReserve'
  | 'InvalidDest'
  | 'NotCrossChainTransfer'
  | 'AssetIsNotReserveInDestination'
  | 'DestinationNotInvertible'
  | 'ErrorDelivering'
  | 'DispatchWeightBiggerThanTotalWeight'
  | 'WeightOverflow'
  | 'AmountOverflow'
  | 'TransactorInfoNotSet'
  | 'NotCrossChainTransferableCurrency'
  | 'XcmExecuteError'
  | 'BadVersion'
  | 'MaxWeightTransactReached'
  | 'UnableToWithdrawAsset'
  | 'FeePerSecondNotSet'
  | 'SignedTransactNotAllowedForDestination'
  | 'FailedMultiLocationToJunction'
  | 'HrmpHandlerNotImplemented'
  | 'TooMuchFeeUsed'
  | 'ErrorValidating'
  | 'RefundNotSupportedWithTransactInfo';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletEthereumXcmError =
  /**
   * Xcm to Ethereum execution is suspended
   **/
  'EthereumXcmExecutionSuspended';

export type PalletMessageQueueBookState = {
  begin: number;
  end: number;
  count: number;
  readyNeighbours?: PalletMessageQueueNeighbours | undefined;
  messageCount: bigint;
  size: bigint;
};

export type PalletMessageQueueNeighbours = {
  prev: CumulusPrimitivesCoreAggregateMessageOrigin;
  next: CumulusPrimitivesCoreAggregateMessageOrigin;
};

export type PalletMessageQueuePage = {
  remaining: number;
  remainingSize: number;
  firstIndex: number;
  first: number;
  last: number;
  heap: Bytes;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletMessageQueueError =
  /**
   * Page is not reapable because it has items remaining to be processed and is not old
   * enough.
   **/
  | 'NotReapable'
  /**
   * Page to be reaped does not exist.
   **/
  | 'NoPage'
  /**
   * The referenced message could not be found.
   **/
  | 'NoMessage'
  /**
   * The message was already processed and cannot be processed again.
   **/
  | 'AlreadyProcessed'
  /**
   * The message is queued for future execution.
   **/
  | 'Queued'
  /**
   * There is temporarily not enough weight to continue servicing messages.
   **/
  | 'InsufficientWeight'
  /**
   * This message is temporarily unprocessable.
   *
   * Such errors are expected, but not guaranteed, to resolve themselves eventually through
   * retrying.
   **/
  | 'TemporarilyUnprocessable'
  /**
   * The queue is paused and no message can be executed from it.
   *
   * This can change at any time and may resolve in the future by re-trying.
   **/
  | 'QueuePaused'
  /**
   * Another call is in progress and needs to finish before this call can happen.
   **/
  | 'RecursiveDisallowed';

export type PalletMoonbeamForeignAssetsAssetStatus = 'Active' | 'FrozenXcmDepositAllowed' | 'FrozenXcmDepositForbidden';

/**
 * An error that can occur while executing the mapping pallet's logic.
 **/
export type PalletMoonbeamForeignAssetsError =
  | 'AssetAlreadyExists'
  | 'AssetAlreadyFrozen'
  | 'AssetDoesNotExist'
  | 'AssetIdFiltered'
  | 'AssetNotFrozen'
  | 'CorruptedStorageOrphanLocation'
  | 'Erc20ContractCreationFail'
  | 'EvmCallPauseFail'
  | 'EvmCallUnpauseFail'
  | 'EvmInternalError'
  | 'InvalidSymbol'
  | 'InvalidTokenName'
  | 'LocationAlreadyExists'
  | 'TooManyForeignAssets';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletXcmWeightTraderError =
  /**
   * The given asset was already added
   **/
  | 'AssetAlreadyAdded'
  /**
   * The given asset was already paused
   **/
  | 'AssetAlreadyPaused'
  /**
   * The given asset was not found
   **/
  | 'AssetNotFound'
  /**
   * The given asset is not paused
   **/
  | 'AssetNotPaused'
  /**
   * XCM location filtered
   **/
  | 'XcmLocationFiltered'
  /**
   * The relative price cannot be zero
   **/
  | 'PriceCannotBeZero';

export type PalletEmergencyParaXcmXcmMode = 'Normal' | 'Paused';

/**
 * An error that can occur while executing this pallet's extrinsics.
 **/
export type PalletEmergencyParaXcmError =
  /**
   * The current XCM Mode is not Paused
   **/
  'NotInPausedMode';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletPrecompileBenchmarksError = 'BenchmarkError';

export type PalletRandomnessRequestState = { request: PalletRandomnessRequest; deposit: bigint };

export type PalletRandomnessRequest = {
  refundAddress: H160;
  contractAddress: H160;
  fee: bigint;
  gasLimit: bigint;
  numWords: number;
  salt: H256;
  info: PalletRandomnessRequestInfo;
};

export type PalletRandomnessRequestInfo =
  | { type: 'BabeEpoch'; value: [bigint, bigint] }
  | { type: 'Local'; value: [number, number] };

export type PalletRandomnessRequestType = { type: 'BabeEpoch'; value: bigint } | { type: 'Local'; value: number };

export type PalletRandomnessRandomnessResult = { randomness?: H256 | undefined; requestCount: bigint };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletRandomnessError =
  | 'RequestCounterOverflowed'
  | 'RequestFeeOverflowed'
  | 'MustRequestAtLeastOneWord'
  | 'CannotRequestMoreWordsThanMax'
  | 'CannotRequestRandomnessAfterMaxDelay'
  | 'CannotRequestRandomnessBeforeMinDelay'
  | 'RequestDNE'
  | 'RequestCannotYetBeFulfilled'
  | 'OnlyRequesterCanIncreaseFee'
  | 'RequestHasNotExpired'
  | 'RandomnessResultDNE'
  | 'RandomnessResultNotFilled';

export type FrameSystemExtensionsCheckNonZeroSender = {};

export type FrameSystemExtensionsCheckSpecVersion = {};

export type FrameSystemExtensionsCheckTxVersion = {};

export type FrameSystemExtensionsCheckGenesis = {};

export type FrameSystemExtensionsCheckMortality = Era;

export type FrameSystemExtensionsCheckNonce = number;

export type FrameSystemExtensionsCheckWeight = {};

export type PalletTransactionPaymentChargeTransactionPayment = bigint;

export type FrameMetadataHashExtensionCheckMetadataHash = { mode: FrameMetadataHashExtensionMode };

export type FrameMetadataHashExtensionMode = 'Disabled' | 'Enabled';

export type CumulusPrimitivesStorageWeightReclaimStorageWeightReclaim = {};

export type MoonbeamRuntimeRuntime = {};

export type SpRuntimeTransactionValidityTransactionSource = 'InBlock' | 'Local' | 'External';

export type FpSelfContainedUncheckedExtrinsic = UncheckedExtrinsic;

export type SpRuntimeTransactionValidityValidTransaction = {
  priority: bigint;
  requires: Array<Bytes>;
  provides: Array<Bytes>;
  longevity: bigint;
  propagate: boolean;
};

export type SpRuntimeTransactionValidityTransactionValidityError =
  | { type: 'Invalid'; value: SpRuntimeTransactionValidityInvalidTransaction }
  | { type: 'Unknown'; value: SpRuntimeTransactionValidityUnknownTransaction };

export type SpRuntimeTransactionValidityInvalidTransaction =
  | { type: 'Call' }
  | { type: 'Payment' }
  | { type: 'Future' }
  | { type: 'Stale' }
  | { type: 'BadProof' }
  | { type: 'AncientBirthBlock' }
  | { type: 'ExhaustsResources' }
  | { type: 'Custom'; value: number }
  | { type: 'BadMandatory' }
  | { type: 'MandatoryValidation' }
  | { type: 'BadSigner' };

export type SpRuntimeTransactionValidityUnknownTransaction =
  | { type: 'CannotLookup' }
  | { type: 'NoUnsignedValidator' }
  | { type: 'Custom'; value: number };

export type SpRuntimeBlock = { header: Header; extrinsics: Array<FpSelfContainedUncheckedExtrinsic> };

export type SpRuntimeExtrinsicInclusionMode = 'AllExtrinsics' | 'OnlyInherents';

export type SpCoreOpaqueMetadata = Bytes;

export type SpInherentsInherentData = { data: Array<[FixedBytes<8>, Bytes]> };

export type SpInherentsCheckInherentsResult = { okay: boolean; fatalError: boolean; errors: SpInherentsInherentData };

export type SpCoreCryptoKeyTypeId = FixedBytes<4>;

export type MoonbeamRpcPrimitivesTxpoolTxPoolResponse = {
  ready: Array<EthereumTransactionTransactionV2>;
  future: Array<EthereumTransactionTransactionV2>;
};

export type EvmBackendBasic = { balance: U256; nonce: U256 };

export type FpEvmExecutionInfoV2 = {
  exitReason: EvmCoreErrorExitReason;
  value: Bytes;
  usedGas: FpEvmUsedGas;
  weightInfo?: FpEvmWeightInfo | undefined;
  logs: Array<EthereumLog>;
};

export type FpEvmUsedGas = { standard: U256; effective: U256 };

export type FpEvmWeightInfo = {
  refTimeLimit?: bigint | undefined;
  proofSizeLimit?: bigint | undefined;
  refTimeUsage?: bigint | undefined;
  proofSizeUsage?: bigint | undefined;
};

export type FpEvmExecutionInfoV2H160 = {
  exitReason: EvmCoreErrorExitReason;
  value: H160;
  usedGas: FpEvmUsedGas;
  weightInfo?: FpEvmWeightInfo | undefined;
  logs: Array<EthereumLog>;
};

export type PalletTransactionPaymentRuntimeDispatchInfo = {
  weight: SpWeightsWeightV2Weight;
  class: FrameSupportDispatchDispatchClass;
  partialFee: bigint;
};

export type PalletTransactionPaymentFeeDetails = {
  inclusionFee?: PalletTransactionPaymentInclusionFee | undefined;
  tip: bigint;
};

export type PalletTransactionPaymentInclusionFee = { baseFee: bigint; lenFee: bigint; adjustedWeightFee: bigint };

export type CumulusPrimitivesCoreCollationInfo = {
  upwardMessages: Array<Bytes>;
  horizontalMessages: Array<PolkadotCorePrimitivesOutboundHrmpMessage>;
  newValidationCode?: PolkadotParachainPrimitivesPrimitivesValidationCode | undefined;
  processedDownwardMessages: number;
  hrmpWatermark: number;
  headData: PolkadotParachainPrimitivesPrimitivesHeadData;
};

export type PolkadotParachainPrimitivesPrimitivesValidationCode = Bytes;

export type XcmRuntimeApisFeesError =
  | 'Unimplemented'
  | 'VersionedConversionFailed'
  | 'WeightNotComputable'
  | 'UnhandledXcmVersion'
  | 'AssetNotFound'
  | 'Unroutable';

export type XcmRuntimeApisDryRunCallDryRunEffects = {
  executionResult: Result<FrameSupportDispatchPostDispatchInfo, SpRuntimeDispatchErrorWithPostInfo>;
  emittedEvents: Array<MoonbeamRuntimeRuntimeEvent>;
  localXcm?: XcmVersionedXcm | undefined;
  forwardedXcms: Array<[XcmVersionedLocation, Array<XcmVersionedXcm>]>;
};

export type XcmRuntimeApisDryRunError = 'Unimplemented' | 'VersionedConversionFailed';

export type XcmRuntimeApisDryRunXcmDryRunEffects = {
  executionResult: StagingXcmV4TraitsOutcome;
  emittedEvents: Array<MoonbeamRuntimeRuntimeEvent>;
  forwardedXcms: Array<[XcmVersionedLocation, Array<XcmVersionedXcm>]>;
};

export type XcmRuntimeApisConversionsError = 'Unsupported' | 'VersionedConversionFailed';

export type MoonbeamRuntimeRuntimeError =
  | { pallet: 'System'; palletError: FrameSystemError }
  | { pallet: 'ParachainSystem'; palletError: CumulusPalletParachainSystemError }
  | { pallet: 'Balances'; palletError: PalletBalancesError }
  | { pallet: 'ParachainStaking'; palletError: PalletParachainStakingError }
  | { pallet: 'AuthorInherent'; palletError: PalletAuthorInherentError }
  | { pallet: 'AuthorMapping'; palletError: PalletAuthorMappingError }
  | { pallet: 'MoonbeamOrbiters'; palletError: PalletMoonbeamOrbitersError }
  | { pallet: 'Utility'; palletError: PalletUtilityError }
  | { pallet: 'Proxy'; palletError: PalletProxyError }
  | { pallet: 'MaintenanceMode'; palletError: PalletMaintenanceModeError }
  | { pallet: 'Identity'; palletError: PalletIdentityError }
  | { pallet: 'Migrations'; palletError: PalletMigrationsError }
  | { pallet: 'Multisig'; palletError: PalletMultisigError }
  | { pallet: 'MoonbeamLazyMigrations'; palletError: PalletMoonbeamLazyMigrationsError }
  | { pallet: 'Evm'; palletError: PalletEvmError }
  | { pallet: 'Ethereum'; palletError: PalletEthereumError }
  | { pallet: 'Scheduler'; palletError: PalletSchedulerError }
  | { pallet: 'Preimage'; palletError: PalletPreimageError }
  | { pallet: 'ConvictionVoting'; palletError: PalletConvictionVotingError }
  | { pallet: 'Referenda'; palletError: PalletReferendaError }
  | { pallet: 'Whitelist'; palletError: PalletWhitelistError }
  | { pallet: 'TreasuryCouncilCollective'; palletError: PalletCollectiveError }
  | { pallet: 'OpenTechCommitteeCollective'; palletError: PalletCollectiveError }
  | { pallet: 'Treasury'; palletError: PalletTreasuryError }
  | { pallet: 'CrowdloanRewards'; palletError: PalletCrowdloanRewardsError }
  | { pallet: 'XcmpQueue'; palletError: CumulusPalletXcmpQueueError }
  | { pallet: 'PolkadotXcm'; palletError: PalletXcmError }
  | { pallet: 'Assets'; palletError: PalletAssetsError }
  | { pallet: 'AssetManager'; palletError: PalletAssetManagerError }
  | { pallet: 'XcmTransactor'; palletError: PalletXcmTransactorError }
  | { pallet: 'EthereumXcm'; palletError: PalletEthereumXcmError }
  | { pallet: 'MessageQueue'; palletError: PalletMessageQueueError }
  | { pallet: 'EvmForeignAssets'; palletError: PalletMoonbeamForeignAssetsError }
  | { pallet: 'XcmWeightTrader'; palletError: PalletXcmWeightTraderError }
  | { pallet: 'EmergencyParaXcm'; palletError: PalletEmergencyParaXcmError }
  | { pallet: 'PrecompileBenchmarks'; palletError: PalletPrecompileBenchmarksError }
  | { pallet: 'Randomness'; palletError: PalletRandomnessError };
