// Generated by dedot cli

import type {
  GenericChainTx,
  GenericTxCall,
  ISubmittableExtrinsic,
  ISubmittableResult,
  IRuntimeTxCall,
  RpcVersion,
  RpcV2,
  ISubmittableExtrinsicLegacy,
} from 'dedot/types';
import type { MultiAddressLike, Extrinsic, BytesLike, H256, AccountId32Like, FixedBytes, Data } from 'dedot/codecs';
import type {
  PeopleWestendRuntimeRuntimeCallLike,
  SpRuntimeMultiSignature,
  FrameSystemEventRecord,
  CumulusPrimitivesParachainInherentParachainInherentData,
  PalletBalancesAdjustmentDirection,
  PeopleWestendRuntimeSessionKeys,
  XcmVersionedLocation,
  XcmVersionedXcm,
  XcmVersionedAssets,
  SpWeightsWeightV2Weight,
  StagingXcmV4Location,
  XcmV3WeightLimit,
  StagingXcmExecutorAssetTransferTransferType,
  XcmVersionedAssetId,
  CumulusPrimitivesCoreAggregateMessageOrigin,
  PeopleWestendRuntimeOriginCaller,
  PalletMultisigTimepoint,
  PeopleWestendRuntimeProxyType,
  PeopleWestendRuntimePeopleIdentityInfo,
  PalletIdentityJudgement,
} from './types';

export type ChainSubmittableExtrinsic<
  Rv extends RpcVersion,
  T extends IRuntimeTxCall = PeopleWestendRuntimeRuntimeCallLike,
> = Extrinsic<MultiAddressLike, T, SpRuntimeMultiSignature, any[]> &
  (Rv extends RpcV2
    ? ISubmittableExtrinsic<ISubmittableResult<FrameSystemEventRecord>>
    : ISubmittableExtrinsicLegacy<ISubmittableResult<FrameSystemEventRecord>>);

export type TxCall<Rv extends RpcVersion> = (...args: any[]) => ChainSubmittableExtrinsic<Rv>;

export interface ChainTx<Rv extends RpcVersion> extends GenericChainTx<Rv, TxCall<Rv>> {
  /**
   * Pallet `System`'s transaction calls
   **/
  system: {
    /**
     * Make some on-chain remark.
     *
     * Can be executed by every `origin`.
     *
     * @param {BytesLike} remark
     **/
    remark: GenericTxCall<
      Rv,
      (remark: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'Remark';
            params: { remark: BytesLike };
          };
        }
      >
    >;

    /**
     * Set the number of pages in the WebAssembly environment's heap.
     *
     * @param {bigint} pages
     **/
    setHeapPages: GenericTxCall<
      Rv,
      (pages: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'SetHeapPages';
            params: { pages: bigint };
          };
        }
      >
    >;

    /**
     * Set the new runtime code.
     *
     * @param {BytesLike} code
     **/
    setCode: GenericTxCall<
      Rv,
      (code: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'SetCode';
            params: { code: BytesLike };
          };
        }
      >
    >;

    /**
     * Set the new runtime code without doing any checks of the given `code`.
     *
     * Note that runtime upgrades will not run if this is called with a not-increasing spec
     * version!
     *
     * @param {BytesLike} code
     **/
    setCodeWithoutChecks: GenericTxCall<
      Rv,
      (code: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'SetCodeWithoutChecks';
            params: { code: BytesLike };
          };
        }
      >
    >;

    /**
     * Set some items of storage.
     *
     * @param {Array<[BytesLike, BytesLike]>} items
     **/
    setStorage: GenericTxCall<
      Rv,
      (items: Array<[BytesLike, BytesLike]>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'SetStorage';
            params: { items: Array<[BytesLike, BytesLike]> };
          };
        }
      >
    >;

    /**
     * Kill some items from storage.
     *
     * @param {Array<BytesLike>} keys
     **/
    killStorage: GenericTxCall<
      Rv,
      (keys: Array<BytesLike>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'KillStorage';
            params: { keys: Array<BytesLike> };
          };
        }
      >
    >;

    /**
     * Kill all storage items with a key that starts with the given prefix.
     *
     * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
     * the prefix we are removing to accurately calculate the weight of this function.
     *
     * @param {BytesLike} prefix
     * @param {number} subkeys
     **/
    killPrefix: GenericTxCall<
      Rv,
      (
        prefix: BytesLike,
        subkeys: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'KillPrefix';
            params: { prefix: BytesLike; subkeys: number };
          };
        }
      >
    >;

    /**
     * Make some on-chain remark and emit event.
     *
     * @param {BytesLike} remark
     **/
    remarkWithEvent: GenericTxCall<
      Rv,
      (remark: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'RemarkWithEvent';
            params: { remark: BytesLike };
          };
        }
      >
    >;

    /**
     * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
     * later.
     *
     * This call requires Root origin.
     *
     * @param {H256} codeHash
     **/
    authorizeUpgrade: GenericTxCall<
      Rv,
      (codeHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'AuthorizeUpgrade';
            params: { codeHash: H256 };
          };
        }
      >
    >;

    /**
     * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
     * later.
     *
     * WARNING: This authorizes an upgrade that will take place without any safety checks, for
     * example that the spec name remains the same and that the version number increases. Not
     * recommended for normal use. Use `authorize_upgrade` instead.
     *
     * This call requires Root origin.
     *
     * @param {H256} codeHash
     **/
    authorizeUpgradeWithoutChecks: GenericTxCall<
      Rv,
      (codeHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'AuthorizeUpgradeWithoutChecks';
            params: { codeHash: H256 };
          };
        }
      >
    >;

    /**
     * Provide the preimage (runtime binary) `code` for an upgrade that has been authorized.
     *
     * If the authorization required a version check, this call will ensure the spec name
     * remains unchanged and that the spec version has increased.
     *
     * Depending on the runtime's `OnSetCode` configuration, this function may directly apply
     * the new `code` in the same block or attempt to schedule the upgrade.
     *
     * All origins are allowed.
     *
     * @param {BytesLike} code
     **/
    applyAuthorizedUpgrade: GenericTxCall<
      Rv,
      (code: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'ApplyAuthorizedUpgrade';
            params: { code: BytesLike };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `ParachainSystem`'s transaction calls
   **/
  parachainSystem: {
    /**
     * Set the current validation data.
     *
     * This should be invoked exactly once per block. It will panic at the finalization
     * phase if the call was not invoked.
     *
     * The dispatch origin for this call must be `Inherent`
     *
     * As a side effect, this function upgrades the current validation function
     * if the appropriate time has come.
     *
     * @param {CumulusPrimitivesParachainInherentParachainInherentData} data
     **/
    setValidationData: GenericTxCall<
      Rv,
      (data: CumulusPrimitivesParachainInherentParachainInherentData) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainSystem';
          palletCall: {
            name: 'SetValidationData';
            params: { data: CumulusPrimitivesParachainInherentParachainInherentData };
          };
        }
      >
    >;

    /**
     *
     * @param {BytesLike} message
     **/
    sudoSendUpwardMessage: GenericTxCall<
      Rv,
      (message: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainSystem';
          palletCall: {
            name: 'SudoSendUpwardMessage';
            params: { message: BytesLike };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Timestamp`'s transaction calls
   **/
  timestamp: {
    /**
     * Set the current time.
     *
     * This call should be invoked exactly once per block. It will panic at the finalization
     * phase, if this call hasn't been invoked by that time.
     *
     * The timestamp should be greater than the previous one by the amount specified by
     * [`Config::MinimumPeriod`].
     *
     * The dispatch origin for this call must be _None_.
     *
     * This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware
     * that changing the complexity of this call could result exhausting the resources in a
     * block to execute any other calls.
     *
     * ## Complexity
     * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
     * - 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in
     * `on_finalize`)
     * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
     *
     * @param {bigint} now
     **/
    set: GenericTxCall<
      Rv,
      (now: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Timestamp';
          palletCall: {
            name: 'Set';
            params: { now: bigint };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `ParachainInfo`'s transaction calls
   **/
  parachainInfo: {
    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Balances`'s transaction calls
   **/
  balances: {
    /**
     * Transfer some liquid free balance to another account.
     *
     * `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
     * If the sender's account is below the existential deposit as a result
     * of the transfer, the account will be reaped.
     *
     * The dispatch origin for this call must be `Signed` by the transactor.
     *
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     **/
    transferAllowDeath: GenericTxCall<
      Rv,
      (
        dest: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'TransferAllowDeath';
            params: { dest: MultiAddressLike; value: bigint };
          };
        }
      >
    >;

    /**
     * Exactly as `transfer_allow_death`, except the origin must be root and the source account
     * may be specified.
     *
     * @param {MultiAddressLike} source
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     **/
    forceTransfer: GenericTxCall<
      Rv,
      (
        source: MultiAddressLike,
        dest: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'ForceTransfer';
            params: { source: MultiAddressLike; dest: MultiAddressLike; value: bigint };
          };
        }
      >
    >;

    /**
     * Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
     * kill the origin account.
     *
     * 99% of the time you want [`transfer_allow_death`] instead.
     *
     * [`transfer_allow_death`]: struct.Pallet.html#method.transfer
     *
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     **/
    transferKeepAlive: GenericTxCall<
      Rv,
      (
        dest: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'TransferKeepAlive';
            params: { dest: MultiAddressLike; value: bigint };
          };
        }
      >
    >;

    /**
     * Transfer the entire transferable balance from the caller account.
     *
     * NOTE: This function only attempts to transfer _transferable_ balances. This means that
     * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
     * transferred by this function. To ensure that this function results in a killed account,
     * you might need to prepare the account by removing any reference counters, storage
     * deposits, etc...
     *
     * The dispatch origin of this call must be Signed.
     *
     * - `dest`: The recipient of the transfer.
     * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
     * of the funds the account has, causing the sender account to be killed (false), or
     * transfer everything except at least the existential deposit, which will guarantee to
     * keep the sender account alive (true).
     *
     * @param {MultiAddressLike} dest
     * @param {boolean} keepAlive
     **/
    transferAll: GenericTxCall<
      Rv,
      (
        dest: MultiAddressLike,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'TransferAll';
            params: { dest: MultiAddressLike; keepAlive: boolean };
          };
        }
      >
    >;

    /**
     * Unreserve some balance from a user by force.
     *
     * Can only be called by ROOT.
     *
     * @param {MultiAddressLike} who
     * @param {bigint} amount
     **/
    forceUnreserve: GenericTxCall<
      Rv,
      (
        who: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'ForceUnreserve';
            params: { who: MultiAddressLike; amount: bigint };
          };
        }
      >
    >;

    /**
     * Upgrade a specified account.
     *
     * - `origin`: Must be `Signed`.
     * - `who`: The account to be upgraded.
     *
     * This will waive the transaction fee if at least all but 10% of the accounts needed to
     * be upgraded. (We let some not have to be upgraded just in order to allow for the
     * possibility of churn).
     *
     * @param {Array<AccountId32Like>} who
     **/
    upgradeAccounts: GenericTxCall<
      Rv,
      (who: Array<AccountId32Like>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'UpgradeAccounts';
            params: { who: Array<AccountId32Like> };
          };
        }
      >
    >;

    /**
     * Set the regular balance of a given account.
     *
     * The dispatch origin for this call is `root`.
     *
     * @param {MultiAddressLike} who
     * @param {bigint} newFree
     **/
    forceSetBalance: GenericTxCall<
      Rv,
      (
        who: MultiAddressLike,
        newFree: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'ForceSetBalance';
            params: { who: MultiAddressLike; newFree: bigint };
          };
        }
      >
    >;

    /**
     * Adjust the total issuance in a saturating way.
     *
     * Can only be called by root and always needs a positive `delta`.
     *
     * # Example
     *
     * @param {PalletBalancesAdjustmentDirection} direction
     * @param {bigint} delta
     **/
    forceAdjustTotalIssuance: GenericTxCall<
      Rv,
      (
        direction: PalletBalancesAdjustmentDirection,
        delta: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'ForceAdjustTotalIssuance';
            params: { direction: PalletBalancesAdjustmentDirection; delta: bigint };
          };
        }
      >
    >;

    /**
     * Burn the specified liquid free balance from the origin account.
     *
     * If the origin's account ends up below the existential deposit as a result
     * of the burn and `keep_alive` is false, the account will be reaped.
     *
     * Unlike sending funds to a _burn_ address, which merely makes the funds inaccessible,
     * this `burn` operation will reduce total issuance by the amount _burned_.
     *
     * @param {bigint} value
     * @param {boolean} keepAlive
     **/
    burn: GenericTxCall<
      Rv,
      (
        value: bigint,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'Burn';
            params: { value: bigint; keepAlive: boolean };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `CollatorSelection`'s transaction calls
   **/
  collatorSelection: {
    /**
     * Set the list of invulnerable (fixed) collators. These collators must do some
     * preparation, namely to have registered session keys.
     *
     * The call will remove any accounts that have not registered keys from the set. That is,
     * it is non-atomic; the caller accepts all `AccountId`s passed in `new` _individually_ as
     * acceptable Invulnerables, and is not proposing a _set_ of new Invulnerables.
     *
     * This call does not maintain mutual exclusivity of `Invulnerables` and `Candidates`. It
     * is recommended to use a batch of `add_invulnerable` and `remove_invulnerable` instead. A
     * `batch_all` can also be used to enforce atomicity. If any candidates are included in
     * `new`, they should be removed with `remove_invulnerable_candidate` after execution.
     *
     * Must be called by the `UpdateOrigin`.
     *
     * @param {Array<AccountId32Like>} new_
     **/
    setInvulnerables: GenericTxCall<
      Rv,
      (new_: Array<AccountId32Like>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'CollatorSelection';
          palletCall: {
            name: 'SetInvulnerables';
            params: { new: Array<AccountId32Like> };
          };
        }
      >
    >;

    /**
     * Set the ideal number of non-invulnerable collators. If lowering this number, then the
     * number of running collators could be higher than this figure. Aside from that edge case,
     * there should be no other way to have more candidates than the desired number.
     *
     * The origin for this call must be the `UpdateOrigin`.
     *
     * @param {number} max
     **/
    setDesiredCandidates: GenericTxCall<
      Rv,
      (max: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'CollatorSelection';
          palletCall: {
            name: 'SetDesiredCandidates';
            params: { max: number };
          };
        }
      >
    >;

    /**
     * Set the candidacy bond amount.
     *
     * If the candidacy bond is increased by this call, all current candidates which have a
     * deposit lower than the new bond will be kicked from the list and get their deposits
     * back.
     *
     * The origin for this call must be the `UpdateOrigin`.
     *
     * @param {bigint} bond
     **/
    setCandidacyBond: GenericTxCall<
      Rv,
      (bond: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'CollatorSelection';
          palletCall: {
            name: 'SetCandidacyBond';
            params: { bond: bigint };
          };
        }
      >
    >;

    /**
     * Register this account as a collator candidate. The account must (a) already have
     * registered session keys and (b) be able to reserve the `CandidacyBond`.
     *
     * This call is not available to `Invulnerable` collators.
     *
     **/
    registerAsCandidate: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'CollatorSelection';
          palletCall: {
            name: 'RegisterAsCandidate';
          };
        }
      >
    >;

    /**
     * Deregister `origin` as a collator candidate. Note that the collator can only leave on
     * session change. The `CandidacyBond` will be unreserved immediately.
     *
     * This call will fail if the total number of candidates would drop below
     * `MinEligibleCollators`.
     *
     **/
    leaveIntent: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'CollatorSelection';
          palletCall: {
            name: 'LeaveIntent';
          };
        }
      >
    >;

    /**
     * Add a new account `who` to the list of `Invulnerables` collators. `who` must have
     * registered session keys. If `who` is a candidate, they will be removed.
     *
     * The origin for this call must be the `UpdateOrigin`.
     *
     * @param {AccountId32Like} who
     **/
    addInvulnerable: GenericTxCall<
      Rv,
      (who: AccountId32Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'CollatorSelection';
          palletCall: {
            name: 'AddInvulnerable';
            params: { who: AccountId32Like };
          };
        }
      >
    >;

    /**
     * Remove an account `who` from the list of `Invulnerables` collators. `Invulnerables` must
     * be sorted.
     *
     * The origin for this call must be the `UpdateOrigin`.
     *
     * @param {AccountId32Like} who
     **/
    removeInvulnerable: GenericTxCall<
      Rv,
      (who: AccountId32Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'CollatorSelection';
          palletCall: {
            name: 'RemoveInvulnerable';
            params: { who: AccountId32Like };
          };
        }
      >
    >;

    /**
     * Update the candidacy bond of collator candidate `origin` to a new amount `new_deposit`.
     *
     * Setting a `new_deposit` that is lower than the current deposit while `origin` is
     * occupying a top-`DesiredCandidates` slot is not allowed.
     *
     * This call will fail if `origin` is not a collator candidate, the updated bond is lower
     * than the minimum candidacy bond, and/or the amount cannot be reserved.
     *
     * @param {bigint} newDeposit
     **/
    updateBond: GenericTxCall<
      Rv,
      (newDeposit: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'CollatorSelection';
          palletCall: {
            name: 'UpdateBond';
            params: { newDeposit: bigint };
          };
        }
      >
    >;

    /**
     * The caller `origin` replaces a candidate `target` in the collator candidate list by
     * reserving `deposit`. The amount `deposit` reserved by the caller must be greater than
     * the existing bond of the target it is trying to replace.
     *
     * This call will fail if the caller is already a collator candidate or invulnerable, the
     * caller does not have registered session keys, the target is not a collator candidate,
     * and/or the `deposit` amount cannot be reserved.
     *
     * @param {bigint} deposit
     * @param {AccountId32Like} target
     **/
    takeCandidateSlot: GenericTxCall<
      Rv,
      (
        deposit: bigint,
        target: AccountId32Like,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'CollatorSelection';
          palletCall: {
            name: 'TakeCandidateSlot';
            params: { deposit: bigint; target: AccountId32Like };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Session`'s transaction calls
   **/
  session: {
    /**
     * Sets the session key(s) of the function caller to `keys`.
     * Allows an account to set its session key prior to becoming a validator.
     * This doesn't take effect until the next session.
     *
     * The dispatch origin of this function must be signed.
     *
     * ## Complexity
     * - `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is
     * fixed.
     *
     * @param {PeopleWestendRuntimeSessionKeys} keys
     * @param {BytesLike} proof
     **/
    setKeys: GenericTxCall<
      Rv,
      (
        keys: PeopleWestendRuntimeSessionKeys,
        proof: BytesLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Session';
          palletCall: {
            name: 'SetKeys';
            params: { keys: PeopleWestendRuntimeSessionKeys; proof: BytesLike };
          };
        }
      >
    >;

    /**
     * Removes any session key(s) of the function caller.
     *
     * This doesn't take effect until the next session.
     *
     * The dispatch origin of this function must be Signed and the account must be either be
     * convertible to a validator ID using the chain's typical addressing system (this usually
     * means being a controller account) or directly convertible into a validator ID (which
     * usually means being a stash account).
     *
     * ## Complexity
     * - `O(1)` in number of key types. Actual cost depends on the number of length of
     * `T::Keys::key_ids()` which is fixed.
     *
     **/
    purgeKeys: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Session';
          palletCall: {
            name: 'PurgeKeys';
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `XcmpQueue`'s transaction calls
   **/
  xcmpQueue: {
    /**
     * Suspends all XCM executions for the XCMP queue, regardless of the sender's origin.
     *
     * - `origin`: Must pass `ControllerOrigin`.
     *
     **/
    suspendXcmExecution: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmpQueue';
          palletCall: {
            name: 'SuspendXcmExecution';
          };
        }
      >
    >;

    /**
     * Resumes all XCM executions for the XCMP queue.
     *
     * Note that this function doesn't change the status of the in/out bound channels.
     *
     * - `origin`: Must pass `ControllerOrigin`.
     *
     **/
    resumeXcmExecution: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmpQueue';
          palletCall: {
            name: 'ResumeXcmExecution';
          };
        }
      >
    >;

    /**
     * Overwrites the number of pages which must be in the queue for the other side to be
     * told to suspend their sending.
     *
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.suspend_value`
     *
     * @param {number} new_
     **/
    updateSuspendThreshold: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmpQueue';
          palletCall: {
            name: 'UpdateSuspendThreshold';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Overwrites the number of pages which must be in the queue after which we drop any
     * further messages from the channel.
     *
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.drop_threshold`
     *
     * @param {number} new_
     **/
    updateDropThreshold: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmpQueue';
          palletCall: {
            name: 'UpdateDropThreshold';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Overwrites the number of pages which the queue must be reduced to before it signals
     * that message sending may recommence after it has been suspended.
     *
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.resume_threshold`
     *
     * @param {number} new_
     **/
    updateResumeThreshold: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmpQueue';
          palletCall: {
            name: 'UpdateResumeThreshold';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `PolkadotXcm`'s transaction calls
   **/
  polkadotXcm: {
    /**
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedXcm} message
     **/
    send: GenericTxCall<
      Rv,
      (
        dest: XcmVersionedLocation,
        message: XcmVersionedXcm,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'Send';
            params: { dest: XcmVersionedLocation; message: XcmVersionedXcm };
          };
        }
      >
    >;

    /**
     * Teleport some assets from the local chain to some destination chain.
     *
     * **This function is deprecated: Use `limited_teleport_assets` instead.**
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` chain.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedLocation} beneficiary
     * @param {XcmVersionedAssets} assets
     * @param {number} feeAssetItem
     **/
    teleportAssets: GenericTxCall<
      Rv,
      (
        dest: XcmVersionedLocation,
        beneficiary: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        feeAssetItem: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'TeleportAssets';
            params: {
              dest: XcmVersionedLocation;
              beneficiary: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              feeAssetItem: number;
            };
          };
        }
      >
    >;

    /**
     * Transfer some assets from the local chain to the destination chain through their local,
     * destination or remote reserve.
     *
     * `assets` must have same reserve location and may not be teleportable to `dest`.
     * - `assets` have local reserve: transfer assets to sovereign account of destination
     * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
     * assets to `beneficiary`.
     * - `assets` have destination reserve: burn local assets and forward a notification to
     * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
     * deposit them to `beneficiary`.
     * - `assets` have remote reserve: burn local assets, forward XCM to reserve chain to move
     * reserves from this chain's SA to `dest` chain's SA, and forward another XCM to `dest`
     * to mint and deposit reserve-based assets to `beneficiary`.
     *
     * **This function is deprecated: Use `limited_reserve_transfer_assets` instead.**
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` (and possibly reserve) chains.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedLocation} beneficiary
     * @param {XcmVersionedAssets} assets
     * @param {number} feeAssetItem
     **/
    reserveTransferAssets: GenericTxCall<
      Rv,
      (
        dest: XcmVersionedLocation,
        beneficiary: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        feeAssetItem: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'ReserveTransferAssets';
            params: {
              dest: XcmVersionedLocation;
              beneficiary: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              feeAssetItem: number;
            };
          };
        }
      >
    >;

    /**
     * Execute an XCM message from a local, signed, origin.
     *
     * An event is deposited indicating whether `msg` could be executed completely or only
     * partially.
     *
     * No more than `max_weight` will be used in its attempted execution. If this is less than
     * the maximum amount of weight that the message could take to be executed, then no
     * execution attempt will be made.
     *
     * @param {XcmVersionedXcm} message
     * @param {SpWeightsWeightV2Weight} maxWeight
     **/
    execute: GenericTxCall<
      Rv,
      (
        message: XcmVersionedXcm,
        maxWeight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'Execute';
            params: { message: XcmVersionedXcm; maxWeight: SpWeightsWeightV2Weight };
          };
        }
      >
    >;

    /**
     * Extoll that a particular destination can be communicated with through a particular
     * version of XCM.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The destination that is being described.
     * - `xcm_version`: The latest version of XCM that `location` supports.
     *
     * @param {StagingXcmV4Location} location
     * @param {number} version
     **/
    forceXcmVersion: GenericTxCall<
      Rv,
      (
        location: StagingXcmV4Location,
        version: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'ForceXcmVersion';
            params: { location: StagingXcmV4Location; version: number };
          };
        }
      >
    >;

    /**
     * Set a safe XCM version (the version that XCM should be encoded with if the most recent
     * version a destination can accept is unknown).
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `maybe_xcm_version`: The default XCM encoding version, or `None` to disable.
     *
     * @param {number | undefined} maybeXcmVersion
     **/
    forceDefaultXcmVersion: GenericTxCall<
      Rv,
      (maybeXcmVersion: number | undefined) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'ForceDefaultXcmVersion';
            params: { maybeXcmVersion: number | undefined };
          };
        }
      >
    >;

    /**
     * Ask a location to notify us regarding their XCM version and any changes to it.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The location to which we should subscribe for XCM version notifications.
     *
     * @param {XcmVersionedLocation} location
     **/
    forceSubscribeVersionNotify: GenericTxCall<
      Rv,
      (location: XcmVersionedLocation) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'ForceSubscribeVersionNotify';
            params: { location: XcmVersionedLocation };
          };
        }
      >
    >;

    /**
     * Require that a particular destination should no longer notify us regarding any XCM
     * version changes.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The location to which we are currently subscribed for XCM version
     * notifications which we no longer desire.
     *
     * @param {XcmVersionedLocation} location
     **/
    forceUnsubscribeVersionNotify: GenericTxCall<
      Rv,
      (location: XcmVersionedLocation) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'ForceUnsubscribeVersionNotify';
            params: { location: XcmVersionedLocation };
          };
        }
      >
    >;

    /**
     * Transfer some assets from the local chain to the destination chain through their local,
     * destination or remote reserve.
     *
     * `assets` must have same reserve location and may not be teleportable to `dest`.
     * - `assets` have local reserve: transfer assets to sovereign account of destination
     * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
     * assets to `beneficiary`.
     * - `assets` have destination reserve: burn local assets and forward a notification to
     * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
     * deposit them to `beneficiary`.
     * - `assets` have remote reserve: burn local assets, forward XCM to reserve chain to move
     * reserves from this chain's SA to `dest` chain's SA, and forward another XCM to `dest`
     * to mint and deposit reserve-based assets to `beneficiary`.
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the sent assets may be
     * at risk.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` (and possibly reserve) chains.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedLocation} beneficiary
     * @param {XcmVersionedAssets} assets
     * @param {number} feeAssetItem
     * @param {XcmV3WeightLimit} weightLimit
     **/
    limitedReserveTransferAssets: GenericTxCall<
      Rv,
      (
        dest: XcmVersionedLocation,
        beneficiary: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        feeAssetItem: number,
        weightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'LimitedReserveTransferAssets';
            params: {
              dest: XcmVersionedLocation;
              beneficiary: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              feeAssetItem: number;
              weightLimit: XcmV3WeightLimit;
            };
          };
        }
      >
    >;

    /**
     * Teleport some assets from the local chain to some destination chain.
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the sent assets may be
     * at risk.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` chain.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedLocation} beneficiary
     * @param {XcmVersionedAssets} assets
     * @param {number} feeAssetItem
     * @param {XcmV3WeightLimit} weightLimit
     **/
    limitedTeleportAssets: GenericTxCall<
      Rv,
      (
        dest: XcmVersionedLocation,
        beneficiary: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        feeAssetItem: number,
        weightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'LimitedTeleportAssets';
            params: {
              dest: XcmVersionedLocation;
              beneficiary: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              feeAssetItem: number;
              weightLimit: XcmV3WeightLimit;
            };
          };
        }
      >
    >;

    /**
     * Set or unset the global suspension state of the XCM executor.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `suspended`: `true` to suspend, `false` to resume.
     *
     * @param {boolean} suspended
     **/
    forceSuspension: GenericTxCall<
      Rv,
      (suspended: boolean) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'ForceSuspension';
            params: { suspended: boolean };
          };
        }
      >
    >;

    /**
     * Transfer some assets from the local chain to the destination chain through their local,
     * destination or remote reserve, or through teleports.
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item` (hence referred to as `fees`), up to enough to pay for
     * `weight_limit` of weight. If more weight is needed than `weight_limit`, then the
     * operation will fail and the sent assets may be at risk.
     *
     * `assets` (excluding `fees`) must have same reserve location or otherwise be teleportable
     * to `dest`, no limitations imposed on `fees`.
     * - for local reserve: transfer assets to sovereign account of destination chain and
     * forward a notification XCM to `dest` to mint and deposit reserve-based assets to
     * `beneficiary`.
     * - for destination reserve: burn local assets and forward a notification to `dest` chain
     * to withdraw the reserve assets from this chain's sovereign account and deposit them
     * to `beneficiary`.
     * - for remote reserve: burn local assets, forward XCM to reserve chain to move reserves
     * from this chain's SA to `dest` chain's SA, and forward another XCM to `dest` to mint
     * and deposit reserve-based assets to `beneficiary`.
     * - for teleports: burn local assets and forward XCM to `dest` chain to mint/teleport
     * assets and deposit them to `beneficiary`.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent,
     * Parachain(..))` to send from parachain to parachain, or `X1(Parachain(..))` to send
     * from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` (and possibly reserve) chains.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedLocation} beneficiary
     * @param {XcmVersionedAssets} assets
     * @param {number} feeAssetItem
     * @param {XcmV3WeightLimit} weightLimit
     **/
    transferAssets: GenericTxCall<
      Rv,
      (
        dest: XcmVersionedLocation,
        beneficiary: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        feeAssetItem: number,
        weightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'TransferAssets';
            params: {
              dest: XcmVersionedLocation;
              beneficiary: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              feeAssetItem: number;
              weightLimit: XcmV3WeightLimit;
            };
          };
        }
      >
    >;

    /**
     * Claims assets trapped on this pallet because of leftover assets during XCM execution.
     *
     * - `origin`: Anyone can call this extrinsic.
     * - `assets`: The exact assets that were trapped. Use the version to specify what version
     * was the latest when they were trapped.
     * - `beneficiary`: The location/account where the claimed assets will be deposited.
     *
     * @param {XcmVersionedAssets} assets
     * @param {XcmVersionedLocation} beneficiary
     **/
    claimAssets: GenericTxCall<
      Rv,
      (
        assets: XcmVersionedAssets,
        beneficiary: XcmVersionedLocation,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'ClaimAssets';
            params: { assets: XcmVersionedAssets; beneficiary: XcmVersionedLocation };
          };
        }
      >
    >;

    /**
     * Transfer assets from the local chain to the destination chain using explicit transfer
     * types for assets and fees.
     *
     * `assets` must have same reserve location or may be teleportable to `dest`. Caller must
     * provide the `assets_transfer_type` to be used for `assets`:
     * - `TransferType::LocalReserve`: transfer assets to sovereign account of destination
     * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
     * assets to `beneficiary`.
     * - `TransferType::DestinationReserve`: burn local assets and forward a notification to
     * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
     * deposit them to `beneficiary`.
     * - `TransferType::RemoteReserve(reserve)`: burn local assets, forward XCM to `reserve`
     * chain to move reserves from this chain's SA to `dest` chain's SA, and forward another
     * XCM to `dest` to mint and deposit reserve-based assets to `beneficiary`. Typically
     * the remote `reserve` is Asset Hub.
     * - `TransferType::Teleport`: burn local assets and forward XCM to `dest` chain to
     * mint/teleport assets and deposit them to `beneficiary`.
     *
     * On the destination chain, as well as any intermediary hops, `BuyExecution` is used to
     * buy execution using transferred `assets` identified by `remote_fees_id`.
     * Make sure enough of the specified `remote_fees_id` asset is included in the given list
     * of `assets`. `remote_fees_id` should be enough to pay for `weight_limit`. If more weight
     * is needed than `weight_limit`, then the operation will fail and the sent assets may be
     * at risk.
     *
     * `remote_fees_id` may use different transfer type than rest of `assets` and can be
     * specified through `fees_transfer_type`.
     *
     * The caller needs to specify what should happen to the transferred assets once they reach
     * the `dest` chain. This is done through the `custom_xcm_on_dest` parameter, which
     * contains the instructions to execute on `dest` as a final step.
     * This is usually as simple as:
     * `Xcm(vec![DepositAsset { assets: Wild(AllCounted(assets.len())), beneficiary }])`,
     * but could be something more exotic like sending the `assets` even further.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain, or `(parents: 2, (GlobalConsensus(..), ..))` to send from
     * parachain across a bridge to another ecosystem destination.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` (and possibly reserve) chains.
     * - `assets_transfer_type`: The XCM `TransferType` used to transfer the `assets`.
     * - `remote_fees_id`: One of the included `assets` to be used to pay fees.
     * - `fees_transfer_type`: The XCM `TransferType` used to transfer the `fees` assets.
     * - `custom_xcm_on_dest`: The XCM to be executed on `dest` chain as the last step of the
     * transfer, which also determines what happens to the assets on the destination chain.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedAssets} assets
     * @param {StagingXcmExecutorAssetTransferTransferType} assetsTransferType
     * @param {XcmVersionedAssetId} remoteFeesId
     * @param {StagingXcmExecutorAssetTransferTransferType} feesTransferType
     * @param {XcmVersionedXcm} customXcmOnDest
     * @param {XcmV3WeightLimit} weightLimit
     **/
    transferAssetsUsingTypeAndThen: GenericTxCall<
      Rv,
      (
        dest: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        assetsTransferType: StagingXcmExecutorAssetTransferTransferType,
        remoteFeesId: XcmVersionedAssetId,
        feesTransferType: StagingXcmExecutorAssetTransferTransferType,
        customXcmOnDest: XcmVersionedXcm,
        weightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'TransferAssetsUsingTypeAndThen';
            params: {
              dest: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              assetsTransferType: StagingXcmExecutorAssetTransferTransferType;
              remoteFeesId: XcmVersionedAssetId;
              feesTransferType: StagingXcmExecutorAssetTransferTransferType;
              customXcmOnDest: XcmVersionedXcm;
              weightLimit: XcmV3WeightLimit;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `CumulusXcm`'s transaction calls
   **/
  cumulusXcm: {
    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `MessageQueue`'s transaction calls
   **/
  messageQueue: {
    /**
     * Remove a page which has no more messages remaining to be processed or is stale.
     *
     * @param {CumulusPrimitivesCoreAggregateMessageOrigin} messageOrigin
     * @param {number} pageIndex
     **/
    reapPage: GenericTxCall<
      Rv,
      (
        messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin,
        pageIndex: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'MessageQueue';
          palletCall: {
            name: 'ReapPage';
            params: { messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin; pageIndex: number };
          };
        }
      >
    >;

    /**
     * Execute an overweight message.
     *
     * Temporary processing errors will be propagated whereas permanent errors are treated
     * as success condition.
     *
     * - `origin`: Must be `Signed`.
     * - `message_origin`: The origin from which the message to be executed arrived.
     * - `page`: The page in the queue in which the message to be executed is sitting.
     * - `index`: The index into the queue of the message to be executed.
     * - `weight_limit`: The maximum amount of weight allowed to be consumed in the execution
     * of the message.
     *
     * Benchmark complexity considerations: O(index + weight_limit).
     *
     * @param {CumulusPrimitivesCoreAggregateMessageOrigin} messageOrigin
     * @param {number} page
     * @param {number} index
     * @param {SpWeightsWeightV2Weight} weightLimit
     **/
    executeOverweight: GenericTxCall<
      Rv,
      (
        messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin,
        page: number,
        index: number,
        weightLimit: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'MessageQueue';
          palletCall: {
            name: 'ExecuteOverweight';
            params: {
              messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin;
              page: number;
              index: number;
              weightLimit: SpWeightsWeightV2Weight;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Utility`'s transaction calls
   **/
  utility: {
    /**
     * Send a batch of dispatch calls.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     *
     * @param {Array<PeopleWestendRuntimeRuntimeCallLike>} calls
     **/
    batch: GenericTxCall<
      Rv,
      (calls: Array<PeopleWestendRuntimeRuntimeCallLike>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'Batch';
            params: { calls: Array<PeopleWestendRuntimeRuntimeCallLike> };
          };
        }
      >
    >;

    /**
     * Send a call through an indexed pseudonym of the sender.
     *
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     *
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     *
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * @param {number} index
     * @param {PeopleWestendRuntimeRuntimeCallLike} call
     **/
    asDerivative: GenericTxCall<
      Rv,
      (
        index: number,
        call: PeopleWestendRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'AsDerivative';
            params: { index: number; call: PeopleWestendRuntimeRuntimeCallLike };
          };
        }
      >
    >;

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * @param {Array<PeopleWestendRuntimeRuntimeCallLike>} calls
     **/
    batchAll: GenericTxCall<
      Rv,
      (calls: Array<PeopleWestendRuntimeRuntimeCallLike>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'BatchAll';
            params: { calls: Array<PeopleWestendRuntimeRuntimeCallLike> };
          };
        }
      >
    >;

    /**
     * Dispatches a function call with a provided origin.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {PeopleWestendRuntimeOriginCaller} asOrigin
     * @param {PeopleWestendRuntimeRuntimeCallLike} call
     **/
    dispatchAs: GenericTxCall<
      Rv,
      (
        asOrigin: PeopleWestendRuntimeOriginCaller,
        call: PeopleWestendRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'DispatchAs';
            params: { asOrigin: PeopleWestendRuntimeOriginCaller; call: PeopleWestendRuntimeRuntimeCallLike };
          };
        }
      >
    >;

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * @param {Array<PeopleWestendRuntimeRuntimeCallLike>} calls
     **/
    forceBatch: GenericTxCall<
      Rv,
      (calls: Array<PeopleWestendRuntimeRuntimeCallLike>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'ForceBatch';
            params: { calls: Array<PeopleWestendRuntimeRuntimeCallLike> };
          };
        }
      >
    >;

    /**
     * Dispatch a function call with a specified weight.
     *
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * @param {PeopleWestendRuntimeRuntimeCallLike} call
     * @param {SpWeightsWeightV2Weight} weight
     **/
    withWeight: GenericTxCall<
      Rv,
      (
        call: PeopleWestendRuntimeRuntimeCallLike,
        weight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'WithWeight';
            params: { call: PeopleWestendRuntimeRuntimeCallLike; weight: SpWeightsWeightV2Weight };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Multisig`'s transaction calls
   **/
  multisig: {
    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     *
     * Result is equivalent to the dispatched result.
     *
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     *
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {PeopleWestendRuntimeRuntimeCallLike} call
     **/
    asMultiThreshold1: GenericTxCall<
      Rv,
      (
        otherSignatories: Array<AccountId32Like>,
        call: PeopleWestendRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'AsMultiThreshold1';
            params: { otherSignatories: Array<AccountId32Like>; call: PeopleWestendRuntimeRuntimeCallLike };
          };
        }
      >
    >;

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     *
     * If there are enough, then dispatch the call.
     *
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     *
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     *
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     *
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     *
     * @param {number} threshold
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {PalletMultisigTimepoint | undefined} maybeTimepoint
     * @param {PeopleWestendRuntimeRuntimeCallLike} call
     * @param {SpWeightsWeightV2Weight} maxWeight
     **/
    asMulti: GenericTxCall<
      Rv,
      (
        threshold: number,
        otherSignatories: Array<AccountId32Like>,
        maybeTimepoint: PalletMultisigTimepoint | undefined,
        call: PeopleWestendRuntimeRuntimeCallLike,
        maxWeight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'AsMulti';
            params: {
              threshold: number;
              otherSignatories: Array<AccountId32Like>;
              maybeTimepoint: PalletMultisigTimepoint | undefined;
              call: PeopleWestendRuntimeRuntimeCallLike;
              maxWeight: SpWeightsWeightV2Weight;
            };
          };
        }
      >
    >;

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     *
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call_hash`: The hash of the call to be executed.
     *
     * NOTE: If this is the final approval, you will want to use `as_multi` instead.
     *
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     *
     * @param {number} threshold
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {PalletMultisigTimepoint | undefined} maybeTimepoint
     * @param {FixedBytes<32>} callHash
     * @param {SpWeightsWeightV2Weight} maxWeight
     **/
    approveAsMulti: GenericTxCall<
      Rv,
      (
        threshold: number,
        otherSignatories: Array<AccountId32Like>,
        maybeTimepoint: PalletMultisigTimepoint | undefined,
        callHash: FixedBytes<32>,
        maxWeight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'ApproveAsMulti';
            params: {
              threshold: number;
              otherSignatories: Array<AccountId32Like>;
              maybeTimepoint: PalletMultisigTimepoint | undefined;
              callHash: FixedBytes<32>;
              maxWeight: SpWeightsWeightV2Weight;
            };
          };
        }
      >
    >;

    /**
     * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
     * for this operation will be unreserved on success.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `timepoint`: The timepoint (block number and transaction index) of the first approval
     * transaction for this dispatch.
     * - `call_hash`: The hash of the call to be executed.
     *
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - One event.
     * - I/O: 1 read `O(S)`, one remove.
     * - Storage: removes one item.
     *
     * @param {number} threshold
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {PalletMultisigTimepoint} timepoint
     * @param {FixedBytes<32>} callHash
     **/
    cancelAsMulti: GenericTxCall<
      Rv,
      (
        threshold: number,
        otherSignatories: Array<AccountId32Like>,
        timepoint: PalletMultisigTimepoint,
        callHash: FixedBytes<32>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'CancelAsMulti';
            params: {
              threshold: number;
              otherSignatories: Array<AccountId32Like>;
              timepoint: PalletMultisigTimepoint;
              callHash: FixedBytes<32>;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Proxy`'s transaction calls
   **/
  proxy: {
    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     *
     * @param {MultiAddressLike} real
     * @param {PeopleWestendRuntimeProxyType | undefined} forceProxyType
     * @param {PeopleWestendRuntimeRuntimeCallLike} call
     **/
    proxy: GenericTxCall<
      Rv,
      (
        real: MultiAddressLike,
        forceProxyType: PeopleWestendRuntimeProxyType | undefined,
        call: PeopleWestendRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'Proxy';
            params: {
              real: MultiAddressLike;
              forceProxyType: PeopleWestendRuntimeProxyType | undefined;
              call: PeopleWestendRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Register a proxy account for the sender that is able to make calls on its behalf.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `proxy`: The account that the `caller` would like to make a proxy.
     * - `proxy_type`: The permissions allowed for this proxy account.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     *
     * @param {MultiAddressLike} delegate
     * @param {PeopleWestendRuntimeProxyType} proxyType
     * @param {number} delay
     **/
    addProxy: GenericTxCall<
      Rv,
      (
        delegate: MultiAddressLike,
        proxyType: PeopleWestendRuntimeProxyType,
        delay: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'AddProxy';
            params: { delegate: MultiAddressLike; proxyType: PeopleWestendRuntimeProxyType; delay: number };
          };
        }
      >
    >;

    /**
     * Unregister a proxy account for the sender.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `proxy`: The account that the `caller` would like to remove as a proxy.
     * - `proxy_type`: The permissions currently enabled for the removed proxy account.
     *
     * @param {MultiAddressLike} delegate
     * @param {PeopleWestendRuntimeProxyType} proxyType
     * @param {number} delay
     **/
    removeProxy: GenericTxCall<
      Rv,
      (
        delegate: MultiAddressLike,
        proxyType: PeopleWestendRuntimeProxyType,
        delay: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'RemoveProxy';
            params: { delegate: MultiAddressLike; proxyType: PeopleWestendRuntimeProxyType; delay: number };
          };
        }
      >
    >;

    /**
     * Unregister all proxy accounts for the sender.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * WARNING: This may be called on accounts created by `pure`, however if done, then
     * the unreserved fees will be inaccessible. **All access to this account will be lost.**
     *
     **/
    removeProxies: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'RemoveProxies';
          };
        }
      >
    >;

    /**
     * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
     * initialize it with a proxy of `proxy_type` for `origin` sender.
     *
     * Requires a `Signed` origin.
     *
     * - `proxy_type`: The type of the proxy that the sender will be registered as over the
     * new account. This will almost always be the most permissive `ProxyType` possible to
     * allow for maximum flexibility.
     * - `index`: A disambiguation index, in case this is called multiple times in the same
     * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
     * want to use `0`.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     *
     * Fails with `Duplicate` if this has already been called in this transaction, from the
     * same sender, with the same parameters.
     *
     * Fails if there are insufficient funds to pay for deposit.
     *
     * @param {PeopleWestendRuntimeProxyType} proxyType
     * @param {number} delay
     * @param {number} index
     **/
    createPure: GenericTxCall<
      Rv,
      (
        proxyType: PeopleWestendRuntimeProxyType,
        delay: number,
        index: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'CreatePure';
            params: { proxyType: PeopleWestendRuntimeProxyType; delay: number; index: number };
          };
        }
      >
    >;

    /**
     * Removes a previously spawned pure proxy.
     *
     * WARNING: **All access to this account will be lost.** Any funds held in it will be
     * inaccessible.
     *
     * Requires a `Signed` origin, and the sender account must have been created by a call to
     * `pure` with corresponding parameters.
     *
     * - `spawner`: The account that originally called `pure` to create this account.
     * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
     * - `proxy_type`: The proxy type originally passed to `pure`.
     * - `height`: The height of the chain when the call to `pure` was processed.
     * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
     *
     * Fails with `NoPermission` in case the caller is not a previously created pure
     * account whose `pure` call has corresponding parameters.
     *
     * @param {MultiAddressLike} spawner
     * @param {PeopleWestendRuntimeProxyType} proxyType
     * @param {number} index
     * @param {number} height
     * @param {number} extIndex
     **/
    killPure: GenericTxCall<
      Rv,
      (
        spawner: MultiAddressLike,
        proxyType: PeopleWestendRuntimeProxyType,
        index: number,
        height: number,
        extIndex: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'KillPure';
            params: {
              spawner: MultiAddressLike;
              proxyType: PeopleWestendRuntimeProxyType;
              index: number;
              height: number;
              extIndex: number;
            };
          };
        }
      >
    >;

    /**
     * Publish the hash of a proxy-call that will be made in the future.
     *
     * This must be called some number of blocks before the corresponding `proxy` is attempted
     * if the delay associated with the proxy relationship is greater than zero.
     *
     * No more than `MaxPending` announcements may be made at any one time.
     *
     * This will take a deposit of `AnnouncementDepositFactor` as well as
     * `AnnouncementDepositBase` if there are no other pending announcements.
     *
     * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     *
     * @param {MultiAddressLike} real
     * @param {H256} callHash
     **/
    announce: GenericTxCall<
      Rv,
      (
        real: MultiAddressLike,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'Announce';
            params: { real: MultiAddressLike; callHash: H256 };
          };
        }
      >
    >;

    /**
     * Remove a given announcement.
     *
     * May be called by a proxy account to remove a call they previously announced and return
     * the deposit.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     *
     * @param {MultiAddressLike} real
     * @param {H256} callHash
     **/
    removeAnnouncement: GenericTxCall<
      Rv,
      (
        real: MultiAddressLike,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'RemoveAnnouncement';
            params: { real: MultiAddressLike; callHash: H256 };
          };
        }
      >
    >;

    /**
     * Remove the given announcement of a delegate.
     *
     * May be called by a target (proxied) account to remove a call that one of their delegates
     * (`delegate`) has announced they want to execute. The deposit is returned.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `delegate`: The account that previously announced the call.
     * - `call_hash`: The hash of the call to be made.
     *
     * @param {MultiAddressLike} delegate
     * @param {H256} callHash
     **/
    rejectAnnouncement: GenericTxCall<
      Rv,
      (
        delegate: MultiAddressLike,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'RejectAnnouncement';
            params: { delegate: MultiAddressLike; callHash: H256 };
          };
        }
      >
    >;

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     *
     * Removes any corresponding announcement(s).
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     *
     * @param {MultiAddressLike} delegate
     * @param {MultiAddressLike} real
     * @param {PeopleWestendRuntimeProxyType | undefined} forceProxyType
     * @param {PeopleWestendRuntimeRuntimeCallLike} call
     **/
    proxyAnnounced: GenericTxCall<
      Rv,
      (
        delegate: MultiAddressLike,
        real: MultiAddressLike,
        forceProxyType: PeopleWestendRuntimeProxyType | undefined,
        call: PeopleWestendRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'ProxyAnnounced';
            params: {
              delegate: MultiAddressLike;
              real: MultiAddressLike;
              forceProxyType: PeopleWestendRuntimeProxyType | undefined;
              call: PeopleWestendRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Identity`'s transaction calls
   **/
  identity: {
    /**
     * Add a registrar to the system.
     *
     * The dispatch origin for this call must be `T::RegistrarOrigin`.
     *
     * - `account`: the account of the registrar.
     *
     * Emits `RegistrarAdded` if successful.
     *
     * @param {MultiAddressLike} account
     **/
    addRegistrar: GenericTxCall<
      Rv,
      (account: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'AddRegistrar';
            params: { account: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Set an account's identity information and reserve the appropriate deposit.
     *
     * If the account already has identity information, the deposit is taken as part payment
     * for the new deposit.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `info`: The identity information.
     *
     * Emits `IdentitySet` if successful.
     *
     * @param {PeopleWestendRuntimePeopleIdentityInfo} info
     **/
    setIdentity: GenericTxCall<
      Rv,
      (info: PeopleWestendRuntimePeopleIdentityInfo) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetIdentity';
            params: { info: PeopleWestendRuntimePeopleIdentityInfo };
          };
        }
      >
    >;

    /**
     * Set the sub-accounts of the sender.
     *
     * Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
     * and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * identity.
     *
     * - `subs`: The identity's (new) sub-accounts.
     *
     * @param {Array<[AccountId32Like, Data]>} subs
     **/
    setSubs: GenericTxCall<
      Rv,
      (subs: Array<[AccountId32Like, Data]>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetSubs';
            params: { subs: Array<[AccountId32Like, Data]> };
          };
        }
      >
    >;

    /**
     * Clear an account's identity info and all sub-accounts and return all deposits.
     *
     * Payment: All reserved balances on the account are returned.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * identity.
     *
     * Emits `IdentityCleared` if successful.
     *
     **/
    clearIdentity: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'ClearIdentity';
          };
        }
      >
    >;

    /**
     * Request a judgement from a registrar.
     *
     * Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
     * given.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a
     * registered identity.
     *
     * - `reg_index`: The index of the registrar whose judgement is requested.
     * - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
     *
     * ```nocompile
     * Registrars::<T>::get().get(reg_index).unwrap().fee
     * ```
     *
     * Emits `JudgementRequested` if successful.
     *
     * @param {number} regIndex
     * @param {bigint} maxFee
     **/
    requestJudgement: GenericTxCall<
      Rv,
      (
        regIndex: number,
        maxFee: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RequestJudgement';
            params: { regIndex: number; maxFee: bigint };
          };
        }
      >
    >;

    /**
     * Cancel a previous request.
     *
     * Payment: A previously reserved deposit is returned on success.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a
     * registered identity.
     *
     * - `reg_index`: The index of the registrar whose judgement is no longer requested.
     *
     * Emits `JudgementUnrequested` if successful.
     *
     * @param {number} regIndex
     **/
    cancelRequest: GenericTxCall<
      Rv,
      (regIndex: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'CancelRequest';
            params: { regIndex: number };
          };
        }
      >
    >;

    /**
     * Set the fee required for a judgement to be requested from a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `fee`: the new fee.
     *
     * @param {number} index
     * @param {bigint} fee
     **/
    setFee: GenericTxCall<
      Rv,
      (
        index: number,
        fee: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetFee';
            params: { index: number; fee: bigint };
          };
        }
      >
    >;

    /**
     * Change the account associated with a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `new`: the new account ID.
     *
     * @param {number} index
     * @param {MultiAddressLike} new_
     **/
    setAccountId: GenericTxCall<
      Rv,
      (
        index: number,
        new_: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetAccountId';
            params: { index: number; new: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Set the field information for a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `fields`: the fields that the registrar concerns themselves with.
     *
     * @param {number} index
     * @param {bigint} fields
     **/
    setFields: GenericTxCall<
      Rv,
      (
        index: number,
        fields: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetFields';
            params: { index: number; fields: bigint };
          };
        }
      >
    >;

    /**
     * Provide a judgement for an account's identity.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `reg_index`.
     *
     * - `reg_index`: the index of the registrar whose judgement is being made.
     * - `target`: the account whose identity the judgement is upon. This must be an account
     * with a registered identity.
     * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
     * - `identity`: The hash of the [`IdentityInformationProvider`] for that the judgement is
     * provided.
     *
     * Note: Judgements do not apply to a username.
     *
     * Emits `JudgementGiven` if successful.
     *
     * @param {number} regIndex
     * @param {MultiAddressLike} target
     * @param {PalletIdentityJudgement} judgement
     * @param {H256} identity
     **/
    provideJudgement: GenericTxCall<
      Rv,
      (
        regIndex: number,
        target: MultiAddressLike,
        judgement: PalletIdentityJudgement,
        identity: H256,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'ProvideJudgement';
            params: { regIndex: number; target: MultiAddressLike; judgement: PalletIdentityJudgement; identity: H256 };
          };
        }
      >
    >;

    /**
     * Remove an account's identity and sub-account information and slash the deposits.
     *
     * Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
     * `Slash`. Verification request deposits are not returned; they should be cancelled
     * manually using `cancel_request`.
     *
     * The dispatch origin for this call must match `T::ForceOrigin`.
     *
     * - `target`: the account whose identity the judgement is upon. This must be an account
     * with a registered identity.
     *
     * Emits `IdentityKilled` if successful.
     *
     * @param {MultiAddressLike} target
     **/
    killIdentity: GenericTxCall<
      Rv,
      (target: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'KillIdentity';
            params: { target: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Add the given account to the sender's subs.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     *
     * @param {MultiAddressLike} sub
     * @param {Data} data
     **/
    addSub: GenericTxCall<
      Rv,
      (
        sub: MultiAddressLike,
        data: Data,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'AddSub';
            params: { sub: MultiAddressLike; data: Data };
          };
        }
      >
    >;

    /**
     * Alter the associated name of the given sub-account.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     *
     * @param {MultiAddressLike} sub
     * @param {Data} data
     **/
    renameSub: GenericTxCall<
      Rv,
      (
        sub: MultiAddressLike,
        data: Data,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RenameSub';
            params: { sub: MultiAddressLike; data: Data };
          };
        }
      >
    >;

    /**
     * Remove the given account from the sender's subs.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     *
     * @param {MultiAddressLike} sub
     **/
    removeSub: GenericTxCall<
      Rv,
      (sub: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RemoveSub';
            params: { sub: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Remove the sender as a sub-account.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender (*not* the original depositor).
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * super-identity.
     *
     * NOTE: This should not normally be used, but is provided in the case that the non-
     * controller of an account is maliciously registered as a sub-account.
     *
     **/
    quitSub: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'QuitSub';
          };
        }
      >
    >;

    /**
     * Add an `AccountId` with permission to grant usernames with a given `suffix` appended.
     *
     * The authority can grant up to `allocation` usernames. To top up their allocation, they
     * should just issue (or request via governance) a new `add_username_authority` call.
     *
     * @param {MultiAddressLike} authority
     * @param {BytesLike} suffix
     * @param {number} allocation
     **/
    addUsernameAuthority: GenericTxCall<
      Rv,
      (
        authority: MultiAddressLike,
        suffix: BytesLike,
        allocation: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'AddUsernameAuthority';
            params: { authority: MultiAddressLike; suffix: BytesLike; allocation: number };
          };
        }
      >
    >;

    /**
     * Remove `authority` from the username authorities.
     *
     * @param {MultiAddressLike} authority
     **/
    removeUsernameAuthority: GenericTxCall<
      Rv,
      (authority: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RemoveUsernameAuthority';
            params: { authority: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Set the username for `who`. Must be called by a username authority.
     *
     * The authority must have an `allocation`. Users can either pre-sign their usernames or
     * accept them later.
     *
     * Usernames must:
     * - Only contain lowercase ASCII characters or digits.
     * - When combined with the suffix of the issuing authority be _less than_ the
     * `MaxUsernameLength`.
     *
     * @param {MultiAddressLike} who
     * @param {BytesLike} username
     * @param {SpRuntimeMultiSignature | undefined} signature
     **/
    setUsernameFor: GenericTxCall<
      Rv,
      (
        who: MultiAddressLike,
        username: BytesLike,
        signature: SpRuntimeMultiSignature | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetUsernameFor';
            params: { who: MultiAddressLike; username: BytesLike; signature: SpRuntimeMultiSignature | undefined };
          };
        }
      >
    >;

    /**
     * Accept a given username that an `authority` granted. The call must include the full
     * username, as in `username.suffix`.
     *
     * @param {BytesLike} username
     **/
    acceptUsername: GenericTxCall<
      Rv,
      (username: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'AcceptUsername';
            params: { username: BytesLike };
          };
        }
      >
    >;

    /**
     * Remove an expired username approval. The username was approved by an authority but never
     * accepted by the user and must now be beyond its expiration. The call must include the
     * full username, as in `username.suffix`.
     *
     * @param {BytesLike} username
     **/
    removeExpiredApproval: GenericTxCall<
      Rv,
      (username: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RemoveExpiredApproval';
            params: { username: BytesLike };
          };
        }
      >
    >;

    /**
     * Set a given username as the primary. The username should include the suffix.
     *
     * @param {BytesLike} username
     **/
    setPrimaryUsername: GenericTxCall<
      Rv,
      (username: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetPrimaryUsername';
            params: { username: BytesLike };
          };
        }
      >
    >;

    /**
     * Remove a username that corresponds to an account with no identity. Exists when a user
     * gets a username but then calls `clear_identity`.
     *
     * @param {BytesLike} username
     **/
    removeDanglingUsername: GenericTxCall<
      Rv,
      (username: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RemoveDanglingUsername';
            params: { username: BytesLike };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `IdentityMigrator`'s transaction calls
   **/
  identityMigrator: {
    /**
     * Reap the `IdentityInfo` of `who` from the Identity pallet of `T`, unreserving any
     * deposits held and removing storage items associated with `who`.
     *
     * @param {AccountId32Like} who
     **/
    reapIdentity: GenericTxCall<
      Rv,
      (who: AccountId32Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'IdentityMigrator';
          palletCall: {
            name: 'ReapIdentity';
            params: { who: AccountId32Like };
          };
        }
      >
    >;

    /**
     * Update the deposit of `who`. Meant to be called by the system with an XCM `Transact`
     * Instruction.
     *
     * @param {AccountId32Like} who
     **/
    pokeDeposit: GenericTxCall<
      Rv,
      (who: AccountId32Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'IdentityMigrator';
          palletCall: {
            name: 'PokeDeposit';
            params: { who: AccountId32Like };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
}
