// Generated by dedot cli

import type { GenericChainErrors, GenericPalletError } from 'dedot/types';

export interface ChainErrors extends GenericChainErrors {
  /**
   * Pallet `System`'s errors
   **/
  system: {
    /**
     * The name of specification does not match between the current runtime
     * and the new runtime.
     **/
    InvalidSpecName: GenericPalletError;

    /**
     * The specification version is not allowed to decrease between the current runtime
     * and the new runtime.
     **/
    SpecVersionNeedsToIncrease: GenericPalletError;

    /**
     * Failed to extract the runtime version from the new runtime.
     *
     * Either calling `Core_version` or decoding `RuntimeVersion` failed.
     **/
    FailedToExtractRuntimeVersion: GenericPalletError;

    /**
     * Suicide called when the account has non-default composite data.
     **/
    NonDefaultComposite: GenericPalletError;

    /**
     * There is a non-zero reference count preventing the account from being purged.
     **/
    NonZeroRefCount: GenericPalletError;

    /**
     * The origin filter prevent the call to be dispatched.
     **/
    CallFiltered: GenericPalletError;

    /**
     * A multi-block migration is ongoing and prevents the current code from being replaced.
     **/
    MultiBlockMigrationsOngoing: GenericPalletError;

    /**
     * No upgrade authorized.
     **/
    NothingAuthorized: GenericPalletError;

    /**
     * The submitted code is not authorized.
     **/
    Unauthorized: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `ParachainSystem`'s errors
   **/
  parachainSystem: {
    /**
     * Attempt to upgrade validation function while existing upgrade pending.
     **/
    OverlappingUpgrades: GenericPalletError;

    /**
     * Polkadot currently prohibits this parachain from upgrading its validation function.
     **/
    ProhibitedByPolkadot: GenericPalletError;

    /**
     * The supplied validation function has compiled into a blob larger than Polkadot is
     * willing to run.
     **/
    TooBig: GenericPalletError;

    /**
     * The inherent which supplies the validation data did not run this block.
     **/
    ValidationDataNotAvailable: GenericPalletError;

    /**
     * The inherent which supplies the host configuration did not run this block.
     **/
    HostConfigurationNotAvailable: GenericPalletError;

    /**
     * No validation function upgrade is currently scheduled.
     **/
    NotScheduled: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Balances`'s errors
   **/
  balances: {
    /**
     * Vesting balance too high to send value.
     **/
    VestingBalance: GenericPalletError;

    /**
     * Account liquidity restrictions prevent withdrawal.
     **/
    LiquidityRestrictions: GenericPalletError;

    /**
     * Balance too low to send value.
     **/
    InsufficientBalance: GenericPalletError;

    /**
     * Value too low to create account due to existential deposit.
     **/
    ExistentialDeposit: GenericPalletError;

    /**
     * Transfer/payment would kill account.
     **/
    Expendability: GenericPalletError;

    /**
     * A vesting schedule already exists for this account.
     **/
    ExistingVestingSchedule: GenericPalletError;

    /**
     * Beneficiary account must pre-exist.
     **/
    DeadAccount: GenericPalletError;

    /**
     * Number of named reserves exceed `MaxReserves`.
     **/
    TooManyReserves: GenericPalletError;

    /**
     * Number of holds exceed `VariantCountOf<T::RuntimeHoldReason>`.
     **/
    TooManyHolds: GenericPalletError;

    /**
     * Number of freezes exceed `MaxFreezes`.
     **/
    TooManyFreezes: GenericPalletError;

    /**
     * The issuance cannot be modified since it is already deactivated.
     **/
    IssuanceDeactivated: GenericPalletError;

    /**
     * The delta cannot be zero.
     **/
    DeltaZero: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `ParachainStaking`'s errors
   **/
  parachainStaking: {
    DelegatorDNE: GenericPalletError;
    DelegatorDNEinTopNorBottom: GenericPalletError;
    DelegatorDNEInDelegatorSet: GenericPalletError;
    CandidateDNE: GenericPalletError;
    DelegationDNE: GenericPalletError;
    DelegatorExists: GenericPalletError;
    CandidateExists: GenericPalletError;
    CandidateBondBelowMin: GenericPalletError;
    InsufficientBalance: GenericPalletError;
    DelegatorBondBelowMin: GenericPalletError;
    DelegationBelowMin: GenericPalletError;
    AlreadyOffline: GenericPalletError;
    AlreadyActive: GenericPalletError;
    DelegatorAlreadyLeaving: GenericPalletError;
    DelegatorNotLeaving: GenericPalletError;
    DelegatorCannotLeaveYet: GenericPalletError;
    CannotDelegateIfLeaving: GenericPalletError;
    CandidateAlreadyLeaving: GenericPalletError;
    CandidateNotLeaving: GenericPalletError;
    CandidateCannotLeaveYet: GenericPalletError;
    CannotGoOnlineIfLeaving: GenericPalletError;
    ExceedMaxDelegationsPerDelegator: GenericPalletError;
    AlreadyDelegatedCandidate: GenericPalletError;
    InvalidSchedule: GenericPalletError;
    CannotSetBelowMin: GenericPalletError;
    RoundLengthMustBeGreaterThanTotalSelectedCollators: GenericPalletError;
    NoWritingSameValue: GenericPalletError;
    TotalInflationDistributionPercentExceeds100: GenericPalletError;
    TooLowCandidateCountWeightHintJoinCandidates: GenericPalletError;
    TooLowCandidateCountWeightHintCancelLeaveCandidates: GenericPalletError;
    TooLowCandidateCountToLeaveCandidates: GenericPalletError;
    TooLowDelegationCountToDelegate: GenericPalletError;
    TooLowCandidateDelegationCountToDelegate: GenericPalletError;
    TooLowCandidateDelegationCountToLeaveCandidates: GenericPalletError;
    TooLowDelegationCountToLeaveDelegators: GenericPalletError;
    PendingCandidateRequestsDNE: GenericPalletError;
    PendingCandidateRequestAlreadyExists: GenericPalletError;
    PendingCandidateRequestNotDueYet: GenericPalletError;
    PendingDelegationRequestDNE: GenericPalletError;
    PendingDelegationRequestAlreadyExists: GenericPalletError;
    PendingDelegationRequestNotDueYet: GenericPalletError;
    CannotDelegateLessThanOrEqualToLowestBottomWhenFull: GenericPalletError;
    PendingDelegationRevoke: GenericPalletError;
    TooLowDelegationCountToAutoCompound: GenericPalletError;
    TooLowCandidateAutoCompoundingDelegationCountToAutoCompound: GenericPalletError;
    TooLowCandidateAutoCompoundingDelegationCountToDelegate: GenericPalletError;
    TooLowCollatorCountToNotifyAsInactive: GenericPalletError;
    CannotBeNotifiedAsInactive: GenericPalletError;
    TooLowCandidateAutoCompoundingDelegationCountToLeaveCandidates: GenericPalletError;
    TooLowCandidateCountWeightHint: GenericPalletError;
    TooLowCandidateCountWeightHintGoOffline: GenericPalletError;
    CandidateLimitReached: GenericPalletError;
    CannotSetAboveMaxCandidates: GenericPalletError;
    MarkingOfflineNotEnabled: GenericPalletError;
    CurrentRoundTooLow: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `AuthorInherent`'s errors
   **/
  authorInherent: {
    /**
     * Author already set in block.
     **/
    AuthorAlreadySet: GenericPalletError;

    /**
     * No AccountId was found to be associated with this author
     **/
    NoAccountId: GenericPalletError;

    /**
     * The author in the inherent is not an eligible author.
     **/
    CannotBeAuthor: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `AuthorMapping`'s errors
   **/
  authorMapping: {
    /**
     * The association can't be cleared because it is not found.
     **/
    AssociationNotFound: GenericPalletError;

    /**
     * The association can't be cleared because it belongs to another account.
     **/
    NotYourAssociation: GenericPalletError;

    /**
     * This account cannot set an author because it cannon afford the security deposit
     **/
    CannotAffordSecurityDeposit: GenericPalletError;

    /**
     * The NimbusId in question is already associated and cannot be overwritten
     **/
    AlreadyAssociated: GenericPalletError;

    /**
     * No existing NimbusId can be found for the account
     **/
    OldAuthorIdNotFound: GenericPalletError;

    /**
     * Keys have wrong size
     **/
    WrongKeySize: GenericPalletError;

    /**
     * Failed to decode NimbusId for `set_keys`
     **/
    DecodeNimbusFailed: GenericPalletError;

    /**
     * Failed to decode T::Keys for `set_keys`
     **/
    DecodeKeysFailed: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `MoonbeamOrbiters`'s errors
   **/
  moonbeamOrbiters: {
    /**
     * The collator is already added in orbiters program.
     **/
    CollatorAlreadyAdded: GenericPalletError;

    /**
     * This collator is not in orbiters program.
     **/
    CollatorNotFound: GenericPalletError;

    /**
     * There are already too many orbiters associated with this collator.
     **/
    CollatorPoolTooLarge: GenericPalletError;

    /**
     * There are more collator pools than the number specified in the parameter.
     **/
    CollatorsPoolCountTooLow: GenericPalletError;

    /**
     * The minimum deposit required to register as an orbiter has not yet been included in the
     * onchain storage
     **/
    MinOrbiterDepositNotSet: GenericPalletError;

    /**
     * This orbiter is already associated with this collator.
     **/
    OrbiterAlreadyInPool: GenericPalletError;

    /**
     * This orbiter has not made a deposit
     **/
    OrbiterDepositNotFound: GenericPalletError;

    /**
     * This orbiter is not found
     **/
    OrbiterNotFound: GenericPalletError;

    /**
     * The orbiter is still at least in one pool
     **/
    OrbiterStillInAPool: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Utility`'s errors
   **/
  utility: {
    /**
     * Too many calls batched.
     **/
    TooManyCalls: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Proxy`'s errors
   **/
  proxy: {
    /**
     * There are too many proxies registered or too many announcements pending.
     **/
    TooMany: GenericPalletError;

    /**
     * Proxy registration not found.
     **/
    NotFound: GenericPalletError;

    /**
     * Sender is not a proxy of the account to be proxied.
     **/
    NotProxy: GenericPalletError;

    /**
     * A call which is incompatible with the proxy type's filter was attempted.
     **/
    Unproxyable: GenericPalletError;

    /**
     * Account is already a proxy.
     **/
    Duplicate: GenericPalletError;

    /**
     * Call may not be made by proxy because it may escalate its privileges.
     **/
    NoPermission: GenericPalletError;

    /**
     * Announcement, if made at all, was made too recently.
     **/
    Unannounced: GenericPalletError;

    /**
     * Cannot add self as proxy.
     **/
    NoSelfProxy: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `MaintenanceMode`'s errors
   **/
  maintenanceMode: {
    /**
     * The chain cannot enter maintenance mode because it is already in maintenance mode
     **/
    AlreadyInMaintenanceMode: GenericPalletError;

    /**
     * The chain cannot resume normal operation because it is not in maintenance mode
     **/
    NotInMaintenanceMode: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Identity`'s errors
   **/
  identity: {
    /**
     * Too many subs-accounts.
     **/
    TooManySubAccounts: GenericPalletError;

    /**
     * Account isn't found.
     **/
    NotFound: GenericPalletError;

    /**
     * Account isn't named.
     **/
    NotNamed: GenericPalletError;

    /**
     * Empty index.
     **/
    EmptyIndex: GenericPalletError;

    /**
     * Fee is changed.
     **/
    FeeChanged: GenericPalletError;

    /**
     * No identity found.
     **/
    NoIdentity: GenericPalletError;

    /**
     * Sticky judgement.
     **/
    StickyJudgement: GenericPalletError;

    /**
     * Judgement given.
     **/
    JudgementGiven: GenericPalletError;

    /**
     * Invalid judgement.
     **/
    InvalidJudgement: GenericPalletError;

    /**
     * The index is invalid.
     **/
    InvalidIndex: GenericPalletError;

    /**
     * The target is invalid.
     **/
    InvalidTarget: GenericPalletError;

    /**
     * Maximum amount of registrars reached. Cannot add any more.
     **/
    TooManyRegistrars: GenericPalletError;

    /**
     * Account ID is already named.
     **/
    AlreadyClaimed: GenericPalletError;

    /**
     * Sender is not a sub-account.
     **/
    NotSub: GenericPalletError;

    /**
     * Sub-account isn't owned by sender.
     **/
    NotOwned: GenericPalletError;

    /**
     * The provided judgement was for a different identity.
     **/
    JudgementForDifferentIdentity: GenericPalletError;

    /**
     * Error that occurs when there is an issue paying for judgement.
     **/
    JudgementPaymentFailed: GenericPalletError;

    /**
     * The provided suffix is too long.
     **/
    InvalidSuffix: GenericPalletError;

    /**
     * The sender does not have permission to issue a username.
     **/
    NotUsernameAuthority: GenericPalletError;

    /**
     * The authority cannot allocate any more usernames.
     **/
    NoAllocation: GenericPalletError;

    /**
     * The signature on a username was not valid.
     **/
    InvalidSignature: GenericPalletError;

    /**
     * Setting this username requires a signature, but none was provided.
     **/
    RequiresSignature: GenericPalletError;

    /**
     * The username does not meet the requirements.
     **/
    InvalidUsername: GenericPalletError;

    /**
     * The username is already taken.
     **/
    UsernameTaken: GenericPalletError;

    /**
     * The requested username does not exist.
     **/
    NoUsername: GenericPalletError;

    /**
     * The username cannot be forcefully removed because it can still be accepted.
     **/
    NotExpired: GenericPalletError;

    /**
     * The username cannot be removed because it's still in the grace period.
     **/
    TooEarly: GenericPalletError;

    /**
     * The username cannot be removed because it is not unbinding.
     **/
    NotUnbinding: GenericPalletError;

    /**
     * The username cannot be unbound because it is already unbinding.
     **/
    AlreadyUnbinding: GenericPalletError;

    /**
     * The action cannot be performed because of insufficient privileges (e.g. authority
     * trying to unbind a username provided by the system).
     **/
    InsufficientPrivileges: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Multisig`'s errors
   **/
  multisig: {
    /**
     * Threshold must be 2 or greater.
     **/
    MinimumThreshold: GenericPalletError;

    /**
     * Call is already approved by this signatory.
     **/
    AlreadyApproved: GenericPalletError;

    /**
     * Call doesn't need any (more) approvals.
     **/
    NoApprovalsNeeded: GenericPalletError;

    /**
     * There are too few signatories in the list.
     **/
    TooFewSignatories: GenericPalletError;

    /**
     * There are too many signatories in the list.
     **/
    TooManySignatories: GenericPalletError;

    /**
     * The signatories were provided out of order; they should be ordered.
     **/
    SignatoriesOutOfOrder: GenericPalletError;

    /**
     * The sender was contained in the other signatories; it shouldn't be.
     **/
    SenderInSignatories: GenericPalletError;

    /**
     * Multisig operation not found in storage.
     **/
    NotFound: GenericPalletError;

    /**
     * Only the account that originally created the multisig is able to cancel it or update
     * its deposits.
     **/
    NotOwner: GenericPalletError;

    /**
     * No timepoint was given, yet the multisig operation is already underway.
     **/
    NoTimepoint: GenericPalletError;

    /**
     * A different timepoint was given to the multisig operation that is underway.
     **/
    WrongTimepoint: GenericPalletError;

    /**
     * A timepoint was given, yet no multisig operation is underway.
     **/
    UnexpectedTimepoint: GenericPalletError;

    /**
     * The maximum weight information provided was too low.
     **/
    MaxWeightTooLow: GenericPalletError;

    /**
     * The data to be stored is already stored.
     **/
    AlreadyStored: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `MoonbeamLazyMigrations`'s errors
   **/
  moonbeamLazyMigrations: {
    /**
     * The contract already have metadata
     **/
    ContractMetadataAlreadySet: GenericPalletError;

    /**
     * Contract not exist
     **/
    ContractNotExist: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `EVM`'s errors
   **/
  evm: {
    /**
     * Not enough balance to perform action
     **/
    BalanceLow: GenericPalletError;

    /**
     * Calculating total fee overflowed
     **/
    FeeOverflow: GenericPalletError;

    /**
     * Calculating total payment overflowed
     **/
    PaymentOverflow: GenericPalletError;

    /**
     * Withdraw fee failed
     **/
    WithdrawFailed: GenericPalletError;

    /**
     * Gas price is too low.
     **/
    GasPriceTooLow: GenericPalletError;

    /**
     * Nonce is invalid
     **/
    InvalidNonce: GenericPalletError;

    /**
     * Gas limit is too low.
     **/
    GasLimitTooLow: GenericPalletError;

    /**
     * Gas limit is too high.
     **/
    GasLimitTooHigh: GenericPalletError;

    /**
     * The chain id is invalid.
     **/
    InvalidChainId: GenericPalletError;

    /**
     * the signature is invalid.
     **/
    InvalidSignature: GenericPalletError;

    /**
     * EVM reentrancy
     **/
    Reentrancy: GenericPalletError;

    /**
     * EIP-3607,
     **/
    TransactionMustComeFromEOA: GenericPalletError;

    /**
     * Undefined error.
     **/
    Undefined: GenericPalletError;

    /**
     * Address not allowed to deploy contracts either via CREATE or CALL(CREATE).
     **/
    CreateOriginNotAllowed: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Ethereum`'s errors
   **/
  ethereum: {
    /**
     * Signature is invalid.
     **/
    InvalidSignature: GenericPalletError;

    /**
     * Pre-log is present, therefore transact is not allowed.
     **/
    PreLogExists: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Scheduler`'s errors
   **/
  scheduler: {
    /**
     * Failed to schedule a call
     **/
    FailedToSchedule: GenericPalletError;

    /**
     * Cannot find the scheduled call.
     **/
    NotFound: GenericPalletError;

    /**
     * Given target block number is in the past.
     **/
    TargetBlockNumberInPast: GenericPalletError;

    /**
     * Reschedule failed because it does not change scheduled time.
     **/
    RescheduleNoChange: GenericPalletError;

    /**
     * Attempt to use a non-named function on a named task.
     **/
    Named: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Preimage`'s errors
   **/
  preimage: {
    /**
     * Preimage is too large to store on-chain.
     **/
    TooBig: GenericPalletError;

    /**
     * Preimage has already been noted on-chain.
     **/
    AlreadyNoted: GenericPalletError;

    /**
     * The user is not authorized to perform this action.
     **/
    NotAuthorized: GenericPalletError;

    /**
     * The preimage cannot be removed since it has not yet been noted.
     **/
    NotNoted: GenericPalletError;

    /**
     * A preimage may not be removed when there are outstanding requests.
     **/
    Requested: GenericPalletError;

    /**
     * The preimage request cannot be removed since no outstanding requests exist.
     **/
    NotRequested: GenericPalletError;

    /**
     * More than `MAX_HASH_UPGRADE_BULK_COUNT` hashes were requested to be upgraded at once.
     **/
    TooMany: GenericPalletError;

    /**
     * Too few hashes were requested to be upgraded (i.e. zero).
     **/
    TooFew: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `ConvictionVoting`'s errors
   **/
  convictionVoting: {
    /**
     * Poll is not ongoing.
     **/
    NotOngoing: GenericPalletError;

    /**
     * The given account did not vote on the poll.
     **/
    NotVoter: GenericPalletError;

    /**
     * The actor has no permission to conduct the action.
     **/
    NoPermission: GenericPalletError;

    /**
     * The actor has no permission to conduct the action right now but will do in the future.
     **/
    NoPermissionYet: GenericPalletError;

    /**
     * The account is already delegating.
     **/
    AlreadyDelegating: GenericPalletError;

    /**
     * The account currently has votes attached to it and the operation cannot succeed until
     * these are removed through `remove_vote`.
     **/
    AlreadyVoting: GenericPalletError;

    /**
     * Too high a balance was provided that the account cannot afford.
     **/
    InsufficientFunds: GenericPalletError;

    /**
     * The account is not currently delegating.
     **/
    NotDelegating: GenericPalletError;

    /**
     * Delegation to oneself makes no sense.
     **/
    Nonsense: GenericPalletError;

    /**
     * Maximum number of votes reached.
     **/
    MaxVotesReached: GenericPalletError;

    /**
     * The class must be supplied since it is not easily determinable from the state.
     **/
    ClassNeeded: GenericPalletError;

    /**
     * The class ID supplied is invalid.
     **/
    BadClass: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Referenda`'s errors
   **/
  referenda: {
    /**
     * Referendum is not ongoing.
     **/
    NotOngoing: GenericPalletError;

    /**
     * Referendum's decision deposit is already paid.
     **/
    HasDeposit: GenericPalletError;

    /**
     * The track identifier given was invalid.
     **/
    BadTrack: GenericPalletError;

    /**
     * There are already a full complement of referenda in progress for this track.
     **/
    Full: GenericPalletError;

    /**
     * The queue of the track is empty.
     **/
    QueueEmpty: GenericPalletError;

    /**
     * The referendum index provided is invalid in this context.
     **/
    BadReferendum: GenericPalletError;

    /**
     * There was nothing to do in the advancement.
     **/
    NothingToDo: GenericPalletError;

    /**
     * No track exists for the proposal origin.
     **/
    NoTrack: GenericPalletError;

    /**
     * Any deposit cannot be refunded until after the decision is over.
     **/
    Unfinished: GenericPalletError;

    /**
     * The deposit refunder is not the depositor.
     **/
    NoPermission: GenericPalletError;

    /**
     * The deposit cannot be refunded since none was made.
     **/
    NoDeposit: GenericPalletError;

    /**
     * The referendum status is invalid for this operation.
     **/
    BadStatus: GenericPalletError;

    /**
     * The preimage does not exist.
     **/
    PreimageNotExist: GenericPalletError;

    /**
     * The preimage is stored with a different length than the one provided.
     **/
    PreimageStoredWithDifferentLength: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Whitelist`'s errors
   **/
  whitelist: {
    /**
     * The preimage of the call hash could not be loaded.
     **/
    UnavailablePreImage: GenericPalletError;

    /**
     * The call could not be decoded.
     **/
    UndecodableCall: GenericPalletError;

    /**
     * The weight of the decoded call was higher than the witness.
     **/
    InvalidCallWeightWitness: GenericPalletError;

    /**
     * The call was not whitelisted.
     **/
    CallIsNotWhitelisted: GenericPalletError;

    /**
     * The call was already whitelisted; No-Op.
     **/
    CallAlreadyWhitelisted: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `TreasuryCouncilCollective`'s errors
   **/
  treasuryCouncilCollective: {
    /**
     * Account is not a member
     **/
    NotMember: GenericPalletError;

    /**
     * Duplicate proposals not allowed
     **/
    DuplicateProposal: GenericPalletError;

    /**
     * Proposal must exist
     **/
    ProposalMissing: GenericPalletError;

    /**
     * Mismatched index
     **/
    WrongIndex: GenericPalletError;

    /**
     * Duplicate vote ignored
     **/
    DuplicateVote: GenericPalletError;

    /**
     * Members are already initialized!
     **/
    AlreadyInitialized: GenericPalletError;

    /**
     * The close call was made too early, before the end of the voting.
     **/
    TooEarly: GenericPalletError;

    /**
     * There can only be a maximum of `MaxProposals` active proposals.
     **/
    TooManyProposals: GenericPalletError;

    /**
     * The given weight bound for the proposal was too low.
     **/
    WrongProposalWeight: GenericPalletError;

    /**
     * The given length bound for the proposal was too low.
     **/
    WrongProposalLength: GenericPalletError;

    /**
     * Prime account is not a member
     **/
    PrimeAccountNotMember: GenericPalletError;

    /**
     * Proposal is still active.
     **/
    ProposalActive: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `OpenTechCommitteeCollective`'s errors
   **/
  openTechCommitteeCollective: {
    /**
     * Account is not a member
     **/
    NotMember: GenericPalletError;

    /**
     * Duplicate proposals not allowed
     **/
    DuplicateProposal: GenericPalletError;

    /**
     * Proposal must exist
     **/
    ProposalMissing: GenericPalletError;

    /**
     * Mismatched index
     **/
    WrongIndex: GenericPalletError;

    /**
     * Duplicate vote ignored
     **/
    DuplicateVote: GenericPalletError;

    /**
     * Members are already initialized!
     **/
    AlreadyInitialized: GenericPalletError;

    /**
     * The close call was made too early, before the end of the voting.
     **/
    TooEarly: GenericPalletError;

    /**
     * There can only be a maximum of `MaxProposals` active proposals.
     **/
    TooManyProposals: GenericPalletError;

    /**
     * The given weight bound for the proposal was too low.
     **/
    WrongProposalWeight: GenericPalletError;

    /**
     * The given length bound for the proposal was too low.
     **/
    WrongProposalLength: GenericPalletError;

    /**
     * Prime account is not a member
     **/
    PrimeAccountNotMember: GenericPalletError;

    /**
     * Proposal is still active.
     **/
    ProposalActive: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Treasury`'s errors
   **/
  treasury: {
    /**
     * No proposal, bounty or spend at that index.
     **/
    InvalidIndex: GenericPalletError;

    /**
     * Too many approvals in the queue.
     **/
    TooManyApprovals: GenericPalletError;

    /**
     * The spend origin is valid but the amount it is allowed to spend is lower than the
     * amount to be spent.
     **/
    InsufficientPermission: GenericPalletError;

    /**
     * Proposal has not been approved.
     **/
    ProposalNotApproved: GenericPalletError;

    /**
     * The balance of the asset kind is not convertible to the balance of the native asset.
     **/
    FailedToConvertBalance: GenericPalletError;

    /**
     * The spend has expired and cannot be claimed.
     **/
    SpendExpired: GenericPalletError;

    /**
     * The spend is not yet eligible for payout.
     **/
    EarlyPayout: GenericPalletError;

    /**
     * The payment has already been attempted.
     **/
    AlreadyAttempted: GenericPalletError;

    /**
     * There was some issue with the mechanism of payment.
     **/
    PayoutError: GenericPalletError;

    /**
     * The payout was not yet attempted/claimed.
     **/
    NotAttempted: GenericPalletError;

    /**
     * The payment has neither failed nor succeeded yet.
     **/
    Inconclusive: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `CrowdloanRewards`'s errors
   **/
  crowdloanRewards: {
    /**
     * User trying to associate a native identity with a relay chain identity for posterior
     * reward claiming provided an already associated relay chain identity
     **/
    AlreadyAssociated: GenericPalletError;

    /**
     * Trying to introduce a batch that goes beyond the limits of the funds
     **/
    BatchBeyondFundPot: GenericPalletError;

    /**
     * First claim already done
     **/
    FirstClaimAlreadyDone: GenericPalletError;

    /**
     * The contribution is not high enough to be eligible for rewards
     **/
    RewardNotHighEnough: GenericPalletError;

    /**
     * User trying to associate a native identity with a relay chain identity for posterior
     * reward claiming provided a wrong signature
     **/
    InvalidClaimSignature: GenericPalletError;

    /**
     * User trying to claim the first free reward provided the wrong signature
     **/
    InvalidFreeClaimSignature: GenericPalletError;

    /**
     * User trying to claim an award did not have an claim associated with it. This may mean
     * they did not contribute to the crowdloan, or they have not yet associated a native id
     * with their contribution
     **/
    NoAssociatedClaim: GenericPalletError;

    /**
     * User trying to claim rewards has already claimed all rewards associated with its
     * identity and contribution
     **/
    RewardsAlreadyClaimed: GenericPalletError;

    /**
     * Reward vec has already been initialized
     **/
    RewardVecAlreadyInitialized: GenericPalletError;

    /**
     * Reward vec has not yet been fully initialized
     **/
    RewardVecNotFullyInitializedYet: GenericPalletError;

    /**
     * Rewards should match funds of the pallet
     **/
    RewardsDoNotMatchFund: GenericPalletError;

    /**
     * Initialize_reward_vec received too many contributors
     **/
    TooManyContributors: GenericPalletError;

    /**
     * Provided vesting period is not valid
     **/
    VestingPeriodNonValid: GenericPalletError;

    /**
     * User provided a signature from a non-contributor relay account
     **/
    NonContributedAddressProvided: GenericPalletError;

    /**
     * User submitted an unsifficient number of proofs to change the reward address
     **/
    InsufficientNumberOfValidProofs: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `XcmpQueue`'s errors
   **/
  xcmpQueue: {
    /**
     * Setting the queue config failed since one of its values was invalid.
     **/
    BadQueueConfig: GenericPalletError;

    /**
     * The execution is already suspended.
     **/
    AlreadySuspended: GenericPalletError;

    /**
     * The execution is already resumed.
     **/
    AlreadyResumed: GenericPalletError;

    /**
     * There are too many active outbound channels.
     **/
    TooManyActiveOutboundChannels: GenericPalletError;

    /**
     * The message is too big.
     **/
    TooBig: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `PolkadotXcm`'s errors
   **/
  polkadotXcm: {
    /**
     * The desired destination was unreachable, generally because there is a no way of routing
     * to it.
     **/
    Unreachable: GenericPalletError;

    /**
     * There was some other issue (i.e. not to do with routing) in sending the message.
     * Perhaps a lack of space for buffering the message.
     **/
    SendFailure: GenericPalletError;

    /**
     * The message execution fails the filter.
     **/
    Filtered: GenericPalletError;

    /**
     * The message's weight could not be determined.
     **/
    UnweighableMessage: GenericPalletError;

    /**
     * The destination `Location` provided cannot be inverted.
     **/
    DestinationNotInvertible: GenericPalletError;

    /**
     * The assets to be sent are empty.
     **/
    Empty: GenericPalletError;

    /**
     * Could not re-anchor the assets to declare the fees for the destination chain.
     **/
    CannotReanchor: GenericPalletError;

    /**
     * Too many assets have been attempted for transfer.
     **/
    TooManyAssets: GenericPalletError;

    /**
     * Origin is invalid for sending.
     **/
    InvalidOrigin: GenericPalletError;

    /**
     * The version of the `Versioned` value used is not able to be interpreted.
     **/
    BadVersion: GenericPalletError;

    /**
     * The given location could not be used (e.g. because it cannot be expressed in the
     * desired version of XCM).
     **/
    BadLocation: GenericPalletError;

    /**
     * The referenced subscription could not be found.
     **/
    NoSubscription: GenericPalletError;

    /**
     * The location is invalid since it already has a subscription from us.
     **/
    AlreadySubscribed: GenericPalletError;

    /**
     * Could not check-out the assets for teleportation to the destination chain.
     **/
    CannotCheckOutTeleport: GenericPalletError;

    /**
     * The owner does not own (all) of the asset that they wish to do the operation on.
     **/
    LowBalance: GenericPalletError;

    /**
     * The asset owner has too many locks on the asset.
     **/
    TooManyLocks: GenericPalletError;

    /**
     * The given account is not an identifiable sovereign account for any location.
     **/
    AccountNotSovereign: GenericPalletError;

    /**
     * The operation required fees to be paid which the initiator could not meet.
     **/
    FeesNotMet: GenericPalletError;

    /**
     * A remote lock with the corresponding data could not be found.
     **/
    LockNotFound: GenericPalletError;

    /**
     * The unlock operation cannot succeed because there are still consumers of the lock.
     **/
    InUse: GenericPalletError;

    /**
     * Invalid asset, reserve chain could not be determined for it.
     **/
    InvalidAssetUnknownReserve: GenericPalletError;

    /**
     * Invalid asset, do not support remote asset reserves with different fees reserves.
     **/
    InvalidAssetUnsupportedReserve: GenericPalletError;

    /**
     * Too many assets with different reserve locations have been attempted for transfer.
     **/
    TooManyReserves: GenericPalletError;

    /**
     * Local XCM execution incomplete.
     **/
    LocalExecutionIncomplete: GenericPalletError;

    /**
     * Too many locations authorized to alias origin.
     **/
    TooManyAuthorizedAliases: GenericPalletError;

    /**
     * Expiry block number is in the past.
     **/
    ExpiresInPast: GenericPalletError;

    /**
     * The alias to remove authorization for was not found.
     **/
    AliasNotFound: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Assets`'s errors
   **/
  assets: {
    /**
     * Account balance must be greater than or equal to the transfer amount.
     **/
    BalanceLow: GenericPalletError;

    /**
     * The account to alter does not exist.
     **/
    NoAccount: GenericPalletError;

    /**
     * The signing account has no permission to do the operation.
     **/
    NoPermission: GenericPalletError;

    /**
     * The given asset ID is unknown.
     **/
    Unknown: GenericPalletError;

    /**
     * The origin account is frozen.
     **/
    Frozen: GenericPalletError;

    /**
     * The asset ID is already taken.
     **/
    InUse: GenericPalletError;

    /**
     * Invalid witness data given.
     **/
    BadWitness: GenericPalletError;

    /**
     * Minimum balance should be non-zero.
     **/
    MinBalanceZero: GenericPalletError;

    /**
     * Unable to increment the consumer reference counters on the account. Either no provider
     * reference exists to allow a non-zero balance of a non-self-sufficient asset, or one
     * fewer then the maximum number of consumers has been reached.
     **/
    UnavailableConsumer: GenericPalletError;

    /**
     * Invalid metadata given.
     **/
    BadMetadata: GenericPalletError;

    /**
     * No approval exists that would allow the transfer.
     **/
    Unapproved: GenericPalletError;

    /**
     * The source account would not survive the transfer and it needs to stay alive.
     **/
    WouldDie: GenericPalletError;

    /**
     * The asset-account already exists.
     **/
    AlreadyExists: GenericPalletError;

    /**
     * The asset-account doesn't have an associated deposit.
     **/
    NoDeposit: GenericPalletError;

    /**
     * The operation would result in funds being burned.
     **/
    WouldBurn: GenericPalletError;

    /**
     * The asset is a live asset and is actively being used. Usually emit for operations such
     * as `start_destroy` which require the asset to be in a destroying state.
     **/
    LiveAsset: GenericPalletError;

    /**
     * The asset is not live, and likely being destroyed.
     **/
    AssetNotLive: GenericPalletError;

    /**
     * The asset status is not the expected status.
     **/
    IncorrectStatus: GenericPalletError;

    /**
     * The asset should be frozen before the given operation.
     **/
    NotFrozen: GenericPalletError;

    /**
     * Callback action resulted in error
     **/
    CallbackFailed: GenericPalletError;

    /**
     * The asset ID must be equal to the [`NextAssetId`].
     **/
    BadAssetId: GenericPalletError;

    /**
     * The asset cannot be destroyed because some accounts for this asset contain freezes.
     **/
    ContainsFreezes: GenericPalletError;

    /**
     * The asset cannot be destroyed because some accounts for this asset contain holds.
     **/
    ContainsHolds: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `XcmTransactor`'s errors
   **/
  xcmTransactor: {
    IndexAlreadyClaimed: GenericPalletError;
    UnclaimedIndex: GenericPalletError;
    NotOwner: GenericPalletError;
    UnweighableMessage: GenericPalletError;
    CannotReanchor: GenericPalletError;
    AssetHasNoReserve: GenericPalletError;
    InvalidDest: GenericPalletError;
    NotCrossChainTransfer: GenericPalletError;
    AssetIsNotReserveInDestination: GenericPalletError;
    DestinationNotInvertible: GenericPalletError;
    ErrorDelivering: GenericPalletError;
    DispatchWeightBiggerThanTotalWeight: GenericPalletError;
    WeightOverflow: GenericPalletError;
    AmountOverflow: GenericPalletError;
    TransactorInfoNotSet: GenericPalletError;
    NotCrossChainTransferableCurrency: GenericPalletError;
    XcmExecuteError: GenericPalletError;
    BadVersion: GenericPalletError;
    MaxWeightTransactReached: GenericPalletError;
    UnableToWithdrawAsset: GenericPalletError;
    FeePerSecondNotSet: GenericPalletError;
    SignedTransactNotAllowedForDestination: GenericPalletError;
    FailedMultiLocationToJunction: GenericPalletError;
    HrmpHandlerNotImplemented: GenericPalletError;
    TooMuchFeeUsed: GenericPalletError;
    ErrorValidating: GenericPalletError;
    RefundNotSupportedWithTransactInfo: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `EthereumXcm`'s errors
   **/
  ethereumXcm: {
    /**
     * Xcm to Ethereum execution is suspended
     **/
    EthereumXcmExecutionSuspended: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `MessageQueue`'s errors
   **/
  messageQueue: {
    /**
     * Page is not reapable because it has items remaining to be processed and is not old
     * enough.
     **/
    NotReapable: GenericPalletError;

    /**
     * Page to be reaped does not exist.
     **/
    NoPage: GenericPalletError;

    /**
     * The referenced message could not be found.
     **/
    NoMessage: GenericPalletError;

    /**
     * The message was already processed and cannot be processed again.
     **/
    AlreadyProcessed: GenericPalletError;

    /**
     * The message is queued for future execution.
     **/
    Queued: GenericPalletError;

    /**
     * There is temporarily not enough weight to continue servicing messages.
     **/
    InsufficientWeight: GenericPalletError;

    /**
     * This message is temporarily unprocessable.
     *
     * Such errors are expected, but not guaranteed, to resolve themselves eventually through
     * retrying.
     **/
    TemporarilyUnprocessable: GenericPalletError;

    /**
     * The queue is paused and no message can be executed from it.
     *
     * This can change at any time and may resolve in the future by re-trying.
     **/
    QueuePaused: GenericPalletError;

    /**
     * Another call is in progress and needs to finish before this call can happen.
     **/
    RecursiveDisallowed: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `EvmForeignAssets`'s errors
   **/
  evmForeignAssets: {
    AssetAlreadyExists: GenericPalletError;
    AssetAlreadyFrozen: GenericPalletError;
    AssetDoesNotExist: GenericPalletError;
    AssetIdFiltered: GenericPalletError;
    AssetNotFrozen: GenericPalletError;
    CorruptedStorageOrphanLocation: GenericPalletError;
    Erc20ContractCreationFail: GenericPalletError;
    EvmCallPauseFail: GenericPalletError;
    EvmCallUnpauseFail: GenericPalletError;
    EvmCallMintIntoFail: GenericPalletError;
    EvmCallTransferFail: GenericPalletError;
    EvmInternalError: GenericPalletError;

    /**
     * Account has insufficient balance for locking
     **/
    InsufficientBalance: GenericPalletError;
    CannotConvertLocationToAccount: GenericPalletError;
    LocationOutsideOfOrigin: GenericPalletError;
    AssetNotInSiblingPara: GenericPalletError;
    InvalidSymbol: GenericPalletError;
    InvalidTokenName: GenericPalletError;
    LocationAlreadyExists: GenericPalletError;
    TooManyForeignAssets: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `XcmWeightTrader`'s errors
   **/
  xcmWeightTrader: {
    /**
     * The given asset was already added
     **/
    AssetAlreadyAdded: GenericPalletError;

    /**
     * The given asset was already paused
     **/
    AssetAlreadyPaused: GenericPalletError;

    /**
     * The given asset was not found
     **/
    AssetNotFound: GenericPalletError;

    /**
     * The given asset is not paused
     **/
    AssetNotPaused: GenericPalletError;

    /**
     * XCM location filtered
     **/
    XcmLocationFiltered: GenericPalletError;

    /**
     * The relative price cannot be zero
     **/
    PriceCannotBeZero: GenericPalletError;

    /**
     * The relative price calculation overflowed
     **/
    PriceOverflow: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `EmergencyParaXcm`'s errors
   **/
  emergencyParaXcm: {
    /**
     * The current XCM Mode is not Paused
     **/
    NotInPausedMode: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `MultiBlockMigrations`'s errors
   **/
  multiBlockMigrations: {
    /**
     * The operation cannot complete since some MBMs are ongoing.
     **/
    Ongoing: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `Randomness`'s errors
   **/
  randomness: {
    RequestCounterOverflowed: GenericPalletError;
    RequestFeeOverflowed: GenericPalletError;
    MustRequestAtLeastOneWord: GenericPalletError;
    CannotRequestMoreWordsThanMax: GenericPalletError;
    CannotRequestRandomnessAfterMaxDelay: GenericPalletError;
    CannotRequestRandomnessBeforeMinDelay: GenericPalletError;
    RequestDNE: GenericPalletError;
    RequestCannotYetBeFulfilled: GenericPalletError;
    OnlyRequesterCanIncreaseFee: GenericPalletError;
    RequestHasNotExpired: GenericPalletError;
    RandomnessResultDNE: GenericPalletError;
    RandomnessResultNotFilled: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `BridgeKusamaGrandpa`'s errors
   **/
  bridgeKusamaGrandpa: {
    /**
     * The given justification is invalid for the given header.
     **/
    InvalidJustification: GenericPalletError;

    /**
     * The authority set from the underlying header chain is invalid.
     **/
    InvalidAuthoritySet: GenericPalletError;

    /**
     * The header being imported is older than the best finalized header known to the pallet.
     **/
    OldHeader: GenericPalletError;

    /**
     * The scheduled authority set change found in the header is unsupported by the pallet.
     *
     * This is the case for non-standard (e.g forced) authority set changes.
     **/
    UnsupportedScheduledChange: GenericPalletError;

    /**
     * The pallet is not yet initialized.
     **/
    NotInitialized: GenericPalletError;

    /**
     * The pallet has already been initialized.
     **/
    AlreadyInitialized: GenericPalletError;

    /**
     * Too many authorities in the set.
     **/
    TooManyAuthoritiesInSet: GenericPalletError;

    /**
     * Error generated by the `OwnedBridgeModule` trait.
     **/
    BridgeModule: GenericPalletError;

    /**
     * The `current_set_id` argument of the `submit_finality_proof_ex` doesn't match
     * the id of the current set, known to the pallet.
     **/
    InvalidAuthoritySetId: GenericPalletError;

    /**
     * The submitter wanted free execution, but we can't fit more free transactions
     * to the block.
     **/
    FreeHeadersLimitExceded: GenericPalletError;

    /**
     * The submitter wanted free execution, but the difference between best known and
     * bundled header numbers is below the `FreeHeadersInterval`.
     **/
    BelowFreeHeaderInterval: GenericPalletError;

    /**
     * The header (and its finality) submission overflows hardcoded chain limits: size
     * and/or weight are larger than expected.
     **/
    HeaderOverflowLimits: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `BridgeKusamaParachains`'s errors
   **/
  bridgeKusamaParachains: {
    /**
     * Relay chain block hash is unknown to us.
     **/
    UnknownRelayChainBlock: GenericPalletError;

    /**
     * The number of stored relay block is different from what the relayer has provided.
     **/
    InvalidRelayChainBlockNumber: GenericPalletError;

    /**
     * Parachain heads storage proof is invalid.
     **/
    HeaderChainStorageProof: GenericPalletError;

    /**
     * Error generated by the `OwnedBridgeModule` trait.
     **/
    BridgeModule: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `BridgeKusamaMessages`'s errors
   **/
  bridgeKusamaMessages: {
    /**
     * Pallet is not in Normal operating mode.
     **/
    NotOperatingNormally: GenericPalletError;

    /**
     * Error that is reported by the lanes manager.
     **/
    LanesManager: GenericPalletError;

    /**
     * Message has been treated as invalid by the pallet logic.
     **/
    MessageRejectedByPallet: GenericPalletError;

    /**
     * The transaction brings too many messages.
     **/
    TooManyMessagesInTheProof: GenericPalletError;

    /**
     * Invalid messages has been submitted.
     **/
    InvalidMessagesProof: GenericPalletError;

    /**
     * Invalid messages delivery proof has been submitted.
     **/
    InvalidMessagesDeliveryProof: GenericPalletError;

    /**
     * The relayer has declared invalid unrewarded relayers state in the
     * `receive_messages_delivery_proof` call.
     **/
    InvalidUnrewardedRelayersState: GenericPalletError;

    /**
     * The cumulative dispatch weight, passed by relayer is not enough to cover dispatch
     * of all bundled messages.
     **/
    InsufficientDispatchWeight: GenericPalletError;

    /**
     * Error confirming messages receival.
     **/
    ReceptionConfirmation: GenericPalletError;

    /**
     * Error generated by the `OwnedBridgeModule` trait.
     **/
    BridgeModule: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
  /**
   * Pallet `BridgeXcmOverMoonriver`'s errors
   **/
  bridgeXcmOverMoonriver: {
    /**
     * Bridge locations error.
     **/
    BridgeLocations: GenericPalletError;

    /**
     * Invalid local bridge origin account.
     **/
    InvalidBridgeOriginAccount: GenericPalletError;

    /**
     * The bridge is already registered in this pallet.
     **/
    BridgeAlreadyExists: GenericPalletError;

    /**
     * The local origin already owns a maximal number of bridges.
     **/
    TooManyBridgesForLocalOrigin: GenericPalletError;

    /**
     * Trying to close already closed bridge.
     **/
    BridgeAlreadyClosed: GenericPalletError;

    /**
     * Lanes manager error.
     **/
    LanesManager: GenericPalletError;

    /**
     * Trying to access unknown bridge.
     **/
    UnknownBridge: GenericPalletError;

    /**
     * The bridge origin can't pay the required amount for opening the bridge.
     **/
    FailedToReserveBridgeDeposit: GenericPalletError;

    /**
     * The version of XCM location argument is unsupported.
     **/
    UnsupportedXcmVersion: GenericPalletError;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError;
  };
}
