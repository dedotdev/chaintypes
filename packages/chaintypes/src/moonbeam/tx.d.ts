// Generated by dedot cli

import type {
  GenericChainTx,
  GenericTxCall,
  ISubmittableExtrinsic,
  ISubmittableResult,
  IRuntimeTxCall,
  RpcVersion,
  RpcV2,
  ISubmittableExtrinsicLegacy,
} from 'dedot/types';
import type {
  AccountId20Like,
  Extrinsic,
  BytesLike,
  H256,
  Perbill,
  Percent,
  Data,
  FixedBytes,
  H160,
  U256,
} from 'dedot/codecs';
import type {
  MoonbeamRuntimeRuntimeCallLike,
  AccountEthereumSignature,
  FrameSystemEventRecord,
  CumulusPrimitivesParachainInherentParachainInherentData,
  PalletBalancesAdjustmentDirection,
  PalletParachainStakingInflationDistributionConfig,
  PalletAuthorSlotFilterNumNonZeroU32,
  NimbusPrimitivesNimbusCryptoPublic,
  MoonbeamRuntimeOriginCaller,
  SpWeightsWeightV2Weight,
  MoonbeamRuntimeProxyType,
  PalletIdentityLegacyIdentityInfo,
  PalletIdentityJudgement,
  PalletMultisigTimepoint,
  MoonbeamRuntimeRuntimeParamsRuntimeParameters,
  EthereumTransactionTransactionV2,
  PalletConvictionVotingVoteAccountVote,
  PalletConvictionVotingConviction,
  FrameSupportPreimagesBounded,
  FrameSupportScheduleDispatchTime,
  SpRuntimeMultiSignature,
  XcmVersionedLocation,
  XcmVersionedXcm,
  XcmVersionedAssets,
  StagingXcmV4Location,
  XcmV3WeightLimit,
  StagingXcmExecutorAssetTransferTransferType,
  XcmVersionedAssetId,
  MoonbeamRuntimeXcmConfigAssetType,
  MoonbeamRuntimeAssetConfigAssetRegistrarMetadata,
  MoonbeamRuntimeXcmConfigTransactors,
  PalletXcmTransactorCurrencyPayment,
  PalletXcmTransactorTransactWeights,
  XcmV3OriginKind,
  PalletXcmTransactorHrmpOperation,
  XcmPrimitivesEthereumXcmEthereumXcmTransaction,
  CumulusPrimitivesCoreAggregateMessageOrigin,
} from './types';

export type ChainSubmittableExtrinsic<
  Rv extends RpcVersion,
  T extends IRuntimeTxCall = MoonbeamRuntimeRuntimeCallLike,
> = Extrinsic<AccountId20Like, T, AccountEthereumSignature, any[]> &
  (Rv extends RpcV2
    ? ISubmittableExtrinsic<ISubmittableResult<FrameSystemEventRecord>>
    : ISubmittableExtrinsicLegacy<ISubmittableResult<FrameSystemEventRecord>>);

export type TxCall<Rv extends RpcVersion> = (...args: any[]) => ChainSubmittableExtrinsic<Rv>;

export interface ChainTx<Rv extends RpcVersion> extends GenericChainTx<Rv, TxCall<Rv>> {
  /**
   * Pallet `System`'s transaction calls
   **/
  system: {
    /**
     * Make some on-chain remark.
     *
     * Can be executed by every `origin`.
     *
     * @param {BytesLike} remark
     **/
    remark: GenericTxCall<
      Rv,
      (remark: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'Remark';
            params: { remark: BytesLike };
          };
        }
      >
    >;

    /**
     * Set the number of pages in the WebAssembly environment's heap.
     *
     * @param {bigint} pages
     **/
    setHeapPages: GenericTxCall<
      Rv,
      (pages: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'SetHeapPages';
            params: { pages: bigint };
          };
        }
      >
    >;

    /**
     * Set the new runtime code.
     *
     * @param {BytesLike} code
     **/
    setCode: GenericTxCall<
      Rv,
      (code: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'SetCode';
            params: { code: BytesLike };
          };
        }
      >
    >;

    /**
     * Set the new runtime code without doing any checks of the given `code`.
     *
     * Note that runtime upgrades will not run if this is called with a not-increasing spec
     * version!
     *
     * @param {BytesLike} code
     **/
    setCodeWithoutChecks: GenericTxCall<
      Rv,
      (code: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'SetCodeWithoutChecks';
            params: { code: BytesLike };
          };
        }
      >
    >;

    /**
     * Set some items of storage.
     *
     * @param {Array<[BytesLike, BytesLike]>} items
     **/
    setStorage: GenericTxCall<
      Rv,
      (items: Array<[BytesLike, BytesLike]>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'SetStorage';
            params: { items: Array<[BytesLike, BytesLike]> };
          };
        }
      >
    >;

    /**
     * Kill some items from storage.
     *
     * @param {Array<BytesLike>} keys
     **/
    killStorage: GenericTxCall<
      Rv,
      (keys: Array<BytesLike>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'KillStorage';
            params: { keys: Array<BytesLike> };
          };
        }
      >
    >;

    /**
     * Kill all storage items with a key that starts with the given prefix.
     *
     * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
     * the prefix we are removing to accurately calculate the weight of this function.
     *
     * @param {BytesLike} prefix
     * @param {number} subkeys
     **/
    killPrefix: GenericTxCall<
      Rv,
      (
        prefix: BytesLike,
        subkeys: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'KillPrefix';
            params: { prefix: BytesLike; subkeys: number };
          };
        }
      >
    >;

    /**
     * Make some on-chain remark and emit event.
     *
     * @param {BytesLike} remark
     **/
    remarkWithEvent: GenericTxCall<
      Rv,
      (remark: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'RemarkWithEvent';
            params: { remark: BytesLike };
          };
        }
      >
    >;

    /**
     * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
     * later.
     *
     * This call requires Root origin.
     *
     * @param {H256} codeHash
     **/
    authorizeUpgrade: GenericTxCall<
      Rv,
      (codeHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'AuthorizeUpgrade';
            params: { codeHash: H256 };
          };
        }
      >
    >;

    /**
     * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
     * later.
     *
     * WARNING: This authorizes an upgrade that will take place without any safety checks, for
     * example that the spec name remains the same and that the version number increases. Not
     * recommended for normal use. Use `authorize_upgrade` instead.
     *
     * This call requires Root origin.
     *
     * @param {H256} codeHash
     **/
    authorizeUpgradeWithoutChecks: GenericTxCall<
      Rv,
      (codeHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'AuthorizeUpgradeWithoutChecks';
            params: { codeHash: H256 };
          };
        }
      >
    >;

    /**
     * Provide the preimage (runtime binary) `code` for an upgrade that has been authorized.
     *
     * If the authorization required a version check, this call will ensure the spec name
     * remains unchanged and that the spec version has increased.
     *
     * Depending on the runtime's `OnSetCode` configuration, this function may directly apply
     * the new `code` in the same block or attempt to schedule the upgrade.
     *
     * All origins are allowed.
     *
     * @param {BytesLike} code
     **/
    applyAuthorizedUpgrade: GenericTxCall<
      Rv,
      (code: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'System';
          palletCall: {
            name: 'ApplyAuthorizedUpgrade';
            params: { code: BytesLike };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `ParachainSystem`'s transaction calls
   **/
  parachainSystem: {
    /**
     * Set the current validation data.
     *
     * This should be invoked exactly once per block. It will panic at the finalization
     * phase if the call was not invoked.
     *
     * The dispatch origin for this call must be `Inherent`
     *
     * As a side effect, this function upgrades the current validation function
     * if the appropriate time has come.
     *
     * @param {CumulusPrimitivesParachainInherentParachainInherentData} data
     **/
    setValidationData: GenericTxCall<
      Rv,
      (data: CumulusPrimitivesParachainInherentParachainInherentData) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainSystem';
          palletCall: {
            name: 'SetValidationData';
            params: { data: CumulusPrimitivesParachainInherentParachainInherentData };
          };
        }
      >
    >;

    /**
     *
     * @param {BytesLike} message
     **/
    sudoSendUpwardMessage: GenericTxCall<
      Rv,
      (message: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainSystem';
          palletCall: {
            name: 'SudoSendUpwardMessage';
            params: { message: BytesLike };
          };
        }
      >
    >;

    /**
     * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
     * later.
     *
     * The `check_version` parameter sets a boolean flag for whether or not the runtime's spec
     * version and name should be verified on upgrade. Since the authorization only has a hash,
     * it cannot actually perform the verification.
     *
     * This call requires Root origin.
     *
     * @param {H256} codeHash
     * @param {boolean} checkVersion
     **/
    authorizeUpgrade: GenericTxCall<
      Rv,
      (
        codeHash: H256,
        checkVersion: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainSystem';
          palletCall: {
            name: 'AuthorizeUpgrade';
            params: { codeHash: H256; checkVersion: boolean };
          };
        }
      >
    >;

    /**
     * Provide the preimage (runtime binary) `code` for an upgrade that has been authorized.
     *
     * If the authorization required a version check, this call will ensure the spec name
     * remains unchanged and that the spec version has increased.
     *
     * Note that this function will not apply the new `code`, but only attempt to schedule the
     * upgrade with the Relay Chain.
     *
     * All origins are allowed.
     *
     * @param {BytesLike} code
     **/
    enactAuthorizedUpgrade: GenericTxCall<
      Rv,
      (code: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainSystem';
          palletCall: {
            name: 'EnactAuthorizedUpgrade';
            params: { code: BytesLike };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Timestamp`'s transaction calls
   **/
  timestamp: {
    /**
     * Set the current time.
     *
     * This call should be invoked exactly once per block. It will panic at the finalization
     * phase, if this call hasn't been invoked by that time.
     *
     * The timestamp should be greater than the previous one by the amount specified by
     * [`Config::MinimumPeriod`].
     *
     * The dispatch origin for this call must be _None_.
     *
     * This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware
     * that changing the complexity of this call could result exhausting the resources in a
     * block to execute any other calls.
     *
     * ## Complexity
     * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
     * - 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in
     * `on_finalize`)
     * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
     *
     * @param {bigint} now
     **/
    set: GenericTxCall<
      Rv,
      (now: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Timestamp';
          palletCall: {
            name: 'Set';
            params: { now: bigint };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `RootTesting`'s transaction calls
   **/
  rootTesting: {
    /**
     * A dispatch that will fill the block weight up to the given ratio.
     *
     * @param {Perbill} ratio
     **/
    fillBlock: GenericTxCall<
      Rv,
      (ratio: Perbill) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'RootTesting';
          palletCall: {
            name: 'FillBlock';
            params: { ratio: Perbill };
          };
        }
      >
    >;

    /**
     *
     **/
    triggerDefensive: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'RootTesting';
          palletCall: {
            name: 'TriggerDefensive';
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Balances`'s transaction calls
   **/
  balances: {
    /**
     * Transfer some liquid free balance to another account.
     *
     * `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
     * If the sender's account is below the existential deposit as a result
     * of the transfer, the account will be reaped.
     *
     * The dispatch origin for this call must be `Signed` by the transactor.
     *
     * @param {AccountId20Like} dest
     * @param {bigint} value
     **/
    transferAllowDeath: GenericTxCall<
      Rv,
      (
        dest: AccountId20Like,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'TransferAllowDeath';
            params: { dest: AccountId20Like; value: bigint };
          };
        }
      >
    >;

    /**
     * Exactly as `transfer_allow_death`, except the origin must be root and the source account
     * may be specified.
     *
     * @param {AccountId20Like} source
     * @param {AccountId20Like} dest
     * @param {bigint} value
     **/
    forceTransfer: GenericTxCall<
      Rv,
      (
        source: AccountId20Like,
        dest: AccountId20Like,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'ForceTransfer';
            params: { source: AccountId20Like; dest: AccountId20Like; value: bigint };
          };
        }
      >
    >;

    /**
     * Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
     * kill the origin account.
     *
     * 99% of the time you want [`transfer_allow_death`] instead.
     *
     * [`transfer_allow_death`]: struct.Pallet.html#method.transfer
     *
     * @param {AccountId20Like} dest
     * @param {bigint} value
     **/
    transferKeepAlive: GenericTxCall<
      Rv,
      (
        dest: AccountId20Like,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'TransferKeepAlive';
            params: { dest: AccountId20Like; value: bigint };
          };
        }
      >
    >;

    /**
     * Transfer the entire transferable balance from the caller account.
     *
     * NOTE: This function only attempts to transfer _transferable_ balances. This means that
     * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
     * transferred by this function. To ensure that this function results in a killed account,
     * you might need to prepare the account by removing any reference counters, storage
     * deposits, etc...
     *
     * The dispatch origin of this call must be Signed.
     *
     * - `dest`: The recipient of the transfer.
     * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
     * of the funds the account has, causing the sender account to be killed (false), or
     * transfer everything except at least the existential deposit, which will guarantee to
     * keep the sender account alive (true).
     *
     * @param {AccountId20Like} dest
     * @param {boolean} keepAlive
     **/
    transferAll: GenericTxCall<
      Rv,
      (
        dest: AccountId20Like,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'TransferAll';
            params: { dest: AccountId20Like; keepAlive: boolean };
          };
        }
      >
    >;

    /**
     * Unreserve some balance from a user by force.
     *
     * Can only be called by ROOT.
     *
     * @param {AccountId20Like} who
     * @param {bigint} amount
     **/
    forceUnreserve: GenericTxCall<
      Rv,
      (
        who: AccountId20Like,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'ForceUnreserve';
            params: { who: AccountId20Like; amount: bigint };
          };
        }
      >
    >;

    /**
     * Upgrade a specified account.
     *
     * - `origin`: Must be `Signed`.
     * - `who`: The account to be upgraded.
     *
     * This will waive the transaction fee if at least all but 10% of the accounts needed to
     * be upgraded. (We let some not have to be upgraded just in order to allow for the
     * possibility of churn).
     *
     * @param {Array<AccountId20Like>} who
     **/
    upgradeAccounts: GenericTxCall<
      Rv,
      (who: Array<AccountId20Like>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'UpgradeAccounts';
            params: { who: Array<AccountId20Like> };
          };
        }
      >
    >;

    /**
     * Set the regular balance of a given account.
     *
     * The dispatch origin for this call is `root`.
     *
     * @param {AccountId20Like} who
     * @param {bigint} newFree
     **/
    forceSetBalance: GenericTxCall<
      Rv,
      (
        who: AccountId20Like,
        newFree: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'ForceSetBalance';
            params: { who: AccountId20Like; newFree: bigint };
          };
        }
      >
    >;

    /**
     * Adjust the total issuance in a saturating way.
     *
     * Can only be called by root and always needs a positive `delta`.
     *
     * # Example
     *
     * @param {PalletBalancesAdjustmentDirection} direction
     * @param {bigint} delta
     **/
    forceAdjustTotalIssuance: GenericTxCall<
      Rv,
      (
        direction: PalletBalancesAdjustmentDirection,
        delta: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'ForceAdjustTotalIssuance';
            params: { direction: PalletBalancesAdjustmentDirection; delta: bigint };
          };
        }
      >
    >;

    /**
     * Burn the specified liquid free balance from the origin account.
     *
     * If the origin's account ends up below the existential deposit as a result
     * of the burn and `keep_alive` is false, the account will be reaped.
     *
     * Unlike sending funds to a _burn_ address, which merely makes the funds inaccessible,
     * this `burn` operation will reduce total issuance by the amount _burned_.
     *
     * @param {bigint} value
     * @param {boolean} keepAlive
     **/
    burn: GenericTxCall<
      Rv,
      (
        value: bigint,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Balances';
          palletCall: {
            name: 'Burn';
            params: { value: bigint; keepAlive: boolean };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `ParachainStaking`'s transaction calls
   **/
  parachainStaking: {
    /**
     * Set the expectations for total staked. These expectations determine the issuance for
     * the round according to logic in `fn compute_issuance`
     *
     * @param {{min: bigint, ideal: bigint, max: bigint}} expectations
     **/
    setStakingExpectations: GenericTxCall<
      Rv,
      (expectations: { min: bigint; ideal: bigint; max: bigint }) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'SetStakingExpectations';
            params: { expectations: { min: bigint; ideal: bigint; max: bigint } };
          };
        }
      >
    >;

    /**
     * Set the annual inflation rate to derive per-round inflation
     *
     * @param {{min: Perbill, ideal: Perbill, max: Perbill}} schedule
     **/
    setInflation: GenericTxCall<
      Rv,
      (schedule: { min: Perbill; ideal: Perbill; max: Perbill }) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'SetInflation';
            params: { schedule: { min: Perbill; ideal: Perbill; max: Perbill } };
          };
        }
      >
    >;

    /**
     * Deprecated: please use `set_inflation_distribution_config` instead.
     *
     * Set the account that will hold funds set aside for parachain bond
     *
     * @param {AccountId20Like} new_
     **/
    setParachainBondAccount: GenericTxCall<
      Rv,
      (new_: AccountId20Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'SetParachainBondAccount';
            params: { new: AccountId20Like };
          };
        }
      >
    >;

    /**
     * Deprecated: please use `set_inflation_distribution_config` instead.
     *
     * Set the percent of inflation set aside for parachain bond
     *
     * @param {Percent} new_
     **/
    setParachainBondReservePercent: GenericTxCall<
      Rv,
      (new_: Percent) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'SetParachainBondReservePercent';
            params: { new: Percent };
          };
        }
      >
    >;

    /**
     * Set the total number of collator candidates selected per round
     * - changes are not applied until the start of the next round
     *
     * @param {number} new_
     **/
    setTotalSelected: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'SetTotalSelected';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Set the commission for all collators
     *
     * @param {Perbill} new_
     **/
    setCollatorCommission: GenericTxCall<
      Rv,
      (new_: Perbill) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'SetCollatorCommission';
            params: { new: Perbill };
          };
        }
      >
    >;

    /**
     * Set blocks per round
     * - if called with `new` less than length of current round, will transition immediately
     * in the next block
     * - also updates per-round inflation config
     *
     * @param {number} new_
     **/
    setBlocksPerRound: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'SetBlocksPerRound';
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Join the set of collator candidates
     *
     * @param {bigint} bond
     * @param {number} candidateCount
     **/
    joinCandidates: GenericTxCall<
      Rv,
      (
        bond: bigint,
        candidateCount: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'JoinCandidates';
            params: { bond: bigint; candidateCount: number };
          };
        }
      >
    >;

    /**
     * Request to leave the set of candidates. If successful, the account is immediately
     * removed from the candidate pool to prevent selection as a collator.
     *
     * @param {number} candidateCount
     **/
    scheduleLeaveCandidates: GenericTxCall<
      Rv,
      (candidateCount: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'ScheduleLeaveCandidates';
            params: { candidateCount: number };
          };
        }
      >
    >;

    /**
     * Execute leave candidates request
     *
     * @param {AccountId20Like} candidate
     * @param {number} candidateDelegationCount
     **/
    executeLeaveCandidates: GenericTxCall<
      Rv,
      (
        candidate: AccountId20Like,
        candidateDelegationCount: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'ExecuteLeaveCandidates';
            params: { candidate: AccountId20Like; candidateDelegationCount: number };
          };
        }
      >
    >;

    /**
     * Cancel open request to leave candidates
     * - only callable by collator account
     * - result upon successful call is the candidate is active in the candidate pool
     *
     * @param {number} candidateCount
     **/
    cancelLeaveCandidates: GenericTxCall<
      Rv,
      (candidateCount: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'CancelLeaveCandidates';
            params: { candidateCount: number };
          };
        }
      >
    >;

    /**
     * Temporarily leave the set of collator candidates without unbonding
     *
     **/
    goOffline: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'GoOffline';
          };
        }
      >
    >;

    /**
     * Rejoin the set of collator candidates if previously had called `go_offline`
     *
     **/
    goOnline: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'GoOnline';
          };
        }
      >
    >;

    /**
     * Increase collator candidate self bond by `more`
     *
     * @param {bigint} more
     **/
    candidateBondMore: GenericTxCall<
      Rv,
      (more: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'CandidateBondMore';
            params: { more: bigint };
          };
        }
      >
    >;

    /**
     * Request by collator candidate to decrease self bond by `less`
     *
     * @param {bigint} less
     **/
    scheduleCandidateBondLess: GenericTxCall<
      Rv,
      (less: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'ScheduleCandidateBondLess';
            params: { less: bigint };
          };
        }
      >
    >;

    /**
     * Execute pending request to adjust the collator candidate self bond
     *
     * @param {AccountId20Like} candidate
     **/
    executeCandidateBondLess: GenericTxCall<
      Rv,
      (candidate: AccountId20Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'ExecuteCandidateBondLess';
            params: { candidate: AccountId20Like };
          };
        }
      >
    >;

    /**
     * Cancel pending request to adjust the collator candidate self bond
     *
     **/
    cancelCandidateBondLess: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'CancelCandidateBondLess';
          };
        }
      >
    >;

    /**
     * DEPRECATED use delegateWithAutoCompound
     * If caller is not a delegator and not a collator, then join the set of delegators
     * If caller is a delegator, then makes delegation to change their delegation state
     *
     * @param {AccountId20Like} candidate
     * @param {bigint} amount
     * @param {number} candidateDelegationCount
     * @param {number} delegationCount
     **/
    delegate: GenericTxCall<
      Rv,
      (
        candidate: AccountId20Like,
        amount: bigint,
        candidateDelegationCount: number,
        delegationCount: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'Delegate';
            params: {
              candidate: AccountId20Like;
              amount: bigint;
              candidateDelegationCount: number;
              delegationCount: number;
            };
          };
        }
      >
    >;

    /**
     * If caller is not a delegator and not a collator, then join the set of delegators
     * If caller is a delegator, then makes delegation to change their delegation state
     * Sets the auto-compound config for the delegation
     *
     * @param {AccountId20Like} candidate
     * @param {bigint} amount
     * @param {Percent} autoCompound
     * @param {number} candidateDelegationCount
     * @param {number} candidateAutoCompoundingDelegationCount
     * @param {number} delegationCount
     **/
    delegateWithAutoCompound: GenericTxCall<
      Rv,
      (
        candidate: AccountId20Like,
        amount: bigint,
        autoCompound: Percent,
        candidateDelegationCount: number,
        candidateAutoCompoundingDelegationCount: number,
        delegationCount: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'DelegateWithAutoCompound';
            params: {
              candidate: AccountId20Like;
              amount: bigint;
              autoCompound: Percent;
              candidateDelegationCount: number;
              candidateAutoCompoundingDelegationCount: number;
              delegationCount: number;
            };
          };
        }
      >
    >;

    /**
     * REMOVED, was schedule_leave_delegators
     *
     **/
    removedCall19: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'RemovedCall19';
          };
        }
      >
    >;

    /**
     * REMOVED, was execute_leave_delegators
     *
     **/
    removedCall20: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'RemovedCall20';
          };
        }
      >
    >;

    /**
     * REMOVED, was cancel_leave_delegators
     *
     **/
    removedCall21: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'RemovedCall21';
          };
        }
      >
    >;

    /**
     * Request to revoke an existing delegation. If successful, the delegation is scheduled
     * to be allowed to be revoked via the `execute_delegation_request` extrinsic.
     * The delegation receives no rewards for the rounds while a revoke is pending.
     * A revoke may not be performed if any other scheduled request is pending.
     *
     * @param {AccountId20Like} collator
     **/
    scheduleRevokeDelegation: GenericTxCall<
      Rv,
      (collator: AccountId20Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'ScheduleRevokeDelegation';
            params: { collator: AccountId20Like };
          };
        }
      >
    >;

    /**
     * Bond more for delegators wrt a specific collator candidate.
     *
     * @param {AccountId20Like} candidate
     * @param {bigint} more
     **/
    delegatorBondMore: GenericTxCall<
      Rv,
      (
        candidate: AccountId20Like,
        more: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'DelegatorBondMore';
            params: { candidate: AccountId20Like; more: bigint };
          };
        }
      >
    >;

    /**
     * Request bond less for delegators wrt a specific collator candidate. The delegation's
     * rewards for rounds while the request is pending use the reduced bonded amount.
     * A bond less may not be performed if any other scheduled request is pending.
     *
     * @param {AccountId20Like} candidate
     * @param {bigint} less
     **/
    scheduleDelegatorBondLess: GenericTxCall<
      Rv,
      (
        candidate: AccountId20Like,
        less: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'ScheduleDelegatorBondLess';
            params: { candidate: AccountId20Like; less: bigint };
          };
        }
      >
    >;

    /**
     * Execute pending request to change an existing delegation
     *
     * @param {AccountId20Like} delegator
     * @param {AccountId20Like} candidate
     **/
    executeDelegationRequest: GenericTxCall<
      Rv,
      (
        delegator: AccountId20Like,
        candidate: AccountId20Like,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'ExecuteDelegationRequest';
            params: { delegator: AccountId20Like; candidate: AccountId20Like };
          };
        }
      >
    >;

    /**
     * Cancel request to change an existing delegation.
     *
     * @param {AccountId20Like} candidate
     **/
    cancelDelegationRequest: GenericTxCall<
      Rv,
      (candidate: AccountId20Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'CancelDelegationRequest';
            params: { candidate: AccountId20Like };
          };
        }
      >
    >;

    /**
     * Sets the auto-compounding reward percentage for a delegation.
     *
     * @param {AccountId20Like} candidate
     * @param {Percent} value
     * @param {number} candidateAutoCompoundingDelegationCountHint
     * @param {number} delegationCountHint
     **/
    setAutoCompound: GenericTxCall<
      Rv,
      (
        candidate: AccountId20Like,
        value: Percent,
        candidateAutoCompoundingDelegationCountHint: number,
        delegationCountHint: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'SetAutoCompound';
            params: {
              candidate: AccountId20Like;
              value: Percent;
              candidateAutoCompoundingDelegationCountHint: number;
              delegationCountHint: number;
            };
          };
        }
      >
    >;

    /**
     * Hotfix to remove existing empty entries for candidates that have left.
     *
     * @param {Array<AccountId20Like>} candidates
     **/
    hotfixRemoveDelegationRequestsExitedCandidates: GenericTxCall<
      Rv,
      (candidates: Array<AccountId20Like>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'HotfixRemoveDelegationRequestsExitedCandidates';
            params: { candidates: Array<AccountId20Like> };
          };
        }
      >
    >;

    /**
     * Notify a collator is inactive during MaxOfflineRounds
     *
     * @param {AccountId20Like} collator
     **/
    notifyInactiveCollator: GenericTxCall<
      Rv,
      (collator: AccountId20Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'NotifyInactiveCollator';
            params: { collator: AccountId20Like };
          };
        }
      >
    >;

    /**
     * Enable/Disable marking offline feature
     *
     * @param {boolean} value
     **/
    enableMarkingOffline: GenericTxCall<
      Rv,
      (value: boolean) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'EnableMarkingOffline';
            params: { value: boolean };
          };
        }
      >
    >;

    /**
     * Force join the set of collator candidates.
     * It will skip the minimum required bond check.
     *
     * @param {AccountId20Like} account
     * @param {bigint} bond
     * @param {number} candidateCount
     **/
    forceJoinCandidates: GenericTxCall<
      Rv,
      (
        account: AccountId20Like,
        bond: bigint,
        candidateCount: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'ForceJoinCandidates';
            params: { account: AccountId20Like; bond: bigint; candidateCount: number };
          };
        }
      >
    >;

    /**
     * Set the inflation distribution configuration.
     *
     * @param {PalletParachainStakingInflationDistributionConfig} new_
     **/
    setInflationDistributionConfig: GenericTxCall<
      Rv,
      (new_: PalletParachainStakingInflationDistributionConfig) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ParachainStaking';
          palletCall: {
            name: 'SetInflationDistributionConfig';
            params: { new: PalletParachainStakingInflationDistributionConfig };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `AuthorInherent`'s transaction calls
   **/
  authorInherent: {
    /**
     * This inherent is a workaround to run code after the "real" inherents have executed,
     * but before transactions are executed.
     *
     **/
    kickOffAuthorshipValidation: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'AuthorInherent';
          palletCall: 'KickOffAuthorshipValidation';
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `AuthorFilter`'s transaction calls
   **/
  authorFilter: {
    /**
     * Update the eligible count. Intended to be called by governance.
     *
     * @param {PalletAuthorSlotFilterNumNonZeroU32} new_
     **/
    setEligible: GenericTxCall<
      Rv,
      (new_: PalletAuthorSlotFilterNumNonZeroU32) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'AuthorFilter';
          palletCall: {
            name: 'SetEligible';
            params: { new: PalletAuthorSlotFilterNumNonZeroU32 };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `AuthorMapping`'s transaction calls
   **/
  authorMapping: {
    /**
     * Register your NimbusId onchain so blocks you author are associated with your account.
     *
     * Users who have been (or will soon be) elected active collators in staking,
     * should submit this extrinsic to have their blocks accepted and earn rewards.
     *
     * @param {NimbusPrimitivesNimbusCryptoPublic} nimbusId
     **/
    addAssociation: GenericTxCall<
      Rv,
      (nimbusId: NimbusPrimitivesNimbusCryptoPublic) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'AuthorMapping';
          palletCall: {
            name: 'AddAssociation';
            params: { nimbusId: NimbusPrimitivesNimbusCryptoPublic };
          };
        }
      >
    >;

    /**
     * Change your Mapping.
     *
     * This is useful for normal key rotation or for when switching from one physical collator
     * machine to another. No new security deposit is required.
     * This sets keys to new_nimbus_id.into() by default.
     *
     * @param {NimbusPrimitivesNimbusCryptoPublic} oldNimbusId
     * @param {NimbusPrimitivesNimbusCryptoPublic} newNimbusId
     **/
    updateAssociation: GenericTxCall<
      Rv,
      (
        oldNimbusId: NimbusPrimitivesNimbusCryptoPublic,
        newNimbusId: NimbusPrimitivesNimbusCryptoPublic,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'AuthorMapping';
          palletCall: {
            name: 'UpdateAssociation';
            params: {
              oldNimbusId: NimbusPrimitivesNimbusCryptoPublic;
              newNimbusId: NimbusPrimitivesNimbusCryptoPublic;
            };
          };
        }
      >
    >;

    /**
     * Clear your Mapping.
     *
     * This is useful when you are no longer an author and would like to re-claim your security
     * deposit.
     *
     * @param {NimbusPrimitivesNimbusCryptoPublic} nimbusId
     **/
    clearAssociation: GenericTxCall<
      Rv,
      (nimbusId: NimbusPrimitivesNimbusCryptoPublic) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'AuthorMapping';
          palletCall: {
            name: 'ClearAssociation';
            params: { nimbusId: NimbusPrimitivesNimbusCryptoPublic };
          };
        }
      >
    >;

    /**
     * Remove your Mapping.
     *
     * This is useful when you are no longer an author and would like to re-claim your security
     * deposit.
     *
     **/
    removeKeys: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'AuthorMapping';
          palletCall: {
            name: 'RemoveKeys';
          };
        }
      >
    >;

    /**
     * Set association and session keys at once.
     *
     * This is useful for key rotation to update Nimbus and VRF keys in one call.
     * No new security deposit is required. Will replace `update_association` which is kept
     * now for backwards compatibility reasons.
     *
     * @param {BytesLike} keys
     **/
    setKeys: GenericTxCall<
      Rv,
      (keys: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'AuthorMapping';
          palletCall: {
            name: 'SetKeys';
            params: { keys: BytesLike };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `MoonbeamOrbiters`'s transaction calls
   **/
  moonbeamOrbiters: {
    /**
     * Add an orbiter in a collator pool
     *
     * @param {AccountId20Like} orbiter
     **/
    collatorAddOrbiter: GenericTxCall<
      Rv,
      (orbiter: AccountId20Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'MoonbeamOrbiters';
          palletCall: {
            name: 'CollatorAddOrbiter';
            params: { orbiter: AccountId20Like };
          };
        }
      >
    >;

    /**
     * Remove an orbiter from the caller collator pool
     *
     * @param {AccountId20Like} orbiter
     **/
    collatorRemoveOrbiter: GenericTxCall<
      Rv,
      (orbiter: AccountId20Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'MoonbeamOrbiters';
          palletCall: {
            name: 'CollatorRemoveOrbiter';
            params: { orbiter: AccountId20Like };
          };
        }
      >
    >;

    /**
     * Remove the caller from the specified collator pool
     *
     * @param {AccountId20Like} collator
     **/
    orbiterLeaveCollatorPool: GenericTxCall<
      Rv,
      (collator: AccountId20Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'MoonbeamOrbiters';
          palletCall: {
            name: 'OrbiterLeaveCollatorPool';
            params: { collator: AccountId20Like };
          };
        }
      >
    >;

    /**
     * Registering as an orbiter
     *
     **/
    orbiterRegister: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'MoonbeamOrbiters';
          palletCall: {
            name: 'OrbiterRegister';
          };
        }
      >
    >;

    /**
     * Deregistering from orbiters
     *
     * @param {number} collatorsPoolCount
     **/
    orbiterUnregister: GenericTxCall<
      Rv,
      (collatorsPoolCount: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'MoonbeamOrbiters';
          palletCall: {
            name: 'OrbiterUnregister';
            params: { collatorsPoolCount: number };
          };
        }
      >
    >;

    /**
     * Add a collator to orbiters program.
     *
     * @param {AccountId20Like} collator
     **/
    addCollator: GenericTxCall<
      Rv,
      (collator: AccountId20Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'MoonbeamOrbiters';
          palletCall: {
            name: 'AddCollator';
            params: { collator: AccountId20Like };
          };
        }
      >
    >;

    /**
     * Remove a collator from orbiters program.
     *
     * @param {AccountId20Like} collator
     **/
    removeCollator: GenericTxCall<
      Rv,
      (collator: AccountId20Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'MoonbeamOrbiters';
          palletCall: {
            name: 'RemoveCollator';
            params: { collator: AccountId20Like };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Utility`'s transaction calls
   **/
  utility: {
    /**
     * Send a batch of dispatch calls.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     *
     * @param {Array<MoonbeamRuntimeRuntimeCallLike>} calls
     **/
    batch: GenericTxCall<
      Rv,
      (calls: Array<MoonbeamRuntimeRuntimeCallLike>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'Batch';
            params: { calls: Array<MoonbeamRuntimeRuntimeCallLike> };
          };
        }
      >
    >;

    /**
     * Send a call through an indexed pseudonym of the sender.
     *
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     *
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     *
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * @param {number} index
     * @param {MoonbeamRuntimeRuntimeCallLike} call
     **/
    asDerivative: GenericTxCall<
      Rv,
      (
        index: number,
        call: MoonbeamRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'AsDerivative';
            params: { index: number; call: MoonbeamRuntimeRuntimeCallLike };
          };
        }
      >
    >;

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * @param {Array<MoonbeamRuntimeRuntimeCallLike>} calls
     **/
    batchAll: GenericTxCall<
      Rv,
      (calls: Array<MoonbeamRuntimeRuntimeCallLike>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'BatchAll';
            params: { calls: Array<MoonbeamRuntimeRuntimeCallLike> };
          };
        }
      >
    >;

    /**
     * Dispatches a function call with a provided origin.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {MoonbeamRuntimeOriginCaller} asOrigin
     * @param {MoonbeamRuntimeRuntimeCallLike} call
     **/
    dispatchAs: GenericTxCall<
      Rv,
      (
        asOrigin: MoonbeamRuntimeOriginCaller,
        call: MoonbeamRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'DispatchAs';
            params: { asOrigin: MoonbeamRuntimeOriginCaller; call: MoonbeamRuntimeRuntimeCallLike };
          };
        }
      >
    >;

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * @param {Array<MoonbeamRuntimeRuntimeCallLike>} calls
     **/
    forceBatch: GenericTxCall<
      Rv,
      (calls: Array<MoonbeamRuntimeRuntimeCallLike>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'ForceBatch';
            params: { calls: Array<MoonbeamRuntimeRuntimeCallLike> };
          };
        }
      >
    >;

    /**
     * Dispatch a function call with a specified weight.
     *
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * @param {MoonbeamRuntimeRuntimeCallLike} call
     * @param {SpWeightsWeightV2Weight} weight
     **/
    withWeight: GenericTxCall<
      Rv,
      (
        call: MoonbeamRuntimeRuntimeCallLike,
        weight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Utility';
          palletCall: {
            name: 'WithWeight';
            params: { call: MoonbeamRuntimeRuntimeCallLike; weight: SpWeightsWeightV2Weight };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Proxy`'s transaction calls
   **/
  proxy: {
    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     *
     * @param {AccountId20Like} real
     * @param {MoonbeamRuntimeProxyType | undefined} forceProxyType
     * @param {MoonbeamRuntimeRuntimeCallLike} call
     **/
    proxy: GenericTxCall<
      Rv,
      (
        real: AccountId20Like,
        forceProxyType: MoonbeamRuntimeProxyType | undefined,
        call: MoonbeamRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'Proxy';
            params: {
              real: AccountId20Like;
              forceProxyType: MoonbeamRuntimeProxyType | undefined;
              call: MoonbeamRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Register a proxy account for the sender that is able to make calls on its behalf.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `proxy`: The account that the `caller` would like to make a proxy.
     * - `proxy_type`: The permissions allowed for this proxy account.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     *
     * @param {AccountId20Like} delegate
     * @param {MoonbeamRuntimeProxyType} proxyType
     * @param {number} delay
     **/
    addProxy: GenericTxCall<
      Rv,
      (
        delegate: AccountId20Like,
        proxyType: MoonbeamRuntimeProxyType,
        delay: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'AddProxy';
            params: { delegate: AccountId20Like; proxyType: MoonbeamRuntimeProxyType; delay: number };
          };
        }
      >
    >;

    /**
     * Unregister a proxy account for the sender.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `proxy`: The account that the `caller` would like to remove as a proxy.
     * - `proxy_type`: The permissions currently enabled for the removed proxy account.
     *
     * @param {AccountId20Like} delegate
     * @param {MoonbeamRuntimeProxyType} proxyType
     * @param {number} delay
     **/
    removeProxy: GenericTxCall<
      Rv,
      (
        delegate: AccountId20Like,
        proxyType: MoonbeamRuntimeProxyType,
        delay: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'RemoveProxy';
            params: { delegate: AccountId20Like; proxyType: MoonbeamRuntimeProxyType; delay: number };
          };
        }
      >
    >;

    /**
     * Unregister all proxy accounts for the sender.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * WARNING: This may be called on accounts created by `pure`, however if done, then
     * the unreserved fees will be inaccessible. **All access to this account will be lost.**
     *
     **/
    removeProxies: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'RemoveProxies';
          };
        }
      >
    >;

    /**
     * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
     * initialize it with a proxy of `proxy_type` for `origin` sender.
     *
     * Requires a `Signed` origin.
     *
     * - `proxy_type`: The type of the proxy that the sender will be registered as over the
     * new account. This will almost always be the most permissive `ProxyType` possible to
     * allow for maximum flexibility.
     * - `index`: A disambiguation index, in case this is called multiple times in the same
     * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
     * want to use `0`.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     *
     * Fails with `Duplicate` if this has already been called in this transaction, from the
     * same sender, with the same parameters.
     *
     * Fails if there are insufficient funds to pay for deposit.
     *
     * @param {MoonbeamRuntimeProxyType} proxyType
     * @param {number} delay
     * @param {number} index
     **/
    createPure: GenericTxCall<
      Rv,
      (
        proxyType: MoonbeamRuntimeProxyType,
        delay: number,
        index: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'CreatePure';
            params: { proxyType: MoonbeamRuntimeProxyType; delay: number; index: number };
          };
        }
      >
    >;

    /**
     * Removes a previously spawned pure proxy.
     *
     * WARNING: **All access to this account will be lost.** Any funds held in it will be
     * inaccessible.
     *
     * Requires a `Signed` origin, and the sender account must have been created by a call to
     * `pure` with corresponding parameters.
     *
     * - `spawner`: The account that originally called `pure` to create this account.
     * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
     * - `proxy_type`: The proxy type originally passed to `pure`.
     * - `height`: The height of the chain when the call to `pure` was processed.
     * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
     *
     * Fails with `NoPermission` in case the caller is not a previously created pure
     * account whose `pure` call has corresponding parameters.
     *
     * @param {AccountId20Like} spawner
     * @param {MoonbeamRuntimeProxyType} proxyType
     * @param {number} index
     * @param {number} height
     * @param {number} extIndex
     **/
    killPure: GenericTxCall<
      Rv,
      (
        spawner: AccountId20Like,
        proxyType: MoonbeamRuntimeProxyType,
        index: number,
        height: number,
        extIndex: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'KillPure';
            params: {
              spawner: AccountId20Like;
              proxyType: MoonbeamRuntimeProxyType;
              index: number;
              height: number;
              extIndex: number;
            };
          };
        }
      >
    >;

    /**
     * Publish the hash of a proxy-call that will be made in the future.
     *
     * This must be called some number of blocks before the corresponding `proxy` is attempted
     * if the delay associated with the proxy relationship is greater than zero.
     *
     * No more than `MaxPending` announcements may be made at any one time.
     *
     * This will take a deposit of `AnnouncementDepositFactor` as well as
     * `AnnouncementDepositBase` if there are no other pending announcements.
     *
     * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     *
     * @param {AccountId20Like} real
     * @param {H256} callHash
     **/
    announce: GenericTxCall<
      Rv,
      (
        real: AccountId20Like,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'Announce';
            params: { real: AccountId20Like; callHash: H256 };
          };
        }
      >
    >;

    /**
     * Remove a given announcement.
     *
     * May be called by a proxy account to remove a call they previously announced and return
     * the deposit.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     *
     * @param {AccountId20Like} real
     * @param {H256} callHash
     **/
    removeAnnouncement: GenericTxCall<
      Rv,
      (
        real: AccountId20Like,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'RemoveAnnouncement';
            params: { real: AccountId20Like; callHash: H256 };
          };
        }
      >
    >;

    /**
     * Remove the given announcement of a delegate.
     *
     * May be called by a target (proxied) account to remove a call that one of their delegates
     * (`delegate`) has announced they want to execute. The deposit is returned.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `delegate`: The account that previously announced the call.
     * - `call_hash`: The hash of the call to be made.
     *
     * @param {AccountId20Like} delegate
     * @param {H256} callHash
     **/
    rejectAnnouncement: GenericTxCall<
      Rv,
      (
        delegate: AccountId20Like,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'RejectAnnouncement';
            params: { delegate: AccountId20Like; callHash: H256 };
          };
        }
      >
    >;

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     *
     * Removes any corresponding announcement(s).
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     *
     * @param {AccountId20Like} delegate
     * @param {AccountId20Like} real
     * @param {MoonbeamRuntimeProxyType | undefined} forceProxyType
     * @param {MoonbeamRuntimeRuntimeCallLike} call
     **/
    proxyAnnounced: GenericTxCall<
      Rv,
      (
        delegate: AccountId20Like,
        real: AccountId20Like,
        forceProxyType: MoonbeamRuntimeProxyType | undefined,
        call: MoonbeamRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Proxy';
          palletCall: {
            name: 'ProxyAnnounced';
            params: {
              delegate: AccountId20Like;
              real: AccountId20Like;
              forceProxyType: MoonbeamRuntimeProxyType | undefined;
              call: MoonbeamRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `MaintenanceMode`'s transaction calls
   **/
  maintenanceMode: {
    /**
     * Place the chain in maintenance mode
     *
     * Weight cost is:
     * * One DB read to ensure we're not already in maintenance mode
     * * Three DB writes - 1 for the mode, 1 for suspending xcm execution, 1 for the event
     *
     **/
    enterMaintenanceMode: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'MaintenanceMode';
          palletCall: 'EnterMaintenanceMode';
        }
      >
    >;

    /**
     * Return the chain to normal operating mode
     *
     * Weight cost is:
     * * One DB read to ensure we're in maintenance mode
     * * Three DB writes - 1 for the mode, 1 for resuming xcm execution, 1 for the event
     *
     **/
    resumeNormalOperation: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'MaintenanceMode';
          palletCall: 'ResumeNormalOperation';
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Identity`'s transaction calls
   **/
  identity: {
    /**
     * Add a registrar to the system.
     *
     * The dispatch origin for this call must be `T::RegistrarOrigin`.
     *
     * - `account`: the account of the registrar.
     *
     * Emits `RegistrarAdded` if successful.
     *
     * @param {AccountId20Like} account
     **/
    addRegistrar: GenericTxCall<
      Rv,
      (account: AccountId20Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'AddRegistrar';
            params: { account: AccountId20Like };
          };
        }
      >
    >;

    /**
     * Set an account's identity information and reserve the appropriate deposit.
     *
     * If the account already has identity information, the deposit is taken as part payment
     * for the new deposit.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `info`: The identity information.
     *
     * Emits `IdentitySet` if successful.
     *
     * @param {PalletIdentityLegacyIdentityInfo} info
     **/
    setIdentity: GenericTxCall<
      Rv,
      (info: PalletIdentityLegacyIdentityInfo) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetIdentity';
            params: { info: PalletIdentityLegacyIdentityInfo };
          };
        }
      >
    >;

    /**
     * Set the sub-accounts of the sender.
     *
     * Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
     * and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * identity.
     *
     * - `subs`: The identity's (new) sub-accounts.
     *
     * @param {Array<[AccountId20Like, Data]>} subs
     **/
    setSubs: GenericTxCall<
      Rv,
      (subs: Array<[AccountId20Like, Data]>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetSubs';
            params: { subs: Array<[AccountId20Like, Data]> };
          };
        }
      >
    >;

    /**
     * Clear an account's identity info and all sub-accounts and return all deposits.
     *
     * Payment: All reserved balances on the account are returned.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * identity.
     *
     * Emits `IdentityCleared` if successful.
     *
     **/
    clearIdentity: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'ClearIdentity';
          };
        }
      >
    >;

    /**
     * Request a judgement from a registrar.
     *
     * Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
     * given.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a
     * registered identity.
     *
     * - `reg_index`: The index of the registrar whose judgement is requested.
     * - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
     *
     * ```nocompile
     * Self::registrars().get(reg_index).unwrap().fee
     * ```
     *
     * Emits `JudgementRequested` if successful.
     *
     * @param {number} regIndex
     * @param {bigint} maxFee
     **/
    requestJudgement: GenericTxCall<
      Rv,
      (
        regIndex: number,
        maxFee: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RequestJudgement';
            params: { regIndex: number; maxFee: bigint };
          };
        }
      >
    >;

    /**
     * Cancel a previous request.
     *
     * Payment: A previously reserved deposit is returned on success.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a
     * registered identity.
     *
     * - `reg_index`: The index of the registrar whose judgement is no longer requested.
     *
     * Emits `JudgementUnrequested` if successful.
     *
     * @param {number} regIndex
     **/
    cancelRequest: GenericTxCall<
      Rv,
      (regIndex: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'CancelRequest';
            params: { regIndex: number };
          };
        }
      >
    >;

    /**
     * Set the fee required for a judgement to be requested from a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `fee`: the new fee.
     *
     * @param {number} index
     * @param {bigint} fee
     **/
    setFee: GenericTxCall<
      Rv,
      (
        index: number,
        fee: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetFee';
            params: { index: number; fee: bigint };
          };
        }
      >
    >;

    /**
     * Change the account associated with a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `new`: the new account ID.
     *
     * @param {number} index
     * @param {AccountId20Like} new_
     **/
    setAccountId: GenericTxCall<
      Rv,
      (
        index: number,
        new_: AccountId20Like,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetAccountId';
            params: { index: number; new: AccountId20Like };
          };
        }
      >
    >;

    /**
     * Set the field information for a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `fields`: the fields that the registrar concerns themselves with.
     *
     * @param {number} index
     * @param {bigint} fields
     **/
    setFields: GenericTxCall<
      Rv,
      (
        index: number,
        fields: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetFields';
            params: { index: number; fields: bigint };
          };
        }
      >
    >;

    /**
     * Provide a judgement for an account's identity.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `reg_index`.
     *
     * - `reg_index`: the index of the registrar whose judgement is being made.
     * - `target`: the account whose identity the judgement is upon. This must be an account
     * with a registered identity.
     * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
     * - `identity`: The hash of the [`IdentityInformationProvider`] for that the judgement is
     * provided.
     *
     * Note: Judgements do not apply to a username.
     *
     * Emits `JudgementGiven` if successful.
     *
     * @param {number} regIndex
     * @param {AccountId20Like} target
     * @param {PalletIdentityJudgement} judgement
     * @param {H256} identity
     **/
    provideJudgement: GenericTxCall<
      Rv,
      (
        regIndex: number,
        target: AccountId20Like,
        judgement: PalletIdentityJudgement,
        identity: H256,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'ProvideJudgement';
            params: { regIndex: number; target: AccountId20Like; judgement: PalletIdentityJudgement; identity: H256 };
          };
        }
      >
    >;

    /**
     * Remove an account's identity and sub-account information and slash the deposits.
     *
     * Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
     * `Slash`. Verification request deposits are not returned; they should be cancelled
     * manually using `cancel_request`.
     *
     * The dispatch origin for this call must match `T::ForceOrigin`.
     *
     * - `target`: the account whose identity the judgement is upon. This must be an account
     * with a registered identity.
     *
     * Emits `IdentityKilled` if successful.
     *
     * @param {AccountId20Like} target
     **/
    killIdentity: GenericTxCall<
      Rv,
      (target: AccountId20Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'KillIdentity';
            params: { target: AccountId20Like };
          };
        }
      >
    >;

    /**
     * Add the given account to the sender's subs.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     *
     * @param {AccountId20Like} sub
     * @param {Data} data
     **/
    addSub: GenericTxCall<
      Rv,
      (
        sub: AccountId20Like,
        data: Data,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'AddSub';
            params: { sub: AccountId20Like; data: Data };
          };
        }
      >
    >;

    /**
     * Alter the associated name of the given sub-account.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     *
     * @param {AccountId20Like} sub
     * @param {Data} data
     **/
    renameSub: GenericTxCall<
      Rv,
      (
        sub: AccountId20Like,
        data: Data,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RenameSub';
            params: { sub: AccountId20Like; data: Data };
          };
        }
      >
    >;

    /**
     * Remove the given account from the sender's subs.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     *
     * @param {AccountId20Like} sub
     **/
    removeSub: GenericTxCall<
      Rv,
      (sub: AccountId20Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RemoveSub';
            params: { sub: AccountId20Like };
          };
        }
      >
    >;

    /**
     * Remove the sender as a sub-account.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender (*not* the original depositor).
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * super-identity.
     *
     * NOTE: This should not normally be used, but is provided in the case that the non-
     * controller of an account is maliciously registered as a sub-account.
     *
     **/
    quitSub: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'QuitSub';
          };
        }
      >
    >;

    /**
     * Add an `AccountId` with permission to grant usernames with a given `suffix` appended.
     *
     * The authority can grant up to `allocation` usernames. To top up their allocation, they
     * should just issue (or request via governance) a new `add_username_authority` call.
     *
     * @param {AccountId20Like} authority
     * @param {BytesLike} suffix
     * @param {number} allocation
     **/
    addUsernameAuthority: GenericTxCall<
      Rv,
      (
        authority: AccountId20Like,
        suffix: BytesLike,
        allocation: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'AddUsernameAuthority';
            params: { authority: AccountId20Like; suffix: BytesLike; allocation: number };
          };
        }
      >
    >;

    /**
     * Remove `authority` from the username authorities.
     *
     * @param {AccountId20Like} authority
     **/
    removeUsernameAuthority: GenericTxCall<
      Rv,
      (authority: AccountId20Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RemoveUsernameAuthority';
            params: { authority: AccountId20Like };
          };
        }
      >
    >;

    /**
     * Set the username for `who`. Must be called by a username authority.
     *
     * The authority must have an `allocation`. Users can either pre-sign their usernames or
     * accept them later.
     *
     * Usernames must:
     * - Only contain lowercase ASCII characters or digits.
     * - When combined with the suffix of the issuing authority be _less than_ the
     * `MaxUsernameLength`.
     *
     * @param {AccountId20Like} who
     * @param {BytesLike} username
     * @param {AccountEthereumSignature | undefined} signature
     **/
    setUsernameFor: GenericTxCall<
      Rv,
      (
        who: AccountId20Like,
        username: BytesLike,
        signature: AccountEthereumSignature | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetUsernameFor';
            params: { who: AccountId20Like; username: BytesLike; signature: AccountEthereumSignature | undefined };
          };
        }
      >
    >;

    /**
     * Accept a given username that an `authority` granted. The call must include the full
     * username, as in `username.suffix`.
     *
     * @param {BytesLike} username
     **/
    acceptUsername: GenericTxCall<
      Rv,
      (username: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'AcceptUsername';
            params: { username: BytesLike };
          };
        }
      >
    >;

    /**
     * Remove an expired username approval. The username was approved by an authority but never
     * accepted by the user and must now be beyond its expiration. The call must include the
     * full username, as in `username.suffix`.
     *
     * @param {BytesLike} username
     **/
    removeExpiredApproval: GenericTxCall<
      Rv,
      (username: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RemoveExpiredApproval';
            params: { username: BytesLike };
          };
        }
      >
    >;

    /**
     * Set a given username as the primary. The username should include the suffix.
     *
     * @param {BytesLike} username
     **/
    setPrimaryUsername: GenericTxCall<
      Rv,
      (username: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'SetPrimaryUsername';
            params: { username: BytesLike };
          };
        }
      >
    >;

    /**
     * Remove a username that corresponds to an account with no identity. Exists when a user
     * gets a username but then calls `clear_identity`.
     *
     * @param {BytesLike} username
     **/
    removeDanglingUsername: GenericTxCall<
      Rv,
      (username: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Identity';
          palletCall: {
            name: 'RemoveDanglingUsername';
            params: { username: BytesLike };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Multisig`'s transaction calls
   **/
  multisig: {
    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     *
     * Result is equivalent to the dispatched result.
     *
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     *
     * @param {Array<AccountId20Like>} otherSignatories
     * @param {MoonbeamRuntimeRuntimeCallLike} call
     **/
    asMultiThreshold1: GenericTxCall<
      Rv,
      (
        otherSignatories: Array<AccountId20Like>,
        call: MoonbeamRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'AsMultiThreshold1';
            params: { otherSignatories: Array<AccountId20Like>; call: MoonbeamRuntimeRuntimeCallLike };
          };
        }
      >
    >;

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     *
     * If there are enough, then dispatch the call.
     *
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     *
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     *
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     *
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     *
     * @param {number} threshold
     * @param {Array<AccountId20Like>} otherSignatories
     * @param {PalletMultisigTimepoint | undefined} maybeTimepoint
     * @param {MoonbeamRuntimeRuntimeCallLike} call
     * @param {SpWeightsWeightV2Weight} maxWeight
     **/
    asMulti: GenericTxCall<
      Rv,
      (
        threshold: number,
        otherSignatories: Array<AccountId20Like>,
        maybeTimepoint: PalletMultisigTimepoint | undefined,
        call: MoonbeamRuntimeRuntimeCallLike,
        maxWeight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'AsMulti';
            params: {
              threshold: number;
              otherSignatories: Array<AccountId20Like>;
              maybeTimepoint: PalletMultisigTimepoint | undefined;
              call: MoonbeamRuntimeRuntimeCallLike;
              maxWeight: SpWeightsWeightV2Weight;
            };
          };
        }
      >
    >;

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     *
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call_hash`: The hash of the call to be executed.
     *
     * NOTE: If this is the final approval, you will want to use `as_multi` instead.
     *
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     *
     * @param {number} threshold
     * @param {Array<AccountId20Like>} otherSignatories
     * @param {PalletMultisigTimepoint | undefined} maybeTimepoint
     * @param {FixedBytes<32>} callHash
     * @param {SpWeightsWeightV2Weight} maxWeight
     **/
    approveAsMulti: GenericTxCall<
      Rv,
      (
        threshold: number,
        otherSignatories: Array<AccountId20Like>,
        maybeTimepoint: PalletMultisigTimepoint | undefined,
        callHash: FixedBytes<32>,
        maxWeight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'ApproveAsMulti';
            params: {
              threshold: number;
              otherSignatories: Array<AccountId20Like>;
              maybeTimepoint: PalletMultisigTimepoint | undefined;
              callHash: FixedBytes<32>;
              maxWeight: SpWeightsWeightV2Weight;
            };
          };
        }
      >
    >;

    /**
     * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
     * for this operation will be unreserved on success.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `timepoint`: The timepoint (block number and transaction index) of the first approval
     * transaction for this dispatch.
     * - `call_hash`: The hash of the call to be executed.
     *
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - One event.
     * - I/O: 1 read `O(S)`, one remove.
     * - Storage: removes one item.
     *
     * @param {number} threshold
     * @param {Array<AccountId20Like>} otherSignatories
     * @param {PalletMultisigTimepoint} timepoint
     * @param {FixedBytes<32>} callHash
     **/
    cancelAsMulti: GenericTxCall<
      Rv,
      (
        threshold: number,
        otherSignatories: Array<AccountId20Like>,
        timepoint: PalletMultisigTimepoint,
        callHash: FixedBytes<32>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Multisig';
          palletCall: {
            name: 'CancelAsMulti';
            params: {
              threshold: number;
              otherSignatories: Array<AccountId20Like>;
              timepoint: PalletMultisigTimepoint;
              callHash: FixedBytes<32>;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `MoonbeamLazyMigrations`'s transaction calls
   **/
  moonbeamLazyMigrations: {
    /**
     *
     * @param {Array<H160>} addresses
     * @param {number} limit
     **/
    clearSuicidedStorage: GenericTxCall<
      Rv,
      (
        addresses: Array<H160>,
        limit: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'MoonbeamLazyMigrations';
          palletCall: {
            name: 'ClearSuicidedStorage';
            params: { addresses: Array<H160>; limit: number };
          };
        }
      >
    >;

    /**
     *
     * @param {H160} address
     **/
    createContractMetadata: GenericTxCall<
      Rv,
      (address: H160) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'MoonbeamLazyMigrations';
          palletCall: {
            name: 'CreateContractMetadata';
            params: { address: H160 };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Parameters`'s transaction calls
   **/
  parameters: {
    /**
     * Set the value of a parameter.
     *
     * The dispatch origin of this call must be `AdminOrigin` for the given `key`. Values be
     * deleted by setting them to `None`.
     *
     * @param {MoonbeamRuntimeRuntimeParamsRuntimeParameters} keyValue
     **/
    setParameter: GenericTxCall<
      Rv,
      (keyValue: MoonbeamRuntimeRuntimeParamsRuntimeParameters) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Parameters';
          palletCall: {
            name: 'SetParameter';
            params: { keyValue: MoonbeamRuntimeRuntimeParamsRuntimeParameters };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `EVM`'s transaction calls
   **/
  evm: {
    /**
     * Withdraw balance from EVM into currency/balances pallet.
     *
     * @param {H160} address
     * @param {bigint} value
     **/
    withdraw: GenericTxCall<
      Rv,
      (
        address: H160,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Evm';
          palletCall: {
            name: 'Withdraw';
            params: { address: H160; value: bigint };
          };
        }
      >
    >;

    /**
     * Issue an EVM call operation. This is similar to a message call transaction in Ethereum.
     *
     * @param {H160} source
     * @param {H160} target
     * @param {BytesLike} input
     * @param {U256} value
     * @param {bigint} gasLimit
     * @param {U256} maxFeePerGas
     * @param {U256 | undefined} maxPriorityFeePerGas
     * @param {U256 | undefined} nonce
     * @param {Array<[H160, Array<H256>]>} accessList
     **/
    call: GenericTxCall<
      Rv,
      (
        source: H160,
        target: H160,
        input: BytesLike,
        value: U256,
        gasLimit: bigint,
        maxFeePerGas: U256,
        maxPriorityFeePerGas: U256 | undefined,
        nonce: U256 | undefined,
        accessList: Array<[H160, Array<H256>]>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Evm';
          palletCall: {
            name: 'Call';
            params: {
              source: H160;
              target: H160;
              input: BytesLike;
              value: U256;
              gasLimit: bigint;
              maxFeePerGas: U256;
              maxPriorityFeePerGas: U256 | undefined;
              nonce: U256 | undefined;
              accessList: Array<[H160, Array<H256>]>;
            };
          };
        }
      >
    >;

    /**
     * Issue an EVM create operation. This is similar to a contract creation transaction in
     * Ethereum.
     *
     * @param {H160} source
     * @param {BytesLike} init
     * @param {U256} value
     * @param {bigint} gasLimit
     * @param {U256} maxFeePerGas
     * @param {U256 | undefined} maxPriorityFeePerGas
     * @param {U256 | undefined} nonce
     * @param {Array<[H160, Array<H256>]>} accessList
     **/
    create: GenericTxCall<
      Rv,
      (
        source: H160,
        init: BytesLike,
        value: U256,
        gasLimit: bigint,
        maxFeePerGas: U256,
        maxPriorityFeePerGas: U256 | undefined,
        nonce: U256 | undefined,
        accessList: Array<[H160, Array<H256>]>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Evm';
          palletCall: {
            name: 'Create';
            params: {
              source: H160;
              init: BytesLike;
              value: U256;
              gasLimit: bigint;
              maxFeePerGas: U256;
              maxPriorityFeePerGas: U256 | undefined;
              nonce: U256 | undefined;
              accessList: Array<[H160, Array<H256>]>;
            };
          };
        }
      >
    >;

    /**
     * Issue an EVM create2 operation.
     *
     * @param {H160} source
     * @param {BytesLike} init
     * @param {H256} salt
     * @param {U256} value
     * @param {bigint} gasLimit
     * @param {U256} maxFeePerGas
     * @param {U256 | undefined} maxPriorityFeePerGas
     * @param {U256 | undefined} nonce
     * @param {Array<[H160, Array<H256>]>} accessList
     **/
    create2: GenericTxCall<
      Rv,
      (
        source: H160,
        init: BytesLike,
        salt: H256,
        value: U256,
        gasLimit: bigint,
        maxFeePerGas: U256,
        maxPriorityFeePerGas: U256 | undefined,
        nonce: U256 | undefined,
        accessList: Array<[H160, Array<H256>]>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Evm';
          palletCall: {
            name: 'Create2';
            params: {
              source: H160;
              init: BytesLike;
              salt: H256;
              value: U256;
              gasLimit: bigint;
              maxFeePerGas: U256;
              maxPriorityFeePerGas: U256 | undefined;
              nonce: U256 | undefined;
              accessList: Array<[H160, Array<H256>]>;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Ethereum`'s transaction calls
   **/
  ethereum: {
    /**
     * Transact an Ethereum transaction.
     *
     * @param {EthereumTransactionTransactionV2} transaction
     **/
    transact: GenericTxCall<
      Rv,
      (transaction: EthereumTransactionTransactionV2) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Ethereum';
          palletCall: {
            name: 'Transact';
            params: { transaction: EthereumTransactionTransactionV2 };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Scheduler`'s transaction calls
   **/
  scheduler: {
    /**
     * Anonymously schedule a task.
     *
     * @param {number} when
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {MoonbeamRuntimeRuntimeCallLike} call
     **/
    schedule: GenericTxCall<
      Rv,
      (
        when: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: MoonbeamRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'Schedule';
            params: {
              when: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: MoonbeamRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Cancel an anonymously scheduled task.
     *
     * @param {number} when
     * @param {number} index
     **/
    cancel: GenericTxCall<
      Rv,
      (
        when: number,
        index: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'Cancel';
            params: { when: number; index: number };
          };
        }
      >
    >;

    /**
     * Schedule a named task.
     *
     * @param {FixedBytes<32>} id
     * @param {number} when
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {MoonbeamRuntimeRuntimeCallLike} call
     **/
    scheduleNamed: GenericTxCall<
      Rv,
      (
        id: FixedBytes<32>,
        when: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: MoonbeamRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'ScheduleNamed';
            params: {
              id: FixedBytes<32>;
              when: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: MoonbeamRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Cancel a named scheduled task.
     *
     * @param {FixedBytes<32>} id
     **/
    cancelNamed: GenericTxCall<
      Rv,
      (id: FixedBytes<32>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'CancelNamed';
            params: { id: FixedBytes<32> };
          };
        }
      >
    >;

    /**
     * Anonymously schedule a task after a delay.
     *
     * @param {number} after
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {MoonbeamRuntimeRuntimeCallLike} call
     **/
    scheduleAfter: GenericTxCall<
      Rv,
      (
        after: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: MoonbeamRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'ScheduleAfter';
            params: {
              after: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: MoonbeamRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Schedule a named task after a delay.
     *
     * @param {FixedBytes<32>} id
     * @param {number} after
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {MoonbeamRuntimeRuntimeCallLike} call
     **/
    scheduleNamedAfter: GenericTxCall<
      Rv,
      (
        id: FixedBytes<32>,
        after: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: MoonbeamRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'ScheduleNamedAfter';
            params: {
              id: FixedBytes<32>;
              after: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: MoonbeamRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Set a retry configuration for a task so that, in case its scheduled run fails, it will
     * be retried after `period` blocks, for a total amount of `retries` retries or until it
     * succeeds.
     *
     * Tasks which need to be scheduled for a retry are still subject to weight metering and
     * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
     * normally while the task is retrying.
     *
     * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
     * clones of the original task. Their retry configuration will be derived from the
     * original task's configuration, but will have a lower value for `remaining` than the
     * original `total_retries`.
     *
     * @param {[number, number]} task
     * @param {number} retries
     * @param {number} period
     **/
    setRetry: GenericTxCall<
      Rv,
      (
        task: [number, number],
        retries: number,
        period: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'SetRetry';
            params: { task: [number, number]; retries: number; period: number };
          };
        }
      >
    >;

    /**
     * Set a retry configuration for a named task so that, in case its scheduled run fails, it
     * will be retried after `period` blocks, for a total amount of `retries` retries or until
     * it succeeds.
     *
     * Tasks which need to be scheduled for a retry are still subject to weight metering and
     * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
     * normally while the task is retrying.
     *
     * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
     * clones of the original task. Their retry configuration will be derived from the
     * original task's configuration, but will have a lower value for `remaining` than the
     * original `total_retries`.
     *
     * @param {FixedBytes<32>} id
     * @param {number} retries
     * @param {number} period
     **/
    setRetryNamed: GenericTxCall<
      Rv,
      (
        id: FixedBytes<32>,
        retries: number,
        period: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'SetRetryNamed';
            params: { id: FixedBytes<32>; retries: number; period: number };
          };
        }
      >
    >;

    /**
     * Removes the retry configuration of a task.
     *
     * @param {[number, number]} task
     **/
    cancelRetry: GenericTxCall<
      Rv,
      (task: [number, number]) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'CancelRetry';
            params: { task: [number, number] };
          };
        }
      >
    >;

    /**
     * Cancel the retry configuration of a named task.
     *
     * @param {FixedBytes<32>} id
     **/
    cancelRetryNamed: GenericTxCall<
      Rv,
      (id: FixedBytes<32>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Scheduler';
          palletCall: {
            name: 'CancelRetryNamed';
            params: { id: FixedBytes<32> };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Preimage`'s transaction calls
   **/
  preimage: {
    /**
     * Register a preimage on-chain.
     *
     * If the preimage was previously requested, no fees or deposits are taken for providing
     * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
     *
     * @param {BytesLike} bytes
     **/
    notePreimage: GenericTxCall<
      Rv,
      (bytes: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'NotePreimage';
            params: { bytes: BytesLike };
          };
        }
      >
    >;

    /**
     * Clear an unrequested preimage from the runtime storage.
     *
     * If `len` is provided, then it will be a much cheaper operation.
     *
     * - `hash`: The hash of the preimage to be removed from the store.
     * - `len`: The length of the preimage of `hash`.
     *
     * @param {H256} hash
     **/
    unnotePreimage: GenericTxCall<
      Rv,
      (hash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'UnnotePreimage';
            params: { hash: H256 };
          };
        }
      >
    >;

    /**
     * Request a preimage be uploaded to the chain without paying any fees or deposits.
     *
     * If the preimage requests has already been provided on-chain, we unreserve any deposit
     * a user may have paid, and take the control of the preimage out of their hands.
     *
     * @param {H256} hash
     **/
    requestPreimage: GenericTxCall<
      Rv,
      (hash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'RequestPreimage';
            params: { hash: H256 };
          };
        }
      >
    >;

    /**
     * Clear a previously made request for a preimage.
     *
     * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
     *
     * @param {H256} hash
     **/
    unrequestPreimage: GenericTxCall<
      Rv,
      (hash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'UnrequestPreimage';
            params: { hash: H256 };
          };
        }
      >
    >;

    /**
     * Ensure that the a bulk of pre-images is upgraded.
     *
     * The caller pays no fee if at least 90% of pre-images were successfully updated.
     *
     * @param {Array<H256>} hashes
     **/
    ensureUpdated: GenericTxCall<
      Rv,
      (hashes: Array<H256>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Preimage';
          palletCall: {
            name: 'EnsureUpdated';
            params: { hashes: Array<H256> };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `ConvictionVoting`'s transaction calls
   **/
  convictionVoting: {
    /**
     * Vote in a poll. If `vote.is_aye()`, the vote is to enact the proposal;
     * otherwise it is a vote to keep the status quo.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `poll_index`: The index of the poll to vote for.
     * - `vote`: The vote configuration.
     *
     * Weight: `O(R)` where R is the number of polls the voter has voted on.
     *
     * @param {number} pollIndex
     * @param {PalletConvictionVotingVoteAccountVote} vote
     **/
    vote: GenericTxCall<
      Rv,
      (
        pollIndex: number,
        vote: PalletConvictionVotingVoteAccountVote,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ConvictionVoting';
          palletCall: {
            name: 'Vote';
            params: { pollIndex: number; vote: PalletConvictionVotingVoteAccountVote };
          };
        }
      >
    >;

    /**
     * Delegate the voting power (with some given conviction) of the sending account for a
     * particular class of polls.
     *
     * The balance delegated is locked for as long as it's delegated, and thereafter for the
     * time appropriate for the conviction's lock period.
     *
     * The dispatch origin of this call must be _Signed_, and the signing account must either:
     * - be delegating already; or
     * - have no voting activity (if there is, then it will need to be removed through
     * `remove_vote`).
     *
     * - `to`: The account whose voting the `target` account's voting power will follow.
     * - `class`: The class of polls to delegate. To delegate multiple classes, multiple calls
     * to this function are required.
     * - `conviction`: The conviction that will be attached to the delegated votes. When the
     * account is undelegated, the funds will be locked for the corresponding period.
     * - `balance`: The amount of the account's balance to be used in delegating. This must not
     * be more than the account's current balance.
     *
     * Emits `Delegated`.
     *
     * Weight: `O(R)` where R is the number of polls the voter delegating to has
     * voted on. Weight is initially charged as if maximum votes, but is refunded later.
     *
     * @param {number} class_
     * @param {AccountId20Like} to
     * @param {PalletConvictionVotingConviction} conviction
     * @param {bigint} balance
     **/
    delegate: GenericTxCall<
      Rv,
      (
        class_: number,
        to: AccountId20Like,
        conviction: PalletConvictionVotingConviction,
        balance: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ConvictionVoting';
          palletCall: {
            name: 'Delegate';
            params: {
              class: number;
              to: AccountId20Like;
              conviction: PalletConvictionVotingConviction;
              balance: bigint;
            };
          };
        }
      >
    >;

    /**
     * Undelegate the voting power of the sending account for a particular class of polls.
     *
     * Tokens may be unlocked following once an amount of time consistent with the lock period
     * of the conviction with which the delegation was issued has passed.
     *
     * The dispatch origin of this call must be _Signed_ and the signing account must be
     * currently delegating.
     *
     * - `class`: The class of polls to remove the delegation from.
     *
     * Emits `Undelegated`.
     *
     * Weight: `O(R)` where R is the number of polls the voter delegating to has
     * voted on. Weight is initially charged as if maximum votes, but is refunded later.
     *
     * @param {number} class_
     **/
    undelegate: GenericTxCall<
      Rv,
      (class_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ConvictionVoting';
          palletCall: {
            name: 'Undelegate';
            params: { class: number };
          };
        }
      >
    >;

    /**
     * Remove the lock caused by prior voting/delegating which has expired within a particular
     * class.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `class`: The class of polls to unlock.
     * - `target`: The account to remove the lock on.
     *
     * Weight: `O(R)` with R number of vote of target.
     *
     * @param {number} class_
     * @param {AccountId20Like} target
     **/
    unlock: GenericTxCall<
      Rv,
      (
        class_: number,
        target: AccountId20Like,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ConvictionVoting';
          palletCall: {
            name: 'Unlock';
            params: { class: number; target: AccountId20Like };
          };
        }
      >
    >;

    /**
     * Remove a vote for a poll.
     *
     * If:
     * - the poll was cancelled, or
     * - the poll is ongoing, or
     * - the poll has ended such that
     * - the vote of the account was in opposition to the result; or
     * - there was no conviction to the account's vote; or
     * - the account made a split vote
     * ...then the vote is removed cleanly and a following call to `unlock` may result in more
     * funds being available.
     *
     * If, however, the poll has ended and:
     * - it finished corresponding to the vote of the account, and
     * - the account made a standard vote with conviction, and
     * - the lock period of the conviction is not over
     * ...then the lock will be aggregated into the overall account's lock, which may involve
     * *overlocking* (where the two locks are combined into a single lock that is the maximum
     * of both the amount locked and the time is it locked for).
     *
     * The dispatch origin of this call must be _Signed_, and the signer must have a vote
     * registered for poll `index`.
     *
     * - `index`: The index of poll of the vote to be removed.
     * - `class`: Optional parameter, if given it indicates the class of the poll. For polls
     * which have finished or are cancelled, this must be `Some`.
     *
     * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
     * Weight is calculated for the maximum number of vote.
     *
     * @param {number | undefined} class_
     * @param {number} index
     **/
    removeVote: GenericTxCall<
      Rv,
      (
        class_: number | undefined,
        index: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ConvictionVoting';
          palletCall: {
            name: 'RemoveVote';
            params: { class: number | undefined; index: number };
          };
        }
      >
    >;

    /**
     * Remove a vote for a poll.
     *
     * If the `target` is equal to the signer, then this function is exactly equivalent to
     * `remove_vote`. If not equal to the signer, then the vote must have expired,
     * either because the poll was cancelled, because the voter lost the poll or
     * because the conviction period is over.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `target`: The account of the vote to be removed; this account must have voted for poll
     * `index`.
     * - `index`: The index of poll of the vote to be removed.
     * - `class`: The class of the poll.
     *
     * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
     * Weight is calculated for the maximum number of vote.
     *
     * @param {AccountId20Like} target
     * @param {number} class_
     * @param {number} index
     **/
    removeOtherVote: GenericTxCall<
      Rv,
      (
        target: AccountId20Like,
        class_: number,
        index: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'ConvictionVoting';
          palletCall: {
            name: 'RemoveOtherVote';
            params: { target: AccountId20Like; class: number; index: number };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Referenda`'s transaction calls
   **/
  referenda: {
    /**
     * Propose a referendum on a privileged action.
     *
     * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
     * available.
     * - `proposal_origin`: The origin from which the proposal should be executed.
     * - `proposal`: The proposal.
     * - `enactment_moment`: The moment that the proposal should be enacted.
     *
     * Emits `Submitted`.
     *
     * @param {MoonbeamRuntimeOriginCaller} proposalOrigin
     * @param {FrameSupportPreimagesBounded} proposal
     * @param {FrameSupportScheduleDispatchTime} enactmentMoment
     **/
    submit: GenericTxCall<
      Rv,
      (
        proposalOrigin: MoonbeamRuntimeOriginCaller,
        proposal: FrameSupportPreimagesBounded,
        enactmentMoment: FrameSupportScheduleDispatchTime,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'Submit';
            params: {
              proposalOrigin: MoonbeamRuntimeOriginCaller;
              proposal: FrameSupportPreimagesBounded;
              enactmentMoment: FrameSupportScheduleDispatchTime;
            };
          };
        }
      >
    >;

    /**
     * Post the Decision Deposit for a referendum.
     *
     * - `origin`: must be `Signed` and the account must have funds available for the
     * referendum's track's Decision Deposit.
     * - `index`: The index of the submitted referendum whose Decision Deposit is yet to be
     * posted.
     *
     * Emits `DecisionDepositPlaced`.
     *
     * @param {number} index
     **/
    placeDecisionDeposit: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'PlaceDecisionDeposit';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Refund the Decision Deposit for a closed referendum back to the depositor.
     *
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Decision Deposit has not yet been
     * refunded.
     *
     * Emits `DecisionDepositRefunded`.
     *
     * @param {number} index
     **/
    refundDecisionDeposit: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'RefundDecisionDeposit';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Cancel an ongoing referendum.
     *
     * - `origin`: must be the `CancelOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     *
     * Emits `Cancelled`.
     *
     * @param {number} index
     **/
    cancel: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'Cancel';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Cancel an ongoing referendum and slash the deposits.
     *
     * - `origin`: must be the `KillOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     *
     * Emits `Killed` and `DepositSlashed`.
     *
     * @param {number} index
     **/
    kill: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'Kill';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Advance a referendum onto its next logical state. Only used internally.
     *
     * - `origin`: must be `Root`.
     * - `index`: the referendum to be advanced.
     *
     * @param {number} index
     **/
    nudgeReferendum: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'NudgeReferendum';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Advance a track onto its next logical state. Only used internally.
     *
     * - `origin`: must be `Root`.
     * - `track`: the track to be advanced.
     *
     * Action item for when there is now one fewer referendum in the deciding phase and the
     * `DecidingCount` is not yet updated. This means that we should either:
     * - begin deciding another referendum (and leave `DecidingCount` alone); or
     * - decrement `DecidingCount`.
     *
     * @param {number} track
     **/
    oneFewerDeciding: GenericTxCall<
      Rv,
      (track: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'OneFewerDeciding';
            params: { track: number };
          };
        }
      >
    >;

    /**
     * Refund the Submission Deposit for a closed referendum back to the depositor.
     *
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Submission Deposit has not yet been
     * refunded.
     *
     * Emits `SubmissionDepositRefunded`.
     *
     * @param {number} index
     **/
    refundSubmissionDeposit: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'RefundSubmissionDeposit';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Set or clear metadata of a referendum.
     *
     * Parameters:
     * - `origin`: Must be `Signed` by a creator of a referendum or by anyone to clear a
     * metadata of a finished referendum.
     * - `index`: The index of a referendum to set or clear metadata for.
     * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
     *
     * @param {number} index
     * @param {H256 | undefined} maybeHash
     **/
    setMetadata: GenericTxCall<
      Rv,
      (
        index: number,
        maybeHash: H256 | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Referenda';
          palletCall: {
            name: 'SetMetadata';
            params: { index: number; maybeHash: H256 | undefined };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Whitelist`'s transaction calls
   **/
  whitelist: {
    /**
     *
     * @param {H256} callHash
     **/
    whitelistCall: GenericTxCall<
      Rv,
      (callHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Whitelist';
          palletCall: {
            name: 'WhitelistCall';
            params: { callHash: H256 };
          };
        }
      >
    >;

    /**
     *
     * @param {H256} callHash
     **/
    removeWhitelistedCall: GenericTxCall<
      Rv,
      (callHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Whitelist';
          palletCall: {
            name: 'RemoveWhitelistedCall';
            params: { callHash: H256 };
          };
        }
      >
    >;

    /**
     *
     * @param {H256} callHash
     * @param {number} callEncodedLen
     * @param {SpWeightsWeightV2Weight} callWeightWitness
     **/
    dispatchWhitelistedCall: GenericTxCall<
      Rv,
      (
        callHash: H256,
        callEncodedLen: number,
        callWeightWitness: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Whitelist';
          palletCall: {
            name: 'DispatchWhitelistedCall';
            params: { callHash: H256; callEncodedLen: number; callWeightWitness: SpWeightsWeightV2Weight };
          };
        }
      >
    >;

    /**
     *
     * @param {MoonbeamRuntimeRuntimeCallLike} call
     **/
    dispatchWhitelistedCallWithPreimage: GenericTxCall<
      Rv,
      (call: MoonbeamRuntimeRuntimeCallLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Whitelist';
          palletCall: {
            name: 'DispatchWhitelistedCallWithPreimage';
            params: { call: MoonbeamRuntimeRuntimeCallLike };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `TreasuryCouncilCollective`'s transaction calls
   **/
  treasuryCouncilCollective: {
    /**
     * Set the collective's membership.
     *
     * - `new_members`: The new member list. Be nice to the chain and provide it sorted.
     * - `prime`: The prime member whose vote sets the default.
     * - `old_count`: The upper bound for the previous number of members in storage. Used for
     * weight estimation.
     *
     * The dispatch of this call must be `SetMembersOrigin`.
     *
     * NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
     * the weight estimations rely on it to estimate dispatchable weight.
     *
     * # WARNING:
     *
     * The `pallet-collective` can also be managed by logic outside of the pallet through the
     * implementation of the trait [`ChangeMembers`].
     * Any call to `set_members` must be careful that the member set doesn't get out of sync
     * with other logic managing the member set.
     *
     * ## Complexity:
     * - `O(MP + N)` where:
     * - `M` old-members-count (code- and governance-bounded)
     * - `N` new-members-count (code- and governance-bounded)
     * - `P` proposals-count (code-bounded)
     *
     * @param {Array<AccountId20Like>} newMembers
     * @param {AccountId20Like | undefined} prime
     * @param {number} oldCount
     **/
    setMembers: GenericTxCall<
      Rv,
      (
        newMembers: Array<AccountId20Like>,
        prime: AccountId20Like | undefined,
        oldCount: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'TreasuryCouncilCollective';
          palletCall: {
            name: 'SetMembers';
            params: { newMembers: Array<AccountId20Like>; prime: AccountId20Like | undefined; oldCount: number };
          };
        }
      >
    >;

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     *
     * Origin must be a member of the collective.
     *
     * ## Complexity:
     * - `O(B + M + P)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` members-count (code-bounded)
     * - `P` complexity of dispatching `proposal`
     *
     * @param {MoonbeamRuntimeRuntimeCallLike} proposal
     * @param {number} lengthBound
     **/
    execute: GenericTxCall<
      Rv,
      (
        proposal: MoonbeamRuntimeRuntimeCallLike,
        lengthBound: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'TreasuryCouncilCollective';
          palletCall: {
            name: 'Execute';
            params: { proposal: MoonbeamRuntimeRuntimeCallLike; lengthBound: number };
          };
        }
      >
    >;

    /**
     * Add a new proposal to either be voted on or executed directly.
     *
     * Requires the sender to be member.
     *
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     *
     * ## Complexity
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` is members-count (code- and governance-bounded)
     * - branching is influenced by `threshold` where:
     * - `P1` is proposal execution complexity (`threshold < 2`)
     * - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *
     * @param {number} threshold
     * @param {MoonbeamRuntimeRuntimeCallLike} proposal
     * @param {number} lengthBound
     **/
    propose: GenericTxCall<
      Rv,
      (
        threshold: number,
        proposal: MoonbeamRuntimeRuntimeCallLike,
        lengthBound: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'TreasuryCouncilCollective';
          palletCall: {
            name: 'Propose';
            params: { threshold: number; proposal: MoonbeamRuntimeRuntimeCallLike; lengthBound: number };
          };
        }
      >
    >;

    /**
     * Add an aye or nay vote for the sender to the given proposal.
     *
     * Requires the sender to be a member.
     *
     * Transaction fees will be waived if the member is voting on any particular proposal
     * for the first time and the call is successful. Subsequent vote changes will charge a
     * fee.
     * ## Complexity
     * - `O(M)` where `M` is members-count (code- and governance-bounded)
     *
     * @param {H256} proposal
     * @param {number} index
     * @param {boolean} approve
     **/
    vote: GenericTxCall<
      Rv,
      (
        proposal: H256,
        index: number,
        approve: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'TreasuryCouncilCollective';
          palletCall: {
            name: 'Vote';
            params: { proposal: H256; index: number; approve: boolean };
          };
        }
      >
    >;

    /**
     * Disapprove a proposal, close, and remove it from the system, regardless of its current
     * state.
     *
     * Must be called by the Root origin.
     *
     * Parameters:
     * * `proposal_hash`: The hash of the proposal that should be disapproved.
     *
     * ## Complexity
     * O(P) where P is the number of max proposals
     *
     * @param {H256} proposalHash
     **/
    disapproveProposal: GenericTxCall<
      Rv,
      (proposalHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'TreasuryCouncilCollective';
          palletCall: {
            name: 'DisapproveProposal';
            params: { proposalHash: H256 };
          };
        }
      >
    >;

    /**
     * Close a vote that is either approved, disapproved or whose voting period has ended.
     *
     * May be called by any signed account in order to finish voting and close the proposal.
     *
     * If called before the end of the voting period it will only close the vote if it is
     * has enough votes to be approved or disapproved.
     *
     * If called after the end of the voting period abstentions are counted as rejections
     * unless there is a prime member set and the prime member cast an approval.
     *
     * If the close operation completes successfully with disapproval, the transaction fee will
     * be waived. Otherwise execution of the approved operation will be charged to the caller.
     *
     * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
     * proposal.
     * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     *
     * ## Complexity
     * - `O(B + M + P1 + P2)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` is members-count (code- and governance-bounded)
     * - `P1` is the complexity of `proposal` preimage.
     * - `P2` is proposal-count (code-bounded)
     *
     * @param {H256} proposalHash
     * @param {number} index
     * @param {SpWeightsWeightV2Weight} proposalWeightBound
     * @param {number} lengthBound
     **/
    close: GenericTxCall<
      Rv,
      (
        proposalHash: H256,
        index: number,
        proposalWeightBound: SpWeightsWeightV2Weight,
        lengthBound: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'TreasuryCouncilCollective';
          palletCall: {
            name: 'Close';
            params: {
              proposalHash: H256;
              index: number;
              proposalWeightBound: SpWeightsWeightV2Weight;
              lengthBound: number;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `OpenTechCommitteeCollective`'s transaction calls
   **/
  openTechCommitteeCollective: {
    /**
     * Set the collective's membership.
     *
     * - `new_members`: The new member list. Be nice to the chain and provide it sorted.
     * - `prime`: The prime member whose vote sets the default.
     * - `old_count`: The upper bound for the previous number of members in storage. Used for
     * weight estimation.
     *
     * The dispatch of this call must be `SetMembersOrigin`.
     *
     * NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
     * the weight estimations rely on it to estimate dispatchable weight.
     *
     * # WARNING:
     *
     * The `pallet-collective` can also be managed by logic outside of the pallet through the
     * implementation of the trait [`ChangeMembers`].
     * Any call to `set_members` must be careful that the member set doesn't get out of sync
     * with other logic managing the member set.
     *
     * ## Complexity:
     * - `O(MP + N)` where:
     * - `M` old-members-count (code- and governance-bounded)
     * - `N` new-members-count (code- and governance-bounded)
     * - `P` proposals-count (code-bounded)
     *
     * @param {Array<AccountId20Like>} newMembers
     * @param {AccountId20Like | undefined} prime
     * @param {number} oldCount
     **/
    setMembers: GenericTxCall<
      Rv,
      (
        newMembers: Array<AccountId20Like>,
        prime: AccountId20Like | undefined,
        oldCount: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'OpenTechCommitteeCollective';
          palletCall: {
            name: 'SetMembers';
            params: { newMembers: Array<AccountId20Like>; prime: AccountId20Like | undefined; oldCount: number };
          };
        }
      >
    >;

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     *
     * Origin must be a member of the collective.
     *
     * ## Complexity:
     * - `O(B + M + P)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` members-count (code-bounded)
     * - `P` complexity of dispatching `proposal`
     *
     * @param {MoonbeamRuntimeRuntimeCallLike} proposal
     * @param {number} lengthBound
     **/
    execute: GenericTxCall<
      Rv,
      (
        proposal: MoonbeamRuntimeRuntimeCallLike,
        lengthBound: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'OpenTechCommitteeCollective';
          palletCall: {
            name: 'Execute';
            params: { proposal: MoonbeamRuntimeRuntimeCallLike; lengthBound: number };
          };
        }
      >
    >;

    /**
     * Add a new proposal to either be voted on or executed directly.
     *
     * Requires the sender to be member.
     *
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     *
     * ## Complexity
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` is members-count (code- and governance-bounded)
     * - branching is influenced by `threshold` where:
     * - `P1` is proposal execution complexity (`threshold < 2`)
     * - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *
     * @param {number} threshold
     * @param {MoonbeamRuntimeRuntimeCallLike} proposal
     * @param {number} lengthBound
     **/
    propose: GenericTxCall<
      Rv,
      (
        threshold: number,
        proposal: MoonbeamRuntimeRuntimeCallLike,
        lengthBound: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'OpenTechCommitteeCollective';
          palletCall: {
            name: 'Propose';
            params: { threshold: number; proposal: MoonbeamRuntimeRuntimeCallLike; lengthBound: number };
          };
        }
      >
    >;

    /**
     * Add an aye or nay vote for the sender to the given proposal.
     *
     * Requires the sender to be a member.
     *
     * Transaction fees will be waived if the member is voting on any particular proposal
     * for the first time and the call is successful. Subsequent vote changes will charge a
     * fee.
     * ## Complexity
     * - `O(M)` where `M` is members-count (code- and governance-bounded)
     *
     * @param {H256} proposal
     * @param {number} index
     * @param {boolean} approve
     **/
    vote: GenericTxCall<
      Rv,
      (
        proposal: H256,
        index: number,
        approve: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'OpenTechCommitteeCollective';
          palletCall: {
            name: 'Vote';
            params: { proposal: H256; index: number; approve: boolean };
          };
        }
      >
    >;

    /**
     * Disapprove a proposal, close, and remove it from the system, regardless of its current
     * state.
     *
     * Must be called by the Root origin.
     *
     * Parameters:
     * * `proposal_hash`: The hash of the proposal that should be disapproved.
     *
     * ## Complexity
     * O(P) where P is the number of max proposals
     *
     * @param {H256} proposalHash
     **/
    disapproveProposal: GenericTxCall<
      Rv,
      (proposalHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'OpenTechCommitteeCollective';
          palletCall: {
            name: 'DisapproveProposal';
            params: { proposalHash: H256 };
          };
        }
      >
    >;

    /**
     * Close a vote that is either approved, disapproved or whose voting period has ended.
     *
     * May be called by any signed account in order to finish voting and close the proposal.
     *
     * If called before the end of the voting period it will only close the vote if it is
     * has enough votes to be approved or disapproved.
     *
     * If called after the end of the voting period abstentions are counted as rejections
     * unless there is a prime member set and the prime member cast an approval.
     *
     * If the close operation completes successfully with disapproval, the transaction fee will
     * be waived. Otherwise execution of the approved operation will be charged to the caller.
     *
     * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
     * proposal.
     * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     *
     * ## Complexity
     * - `O(B + M + P1 + P2)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` is members-count (code- and governance-bounded)
     * - `P1` is the complexity of `proposal` preimage.
     * - `P2` is proposal-count (code-bounded)
     *
     * @param {H256} proposalHash
     * @param {number} index
     * @param {SpWeightsWeightV2Weight} proposalWeightBound
     * @param {number} lengthBound
     **/
    close: GenericTxCall<
      Rv,
      (
        proposalHash: H256,
        index: number,
        proposalWeightBound: SpWeightsWeightV2Weight,
        lengthBound: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'OpenTechCommitteeCollective';
          palletCall: {
            name: 'Close';
            params: {
              proposalHash: H256;
              index: number;
              proposalWeightBound: SpWeightsWeightV2Weight;
              lengthBound: number;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Treasury`'s transaction calls
   **/
  treasury: {
    /**
     * Propose and approve a spend of treasury funds.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::SpendOrigin`] with the `Success` value being at least `amount`.
     *
     * ### Details
     * NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
     * beneficiary.
     *
     * ### Parameters
     * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
     * - `beneficiary`: The destination account for the transfer.
     *
     * ## Events
     *
     * Emits [`Event::SpendApproved`] if successful.
     *
     * @param {bigint} amount
     * @param {AccountId20Like} beneficiary
     **/
    spendLocal: GenericTxCall<
      Rv,
      (
        amount: bigint,
        beneficiary: AccountId20Like,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Treasury';
          palletCall: {
            name: 'SpendLocal';
            params: { amount: bigint; beneficiary: AccountId20Like };
          };
        }
      >
    >;

    /**
     * Force a previously approved proposal to be removed from the approval queue.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::RejectOrigin`].
     *
     * ## Details
     *
     * The original deposit will no longer be returned.
     *
     * ### Parameters
     * - `proposal_id`: The index of a proposal
     *
     * ### Complexity
     * - O(A) where `A` is the number of approvals
     *
     * ### Errors
     * - [`Error::ProposalNotApproved`]: The `proposal_id` supplied was not found in the
     * approval queue, i.e., the proposal has not been approved. This could also mean the
     * proposal does not exist altogether, thus there is no way it would have been approved
     * in the first place.
     *
     * @param {number} proposalId
     **/
    removeApproval: GenericTxCall<
      Rv,
      (proposalId: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Treasury';
          palletCall: {
            name: 'RemoveApproval';
            params: { proposalId: number };
          };
        }
      >
    >;

    /**
     * Propose and approve a spend of treasury funds.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::SpendOrigin`] with the `Success` value being at least
     * `amount` of `asset_kind` in the native asset. The amount of `asset_kind` is converted
     * for assertion using the [`Config::BalanceConverter`].
     *
     * ## Details
     *
     * Create an approved spend for transferring a specific `amount` of `asset_kind` to a
     * designated beneficiary. The spend must be claimed using the `payout` dispatchable within
     * the [`Config::PayoutPeriod`].
     *
     * ### Parameters
     * - `asset_kind`: An indicator of the specific asset class to be spent.
     * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
     * - `beneficiary`: The beneficiary of the spend.
     * - `valid_from`: The block number from which the spend can be claimed. It can refer to
     * the past if the resulting spend has not yet expired according to the
     * [`Config::PayoutPeriod`]. If `None`, the spend can be claimed immediately after
     * approval.
     *
     * ## Events
     *
     * Emits [`Event::AssetSpendApproved`] if successful.
     *
     * @param {[]} assetKind
     * @param {bigint} amount
     * @param {AccountId20Like} beneficiary
     * @param {number | undefined} validFrom
     **/
    spend: GenericTxCall<
      Rv,
      (
        assetKind: [],
        amount: bigint,
        beneficiary: AccountId20Like,
        validFrom: number | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Treasury';
          palletCall: {
            name: 'Spend';
            params: { assetKind: []; amount: bigint; beneficiary: AccountId20Like; validFrom: number | undefined };
          };
        }
      >
    >;

    /**
     * Claim a spend.
     *
     * ## Dispatch Origin
     *
     * Must be signed
     *
     * ## Details
     *
     * Spends must be claimed within some temporal bounds. A spend may be claimed within one
     * [`Config::PayoutPeriod`] from the `valid_from` block.
     * In case of a payout failure, the spend status must be updated with the `check_status`
     * dispatchable before retrying with the current function.
     *
     * ### Parameters
     * - `index`: The spend index.
     *
     * ## Events
     *
     * Emits [`Event::Paid`] if successful.
     *
     * @param {number} index
     **/
    payout: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Treasury';
          palletCall: {
            name: 'Payout';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Check the status of the spend and remove it from the storage if processed.
     *
     * ## Dispatch Origin
     *
     * Must be signed.
     *
     * ## Details
     *
     * The status check is a prerequisite for retrying a failed payout.
     * If a spend has either succeeded or expired, it is removed from the storage by this
     * function. In such instances, transaction fees are refunded.
     *
     * ### Parameters
     * - `index`: The spend index.
     *
     * ## Events
     *
     * Emits [`Event::PaymentFailed`] if the spend payout has failed.
     * Emits [`Event::SpendProcessed`] if the spend payout has succeed.
     *
     * @param {number} index
     **/
    checkStatus: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Treasury';
          palletCall: {
            name: 'CheckStatus';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Void previously approved spend.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::RejectOrigin`].
     *
     * ## Details
     *
     * A spend void is only possible if the payout has not been attempted yet.
     *
     * ### Parameters
     * - `index`: The spend index.
     *
     * ## Events
     *
     * Emits [`Event::AssetSpendVoided`] if successful.
     *
     * @param {number} index
     **/
    voidSpend: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Treasury';
          palletCall: {
            name: 'VoidSpend';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `CrowdloanRewards`'s transaction calls
   **/
  crowdloanRewards: {
    /**
     * Associate a native rewards_destination identity with a crowdloan contribution.
     *
     * The caller needs to provide the unassociated relay account and a proof to succeed
     * with the association
     * The proof is nothing but a signature over the reward_address using the relay keys
     *
     * @param {AccountId20Like} rewardAccount
     * @param {FixedBytes<32>} relayAccount
     * @param {SpRuntimeMultiSignature} proof
     **/
    associateNativeIdentity: GenericTxCall<
      Rv,
      (
        rewardAccount: AccountId20Like,
        relayAccount: FixedBytes<32>,
        proof: SpRuntimeMultiSignature,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'CrowdloanRewards';
          palletCall: {
            name: 'AssociateNativeIdentity';
            params: { rewardAccount: AccountId20Like; relayAccount: FixedBytes<32>; proof: SpRuntimeMultiSignature };
          };
        }
      >
    >;

    /**
     * Change reward account by submitting proofs from relay accounts
     *
     * The number of valid proofs needs to be bigger than 'RewardAddressRelayVoteThreshold'
     * The account to be changed needs to be submitted as 'previous_account'
     * Origin must be RewardAddressChangeOrigin
     *
     * @param {AccountId20Like} rewardAccount
     * @param {AccountId20Like} previousAccount
     * @param {Array<[FixedBytes<32>, SpRuntimeMultiSignature]>} proofs
     **/
    changeAssociationWithRelayKeys: GenericTxCall<
      Rv,
      (
        rewardAccount: AccountId20Like,
        previousAccount: AccountId20Like,
        proofs: Array<[FixedBytes<32>, SpRuntimeMultiSignature]>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'CrowdloanRewards';
          palletCall: {
            name: 'ChangeAssociationWithRelayKeys';
            params: {
              rewardAccount: AccountId20Like;
              previousAccount: AccountId20Like;
              proofs: Array<[FixedBytes<32>, SpRuntimeMultiSignature]>;
            };
          };
        }
      >
    >;

    /**
     * Collect whatever portion of your reward are currently vested.
     *
     **/
    claim: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'CrowdloanRewards';
          palletCall: {
            name: 'Claim';
          };
        }
      >
    >;

    /**
     * Update reward address, proving that the caller owns the current native key
     *
     * @param {AccountId20Like} newRewardAccount
     **/
    updateRewardAddress: GenericTxCall<
      Rv,
      (newRewardAccount: AccountId20Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'CrowdloanRewards';
          palletCall: {
            name: 'UpdateRewardAddress';
            params: { newRewardAccount: AccountId20Like };
          };
        }
      >
    >;

    /**
     * This extrinsic completes the initialization if some checks are fullfiled. These checks are:
     * -The reward contribution money matches the crowdloan pot
     * -The end vesting block is higher than the init vesting block
     * -The initialization has not complete yet
     *
     * @param {number} leaseEndingBlock
     **/
    completeInitialization: GenericTxCall<
      Rv,
      (leaseEndingBlock: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'CrowdloanRewards';
          palletCall: {
            name: 'CompleteInitialization';
            params: { leaseEndingBlock: number };
          };
        }
      >
    >;

    /**
     * Initialize the reward distribution storage. It shortcuts whenever an error is found
     * This does not enforce any checks other than making sure we dont go over funds
     * complete_initialization should perform any additional
     *
     * @param {Array<[FixedBytes<32>, AccountId20Like | undefined, bigint]>} rewards
     **/
    initializeRewardVec: GenericTxCall<
      Rv,
      (rewards: Array<[FixedBytes<32>, AccountId20Like | undefined, bigint]>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'CrowdloanRewards';
          palletCall: {
            name: 'InitializeRewardVec';
            params: { rewards: Array<[FixedBytes<32>, AccountId20Like | undefined, bigint]> };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `PolkadotXcm`'s transaction calls
   **/
  polkadotXcm: {
    /**
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedXcm} message
     **/
    send: GenericTxCall<
      Rv,
      (
        dest: XcmVersionedLocation,
        message: XcmVersionedXcm,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'Send';
            params: { dest: XcmVersionedLocation; message: XcmVersionedXcm };
          };
        }
      >
    >;

    /**
     * Teleport some assets from the local chain to some destination chain.
     *
     * **This function is deprecated: Use `limited_teleport_assets` instead.**
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` chain.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedLocation} beneficiary
     * @param {XcmVersionedAssets} assets
     * @param {number} feeAssetItem
     **/
    teleportAssets: GenericTxCall<
      Rv,
      (
        dest: XcmVersionedLocation,
        beneficiary: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        feeAssetItem: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'TeleportAssets';
            params: {
              dest: XcmVersionedLocation;
              beneficiary: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              feeAssetItem: number;
            };
          };
        }
      >
    >;

    /**
     * Transfer some assets from the local chain to the destination chain through their local,
     * destination or remote reserve.
     *
     * `assets` must have same reserve location and may not be teleportable to `dest`.
     * - `assets` have local reserve: transfer assets to sovereign account of destination
     * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
     * assets to `beneficiary`.
     * - `assets` have destination reserve: burn local assets and forward a notification to
     * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
     * deposit them to `beneficiary`.
     * - `assets` have remote reserve: burn local assets, forward XCM to reserve chain to move
     * reserves from this chain's SA to `dest` chain's SA, and forward another XCM to `dest`
     * to mint and deposit reserve-based assets to `beneficiary`.
     *
     * **This function is deprecated: Use `limited_reserve_transfer_assets` instead.**
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` (and possibly reserve) chains.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedLocation} beneficiary
     * @param {XcmVersionedAssets} assets
     * @param {number} feeAssetItem
     **/
    reserveTransferAssets: GenericTxCall<
      Rv,
      (
        dest: XcmVersionedLocation,
        beneficiary: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        feeAssetItem: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'ReserveTransferAssets';
            params: {
              dest: XcmVersionedLocation;
              beneficiary: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              feeAssetItem: number;
            };
          };
        }
      >
    >;

    /**
     * Execute an XCM message from a local, signed, origin.
     *
     * An event is deposited indicating whether `msg` could be executed completely or only
     * partially.
     *
     * No more than `max_weight` will be used in its attempted execution. If this is less than
     * the maximum amount of weight that the message could take to be executed, then no
     * execution attempt will be made.
     *
     * @param {XcmVersionedXcm} message
     * @param {SpWeightsWeightV2Weight} maxWeight
     **/
    execute: GenericTxCall<
      Rv,
      (
        message: XcmVersionedXcm,
        maxWeight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'Execute';
            params: { message: XcmVersionedXcm; maxWeight: SpWeightsWeightV2Weight };
          };
        }
      >
    >;

    /**
     * Extoll that a particular destination can be communicated with through a particular
     * version of XCM.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The destination that is being described.
     * - `xcm_version`: The latest version of XCM that `location` supports.
     *
     * @param {StagingXcmV4Location} location
     * @param {number} version
     **/
    forceXcmVersion: GenericTxCall<
      Rv,
      (
        location: StagingXcmV4Location,
        version: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'ForceXcmVersion';
            params: { location: StagingXcmV4Location; version: number };
          };
        }
      >
    >;

    /**
     * Set a safe XCM version (the version that XCM should be encoded with if the most recent
     * version a destination can accept is unknown).
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `maybe_xcm_version`: The default XCM encoding version, or `None` to disable.
     *
     * @param {number | undefined} maybeXcmVersion
     **/
    forceDefaultXcmVersion: GenericTxCall<
      Rv,
      (maybeXcmVersion: number | undefined) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'ForceDefaultXcmVersion';
            params: { maybeXcmVersion: number | undefined };
          };
        }
      >
    >;

    /**
     * Ask a location to notify us regarding their XCM version and any changes to it.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The location to which we should subscribe for XCM version notifications.
     *
     * @param {XcmVersionedLocation} location
     **/
    forceSubscribeVersionNotify: GenericTxCall<
      Rv,
      (location: XcmVersionedLocation) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'ForceSubscribeVersionNotify';
            params: { location: XcmVersionedLocation };
          };
        }
      >
    >;

    /**
     * Require that a particular destination should no longer notify us regarding any XCM
     * version changes.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The location to which we are currently subscribed for XCM version
     * notifications which we no longer desire.
     *
     * @param {XcmVersionedLocation} location
     **/
    forceUnsubscribeVersionNotify: GenericTxCall<
      Rv,
      (location: XcmVersionedLocation) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'ForceUnsubscribeVersionNotify';
            params: { location: XcmVersionedLocation };
          };
        }
      >
    >;

    /**
     * Transfer some assets from the local chain to the destination chain through their local,
     * destination or remote reserve.
     *
     * `assets` must have same reserve location and may not be teleportable to `dest`.
     * - `assets` have local reserve: transfer assets to sovereign account of destination
     * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
     * assets to `beneficiary`.
     * - `assets` have destination reserve: burn local assets and forward a notification to
     * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
     * deposit them to `beneficiary`.
     * - `assets` have remote reserve: burn local assets, forward XCM to reserve chain to move
     * reserves from this chain's SA to `dest` chain's SA, and forward another XCM to `dest`
     * to mint and deposit reserve-based assets to `beneficiary`.
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the sent assets may be
     * at risk.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` (and possibly reserve) chains.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedLocation} beneficiary
     * @param {XcmVersionedAssets} assets
     * @param {number} feeAssetItem
     * @param {XcmV3WeightLimit} weightLimit
     **/
    limitedReserveTransferAssets: GenericTxCall<
      Rv,
      (
        dest: XcmVersionedLocation,
        beneficiary: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        feeAssetItem: number,
        weightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'LimitedReserveTransferAssets';
            params: {
              dest: XcmVersionedLocation;
              beneficiary: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              feeAssetItem: number;
              weightLimit: XcmV3WeightLimit;
            };
          };
        }
      >
    >;

    /**
     * Teleport some assets from the local chain to some destination chain.
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the sent assets may be
     * at risk.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` chain.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedLocation} beneficiary
     * @param {XcmVersionedAssets} assets
     * @param {number} feeAssetItem
     * @param {XcmV3WeightLimit} weightLimit
     **/
    limitedTeleportAssets: GenericTxCall<
      Rv,
      (
        dest: XcmVersionedLocation,
        beneficiary: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        feeAssetItem: number,
        weightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'LimitedTeleportAssets';
            params: {
              dest: XcmVersionedLocation;
              beneficiary: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              feeAssetItem: number;
              weightLimit: XcmV3WeightLimit;
            };
          };
        }
      >
    >;

    /**
     * Set or unset the global suspension state of the XCM executor.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `suspended`: `true` to suspend, `false` to resume.
     *
     * @param {boolean} suspended
     **/
    forceSuspension: GenericTxCall<
      Rv,
      (suspended: boolean) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'ForceSuspension';
            params: { suspended: boolean };
          };
        }
      >
    >;

    /**
     * Transfer some assets from the local chain to the destination chain through their local,
     * destination or remote reserve, or through teleports.
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item` (hence referred to as `fees`), up to enough to pay for
     * `weight_limit` of weight. If more weight is needed than `weight_limit`, then the
     * operation will fail and the sent assets may be at risk.
     *
     * `assets` (excluding `fees`) must have same reserve location or otherwise be teleportable
     * to `dest`, no limitations imposed on `fees`.
     * - for local reserve: transfer assets to sovereign account of destination chain and
     * forward a notification XCM to `dest` to mint and deposit reserve-based assets to
     * `beneficiary`.
     * - for destination reserve: burn local assets and forward a notification to `dest` chain
     * to withdraw the reserve assets from this chain's sovereign account and deposit them
     * to `beneficiary`.
     * - for remote reserve: burn local assets, forward XCM to reserve chain to move reserves
     * from this chain's SA to `dest` chain's SA, and forward another XCM to `dest` to mint
     * and deposit reserve-based assets to `beneficiary`.
     * - for teleports: burn local assets and forward XCM to `dest` chain to mint/teleport
     * assets and deposit them to `beneficiary`.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent,
     * Parachain(..))` to send from parachain to parachain, or `X1(Parachain(..))` to send
     * from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` (and possibly reserve) chains.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedLocation} beneficiary
     * @param {XcmVersionedAssets} assets
     * @param {number} feeAssetItem
     * @param {XcmV3WeightLimit} weightLimit
     **/
    transferAssets: GenericTxCall<
      Rv,
      (
        dest: XcmVersionedLocation,
        beneficiary: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        feeAssetItem: number,
        weightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'TransferAssets';
            params: {
              dest: XcmVersionedLocation;
              beneficiary: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              feeAssetItem: number;
              weightLimit: XcmV3WeightLimit;
            };
          };
        }
      >
    >;

    /**
     * Claims assets trapped on this pallet because of leftover assets during XCM execution.
     *
     * - `origin`: Anyone can call this extrinsic.
     * - `assets`: The exact assets that were trapped. Use the version to specify what version
     * was the latest when they were trapped.
     * - `beneficiary`: The location/account where the claimed assets will be deposited.
     *
     * @param {XcmVersionedAssets} assets
     * @param {XcmVersionedLocation} beneficiary
     **/
    claimAssets: GenericTxCall<
      Rv,
      (
        assets: XcmVersionedAssets,
        beneficiary: XcmVersionedLocation,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'ClaimAssets';
            params: { assets: XcmVersionedAssets; beneficiary: XcmVersionedLocation };
          };
        }
      >
    >;

    /**
     * Transfer assets from the local chain to the destination chain using explicit transfer
     * types for assets and fees.
     *
     * `assets` must have same reserve location or may be teleportable to `dest`. Caller must
     * provide the `assets_transfer_type` to be used for `assets`:
     * - `TransferType::LocalReserve`: transfer assets to sovereign account of destination
     * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
     * assets to `beneficiary`.
     * - `TransferType::DestinationReserve`: burn local assets and forward a notification to
     * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
     * deposit them to `beneficiary`.
     * - `TransferType::RemoteReserve(reserve)`: burn local assets, forward XCM to `reserve`
     * chain to move reserves from this chain's SA to `dest` chain's SA, and forward another
     * XCM to `dest` to mint and deposit reserve-based assets to `beneficiary`. Typically
     * the remote `reserve` is Asset Hub.
     * - `TransferType::Teleport`: burn local assets and forward XCM to `dest` chain to
     * mint/teleport assets and deposit them to `beneficiary`.
     *
     * On the destination chain, as well as any intermediary hops, `BuyExecution` is used to
     * buy execution using transferred `assets` identified by `remote_fees_id`.
     * Make sure enough of the specified `remote_fees_id` asset is included in the given list
     * of `assets`. `remote_fees_id` should be enough to pay for `weight_limit`. If more weight
     * is needed than `weight_limit`, then the operation will fail and the sent assets may be
     * at risk.
     *
     * `remote_fees_id` may use different transfer type than rest of `assets` and can be
     * specified through `fees_transfer_type`.
     *
     * The caller needs to specify what should happen to the transferred assets once they reach
     * the `dest` chain. This is done through the `custom_xcm_on_dest` parameter, which
     * contains the instructions to execute on `dest` as a final step.
     * This is usually as simple as:
     * `Xcm(vec![DepositAsset { assets: Wild(AllCounted(assets.len())), beneficiary }])`,
     * but could be something more exotic like sending the `assets` even further.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain, or `(parents: 2, (GlobalConsensus(..), ..))` to send from
     * parachain across a bridge to another ecosystem destination.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` (and possibly reserve) chains.
     * - `assets_transfer_type`: The XCM `TransferType` used to transfer the `assets`.
     * - `remote_fees_id`: One of the included `assets` to be used to pay fees.
     * - `fees_transfer_type`: The XCM `TransferType` used to transfer the `fees` assets.
     * - `custom_xcm_on_dest`: The XCM to be executed on `dest` chain as the last step of the
     * transfer, which also determines what happens to the assets on the destination chain.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedAssets} assets
     * @param {StagingXcmExecutorAssetTransferTransferType} assetsTransferType
     * @param {XcmVersionedAssetId} remoteFeesId
     * @param {StagingXcmExecutorAssetTransferTransferType} feesTransferType
     * @param {XcmVersionedXcm} customXcmOnDest
     * @param {XcmV3WeightLimit} weightLimit
     **/
    transferAssetsUsingTypeAndThen: GenericTxCall<
      Rv,
      (
        dest: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        assetsTransferType: StagingXcmExecutorAssetTransferTransferType,
        remoteFeesId: XcmVersionedAssetId,
        feesTransferType: StagingXcmExecutorAssetTransferTransferType,
        customXcmOnDest: XcmVersionedXcm,
        weightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'PolkadotXcm';
          palletCall: {
            name: 'TransferAssetsUsingTypeAndThen';
            params: {
              dest: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              assetsTransferType: StagingXcmExecutorAssetTransferTransferType;
              remoteFeesId: XcmVersionedAssetId;
              feesTransferType: StagingXcmExecutorAssetTransferTransferType;
              customXcmOnDest: XcmVersionedXcm;
              weightLimit: XcmV3WeightLimit;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Assets`'s transaction calls
   **/
  assets: {
    /**
     * Issue a new class of fungible assets from a public origin.
     *
     * This new asset class has no assets initially and its owner is the origin.
     *
     * The origin must conform to the configured `CreateOrigin` and have sufficient funds free.
     *
     * Funds of sender are reserved by `AssetDeposit`.
     *
     * Parameters:
     * - `id`: The identifier of the new asset. This must not be currently in use to identify
     * an existing asset. If [`NextAssetId`] is set, then this must be equal to it.
     * - `admin`: The admin of this class of assets. The admin is the initial address of each
     * member of the asset class's admin team.
     * - `min_balance`: The minimum balance of this new asset that any single account must
     * have. If an account's balance is reduced below this, then it collapses to zero.
     *
     * Emits `Created` event when successful.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     * @param {AccountId20Like} admin
     * @param {bigint} minBalance
     **/
    create: GenericTxCall<
      Rv,
      (
        id: bigint,
        admin: AccountId20Like,
        minBalance: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Assets';
          palletCall: {
            name: 'Create';
            params: { id: bigint; admin: AccountId20Like; minBalance: bigint };
          };
        }
      >
    >;

    /**
     * Issue a new class of fungible assets from a privileged origin.
     *
     * This new asset class has no assets initially.
     *
     * The origin must conform to `ForceOrigin`.
     *
     * Unlike `create`, no funds are reserved.
     *
     * - `id`: The identifier of the new asset. This must not be currently in use to identify
     * an existing asset. If [`NextAssetId`] is set, then this must be equal to it.
     * - `owner`: The owner of this class of assets. The owner has full superuser permissions
     * over this asset, but may later change and configure the permissions using
     * `transfer_ownership` and `set_team`.
     * - `min_balance`: The minimum balance of this new asset that any single account must
     * have. If an account's balance is reduced below this, then it collapses to zero.
     *
     * Emits `ForceCreated` event when successful.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     * @param {AccountId20Like} owner
     * @param {boolean} isSufficient
     * @param {bigint} minBalance
     **/
    forceCreate: GenericTxCall<
      Rv,
      (
        id: bigint,
        owner: AccountId20Like,
        isSufficient: boolean,
        minBalance: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Assets';
          palletCall: {
            name: 'ForceCreate';
            params: { id: bigint; owner: AccountId20Like; isSufficient: boolean; minBalance: bigint };
          };
        }
      >
    >;

    /**
     * Start the process of destroying a fungible asset class.
     *
     * `start_destroy` is the first in a series of extrinsics that should be called, to allow
     * destruction of an asset class.
     *
     * The origin must conform to `ForceOrigin` or must be `Signed` by the asset's `owner`.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * The asset class must be frozen before calling `start_destroy`.
     *
     * @param {bigint} id
     **/
    startDestroy: GenericTxCall<
      Rv,
      (id: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Assets';
          palletCall: {
            name: 'StartDestroy';
            params: { id: bigint };
          };
        }
      >
    >;

    /**
     * Destroy all accounts associated with a given asset.
     *
     * `destroy_accounts` should only be called after `start_destroy` has been called, and the
     * asset is in a `Destroying` state.
     *
     * Due to weight restrictions, this function may need to be called multiple times to fully
     * destroy all accounts. It will destroy `RemoveItemsLimit` accounts at a time.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * Each call emits the `Event::DestroyedAccounts` event.
     *
     * @param {bigint} id
     **/
    destroyAccounts: GenericTxCall<
      Rv,
      (id: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Assets';
          palletCall: {
            name: 'DestroyAccounts';
            params: { id: bigint };
          };
        }
      >
    >;

    /**
     * Destroy all approvals associated with a given asset up to the max (T::RemoveItemsLimit).
     *
     * `destroy_approvals` should only be called after `start_destroy` has been called, and the
     * asset is in a `Destroying` state.
     *
     * Due to weight restrictions, this function may need to be called multiple times to fully
     * destroy all approvals. It will destroy `RemoveItemsLimit` approvals at a time.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * Each call emits the `Event::DestroyedApprovals` event.
     *
     * @param {bigint} id
     **/
    destroyApprovals: GenericTxCall<
      Rv,
      (id: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Assets';
          palletCall: {
            name: 'DestroyApprovals';
            params: { id: bigint };
          };
        }
      >
    >;

    /**
     * Complete destroying asset and unreserve currency.
     *
     * `finish_destroy` should only be called after `start_destroy` has been called, and the
     * asset is in a `Destroying` state. All accounts or approvals should be destroyed before
     * hand.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * Each successful call emits the `Event::Destroyed` event.
     *
     * @param {bigint} id
     **/
    finishDestroy: GenericTxCall<
      Rv,
      (id: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Assets';
          palletCall: {
            name: 'FinishDestroy';
            params: { id: bigint };
          };
        }
      >
    >;

    /**
     * Mint assets of a particular class.
     *
     * The origin must be Signed and the sender must be the Issuer of the asset `id`.
     *
     * - `id`: The identifier of the asset to have some amount minted.
     * - `beneficiary`: The account to be credited with the minted assets.
     * - `amount`: The amount of the asset to be minted.
     *
     * Emits `Issued` event when successful.
     *
     * Weight: `O(1)`
     * Modes: Pre-existing balance of `beneficiary`; Account pre-existence of `beneficiary`.
     *
     * @param {bigint} id
     * @param {AccountId20Like} beneficiary
     * @param {bigint} amount
     **/
    mint: GenericTxCall<
      Rv,
      (
        id: bigint,
        beneficiary: AccountId20Like,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Assets';
          palletCall: {
            name: 'Mint';
            params: { id: bigint; beneficiary: AccountId20Like; amount: bigint };
          };
        }
      >
    >;

    /**
     * Reduce the balance of `who` by as much as possible up to `amount` assets of `id`.
     *
     * Origin must be Signed and the sender should be the Manager of the asset `id`.
     *
     * Bails with `NoAccount` if the `who` is already dead.
     *
     * - `id`: The identifier of the asset to have some amount burned.
     * - `who`: The account to be debited from.
     * - `amount`: The maximum amount by which `who`'s balance should be reduced.
     *
     * Emits `Burned` with the actual amount burned. If this takes the balance to below the
     * minimum for the asset, then the amount burned is increased to take it to zero.
     *
     * Weight: `O(1)`
     * Modes: Post-existence of `who`; Pre & post Zombie-status of `who`.
     *
     * @param {bigint} id
     * @param {AccountId20Like} who
     * @param {bigint} amount
     **/
    burn: GenericTxCall<
      Rv,
      (
        id: bigint,
        who: AccountId20Like,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Assets';
          palletCall: {
            name: 'Burn';
            params: { id: bigint; who: AccountId20Like; amount: bigint };
          };
        }
      >
    >;

    /**
     * Move some assets from the sender account to another.
     *
     * Origin must be Signed.
     *
     * - `id`: The identifier of the asset to have some amount transferred.
     * - `target`: The account to be credited.
     * - `amount`: The amount by which the sender's balance of assets should be reduced and
     * `target`'s balance increased. The amount actually transferred may be slightly greater in
     * the case that the transfer would otherwise take the sender balance above zero but below
     * the minimum balance. Must be greater than zero.
     *
     * Emits `Transferred` with the actual amount transferred. If this takes the source balance
     * to below the minimum for the asset, then the amount transferred is increased to take it
     * to zero.
     *
     * Weight: `O(1)`
     * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
     * `target`.
     *
     * @param {bigint} id
     * @param {AccountId20Like} target
     * @param {bigint} amount
     **/
    transfer: GenericTxCall<
      Rv,
      (
        id: bigint,
        target: AccountId20Like,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Assets';
          palletCall: {
            name: 'Transfer';
            params: { id: bigint; target: AccountId20Like; amount: bigint };
          };
        }
      >
    >;

    /**
     * Move some assets from the sender account to another, keeping the sender account alive.
     *
     * Origin must be Signed.
     *
     * - `id`: The identifier of the asset to have some amount transferred.
     * - `target`: The account to be credited.
     * - `amount`: The amount by which the sender's balance of assets should be reduced and
     * `target`'s balance increased. The amount actually transferred may be slightly greater in
     * the case that the transfer would otherwise take the sender balance above zero but below
     * the minimum balance. Must be greater than zero.
     *
     * Emits `Transferred` with the actual amount transferred. If this takes the source balance
     * to below the minimum for the asset, then the amount transferred is increased to take it
     * to zero.
     *
     * Weight: `O(1)`
     * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
     * `target`.
     *
     * @param {bigint} id
     * @param {AccountId20Like} target
     * @param {bigint} amount
     **/
    transferKeepAlive: GenericTxCall<
      Rv,
      (
        id: bigint,
        target: AccountId20Like,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Assets';
          palletCall: {
            name: 'TransferKeepAlive';
            params: { id: bigint; target: AccountId20Like; amount: bigint };
          };
        }
      >
    >;

    /**
     * Move some assets from one account to another.
     *
     * Origin must be Signed and the sender should be the Admin of the asset `id`.
     *
     * - `id`: The identifier of the asset to have some amount transferred.
     * - `source`: The account to be debited.
     * - `dest`: The account to be credited.
     * - `amount`: The amount by which the `source`'s balance of assets should be reduced and
     * `dest`'s balance increased. The amount actually transferred may be slightly greater in
     * the case that the transfer would otherwise take the `source` balance above zero but
     * below the minimum balance. Must be greater than zero.
     *
     * Emits `Transferred` with the actual amount transferred. If this takes the source balance
     * to below the minimum for the asset, then the amount transferred is increased to take it
     * to zero.
     *
     * Weight: `O(1)`
     * Modes: Pre-existence of `dest`; Post-existence of `source`; Account pre-existence of
     * `dest`.
     *
     * @param {bigint} id
     * @param {AccountId20Like} source
     * @param {AccountId20Like} dest
     * @param {bigint} amount
     **/
    forceTransfer: GenericTxCall<
      Rv,
      (
        id: bigint,
        source: AccountId20Like,
        dest: AccountId20Like,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Assets';
          palletCall: {
            name: 'ForceTransfer';
            params: { id: bigint; source: AccountId20Like; dest: AccountId20Like; amount: bigint };
          };
        }
      >
    >;

    /**
     * Disallow further unprivileged transfers of an asset `id` from an account `who`. `who`
     * must already exist as an entry in `Account`s of the asset. If you want to freeze an
     * account that does not have an entry, use `touch_other` first.
     *
     * Origin must be Signed and the sender should be the Freezer of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     * - `who`: The account to be frozen.
     *
     * Emits `Frozen`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     * @param {AccountId20Like} who
     **/
    freeze: GenericTxCall<
      Rv,
      (
        id: bigint,
        who: AccountId20Like,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Assets';
          palletCall: {
            name: 'Freeze';
            params: { id: bigint; who: AccountId20Like };
          };
        }
      >
    >;

    /**
     * Allow unprivileged transfers to and from an account again.
     *
     * Origin must be Signed and the sender should be the Admin of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     * - `who`: The account to be unfrozen.
     *
     * Emits `Thawed`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     * @param {AccountId20Like} who
     **/
    thaw: GenericTxCall<
      Rv,
      (
        id: bigint,
        who: AccountId20Like,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Assets';
          palletCall: {
            name: 'Thaw';
            params: { id: bigint; who: AccountId20Like };
          };
        }
      >
    >;

    /**
     * Disallow further unprivileged transfers for the asset class.
     *
     * Origin must be Signed and the sender should be the Freezer of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     *
     * Emits `Frozen`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     **/
    freezeAsset: GenericTxCall<
      Rv,
      (id: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Assets';
          palletCall: {
            name: 'FreezeAsset';
            params: { id: bigint };
          };
        }
      >
    >;

    /**
     * Allow unprivileged transfers for the asset again.
     *
     * Origin must be Signed and the sender should be the Admin of the asset `id`.
     *
     * - `id`: The identifier of the asset to be thawed.
     *
     * Emits `Thawed`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     **/
    thawAsset: GenericTxCall<
      Rv,
      (id: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Assets';
          palletCall: {
            name: 'ThawAsset';
            params: { id: bigint };
          };
        }
      >
    >;

    /**
     * Change the Owner of an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * - `id`: The identifier of the asset.
     * - `owner`: The new Owner of this asset.
     *
     * Emits `OwnerChanged`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     * @param {AccountId20Like} owner
     **/
    transferOwnership: GenericTxCall<
      Rv,
      (
        id: bigint,
        owner: AccountId20Like,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Assets';
          palletCall: {
            name: 'TransferOwnership';
            params: { id: bigint; owner: AccountId20Like };
          };
        }
      >
    >;

    /**
     * Change the Issuer, Admin and Freezer of an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     * - `issuer`: The new Issuer of this asset.
     * - `admin`: The new Admin of this asset.
     * - `freezer`: The new Freezer of this asset.
     *
     * Emits `TeamChanged`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     * @param {AccountId20Like} issuer
     * @param {AccountId20Like} admin
     * @param {AccountId20Like} freezer
     **/
    setTeam: GenericTxCall<
      Rv,
      (
        id: bigint,
        issuer: AccountId20Like,
        admin: AccountId20Like,
        freezer: AccountId20Like,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Assets';
          palletCall: {
            name: 'SetTeam';
            params: { id: bigint; issuer: AccountId20Like; admin: AccountId20Like; freezer: AccountId20Like };
          };
        }
      >
    >;

    /**
     * Set the metadata for an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * Funds of sender are reserved according to the formula:
     * `MetadataDepositBase + MetadataDepositPerByte * (name.len + symbol.len)` taking into
     * account any already reserved funds.
     *
     * - `id`: The identifier of the asset to update.
     * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
     * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
     * - `decimals`: The number of decimals this asset uses to represent one unit.
     *
     * Emits `MetadataSet`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     * @param {BytesLike} name
     * @param {BytesLike} symbol
     * @param {number} decimals
     **/
    setMetadata: GenericTxCall<
      Rv,
      (
        id: bigint,
        name: BytesLike,
        symbol: BytesLike,
        decimals: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Assets';
          palletCall: {
            name: 'SetMetadata';
            params: { id: bigint; name: BytesLike; symbol: BytesLike; decimals: number };
          };
        }
      >
    >;

    /**
     * Clear the metadata for an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * Any deposit is freed for the asset owner.
     *
     * - `id`: The identifier of the asset to clear.
     *
     * Emits `MetadataCleared`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     **/
    clearMetadata: GenericTxCall<
      Rv,
      (id: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Assets';
          palletCall: {
            name: 'ClearMetadata';
            params: { id: bigint };
          };
        }
      >
    >;

    /**
     * Force the metadata for an asset to some value.
     *
     * Origin must be ForceOrigin.
     *
     * Any deposit is left alone.
     *
     * - `id`: The identifier of the asset to update.
     * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
     * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
     * - `decimals`: The number of decimals this asset uses to represent one unit.
     *
     * Emits `MetadataSet`.
     *
     * Weight: `O(N + S)` where N and S are the length of the name and symbol respectively.
     *
     * @param {bigint} id
     * @param {BytesLike} name
     * @param {BytesLike} symbol
     * @param {number} decimals
     * @param {boolean} isFrozen
     **/
    forceSetMetadata: GenericTxCall<
      Rv,
      (
        id: bigint,
        name: BytesLike,
        symbol: BytesLike,
        decimals: number,
        isFrozen: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Assets';
          palletCall: {
            name: 'ForceSetMetadata';
            params: { id: bigint; name: BytesLike; symbol: BytesLike; decimals: number; isFrozen: boolean };
          };
        }
      >
    >;

    /**
     * Clear the metadata for an asset.
     *
     * Origin must be ForceOrigin.
     *
     * Any deposit is returned.
     *
     * - `id`: The identifier of the asset to clear.
     *
     * Emits `MetadataCleared`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     **/
    forceClearMetadata: GenericTxCall<
      Rv,
      (id: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Assets';
          palletCall: {
            name: 'ForceClearMetadata';
            params: { id: bigint };
          };
        }
      >
    >;

    /**
     * Alter the attributes of a given asset.
     *
     * Origin must be `ForceOrigin`.
     *
     * - `id`: The identifier of the asset.
     * - `owner`: The new Owner of this asset.
     * - `issuer`: The new Issuer of this asset.
     * - `admin`: The new Admin of this asset.
     * - `freezer`: The new Freezer of this asset.
     * - `min_balance`: The minimum balance of this new asset that any single account must
     * have. If an account's balance is reduced below this, then it collapses to zero.
     * - `is_sufficient`: Whether a non-zero balance of this asset is deposit of sufficient
     * value to account for the state bloat associated with its balance storage. If set to
     * `true`, then non-zero balances may be stored without a `consumer` reference (and thus
     * an ED in the Balances pallet or whatever else is used to control user-account state
     * growth).
     * - `is_frozen`: Whether this asset class is frozen except for permissioned/admin
     * instructions.
     *
     * Emits `AssetStatusChanged` with the identity of the asset.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     * @param {AccountId20Like} owner
     * @param {AccountId20Like} issuer
     * @param {AccountId20Like} admin
     * @param {AccountId20Like} freezer
     * @param {bigint} minBalance
     * @param {boolean} isSufficient
     * @param {boolean} isFrozen
     **/
    forceAssetStatus: GenericTxCall<
      Rv,
      (
        id: bigint,
        owner: AccountId20Like,
        issuer: AccountId20Like,
        admin: AccountId20Like,
        freezer: AccountId20Like,
        minBalance: bigint,
        isSufficient: boolean,
        isFrozen: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Assets';
          palletCall: {
            name: 'ForceAssetStatus';
            params: {
              id: bigint;
              owner: AccountId20Like;
              issuer: AccountId20Like;
              admin: AccountId20Like;
              freezer: AccountId20Like;
              minBalance: bigint;
              isSufficient: boolean;
              isFrozen: boolean;
            };
          };
        }
      >
    >;

    /**
     * Approve an amount of asset for transfer by a delegated third-party account.
     *
     * Origin must be Signed.
     *
     * Ensures that `ApprovalDeposit` worth of `Currency` is reserved from signing account
     * for the purpose of holding the approval. If some non-zero amount of assets is already
     * approved from signing account to `delegate`, then it is topped up or unreserved to
     * meet the right value.
     *
     * NOTE: The signing account does not need to own `amount` of assets at the point of
     * making this call.
     *
     * - `id`: The identifier of the asset.
     * - `delegate`: The account to delegate permission to transfer asset.
     * - `amount`: The amount of asset that may be transferred by `delegate`. If there is
     * already an approval in place, then this acts additively.
     *
     * Emits `ApprovedTransfer` on success.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     * @param {AccountId20Like} delegate
     * @param {bigint} amount
     **/
    approveTransfer: GenericTxCall<
      Rv,
      (
        id: bigint,
        delegate: AccountId20Like,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Assets';
          palletCall: {
            name: 'ApproveTransfer';
            params: { id: bigint; delegate: AccountId20Like; amount: bigint };
          };
        }
      >
    >;

    /**
     * Cancel all of some asset approved for delegated transfer by a third-party account.
     *
     * Origin must be Signed and there must be an approval in place between signer and
     * `delegate`.
     *
     * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
     *
     * - `id`: The identifier of the asset.
     * - `delegate`: The account delegated permission to transfer asset.
     *
     * Emits `ApprovalCancelled` on success.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     * @param {AccountId20Like} delegate
     **/
    cancelApproval: GenericTxCall<
      Rv,
      (
        id: bigint,
        delegate: AccountId20Like,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Assets';
          palletCall: {
            name: 'CancelApproval';
            params: { id: bigint; delegate: AccountId20Like };
          };
        }
      >
    >;

    /**
     * Cancel all of some asset approved for delegated transfer by a third-party account.
     *
     * Origin must be either ForceOrigin or Signed origin with the signer being the Admin
     * account of the asset `id`.
     *
     * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
     *
     * - `id`: The identifier of the asset.
     * - `delegate`: The account delegated permission to transfer asset.
     *
     * Emits `ApprovalCancelled` on success.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     * @param {AccountId20Like} owner
     * @param {AccountId20Like} delegate
     **/
    forceCancelApproval: GenericTxCall<
      Rv,
      (
        id: bigint,
        owner: AccountId20Like,
        delegate: AccountId20Like,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Assets';
          palletCall: {
            name: 'ForceCancelApproval';
            params: { id: bigint; owner: AccountId20Like; delegate: AccountId20Like };
          };
        }
      >
    >;

    /**
     * Transfer some asset balance from a previously delegated account to some third-party
     * account.
     *
     * Origin must be Signed and there must be an approval in place by the `owner` to the
     * signer.
     *
     * If the entire amount approved for transfer is transferred, then any deposit previously
     * reserved by `approve_transfer` is unreserved.
     *
     * - `id`: The identifier of the asset.
     * - `owner`: The account which previously approved for a transfer of at least `amount` and
     * from which the asset balance will be withdrawn.
     * - `destination`: The account to which the asset balance of `amount` will be transferred.
     * - `amount`: The amount of assets to transfer.
     *
     * Emits `TransferredApproved` on success.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     * @param {AccountId20Like} owner
     * @param {AccountId20Like} destination
     * @param {bigint} amount
     **/
    transferApproved: GenericTxCall<
      Rv,
      (
        id: bigint,
        owner: AccountId20Like,
        destination: AccountId20Like,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Assets';
          palletCall: {
            name: 'TransferApproved';
            params: { id: bigint; owner: AccountId20Like; destination: AccountId20Like; amount: bigint };
          };
        }
      >
    >;

    /**
     * Create an asset account for non-provider assets.
     *
     * A deposit will be taken from the signer account.
     *
     * - `origin`: Must be Signed; the signer account must have sufficient funds for a deposit
     * to be taken.
     * - `id`: The identifier of the asset for the account to be created.
     *
     * Emits `Touched` event when successful.
     *
     * @param {bigint} id
     **/
    touch: GenericTxCall<
      Rv,
      (id: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Assets';
          palletCall: {
            name: 'Touch';
            params: { id: bigint };
          };
        }
      >
    >;

    /**
     * Return the deposit (if any) of an asset account or a consumer reference (if any) of an
     * account.
     *
     * The origin must be Signed.
     *
     * - `id`: The identifier of the asset for which the caller would like the deposit
     * refunded.
     * - `allow_burn`: If `true` then assets may be destroyed in order to complete the refund.
     *
     * Emits `Refunded` event when successful.
     *
     * @param {bigint} id
     * @param {boolean} allowBurn
     **/
    refund: GenericTxCall<
      Rv,
      (
        id: bigint,
        allowBurn: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Assets';
          palletCall: {
            name: 'Refund';
            params: { id: bigint; allowBurn: boolean };
          };
        }
      >
    >;

    /**
     * Sets the minimum balance of an asset.
     *
     * Only works if there aren't any accounts that are holding the asset or if
     * the new value of `min_balance` is less than the old one.
     *
     * Origin must be Signed and the sender has to be the Owner of the
     * asset `id`.
     *
     * - `id`: The identifier of the asset.
     * - `min_balance`: The new value of `min_balance`.
     *
     * Emits `AssetMinBalanceChanged` event when successful.
     *
     * @param {bigint} id
     * @param {bigint} minBalance
     **/
    setMinBalance: GenericTxCall<
      Rv,
      (
        id: bigint,
        minBalance: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Assets';
          palletCall: {
            name: 'SetMinBalance';
            params: { id: bigint; minBalance: bigint };
          };
        }
      >
    >;

    /**
     * Create an asset account for `who`.
     *
     * A deposit will be taken from the signer account.
     *
     * - `origin`: Must be Signed by `Freezer` or `Admin` of the asset `id`; the signer account
     * must have sufficient funds for a deposit to be taken.
     * - `id`: The identifier of the asset for the account to be created.
     * - `who`: The account to be created.
     *
     * Emits `Touched` event when successful.
     *
     * @param {bigint} id
     * @param {AccountId20Like} who
     **/
    touchOther: GenericTxCall<
      Rv,
      (
        id: bigint,
        who: AccountId20Like,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Assets';
          palletCall: {
            name: 'TouchOther';
            params: { id: bigint; who: AccountId20Like };
          };
        }
      >
    >;

    /**
     * Return the deposit (if any) of a target asset account. Useful if you are the depositor.
     *
     * The origin must be Signed and either the account owner, depositor, or asset `Admin`. In
     * order to burn a non-zero balance of the asset, the caller must be the account and should
     * use `refund`.
     *
     * - `id`: The identifier of the asset for the account holding a deposit.
     * - `who`: The account to refund.
     *
     * Emits `Refunded` event when successful.
     *
     * @param {bigint} id
     * @param {AccountId20Like} who
     **/
    refundOther: GenericTxCall<
      Rv,
      (
        id: bigint,
        who: AccountId20Like,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Assets';
          palletCall: {
            name: 'RefundOther';
            params: { id: bigint; who: AccountId20Like };
          };
        }
      >
    >;

    /**
     * Disallow further unprivileged transfers of an asset `id` to and from an account `who`.
     *
     * Origin must be Signed and the sender should be the Freezer of the asset `id`.
     *
     * - `id`: The identifier of the account's asset.
     * - `who`: The account to be unblocked.
     *
     * Emits `Blocked`.
     *
     * Weight: `O(1)`
     *
     * @param {bigint} id
     * @param {AccountId20Like} who
     **/
    block: GenericTxCall<
      Rv,
      (
        id: bigint,
        who: AccountId20Like,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Assets';
          palletCall: {
            name: 'Block';
            params: { id: bigint; who: AccountId20Like };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `AssetManager`'s transaction calls
   **/
  assetManager: {
    /**
     * Register new asset with the asset manager
     *
     * @param {MoonbeamRuntimeXcmConfigAssetType} asset
     * @param {MoonbeamRuntimeAssetConfigAssetRegistrarMetadata} metadata
     * @param {bigint} minAmount
     * @param {boolean} isSufficient
     **/
    registerForeignAsset: GenericTxCall<
      Rv,
      (
        asset: MoonbeamRuntimeXcmConfigAssetType,
        metadata: MoonbeamRuntimeAssetConfigAssetRegistrarMetadata,
        minAmount: bigint,
        isSufficient: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'AssetManager';
          palletCall: {
            name: 'RegisterForeignAsset';
            params: {
              asset: MoonbeamRuntimeXcmConfigAssetType;
              metadata: MoonbeamRuntimeAssetConfigAssetRegistrarMetadata;
              minAmount: bigint;
              isSufficient: boolean;
            };
          };
        }
      >
    >;

    /**
     * Change the xcm type mapping for a given assetId
     * We also change this if the previous units per second where pointing at the old
     * assetType
     *
     * @param {bigint} assetId
     * @param {MoonbeamRuntimeXcmConfigAssetType} newAssetType
     * @param {number} numAssetsWeightHint
     **/
    changeExistingAssetType: GenericTxCall<
      Rv,
      (
        assetId: bigint,
        newAssetType: MoonbeamRuntimeXcmConfigAssetType,
        numAssetsWeightHint: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'AssetManager';
          palletCall: {
            name: 'ChangeExistingAssetType';
            params: { assetId: bigint; newAssetType: MoonbeamRuntimeXcmConfigAssetType; numAssetsWeightHint: number };
          };
        }
      >
    >;

    /**
     * Remove a given assetId -> assetType association
     *
     * @param {bigint} assetId
     * @param {number} numAssetsWeightHint
     **/
    removeExistingAssetType: GenericTxCall<
      Rv,
      (
        assetId: bigint,
        numAssetsWeightHint: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'AssetManager';
          palletCall: {
            name: 'RemoveExistingAssetType';
            params: { assetId: bigint; numAssetsWeightHint: number };
          };
        }
      >
    >;

    /**
     * Destroy a given foreign assetId
     * The weight in this case is the one returned by the trait
     * plus the db writes and reads from removing all the associated
     * data
     *
     * @param {bigint} assetId
     * @param {number} numAssetsWeightHint
     **/
    destroyForeignAsset: GenericTxCall<
      Rv,
      (
        assetId: bigint,
        numAssetsWeightHint: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'AssetManager';
          palletCall: {
            name: 'DestroyForeignAsset';
            params: { assetId: bigint; numAssetsWeightHint: number };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `XcmTransactor`'s transaction calls
   **/
  xcmTransactor: {
    /**
     * Register a derivative index for an account id. Dispatchable by
     * DerivativeAddressRegistrationOrigin
     *
     * We do not store the derivative address, but only the index. We do not need to store
     * the derivative address to issue calls, only the index is enough
     *
     * For now an index is registered for all possible destinations and not per-destination.
     * We can change this in the future although it would just make things more complicated
     *
     * @param {AccountId20Like} who
     * @param {number} index
     **/
    register: GenericTxCall<
      Rv,
      (
        who: AccountId20Like,
        index: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmTransactor';
          palletCall: {
            name: 'Register';
            params: { who: AccountId20Like; index: number };
          };
        }
      >
    >;

    /**
     * De-Register a derivative index. This prevents an account to use a derivative address
     * (represented by an index) from our of our sovereign accounts anymore
     *
     * @param {number} index
     **/
    deregister: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmTransactor';
          palletCall: {
            name: 'Deregister';
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Transact the inner call through a derivative account in a destination chain,
     * using 'fee_location' to pay for the fees. This fee_location is given as a multilocation
     *
     * The caller needs to have the index registered in this pallet. The fee multiasset needs
     * to be a reserve asset for the destination transactor::multilocation.
     *
     * @param {MoonbeamRuntimeXcmConfigTransactors} dest
     * @param {number} index
     * @param {PalletXcmTransactorCurrencyPayment} fee
     * @param {BytesLike} innerCall
     * @param {PalletXcmTransactorTransactWeights} weightInfo
     * @param {boolean} refund
     **/
    transactThroughDerivative: GenericTxCall<
      Rv,
      (
        dest: MoonbeamRuntimeXcmConfigTransactors,
        index: number,
        fee: PalletXcmTransactorCurrencyPayment,
        innerCall: BytesLike,
        weightInfo: PalletXcmTransactorTransactWeights,
        refund: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmTransactor';
          palletCall: {
            name: 'TransactThroughDerivative';
            params: {
              dest: MoonbeamRuntimeXcmConfigTransactors;
              index: number;
              fee: PalletXcmTransactorCurrencyPayment;
              innerCall: BytesLike;
              weightInfo: PalletXcmTransactorTransactWeights;
              refund: boolean;
            };
          };
        }
      >
    >;

    /**
     * Transact the call through the sovereign account in a destination chain,
     * 'fee_payer' pays for the fee
     *
     * SovereignAccountDispatcherOrigin callable only
     *
     * @param {XcmVersionedLocation} dest
     * @param {AccountId20Like | undefined} feePayer
     * @param {PalletXcmTransactorCurrencyPayment} fee
     * @param {BytesLike} call
     * @param {XcmV3OriginKind} originKind
     * @param {PalletXcmTransactorTransactWeights} weightInfo
     * @param {boolean} refund
     **/
    transactThroughSovereign: GenericTxCall<
      Rv,
      (
        dest: XcmVersionedLocation,
        feePayer: AccountId20Like | undefined,
        fee: PalletXcmTransactorCurrencyPayment,
        call: BytesLike,
        originKind: XcmV3OriginKind,
        weightInfo: PalletXcmTransactorTransactWeights,
        refund: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmTransactor';
          palletCall: {
            name: 'TransactThroughSovereign';
            params: {
              dest: XcmVersionedLocation;
              feePayer: AccountId20Like | undefined;
              fee: PalletXcmTransactorCurrencyPayment;
              call: BytesLike;
              originKind: XcmV3OriginKind;
              weightInfo: PalletXcmTransactorTransactWeights;
              refund: boolean;
            };
          };
        }
      >
    >;

    /**
     * Change the transact info of a location
     *
     * @param {XcmVersionedLocation} location
     * @param {SpWeightsWeightV2Weight} transactExtraWeight
     * @param {SpWeightsWeightV2Weight} maxWeight
     * @param {SpWeightsWeightV2Weight | undefined} transactExtraWeightSigned
     **/
    setTransactInfo: GenericTxCall<
      Rv,
      (
        location: XcmVersionedLocation,
        transactExtraWeight: SpWeightsWeightV2Weight,
        maxWeight: SpWeightsWeightV2Weight,
        transactExtraWeightSigned: SpWeightsWeightV2Weight | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmTransactor';
          palletCall: {
            name: 'SetTransactInfo';
            params: {
              location: XcmVersionedLocation;
              transactExtraWeight: SpWeightsWeightV2Weight;
              maxWeight: SpWeightsWeightV2Weight;
              transactExtraWeightSigned: SpWeightsWeightV2Weight | undefined;
            };
          };
        }
      >
    >;

    /**
     * Remove the transact info of a location
     *
     * @param {XcmVersionedLocation} location
     **/
    removeTransactInfo: GenericTxCall<
      Rv,
      (location: XcmVersionedLocation) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmTransactor';
          palletCall: {
            name: 'RemoveTransactInfo';
            params: { location: XcmVersionedLocation };
          };
        }
      >
    >;

    /**
     * Transact the call through the a signed origin in this chain
     * that should be converted to a transaction dispatch account in the destination chain
     * by any method implemented in the destination chains runtime
     *
     * This time we are giving the currency as a currencyId instead of multilocation
     *
     * @param {XcmVersionedLocation} dest
     * @param {PalletXcmTransactorCurrencyPayment} fee
     * @param {BytesLike} call
     * @param {PalletXcmTransactorTransactWeights} weightInfo
     * @param {boolean} refund
     **/
    transactThroughSigned: GenericTxCall<
      Rv,
      (
        dest: XcmVersionedLocation,
        fee: PalletXcmTransactorCurrencyPayment,
        call: BytesLike,
        weightInfo: PalletXcmTransactorTransactWeights,
        refund: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmTransactor';
          palletCall: {
            name: 'TransactThroughSigned';
            params: {
              dest: XcmVersionedLocation;
              fee: PalletXcmTransactorCurrencyPayment;
              call: BytesLike;
              weightInfo: PalletXcmTransactorTransactWeights;
              refund: boolean;
            };
          };
        }
      >
    >;

    /**
     * Set the fee per second of an asset on its reserve chain
     *
     * @param {XcmVersionedLocation} assetLocation
     * @param {bigint} feePerSecond
     **/
    setFeePerSecond: GenericTxCall<
      Rv,
      (
        assetLocation: XcmVersionedLocation,
        feePerSecond: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmTransactor';
          palletCall: {
            name: 'SetFeePerSecond';
            params: { assetLocation: XcmVersionedLocation; feePerSecond: bigint };
          };
        }
      >
    >;

    /**
     * Remove the fee per second of an asset on its reserve chain
     *
     * @param {XcmVersionedLocation} assetLocation
     **/
    removeFeePerSecond: GenericTxCall<
      Rv,
      (assetLocation: XcmVersionedLocation) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmTransactor';
          palletCall: {
            name: 'RemoveFeePerSecond';
            params: { assetLocation: XcmVersionedLocation };
          };
        }
      >
    >;

    /**
     * Manage HRMP operations
     *
     * @param {PalletXcmTransactorHrmpOperation} action
     * @param {PalletXcmTransactorCurrencyPayment} fee
     * @param {PalletXcmTransactorTransactWeights} weightInfo
     **/
    hrmpManage: GenericTxCall<
      Rv,
      (
        action: PalletXcmTransactorHrmpOperation,
        fee: PalletXcmTransactorCurrencyPayment,
        weightInfo: PalletXcmTransactorTransactWeights,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmTransactor';
          palletCall: {
            name: 'HrmpManage';
            params: {
              action: PalletXcmTransactorHrmpOperation;
              fee: PalletXcmTransactorCurrencyPayment;
              weightInfo: PalletXcmTransactorTransactWeights;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `EthereumXcm`'s transaction calls
   **/
  ethereumXcm: {
    /**
     * Xcm Transact an Ethereum transaction.
     * Weight: Gas limit plus the db read involving the suspension check
     *
     * @param {XcmPrimitivesEthereumXcmEthereumXcmTransaction} xcmTransaction
     **/
    transact: GenericTxCall<
      Rv,
      (xcmTransaction: XcmPrimitivesEthereumXcmEthereumXcmTransaction) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'EthereumXcm';
          palletCall: {
            name: 'Transact';
            params: { xcmTransaction: XcmPrimitivesEthereumXcmEthereumXcmTransaction };
          };
        }
      >
    >;

    /**
     * Xcm Transact an Ethereum transaction through proxy.
     * Weight: Gas limit plus the db reads involving the suspension and proxy checks
     *
     * @param {H160} transactAs
     * @param {XcmPrimitivesEthereumXcmEthereumXcmTransaction} xcmTransaction
     **/
    transactThroughProxy: GenericTxCall<
      Rv,
      (
        transactAs: H160,
        xcmTransaction: XcmPrimitivesEthereumXcmEthereumXcmTransaction,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'EthereumXcm';
          palletCall: {
            name: 'TransactThroughProxy';
            params: { transactAs: H160; xcmTransaction: XcmPrimitivesEthereumXcmEthereumXcmTransaction };
          };
        }
      >
    >;

    /**
     * Suspends all Ethereum executions from XCM.
     *
     * - `origin`: Must pass `ControllerOrigin`.
     *
     **/
    suspendEthereumXcmExecution: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'EthereumXcm';
          palletCall: {
            name: 'SuspendEthereumXcmExecution';
          };
        }
      >
    >;

    /**
     * Resumes all Ethereum executions from XCM.
     *
     * - `origin`: Must pass `ControllerOrigin`.
     *
     **/
    resumeEthereumXcmExecution: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'EthereumXcm';
          palletCall: {
            name: 'ResumeEthereumXcmExecution';
          };
        }
      >
    >;

    /**
     * Xcm Transact an Ethereum transaction, but allow to force the caller and create address.
     * This call should be restricted (callable only by the runtime or governance).
     * Weight: Gas limit plus the db reads involving the suspension and proxy checks
     *
     * @param {H160} transactAs
     * @param {XcmPrimitivesEthereumXcmEthereumXcmTransaction} xcmTransaction
     * @param {H160 | undefined} forceCreateAddress
     **/
    forceTransactAs: GenericTxCall<
      Rv,
      (
        transactAs: H160,
        xcmTransaction: XcmPrimitivesEthereumXcmEthereumXcmTransaction,
        forceCreateAddress: H160 | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'EthereumXcm';
          palletCall: {
            name: 'ForceTransactAs';
            params: {
              transactAs: H160;
              xcmTransaction: XcmPrimitivesEthereumXcmEthereumXcmTransaction;
              forceCreateAddress: H160 | undefined;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `MessageQueue`'s transaction calls
   **/
  messageQueue: {
    /**
     * Remove a page which has no more messages remaining to be processed or is stale.
     *
     * @param {CumulusPrimitivesCoreAggregateMessageOrigin} messageOrigin
     * @param {number} pageIndex
     **/
    reapPage: GenericTxCall<
      Rv,
      (
        messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin,
        pageIndex: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'MessageQueue';
          palletCall: {
            name: 'ReapPage';
            params: { messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin; pageIndex: number };
          };
        }
      >
    >;

    /**
     * Execute an overweight message.
     *
     * Temporary processing errors will be propagated whereas permanent errors are treated
     * as success condition.
     *
     * - `origin`: Must be `Signed`.
     * - `message_origin`: The origin from which the message to be executed arrived.
     * - `page`: The page in the queue in which the message to be executed is sitting.
     * - `index`: The index into the queue of the message to be executed.
     * - `weight_limit`: The maximum amount of weight allowed to be consumed in the execution
     * of the message.
     *
     * Benchmark complexity considerations: O(index + weight_limit).
     *
     * @param {CumulusPrimitivesCoreAggregateMessageOrigin} messageOrigin
     * @param {number} page
     * @param {number} index
     * @param {SpWeightsWeightV2Weight} weightLimit
     **/
    executeOverweight: GenericTxCall<
      Rv,
      (
        messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin,
        page: number,
        index: number,
        weightLimit: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'MessageQueue';
          palletCall: {
            name: 'ExecuteOverweight';
            params: {
              messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin;
              page: number;
              index: number;
              weightLimit: SpWeightsWeightV2Weight;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `EvmForeignAssets`'s transaction calls
   **/
  evmForeignAssets: {
    /**
     * Create new asset with the ForeignAssetCreator
     *
     * @param {bigint} assetId
     * @param {StagingXcmV4Location} xcmLocation
     * @param {number} decimals
     * @param {BytesLike} symbol
     * @param {BytesLike} name
     **/
    createForeignAsset: GenericTxCall<
      Rv,
      (
        assetId: bigint,
        xcmLocation: StagingXcmV4Location,
        decimals: number,
        symbol: BytesLike,
        name: BytesLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'EvmForeignAssets';
          palletCall: {
            name: 'CreateForeignAsset';
            params: {
              assetId: bigint;
              xcmLocation: StagingXcmV4Location;
              decimals: number;
              symbol: BytesLike;
              name: BytesLike;
            };
          };
        }
      >
    >;

    /**
     * Change the xcm type mapping for a given assetId
     * We also change this if the previous units per second where pointing at the old
     * assetType
     *
     * @param {bigint} assetId
     * @param {StagingXcmV4Location} newXcmLocation
     **/
    changeXcmLocation: GenericTxCall<
      Rv,
      (
        assetId: bigint,
        newXcmLocation: StagingXcmV4Location,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'EvmForeignAssets';
          palletCall: {
            name: 'ChangeXcmLocation';
            params: { assetId: bigint; newXcmLocation: StagingXcmV4Location };
          };
        }
      >
    >;

    /**
     * Freeze a given foreign assetId
     *
     * @param {bigint} assetId
     * @param {boolean} allowXcmDeposit
     **/
    freezeForeignAsset: GenericTxCall<
      Rv,
      (
        assetId: bigint,
        allowXcmDeposit: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'EvmForeignAssets';
          palletCall: {
            name: 'FreezeForeignAsset';
            params: { assetId: bigint; allowXcmDeposit: boolean };
          };
        }
      >
    >;

    /**
     * Unfreeze a given foreign assetId
     *
     * @param {bigint} assetId
     **/
    unfreezeForeignAsset: GenericTxCall<
      Rv,
      (assetId: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'EvmForeignAssets';
          palletCall: {
            name: 'UnfreezeForeignAsset';
            params: { assetId: bigint };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `XcmWeightTrader`'s transaction calls
   **/
  xcmWeightTrader: {
    /**
     *
     * @param {StagingXcmV4Location} location
     * @param {bigint} relativePrice
     **/
    addAsset: GenericTxCall<
      Rv,
      (
        location: StagingXcmV4Location,
        relativePrice: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmWeightTrader';
          palletCall: {
            name: 'AddAsset';
            params: { location: StagingXcmV4Location; relativePrice: bigint };
          };
        }
      >
    >;

    /**
     *
     * @param {StagingXcmV4Location} location
     * @param {bigint} relativePrice
     **/
    editAsset: GenericTxCall<
      Rv,
      (
        location: StagingXcmV4Location,
        relativePrice: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmWeightTrader';
          palletCall: {
            name: 'EditAsset';
            params: { location: StagingXcmV4Location; relativePrice: bigint };
          };
        }
      >
    >;

    /**
     *
     * @param {StagingXcmV4Location} location
     **/
    pauseAssetSupport: GenericTxCall<
      Rv,
      (location: StagingXcmV4Location) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmWeightTrader';
          palletCall: {
            name: 'PauseAssetSupport';
            params: { location: StagingXcmV4Location };
          };
        }
      >
    >;

    /**
     *
     * @param {StagingXcmV4Location} location
     **/
    resumeAssetSupport: GenericTxCall<
      Rv,
      (location: StagingXcmV4Location) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmWeightTrader';
          palletCall: {
            name: 'ResumeAssetSupport';
            params: { location: StagingXcmV4Location };
          };
        }
      >
    >;

    /**
     *
     * @param {StagingXcmV4Location} location
     **/
    removeAsset: GenericTxCall<
      Rv,
      (location: StagingXcmV4Location) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'XcmWeightTrader';
          palletCall: {
            name: 'RemoveAsset';
            params: { location: StagingXcmV4Location };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `EmergencyParaXcm`'s transaction calls
   **/
  emergencyParaXcm: {
    /**
     * Resume `Normal` mode
     *
     **/
    pausedToNormal: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'EmergencyParaXcm';
          palletCall: {
            name: 'PausedToNormal';
          };
        }
      >
    >;

    /**
     * Authorize a runtime upgrade. Only callable in `Paused` mode
     *
     * @param {H256} codeHash
     **/
    fastAuthorizeUpgrade: GenericTxCall<
      Rv,
      (codeHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'EmergencyParaXcm';
          palletCall: {
            name: 'FastAuthorizeUpgrade';
            params: { codeHash: H256 };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Randomness`'s transaction calls
   **/
  randomness: {
    /**
     * Populates `RandomnessResults` due this epoch with BABE epoch randomness
     *
     **/
    setBabeRandomnessResults: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: 'Randomness';
          palletCall: 'SetBabeRandomnessResults';
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
}
