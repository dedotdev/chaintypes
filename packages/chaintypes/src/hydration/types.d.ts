// Generated by dedot cli

import type {
  Phase,
  H256,
  DispatchInfo,
  DispatchError,
  AccountId32,
  Result,
  Bytes,
  FixedBytes,
  BytesLike,
  AccountId32Like,
  FixedU128,
  H160,
  U256,
  FixedArray,
  Data,
  Permill,
  Perquintill,
  Perbill,
  FixedI64,
  Era,
  Header,
  UncheckedExtrinsic,
} from 'dedot/codecs';

export type FrameSystemAccountInfo = {
  nonce: number;
  consumers: number;
  providers: number;
  sufficients: number;
  data: PalletBalancesAccountData;
};

export type PalletBalancesAccountData = {
  free: bigint;
  reserved: bigint;
  frozen: bigint;
  flags: PalletBalancesExtraFlags;
};

export type PalletBalancesExtraFlags = bigint;

export type FrameSupportDispatchPerDispatchClass = {
  normal: SpWeightsWeightV2Weight;
  operational: SpWeightsWeightV2Weight;
  mandatory: SpWeightsWeightV2Weight;
};

export type SpWeightsWeightV2Weight = { refTime: bigint; proofSize: bigint };

export type FrameSystemEventRecord = { phase: Phase; event: HydradxRuntimeRuntimeEvent; topics: Array<H256> };

export type HydradxRuntimeRuntimeEvent =
  | { pallet: 'System'; palletEvent: FrameSystemEvent }
  | { pallet: 'Balances'; palletEvent: PalletBalancesEvent }
  | { pallet: 'TransactionPayment'; palletEvent: PalletTransactionPaymentEvent }
  | { pallet: 'MultiTransactionPayment'; palletEvent: PalletTransactionMultiPaymentEvent }
  | { pallet: 'Treasury'; palletEvent: PalletTreasuryEvent }
  | { pallet: 'Utility'; palletEvent: PalletUtilityEvent }
  | { pallet: 'Preimage'; palletEvent: PalletPreimageEvent }
  | { pallet: 'Identity'; palletEvent: PalletIdentityEvent }
  | { pallet: 'Democracy'; palletEvent: PalletDemocracyEvent }
  | { pallet: 'Elections'; palletEvent: PalletElectionsPhragmenEvent }
  | { pallet: 'Council'; palletEvent: PalletCollectiveEvent }
  | { pallet: 'TechnicalCommittee'; palletEvent: PalletCollectiveEvent }
  | { pallet: 'Tips'; palletEvent: PalletTipsEvent }
  | { pallet: 'Proxy'; palletEvent: PalletProxyEvent }
  | { pallet: 'Multisig'; palletEvent: PalletMultisigEvent }
  | { pallet: 'Uniques'; palletEvent: PalletUniquesEvent }
  | { pallet: 'StateTrieMigration'; palletEvent: PalletStateTrieMigrationEvent }
  | { pallet: 'ConvictionVoting'; palletEvent: PalletConvictionVotingEvent }
  | { pallet: 'Referenda'; palletEvent: PalletReferendaEvent }
  | { pallet: 'Whitelist'; palletEvent: PalletWhitelistEvent }
  | { pallet: 'Dispatcher'; palletEvent: PalletDispatcherEvent }
  | { pallet: 'AssetRegistry'; palletEvent: PalletAssetRegistryEvent }
  | { pallet: 'Claims'; palletEvent: PalletClaimsEvent }
  | { pallet: 'CollatorRewards'; palletEvent: PalletCollatorRewardsEvent }
  | { pallet: 'Omnipool'; palletEvent: PalletOmnipoolEvent }
  | { pallet: 'TransactionPause'; palletEvent: PalletTransactionPauseEvent }
  | { pallet: 'Duster'; palletEvent: PalletDusterEvent }
  | { pallet: 'OmnipoolWarehouseLM'; palletEvent: PalletLiquidityMiningEvent }
  | { pallet: 'OmnipoolLiquidityMining'; palletEvent: PalletOmnipoolLiquidityMiningEvent }
  | { pallet: 'Otc'; palletEvent: PalletOtcEvent }
  | { pallet: 'CircuitBreaker'; palletEvent: PalletCircuitBreakerEvent }
  | { pallet: 'Router'; palletEvent: PalletRouteExecutorEvent }
  | { pallet: 'DynamicFees'; palletEvent: PalletDynamicFeesEvent }
  | { pallet: 'Staking'; palletEvent: PalletStakingEvent }
  | { pallet: 'Stableswap'; palletEvent: PalletStableswapEvent }
  | { pallet: 'Bonds'; palletEvent: PalletBondsEvent }
  | { pallet: 'OtcSettlements'; palletEvent: PalletOtcSettlementsEvent }
  | { pallet: 'Lbp'; palletEvent: PalletLbpEvent }
  | { pallet: 'Xyk'; palletEvent: PalletXykEvent }
  | { pallet: 'Referrals'; palletEvent: PalletReferralsEvent }
  | { pallet: 'Liquidation'; palletEvent: PalletLiquidationEvent }
  | { pallet: 'Hsm'; palletEvent: PalletHsmEvent }
  | { pallet: 'Tokens'; palletEvent: OrmlTokensModuleEvent }
  | { pallet: 'Currencies'; palletEvent: PalletCurrenciesModuleEvent }
  | { pallet: 'Vesting'; palletEvent: OrmlVestingModuleEvent }
  | { pallet: 'Evm'; palletEvent: PalletEvmEvent }
  | { pallet: 'Ethereum'; palletEvent: PalletEthereumEvent }
  | { pallet: 'EvmAccounts'; palletEvent: PalletEvmAccountsEvent }
  | { pallet: 'XykLiquidityMining'; palletEvent: PalletXykLiquidityMiningEvent }
  | { pallet: 'XykWarehouseLM'; palletEvent: PalletLiquidityMiningEvent }
  | { pallet: 'RelayChainInfo'; palletEvent: PalletRelaychainInfoEvent }
  | { pallet: 'Dca'; palletEvent: PalletDcaEvent }
  | { pallet: 'Scheduler'; palletEvent: PalletSchedulerEvent }
  | { pallet: 'ParachainSystem'; palletEvent: CumulusPalletParachainSystemEvent }
  | { pallet: 'PolkadotXcm'; palletEvent: PalletXcmEvent }
  | { pallet: 'CumulusXcm'; palletEvent: CumulusPalletXcmEvent }
  | { pallet: 'XcmpQueue'; palletEvent: CumulusPalletXcmpQueueEvent }
  | { pallet: 'MessageQueue'; palletEvent: PalletMessageQueueEvent }
  | { pallet: 'OrmlXcm'; palletEvent: OrmlXcmModuleEvent }
  | { pallet: 'XTokens'; palletEvent: OrmlXtokensModuleEvent }
  | { pallet: 'UnknownTokens'; palletEvent: OrmlUnknownTokensModuleEvent }
  | { pallet: 'CollatorSelection'; palletEvent: PalletCollatorSelectionEvent }
  | { pallet: 'Session'; palletEvent: PalletSessionEvent }
  | { pallet: 'EmaOracle'; palletEvent: PalletEmaOracleEvent }
  | { pallet: 'Broadcast'; palletEvent: PalletBroadcastEvent };

/**
 * Event for the System pallet.
 **/
export type FrameSystemEvent =
  /**
   * An extrinsic completed successfully.
   **/
  | { name: 'ExtrinsicSuccess'; data: { dispatchInfo: DispatchInfo } }
  /**
   * An extrinsic failed.
   **/
  | { name: 'ExtrinsicFailed'; data: { dispatchError: DispatchError; dispatchInfo: DispatchInfo } }
  /**
   * `:code` was updated.
   **/
  | { name: 'CodeUpdated' }
  /**
   * A new account was created.
   **/
  | { name: 'NewAccount'; data: { account: AccountId32 } }
  /**
   * An account was reaped.
   **/
  | { name: 'KilledAccount'; data: { account: AccountId32 } }
  /**
   * On on-chain remark happened.
   **/
  | { name: 'Remarked'; data: { sender: AccountId32; hash: H256 } }
  /**
   * An upgrade was authorized.
   **/
  | { name: 'UpgradeAuthorized'; data: { codeHash: H256; checkVersion: boolean } };

export type FrameSupportDispatchDispatchClass = 'Normal' | 'Operational' | 'Mandatory';

export type FrameSupportDispatchPays = 'Yes' | 'No';

/**
 * The `Event` enum of this pallet
 **/
export type PalletBalancesEvent =
  /**
   * An account was created with some free balance.
   **/
  | { name: 'Endowed'; data: { account: AccountId32; freeBalance: bigint } }
  /**
   * An account was removed whose balance was non-zero but below ExistentialDeposit,
   * resulting in an outright loss.
   **/
  | { name: 'DustLost'; data: { account: AccountId32; amount: bigint } }
  /**
   * Transfer succeeded.
   **/
  | { name: 'Transfer'; data: { from: AccountId32; to: AccountId32; amount: bigint } }
  /**
   * A balance was set by root.
   **/
  | { name: 'BalanceSet'; data: { who: AccountId32; free: bigint } }
  /**
   * Some balance was reserved (moved from free to reserved).
   **/
  | { name: 'Reserved'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was unreserved (moved from reserved to free).
   **/
  | { name: 'Unreserved'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was moved from the reserve of the first account to the second account.
   * Final argument indicates the destination balance type.
   **/
  | {
      name: 'ReserveRepatriated';
      data: {
        from: AccountId32;
        to: AccountId32;
        amount: bigint;
        destinationStatus: FrameSupportTokensMiscBalanceStatus;
      };
    }
  /**
   * Some amount was deposited (e.g. for transaction fees).
   **/
  | { name: 'Deposit'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was withdrawn from the account (e.g. for transaction fees).
   **/
  | { name: 'Withdraw'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was removed from the account (e.g. for misbehavior).
   **/
  | { name: 'Slashed'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was minted into an account.
   **/
  | { name: 'Minted'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was burned from an account.
   **/
  | { name: 'Burned'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was suspended from an account (it can be restored later).
   **/
  | { name: 'Suspended'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was restored into an account.
   **/
  | { name: 'Restored'; data: { who: AccountId32; amount: bigint } }
  /**
   * An account was upgraded.
   **/
  | { name: 'Upgraded'; data: { who: AccountId32 } }
  /**
   * Total issuance was increased by `amount`, creating a credit to be balanced.
   **/
  | { name: 'Issued'; data: { amount: bigint } }
  /**
   * Total issuance was decreased by `amount`, creating a debt to be balanced.
   **/
  | { name: 'Rescinded'; data: { amount: bigint } }
  /**
   * Some balance was locked.
   **/
  | { name: 'Locked'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was unlocked.
   **/
  | { name: 'Unlocked'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was frozen.
   **/
  | { name: 'Frozen'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was thawed.
   **/
  | { name: 'Thawed'; data: { who: AccountId32; amount: bigint } }
  /**
   * The `TotalIssuance` was forcefully changed.
   **/
  | { name: 'TotalIssuanceForced'; data: { old: bigint; new: bigint } };

export type FrameSupportTokensMiscBalanceStatus = 'Free' | 'Reserved';

/**
 * The `Event` enum of this pallet
 **/
export type PalletTransactionPaymentEvent =
  /**
   * A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,
   * has been paid by `who`.
   **/
  { name: 'TransactionFeePaid'; data: { who: AccountId32; actualFee: bigint; tip: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletTransactionMultiPaymentEvent =
  /**
   * CurrencySet
   * [who, currency]
   **/
  | { name: 'CurrencySet'; data: { accountId: AccountId32; assetId: number } }
  /**
   * New accepted currency added
   * [currency]
   **/
  | { name: 'CurrencyAdded'; data: { assetId: number } }
  /**
   * Accepted currency removed
   * [currency]
   **/
  | { name: 'CurrencyRemoved'; data: { assetId: number } }
  /**
   * Transaction fee paid in non-native currency
   * [Account, Currency, Native fee amount, Non-native fee amount, Destination account]
   **/
  | {
      name: 'FeeWithdrawn';
      data: {
        accountId: AccountId32;
        assetId: number;
        nativeFeeAmount: bigint;
        nonNativeFeeAmount: bigint;
        destinationAccountId: AccountId32;
      };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletTreasuryEvent =
  /**
   * We have ended a spend period and will now allocate funds.
   **/
  | { name: 'Spending'; data: { budgetRemaining: bigint } }
  /**
   * Some funds have been allocated.
   **/
  | { name: 'Awarded'; data: { proposalIndex: number; award: bigint; account: AccountId32 } }
  /**
   * Some of our funds have been burnt.
   **/
  | { name: 'Burnt'; data: { burntFunds: bigint } }
  /**
   * Spending has finished; this is the amount that rolls over until next spend.
   **/
  | { name: 'Rollover'; data: { rolloverBalance: bigint } }
  /**
   * Some funds have been deposited.
   **/
  | { name: 'Deposit'; data: { value: bigint } }
  /**
   * A new spend proposal has been approved.
   **/
  | { name: 'SpendApproved'; data: { proposalIndex: number; amount: bigint; beneficiary: AccountId32 } }
  /**
   * The inactive funds of the pallet have been updated.
   **/
  | { name: 'UpdatedInactive'; data: { reactivated: bigint; deactivated: bigint } }
  /**
   * A new asset spend proposal has been approved.
   **/
  | {
      name: 'AssetSpendApproved';
      data: {
        index: number;
        assetKind: [];
        amount: bigint;
        beneficiary: AccountId32;
        validFrom: number;
        expireAt: number;
      };
    }
  /**
   * An approved spend was voided.
   **/
  | { name: 'AssetSpendVoided'; data: { index: number } }
  /**
   * A payment happened.
   **/
  | { name: 'Paid'; data: { index: number; paymentId: [] } }
  /**
   * A payment failed and can be retried.
   **/
  | { name: 'PaymentFailed'; data: { index: number; paymentId: [] } }
  /**
   * A spend was processed and removed from the storage. It might have been successfully
   * paid or it may have expired.
   **/
  | { name: 'SpendProcessed'; data: { index: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletUtilityEvent =
  /**
   * Batch of dispatches did not complete fully. Index of first failing dispatch given, as
   * well as the error.
   **/
  | { name: 'BatchInterrupted'; data: { index: number; error: DispatchError } }
  /**
   * Batch of dispatches completed fully with no error.
   **/
  | { name: 'BatchCompleted' }
  /**
   * Batch of dispatches completed but has errors.
   **/
  | { name: 'BatchCompletedWithErrors' }
  /**
   * A single item within a Batch of dispatches has completed with no error.
   **/
  | { name: 'ItemCompleted' }
  /**
   * A single item within a Batch of dispatches has completed with error.
   **/
  | { name: 'ItemFailed'; data: { error: DispatchError } }
  /**
   * A call was dispatched.
   **/
  | { name: 'DispatchedAs'; data: { result: Result<[], DispatchError> } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletPreimageEvent =
  /**
   * A preimage has been noted.
   **/
  | { name: 'Noted'; data: { hash: H256 } }
  /**
   * A preimage has been requested.
   **/
  | { name: 'Requested'; data: { hash: H256 } }
  /**
   * A preimage has ben cleared.
   **/
  | { name: 'Cleared'; data: { hash: H256 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletIdentityEvent =
  /**
   * A name was set or reset (which will remove all judgements).
   **/
  | { name: 'IdentitySet'; data: { who: AccountId32 } }
  /**
   * A name was cleared, and the given balance returned.
   **/
  | { name: 'IdentityCleared'; data: { who: AccountId32; deposit: bigint } }
  /**
   * A name was removed and the given balance slashed.
   **/
  | { name: 'IdentityKilled'; data: { who: AccountId32; deposit: bigint } }
  /**
   * A judgement was asked from a registrar.
   **/
  | { name: 'JudgementRequested'; data: { who: AccountId32; registrarIndex: number } }
  /**
   * A judgement request was retracted.
   **/
  | { name: 'JudgementUnrequested'; data: { who: AccountId32; registrarIndex: number } }
  /**
   * A judgement was given by a registrar.
   **/
  | { name: 'JudgementGiven'; data: { target: AccountId32; registrarIndex: number } }
  /**
   * A registrar was added.
   **/
  | { name: 'RegistrarAdded'; data: { registrarIndex: number } }
  /**
   * A sub-identity was added to an identity and the deposit paid.
   **/
  | { name: 'SubIdentityAdded'; data: { sub: AccountId32; main: AccountId32; deposit: bigint } }
  /**
   * A sub-identity was removed from an identity and the deposit freed.
   **/
  | { name: 'SubIdentityRemoved'; data: { sub: AccountId32; main: AccountId32; deposit: bigint } }
  /**
   * A sub-identity was cleared, and the given deposit repatriated from the
   * main identity account to the sub-identity account.
   **/
  | { name: 'SubIdentityRevoked'; data: { sub: AccountId32; main: AccountId32; deposit: bigint } }
  /**
   * A username authority was added.
   **/
  | { name: 'AuthorityAdded'; data: { authority: AccountId32 } }
  /**
   * A username authority was removed.
   **/
  | { name: 'AuthorityRemoved'; data: { authority: AccountId32 } }
  /**
   * A username was set for `who`.
   **/
  | { name: 'UsernameSet'; data: { who: AccountId32; username: Bytes } }
  /**
   * A username was queued, but `who` must accept it prior to `expiration`.
   **/
  | { name: 'UsernameQueued'; data: { who: AccountId32; username: Bytes; expiration: number } }
  /**
   * A queued username passed its expiration without being claimed and was removed.
   **/
  | { name: 'PreapprovalExpired'; data: { whose: AccountId32 } }
  /**
   * A username was set as a primary and can be looked up from `who`.
   **/
  | { name: 'PrimaryUsernameSet'; data: { who: AccountId32; username: Bytes } }
  /**
   * A dangling username (as in, a username corresponding to an account that has removed its
   * identity) has been removed.
   **/
  | { name: 'DanglingUsernameRemoved'; data: { who: AccountId32; username: Bytes } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletDemocracyEvent =
  /**
   * A motion has been proposed by a public account.
   **/
  | { name: 'Proposed'; data: { proposalIndex: number; deposit: bigint } }
  /**
   * A public proposal has been tabled for referendum vote.
   **/
  | { name: 'Tabled'; data: { proposalIndex: number; deposit: bigint } }
  /**
   * An external proposal has been tabled.
   **/
  | { name: 'ExternalTabled' }
  /**
   * A referendum has begun.
   **/
  | { name: 'Started'; data: { refIndex: number; threshold: PalletDemocracyVoteThreshold } }
  /**
   * A proposal has been approved by referendum.
   **/
  | { name: 'Passed'; data: { refIndex: number } }
  /**
   * A proposal has been rejected by referendum.
   **/
  | { name: 'NotPassed'; data: { refIndex: number } }
  /**
   * A referendum has been cancelled.
   **/
  | { name: 'Cancelled'; data: { refIndex: number } }
  /**
   * An account has delegated their vote to another account.
   **/
  | { name: 'Delegated'; data: { who: AccountId32; target: AccountId32 } }
  /**
   * An account has cancelled a previous delegation operation.
   **/
  | { name: 'Undelegated'; data: { account: AccountId32 } }
  /**
   * An external proposal has been vetoed.
   **/
  | { name: 'Vetoed'; data: { who: AccountId32; proposalHash: H256; until: number } }
  /**
   * A proposal_hash has been blacklisted permanently.
   **/
  | { name: 'Blacklisted'; data: { proposalHash: H256 } }
  /**
   * An account has voted in a referendum
   **/
  | { name: 'Voted'; data: { voter: AccountId32; refIndex: number; vote: PalletDemocracyVoteAccountVote } }
  /**
   * An account has secconded a proposal
   **/
  | { name: 'Seconded'; data: { seconder: AccountId32; propIndex: number } }
  /**
   * A proposal got canceled.
   **/
  | { name: 'ProposalCanceled'; data: { propIndex: number } }
  /**
   * Metadata for a proposal or a referendum has been set.
   **/
  | {
      name: 'MetadataSet';
      data: {
        /**
         * Metadata owner.
         **/
        owner: PalletDemocracyMetadataOwner;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    }
  /**
   * Metadata for a proposal or a referendum has been cleared.
   **/
  | {
      name: 'MetadataCleared';
      data: {
        /**
         * Metadata owner.
         **/
        owner: PalletDemocracyMetadataOwner;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    }
  /**
   * Metadata has been transferred to new owner.
   **/
  | {
      name: 'MetadataTransferred';
      data: {
        /**
         * Previous metadata owner.
         **/
        prevOwner: PalletDemocracyMetadataOwner;

        /**
         * New metadata owner.
         **/
        owner: PalletDemocracyMetadataOwner;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    };

export type PalletDemocracyVoteThreshold = 'SuperMajorityApprove' | 'SuperMajorityAgainst' | 'SimpleMajority';

export type PalletDemocracyVoteAccountVote =
  | { type: 'Standard'; value: { vote: PalletDemocracyVote; balance: bigint } }
  | { type: 'Split'; value: { aye: bigint; nay: bigint } };

export type PalletDemocracyVote = number;

export type PalletDemocracyMetadataOwner =
  | { type: 'External' }
  | { type: 'Proposal'; value: number }
  | { type: 'Referendum'; value: number };

/**
 * The `Event` enum of this pallet
 **/
export type PalletElectionsPhragmenEvent =
  /**
   * A new term with new_members. This indicates that enough candidates existed to run
   * the election, not that enough have has been elected. The inner value must be examined
   * for this purpose. A `NewTerm(\[\])` indicates that some candidates got their bond
   * slashed and none were elected, whilst `EmptyTerm` means that no candidates existed to
   * begin with.
   **/
  | { name: 'NewTerm'; data: { newMembers: Array<[AccountId32, bigint]> } }
  /**
   * No (or not enough) candidates existed for this round. This is different from
   * `NewTerm(\[\])`. See the description of `NewTerm`.
   **/
  | { name: 'EmptyTerm' }
  /**
   * Internal error happened while trying to perform election.
   **/
  | { name: 'ElectionError' }
  /**
   * A member has been removed. This should always be followed by either `NewTerm` or
   * `EmptyTerm`.
   **/
  | { name: 'MemberKicked'; data: { member: AccountId32 } }
  /**
   * Someone has renounced their candidacy.
   **/
  | { name: 'Renounced'; data: { candidate: AccountId32 } }
  /**
   * A candidate was slashed by amount due to failing to obtain a seat as member or
   * runner-up.
   *
   * Note that old members and runners-up are also candidates.
   **/
  | { name: 'CandidateSlashed'; data: { candidate: AccountId32; amount: bigint } }
  /**
   * A seat holder was slashed by amount by being forcefully removed from the set.
   **/
  | { name: 'SeatHolderSlashed'; data: { seatHolder: AccountId32; amount: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletCollectiveEvent =
  /**
   * A motion (given hash) has been proposed (by given account) with a threshold (given
   * `MemberCount`).
   **/
  | { name: 'Proposed'; data: { account: AccountId32; proposalIndex: number; proposalHash: H256; threshold: number } }
  /**
   * A motion (given hash) has been voted on by given account, leaving
   * a tally (yes votes and no votes given respectively as `MemberCount`).
   **/
  | { name: 'Voted'; data: { account: AccountId32; proposalHash: H256; voted: boolean; yes: number; no: number } }
  /**
   * A motion was approved by the required threshold.
   **/
  | { name: 'Approved'; data: { proposalHash: H256 } }
  /**
   * A motion was not approved by the required threshold.
   **/
  | { name: 'Disapproved'; data: { proposalHash: H256 } }
  /**
   * A motion was executed; result will be `Ok` if it returned without error.
   **/
  | { name: 'Executed'; data: { proposalHash: H256; result: Result<[], DispatchError> } }
  /**
   * A single member did some action; result will be `Ok` if it returned without error.
   **/
  | { name: 'MemberExecuted'; data: { proposalHash: H256; result: Result<[], DispatchError> } }
  /**
   * A proposal was closed because its threshold was reached or after its duration was up.
   **/
  | { name: 'Closed'; data: { proposalHash: H256; yes: number; no: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletTipsEvent =
  /**
   * A new tip suggestion has been opened.
   **/
  | { name: 'NewTip'; data: { tipHash: H256 } }
  /**
   * A tip suggestion has reached threshold and is closing.
   **/
  | { name: 'TipClosing'; data: { tipHash: H256 } }
  /**
   * A tip suggestion has been closed.
   **/
  | { name: 'TipClosed'; data: { tipHash: H256; who: AccountId32; payout: bigint } }
  /**
   * A tip suggestion has been retracted.
   **/
  | { name: 'TipRetracted'; data: { tipHash: H256 } }
  /**
   * A tip suggestion has been slashed.
   **/
  | { name: 'TipSlashed'; data: { tipHash: H256; finder: AccountId32; deposit: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletProxyEvent =
  /**
   * A proxy was executed correctly, with the given.
   **/
  | { name: 'ProxyExecuted'; data: { result: Result<[], DispatchError> } }
  /**
   * A pure account has been created by new proxy with given
   * disambiguation index and proxy type.
   **/
  | {
      name: 'PureCreated';
      data: {
        pure: AccountId32;
        who: AccountId32;
        proxyType: HydradxRuntimeSystemProxyType;
        disambiguationIndex: number;
      };
    }
  /**
   * An announcement was placed to make a call in the future.
   **/
  | { name: 'Announced'; data: { real: AccountId32; proxy: AccountId32; callHash: H256 } }
  /**
   * A proxy was added.
   **/
  | {
      name: 'ProxyAdded';
      data: { delegator: AccountId32; delegatee: AccountId32; proxyType: HydradxRuntimeSystemProxyType; delay: number };
    }
  /**
   * A proxy was removed.
   **/
  | {
      name: 'ProxyRemoved';
      data: { delegator: AccountId32; delegatee: AccountId32; proxyType: HydradxRuntimeSystemProxyType; delay: number };
    };

export type HydradxRuntimeSystemProxyType =
  | 'Any'
  | 'CancelProxy'
  | 'Governance'
  | 'Transfer'
  | 'Liquidity'
  | 'LiquidityMining';

/**
 * The `Event` enum of this pallet
 **/
export type PalletMultisigEvent =
  /**
   * A new multisig operation has begun.
   **/
  | { name: 'NewMultisig'; data: { approving: AccountId32; multisig: AccountId32; callHash: FixedBytes<32> } }
  /**
   * A multisig operation has been approved by someone.
   **/
  | {
      name: 'MultisigApproval';
      data: {
        approving: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
      };
    }
  /**
   * A multisig operation has been executed.
   **/
  | {
      name: 'MultisigExecuted';
      data: {
        approving: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
        result: Result<[], DispatchError>;
      };
    }
  /**
   * A multisig operation has been cancelled.
   **/
  | {
      name: 'MultisigCancelled';
      data: {
        cancelling: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
      };
    };

export type PalletMultisigTimepoint = { height: number; index: number };

/**
 * The `Event` enum of this pallet
 **/
export type PalletUniquesEvent =
  /**
   * A `collection` was created.
   **/
  | { name: 'Created'; data: { collection: bigint; creator: AccountId32; owner: AccountId32 } }
  /**
   * A `collection` was force-created.
   **/
  | { name: 'ForceCreated'; data: { collection: bigint; owner: AccountId32 } }
  /**
   * A `collection` was destroyed.
   **/
  | { name: 'Destroyed'; data: { collection: bigint } }
  /**
   * An `item` was issued.
   **/
  | { name: 'Issued'; data: { collection: bigint; item: bigint; owner: AccountId32 } }
  /**
   * An `item` was transferred.
   **/
  | { name: 'Transferred'; data: { collection: bigint; item: bigint; from: AccountId32; to: AccountId32 } }
  /**
   * An `item` was destroyed.
   **/
  | { name: 'Burned'; data: { collection: bigint; item: bigint; owner: AccountId32 } }
  /**
   * Some `item` was frozen.
   **/
  | { name: 'Frozen'; data: { collection: bigint; item: bigint } }
  /**
   * Some `item` was thawed.
   **/
  | { name: 'Thawed'; data: { collection: bigint; item: bigint } }
  /**
   * Some `collection` was frozen.
   **/
  | { name: 'CollectionFrozen'; data: { collection: bigint } }
  /**
   * Some `collection` was thawed.
   **/
  | { name: 'CollectionThawed'; data: { collection: bigint } }
  /**
   * The owner changed.
   **/
  | { name: 'OwnerChanged'; data: { collection: bigint; newOwner: AccountId32 } }
  /**
   * The management team changed.
   **/
  | { name: 'TeamChanged'; data: { collection: bigint; issuer: AccountId32; admin: AccountId32; freezer: AccountId32 } }
  /**
   * An `item` of a `collection` has been approved by the `owner` for transfer by
   * a `delegate`.
   **/
  | { name: 'ApprovedTransfer'; data: { collection: bigint; item: bigint; owner: AccountId32; delegate: AccountId32 } }
  /**
   * An approval for a `delegate` account to transfer the `item` of an item
   * `collection` was cancelled by its `owner`.
   **/
  | { name: 'ApprovalCancelled'; data: { collection: bigint; item: bigint; owner: AccountId32; delegate: AccountId32 } }
  /**
   * A `collection` has had its attributes changed by the `Force` origin.
   **/
  | { name: 'ItemStatusChanged'; data: { collection: bigint } }
  /**
   * New metadata has been set for a `collection`.
   **/
  | { name: 'CollectionMetadataSet'; data: { collection: bigint; data: Bytes; isFrozen: boolean } }
  /**
   * Metadata has been cleared for a `collection`.
   **/
  | { name: 'CollectionMetadataCleared'; data: { collection: bigint } }
  /**
   * New metadata has been set for an item.
   **/
  | { name: 'MetadataSet'; data: { collection: bigint; item: bigint; data: Bytes; isFrozen: boolean } }
  /**
   * Metadata has been cleared for an item.
   **/
  | { name: 'MetadataCleared'; data: { collection: bigint; item: bigint } }
  /**
   * Metadata has been cleared for an item.
   **/
  | { name: 'Redeposited'; data: { collection: bigint; successfulItems: Array<bigint> } }
  /**
   * New attribute metadata has been set for a `collection` or `item`.
   **/
  | { name: 'AttributeSet'; data: { collection: bigint; maybeItem?: bigint | undefined; key: Bytes; value: Bytes } }
  /**
   * Attribute metadata has been cleared for a `collection` or `item`.
   **/
  | { name: 'AttributeCleared'; data: { collection: bigint; maybeItem?: bigint | undefined; key: Bytes } }
  /**
   * Ownership acceptance has changed for an account.
   **/
  | { name: 'OwnershipAcceptanceChanged'; data: { who: AccountId32; maybeCollection?: bigint | undefined } }
  /**
   * Max supply has been set for a collection.
   **/
  | { name: 'CollectionMaxSupplySet'; data: { collection: bigint; maxSupply: number } }
  /**
   * The price was set for the instance.
   **/
  | {
      name: 'ItemPriceSet';
      data: { collection: bigint; item: bigint; price: bigint; whitelistedBuyer?: AccountId32 | undefined };
    }
  /**
   * The price for the instance was removed.
   **/
  | { name: 'ItemPriceRemoved'; data: { collection: bigint; item: bigint } }
  /**
   * An item was bought.
   **/
  | {
      name: 'ItemBought';
      data: { collection: bigint; item: bigint; price: bigint; seller: AccountId32; buyer: AccountId32 };
    };

/**
 * Inner events of this pallet.
 **/
export type PalletStateTrieMigrationEvent =
  /**
   * Given number of `(top, child)` keys were migrated respectively, with the given
   * `compute`.
   **/
  | { name: 'Migrated'; data: { top: number; child: number; compute: PalletStateTrieMigrationMigrationCompute } }
  /**
   * Some account got slashed by the given amount.
   **/
  | { name: 'Slashed'; data: { who: AccountId32; amount: bigint } }
  /**
   * The auto migration task finished.
   **/
  | { name: 'AutoMigrationFinished' }
  /**
   * Migration got halted due to an error or miss-configuration.
   **/
  | { name: 'Halted'; data: { error: PalletStateTrieMigrationError } };

export type PalletStateTrieMigrationMigrationCompute = 'Signed' | 'Auto';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletStateTrieMigrationError =
  /**
   * Max signed limits not respected.
   **/
  | 'MaxSignedLimits'
  /**
   * A key was longer than the configured maximum.
   *
   * This means that the migration halted at the current [`Progress`] and
   * can be resumed with a larger [`crate::Config::MaxKeyLen`] value.
   * Retrying with the same [`crate::Config::MaxKeyLen`] value will not work.
   * The value should only be increased to avoid a storage migration for the currently
   * stored [`crate::Progress::LastKey`].
   **/
  | 'KeyTooLong'
  /**
   * submitter does not have enough funds.
   **/
  | 'NotEnoughFunds'
  /**
   * Bad witness data provided.
   **/
  | 'BadWitness'
  /**
   * Signed migration is not allowed because the maximum limit is not set yet.
   **/
  | 'SignedMigrationNotAllowed'
  /**
   * Bad child root provided.
   **/
  | 'BadChildRoot';

/**
 * The `Event` enum of this pallet
 **/
export type PalletConvictionVotingEvent =
  /**
   * An account has delegated their vote to another account. \[who, target\]
   **/
  | { name: 'Delegated'; data: [AccountId32, AccountId32] }
  /**
   * An \[account\] has cancelled a previous delegation operation.
   **/
  | { name: 'Undelegated'; data: AccountId32 }
  /**
   * An account that has voted
   **/
  | { name: 'Voted'; data: { who: AccountId32; vote: PalletConvictionVotingVoteAccountVote } }
  /**
   * A vote that been removed
   **/
  | { name: 'VoteRemoved'; data: { who: AccountId32; vote: PalletConvictionVotingVoteAccountVote } };

export type PalletConvictionVotingVoteAccountVote =
  | { type: 'Standard'; value: { vote: PalletConvictionVotingVote; balance: bigint } }
  | { type: 'Split'; value: { aye: bigint; nay: bigint } }
  | { type: 'SplitAbstain'; value: { aye: bigint; nay: bigint; abstain: bigint } };

export type PalletConvictionVotingVote = number;

/**
 * The `Event` enum of this pallet
 **/
export type PalletReferendaEvent =
  /**
   * A referendum has been submitted.
   **/
  | {
      name: 'Submitted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The track (and by extension proposal dispatch origin) of this referendum.
         **/
        track: number;

        /**
         * The proposal for the referendum.
         **/
        proposal: FrameSupportPreimagesBounded;
      };
    }
  /**
   * The decision deposit has been placed.
   **/
  | {
      name: 'DecisionDepositPlaced';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * The decision deposit has been refunded.
   **/
  | {
      name: 'DecisionDepositRefunded';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * A deposit has been slashed.
   **/
  | {
      name: 'DepositSlashed';
      data: {
        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * A referendum has moved into the deciding phase.
   **/
  | {
      name: 'DecisionStarted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The track (and by extension proposal dispatch origin) of this referendum.
         **/
        track: number;

        /**
         * The proposal for the referendum.
         **/
        proposal: FrameSupportPreimagesBounded;

        /**
         * The current tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  | {
      name: 'ConfirmStarted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  | {
      name: 'ConfirmAborted';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  /**
   * A referendum has ended its confirmation phase and is ready for approval.
   **/
  | {
      name: 'Confirmed';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  /**
   * A referendum has been approved and its proposal has been scheduled.
   **/
  | {
      name: 'Approved';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  /**
   * A proposal has been rejected by referendum.
   **/
  | {
      name: 'Rejected';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  /**
   * A referendum has been timed out without being decided.
   **/
  | {
      name: 'TimedOut';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  /**
   * A referendum has been cancelled.
   **/
  | {
      name: 'Cancelled';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  /**
   * A referendum has been killed.
   **/
  | {
      name: 'Killed';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  /**
   * The submission deposit has been refunded.
   **/
  | {
      name: 'SubmissionDepositRefunded';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  /**
   * Metadata for a referendum has been set.
   **/
  | {
      name: 'MetadataSet';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    }
  /**
   * Metadata for a referendum has been cleared.
   **/
  | {
      name: 'MetadataCleared';
      data: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    };

export type FrameSupportPreimagesBounded =
  | { type: 'Legacy'; value: { hash: H256 } }
  | { type: 'Inline'; value: Bytes }
  | { type: 'Lookup'; value: { hash: H256; len: number } };

export type HydradxRuntimeRuntimeCall =
  | { pallet: 'System'; palletCall: FrameSystemCall }
  | { pallet: 'Timestamp'; palletCall: PalletTimestampCall }
  | { pallet: 'Balances'; palletCall: PalletBalancesCall }
  | { pallet: 'MultiTransactionPayment'; palletCall: PalletTransactionMultiPaymentCall }
  | { pallet: 'Treasury'; palletCall: PalletTreasuryCall }
  | { pallet: 'Utility'; palletCall: PalletUtilityCall }
  | { pallet: 'Preimage'; palletCall: PalletPreimageCall }
  | { pallet: 'Identity'; palletCall: PalletIdentityCall }
  | { pallet: 'Democracy'; palletCall: PalletDemocracyCall }
  | { pallet: 'Elections'; palletCall: PalletElectionsPhragmenCall }
  | { pallet: 'Council'; palletCall: PalletCollectiveCall }
  | { pallet: 'TechnicalCommittee'; palletCall: PalletCollectiveCall }
  | { pallet: 'Tips'; palletCall: PalletTipsCall }
  | { pallet: 'Proxy'; palletCall: PalletProxyCall }
  | { pallet: 'Multisig'; palletCall: PalletMultisigCall }
  | { pallet: 'Uniques'; palletCall: PalletUniquesCall }
  | { pallet: 'StateTrieMigration'; palletCall: PalletStateTrieMigrationCall }
  | { pallet: 'ConvictionVoting'; palletCall: PalletConvictionVotingCall }
  | { pallet: 'Referenda'; palletCall: PalletReferendaCall }
  | { pallet: 'Whitelist'; palletCall: PalletWhitelistCall }
  | { pallet: 'Dispatcher'; palletCall: PalletDispatcherCall }
  | { pallet: 'AssetRegistry'; palletCall: PalletAssetRegistryCall }
  | { pallet: 'Claims'; palletCall: PalletClaimsCall }
  | { pallet: 'GenesisHistory'; palletCall: PalletGenesisHistoryCall }
  | { pallet: 'Omnipool'; palletCall: PalletOmnipoolCall }
  | { pallet: 'TransactionPause'; palletCall: PalletTransactionPauseCall }
  | { pallet: 'Duster'; palletCall: PalletDusterCall }
  | { pallet: 'OmnipoolWarehouseLM'; palletCall: PalletLiquidityMiningCall }
  | { pallet: 'OmnipoolLiquidityMining'; palletCall: PalletOmnipoolLiquidityMiningCall }
  | { pallet: 'Otc'; palletCall: PalletOtcCall }
  | { pallet: 'CircuitBreaker'; palletCall: PalletCircuitBreakerCall }
  | { pallet: 'Router'; palletCall: PalletRouteExecutorCall }
  | { pallet: 'DynamicFees'; palletCall: PalletDynamicFeesCall }
  | { pallet: 'Staking'; palletCall: PalletStakingCall }
  | { pallet: 'Stableswap'; palletCall: PalletStableswapCall }
  | { pallet: 'Bonds'; palletCall: PalletBondsCall }
  | { pallet: 'OtcSettlements'; palletCall: PalletOtcSettlementsCall }
  | { pallet: 'Lbp'; palletCall: PalletLbpCall }
  | { pallet: 'Xyk'; palletCall: PalletXykCall }
  | { pallet: 'Referrals'; palletCall: PalletReferralsCall }
  | { pallet: 'Liquidation'; palletCall: PalletLiquidationCall }
  | { pallet: 'Hsm'; palletCall: PalletHsmCall }
  | { pallet: 'Tokens'; palletCall: OrmlTokensModuleCall }
  | { pallet: 'Currencies'; palletCall: PalletCurrenciesModuleCall }
  | { pallet: 'Vesting'; palletCall: OrmlVestingModuleCall }
  | { pallet: 'Evm'; palletCall: PalletEvmCall }
  | { pallet: 'Ethereum'; palletCall: PalletEthereumCall }
  | { pallet: 'EvmAccounts'; palletCall: PalletEvmAccountsCall }
  | { pallet: 'XykLiquidityMining'; palletCall: PalletXykLiquidityMiningCall }
  | { pallet: 'XykWarehouseLM'; palletCall: PalletLiquidityMiningCall }
  | { pallet: 'RelayChainInfo'; palletCall: PalletRelaychainInfoCall }
  | { pallet: 'Dca'; palletCall: PalletDcaCall }
  | { pallet: 'Scheduler'; palletCall: PalletSchedulerCall }
  | { pallet: 'ParachainSystem'; palletCall: CumulusPalletParachainSystemCall }
  | { pallet: 'ParachainInfo'; palletCall: StagingParachainInfoCall }
  | { pallet: 'PolkadotXcm'; palletCall: PalletXcmCall }
  | { pallet: 'CumulusXcm'; palletCall: CumulusPalletXcmCall }
  | { pallet: 'MessageQueue'; palletCall: PalletMessageQueueCall }
  | { pallet: 'OrmlXcm'; palletCall: OrmlXcmModuleCall }
  | { pallet: 'XTokens'; palletCall: OrmlXtokensModuleCall }
  | { pallet: 'CollatorSelection'; palletCall: PalletCollatorSelectionCall }
  | { pallet: 'Session'; palletCall: PalletSessionCall }
  | { pallet: 'EmaOracle'; palletCall: PalletEmaOracleCall }
  | { pallet: 'Broadcast'; palletCall: PalletBroadcastCall };

export type HydradxRuntimeRuntimeCallLike =
  | { pallet: 'System'; palletCall: FrameSystemCallLike }
  | { pallet: 'Timestamp'; palletCall: PalletTimestampCallLike }
  | { pallet: 'Balances'; palletCall: PalletBalancesCallLike }
  | { pallet: 'MultiTransactionPayment'; palletCall: PalletTransactionMultiPaymentCallLike }
  | { pallet: 'Treasury'; palletCall: PalletTreasuryCallLike }
  | { pallet: 'Utility'; palletCall: PalletUtilityCallLike }
  | { pallet: 'Preimage'; palletCall: PalletPreimageCallLike }
  | { pallet: 'Identity'; palletCall: PalletIdentityCallLike }
  | { pallet: 'Democracy'; palletCall: PalletDemocracyCallLike }
  | { pallet: 'Elections'; palletCall: PalletElectionsPhragmenCallLike }
  | { pallet: 'Council'; palletCall: PalletCollectiveCallLike }
  | { pallet: 'TechnicalCommittee'; palletCall: PalletCollectiveCallLike }
  | { pallet: 'Tips'; palletCall: PalletTipsCallLike }
  | { pallet: 'Proxy'; palletCall: PalletProxyCallLike }
  | { pallet: 'Multisig'; palletCall: PalletMultisigCallLike }
  | { pallet: 'Uniques'; palletCall: PalletUniquesCallLike }
  | { pallet: 'StateTrieMigration'; palletCall: PalletStateTrieMigrationCallLike }
  | { pallet: 'ConvictionVoting'; palletCall: PalletConvictionVotingCallLike }
  | { pallet: 'Referenda'; palletCall: PalletReferendaCallLike }
  | { pallet: 'Whitelist'; palletCall: PalletWhitelistCallLike }
  | { pallet: 'Dispatcher'; palletCall: PalletDispatcherCallLike }
  | { pallet: 'AssetRegistry'; palletCall: PalletAssetRegistryCallLike }
  | { pallet: 'Claims'; palletCall: PalletClaimsCallLike }
  | { pallet: 'GenesisHistory'; palletCall: PalletGenesisHistoryCallLike }
  | { pallet: 'Omnipool'; palletCall: PalletOmnipoolCallLike }
  | { pallet: 'TransactionPause'; palletCall: PalletTransactionPauseCallLike }
  | { pallet: 'Duster'; palletCall: PalletDusterCallLike }
  | { pallet: 'OmnipoolWarehouseLM'; palletCall: PalletLiquidityMiningCallLike }
  | { pallet: 'OmnipoolLiquidityMining'; palletCall: PalletOmnipoolLiquidityMiningCallLike }
  | { pallet: 'Otc'; palletCall: PalletOtcCallLike }
  | { pallet: 'CircuitBreaker'; palletCall: PalletCircuitBreakerCallLike }
  | { pallet: 'Router'; palletCall: PalletRouteExecutorCallLike }
  | { pallet: 'DynamicFees'; palletCall: PalletDynamicFeesCallLike }
  | { pallet: 'Staking'; palletCall: PalletStakingCallLike }
  | { pallet: 'Stableswap'; palletCall: PalletStableswapCallLike }
  | { pallet: 'Bonds'; palletCall: PalletBondsCallLike }
  | { pallet: 'OtcSettlements'; palletCall: PalletOtcSettlementsCallLike }
  | { pallet: 'Lbp'; palletCall: PalletLbpCallLike }
  | { pallet: 'Xyk'; palletCall: PalletXykCallLike }
  | { pallet: 'Referrals'; palletCall: PalletReferralsCallLike }
  | { pallet: 'Liquidation'; palletCall: PalletLiquidationCallLike }
  | { pallet: 'Hsm'; palletCall: PalletHsmCallLike }
  | { pallet: 'Tokens'; palletCall: OrmlTokensModuleCallLike }
  | { pallet: 'Currencies'; palletCall: PalletCurrenciesModuleCallLike }
  | { pallet: 'Vesting'; palletCall: OrmlVestingModuleCallLike }
  | { pallet: 'Evm'; palletCall: PalletEvmCallLike }
  | { pallet: 'Ethereum'; palletCall: PalletEthereumCallLike }
  | { pallet: 'EvmAccounts'; palletCall: PalletEvmAccountsCallLike }
  | { pallet: 'XykLiquidityMining'; palletCall: PalletXykLiquidityMiningCallLike }
  | { pallet: 'XykWarehouseLM'; palletCall: PalletLiquidityMiningCallLike }
  | { pallet: 'RelayChainInfo'; palletCall: PalletRelaychainInfoCallLike }
  | { pallet: 'Dca'; palletCall: PalletDcaCallLike }
  | { pallet: 'Scheduler'; palletCall: PalletSchedulerCallLike }
  | { pallet: 'ParachainSystem'; palletCall: CumulusPalletParachainSystemCallLike }
  | { pallet: 'ParachainInfo'; palletCall: StagingParachainInfoCallLike }
  | { pallet: 'PolkadotXcm'; palletCall: PalletXcmCallLike }
  | { pallet: 'CumulusXcm'; palletCall: CumulusPalletXcmCallLike }
  | { pallet: 'MessageQueue'; palletCall: PalletMessageQueueCallLike }
  | { pallet: 'OrmlXcm'; palletCall: OrmlXcmModuleCallLike }
  | { pallet: 'XTokens'; palletCall: OrmlXtokensModuleCallLike }
  | { pallet: 'CollatorSelection'; palletCall: PalletCollatorSelectionCallLike }
  | { pallet: 'Session'; palletCall: PalletSessionCallLike }
  | { pallet: 'EmaOracle'; palletCall: PalletEmaOracleCallLike }
  | { pallet: 'Broadcast'; palletCall: PalletBroadcastCallLike };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type FrameSystemCall =
  /**
   * Make some on-chain remark.
   *
   * Can be executed by every `origin`.
   **/
  | { name: 'Remark'; params: { remark: Bytes } }
  /**
   * Set the number of pages in the WebAssembly environment's heap.
   **/
  | { name: 'SetHeapPages'; params: { pages: bigint } }
  /**
   * Set the new runtime code.
   **/
  | { name: 'SetCode'; params: { code: Bytes } }
  /**
   * Set the new runtime code without doing any checks of the given `code`.
   *
   * Note that runtime upgrades will not run if this is called with a not-increasing spec
   * version!
   **/
  | { name: 'SetCodeWithoutChecks'; params: { code: Bytes } }
  /**
   * Set some items of storage.
   **/
  | { name: 'SetStorage'; params: { items: Array<[Bytes, Bytes]> } }
  /**
   * Kill some items from storage.
   **/
  | { name: 'KillStorage'; params: { keys: Array<Bytes> } }
  /**
   * Kill all storage items with a key that starts with the given prefix.
   *
   * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
   * the prefix we are removing to accurately calculate the weight of this function.
   **/
  | { name: 'KillPrefix'; params: { prefix: Bytes; subkeys: number } }
  /**
   * Make some on-chain remark and emit event.
   **/
  | { name: 'RemarkWithEvent'; params: { remark: Bytes } }
  /**
   * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
   * later.
   *
   * This call requires Root origin.
   **/
  | { name: 'AuthorizeUpgrade'; params: { codeHash: H256 } }
  /**
   * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
   * later.
   *
   * WARNING: This authorizes an upgrade that will take place without any safety checks, for
   * example that the spec name remains the same and that the version number increases. Not
   * recommended for normal use. Use `authorize_upgrade` instead.
   *
   * This call requires Root origin.
   **/
  | { name: 'AuthorizeUpgradeWithoutChecks'; params: { codeHash: H256 } }
  /**
   * Provide the preimage (runtime binary) `code` for an upgrade that has been authorized.
   *
   * If the authorization required a version check, this call will ensure the spec name
   * remains unchanged and that the spec version has increased.
   *
   * Depending on the runtime's `OnSetCode` configuration, this function may directly apply
   * the new `code` in the same block or attempt to schedule the upgrade.
   *
   * All origins are allowed.
   **/
  | { name: 'ApplyAuthorizedUpgrade'; params: { code: Bytes } };

export type FrameSystemCallLike =
  /**
   * Make some on-chain remark.
   *
   * Can be executed by every `origin`.
   **/
  | { name: 'Remark'; params: { remark: BytesLike } }
  /**
   * Set the number of pages in the WebAssembly environment's heap.
   **/
  | { name: 'SetHeapPages'; params: { pages: bigint } }
  /**
   * Set the new runtime code.
   **/
  | { name: 'SetCode'; params: { code: BytesLike } }
  /**
   * Set the new runtime code without doing any checks of the given `code`.
   *
   * Note that runtime upgrades will not run if this is called with a not-increasing spec
   * version!
   **/
  | { name: 'SetCodeWithoutChecks'; params: { code: BytesLike } }
  /**
   * Set some items of storage.
   **/
  | { name: 'SetStorage'; params: { items: Array<[BytesLike, BytesLike]> } }
  /**
   * Kill some items from storage.
   **/
  | { name: 'KillStorage'; params: { keys: Array<BytesLike> } }
  /**
   * Kill all storage items with a key that starts with the given prefix.
   *
   * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
   * the prefix we are removing to accurately calculate the weight of this function.
   **/
  | { name: 'KillPrefix'; params: { prefix: BytesLike; subkeys: number } }
  /**
   * Make some on-chain remark and emit event.
   **/
  | { name: 'RemarkWithEvent'; params: { remark: BytesLike } }
  /**
   * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
   * later.
   *
   * This call requires Root origin.
   **/
  | { name: 'AuthorizeUpgrade'; params: { codeHash: H256 } }
  /**
   * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
   * later.
   *
   * WARNING: This authorizes an upgrade that will take place without any safety checks, for
   * example that the spec name remains the same and that the version number increases. Not
   * recommended for normal use. Use `authorize_upgrade` instead.
   *
   * This call requires Root origin.
   **/
  | { name: 'AuthorizeUpgradeWithoutChecks'; params: { codeHash: H256 } }
  /**
   * Provide the preimage (runtime binary) `code` for an upgrade that has been authorized.
   *
   * If the authorization required a version check, this call will ensure the spec name
   * remains unchanged and that the spec version has increased.
   *
   * Depending on the runtime's `OnSetCode` configuration, this function may directly apply
   * the new `code` in the same block or attempt to schedule the upgrade.
   *
   * All origins are allowed.
   **/
  | { name: 'ApplyAuthorizedUpgrade'; params: { code: BytesLike } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTimestampCall =
  /**
   * Set the current time.
   *
   * This call should be invoked exactly once per block. It will panic at the finalization
   * phase, if this call hasn't been invoked by that time.
   *
   * The timestamp should be greater than the previous one by the amount specified by
   * [`Config::MinimumPeriod`].
   *
   * The dispatch origin for this call must be _None_.
   *
   * This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware
   * that changing the complexity of this call could result exhausting the resources in a
   * block to execute any other calls.
   *
   * ## Complexity
   * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
   * - 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in
   * `on_finalize`)
   * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
   **/
  { name: 'Set'; params: { now: bigint } };

export type PalletTimestampCallLike =
  /**
   * Set the current time.
   *
   * This call should be invoked exactly once per block. It will panic at the finalization
   * phase, if this call hasn't been invoked by that time.
   *
   * The timestamp should be greater than the previous one by the amount specified by
   * [`Config::MinimumPeriod`].
   *
   * The dispatch origin for this call must be _None_.
   *
   * This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware
   * that changing the complexity of this call could result exhausting the resources in a
   * block to execute any other calls.
   *
   * ## Complexity
   * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
   * - 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in
   * `on_finalize`)
   * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
   **/
  { name: 'Set'; params: { now: bigint } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBalancesCall =
  /**
   * Transfer some liquid free balance to another account.
   *
   * `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
   * If the sender's account is below the existential deposit as a result
   * of the transfer, the account will be reaped.
   *
   * The dispatch origin for this call must be `Signed` by the transactor.
   **/
  | { name: 'TransferAllowDeath'; params: { dest: AccountId32; value: bigint } }
  /**
   * Exactly as `transfer_allow_death`, except the origin must be root and the source account
   * may be specified.
   **/
  | { name: 'ForceTransfer'; params: { source: AccountId32; dest: AccountId32; value: bigint } }
  /**
   * Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
   * kill the origin account.
   *
   * 99% of the time you want [`transfer_allow_death`] instead.
   *
   * [`transfer_allow_death`]: struct.Pallet.html#method.transfer
   **/
  | { name: 'TransferKeepAlive'; params: { dest: AccountId32; value: bigint } }
  /**
   * Transfer the entire transferable balance from the caller account.
   *
   * NOTE: This function only attempts to transfer _transferable_ balances. This means that
   * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
   * transferred by this function. To ensure that this function results in a killed account,
   * you might need to prepare the account by removing any reference counters, storage
   * deposits, etc...
   *
   * The dispatch origin of this call must be Signed.
   *
   * - `dest`: The recipient of the transfer.
   * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
   * of the funds the account has, causing the sender account to be killed (false), or
   * transfer everything except at least the existential deposit, which will guarantee to
   * keep the sender account alive (true).
   **/
  | { name: 'TransferAll'; params: { dest: AccountId32; keepAlive: boolean } }
  /**
   * Unreserve some balance from a user by force.
   *
   * Can only be called by ROOT.
   **/
  | { name: 'ForceUnreserve'; params: { who: AccountId32; amount: bigint } }
  /**
   * Upgrade a specified account.
   *
   * - `origin`: Must be `Signed`.
   * - `who`: The account to be upgraded.
   *
   * This will waive the transaction fee if at least all but 10% of the accounts needed to
   * be upgraded. (We let some not have to be upgraded just in order to allow for the
   * possibility of churn).
   **/
  | { name: 'UpgradeAccounts'; params: { who: Array<AccountId32> } }
  /**
   * Set the regular balance of a given account.
   *
   * The dispatch origin for this call is `root`.
   **/
  | { name: 'ForceSetBalance'; params: { who: AccountId32; newFree: bigint } }
  /**
   * Adjust the total issuance in a saturating way.
   *
   * Can only be called by root and always needs a positive `delta`.
   *
   * # Example
   **/
  | { name: 'ForceAdjustTotalIssuance'; params: { direction: PalletBalancesAdjustmentDirection; delta: bigint } }
  /**
   * Burn the specified liquid free balance from the origin account.
   *
   * If the origin's account ends up below the existential deposit as a result
   * of the burn and `keep_alive` is false, the account will be reaped.
   *
   * Unlike sending funds to a _burn_ address, which merely makes the funds inaccessible,
   * this `burn` operation will reduce total issuance by the amount _burned_.
   **/
  | { name: 'Burn'; params: { value: bigint; keepAlive: boolean } };

export type PalletBalancesCallLike =
  /**
   * Transfer some liquid free balance to another account.
   *
   * `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
   * If the sender's account is below the existential deposit as a result
   * of the transfer, the account will be reaped.
   *
   * The dispatch origin for this call must be `Signed` by the transactor.
   **/
  | { name: 'TransferAllowDeath'; params: { dest: AccountId32Like; value: bigint } }
  /**
   * Exactly as `transfer_allow_death`, except the origin must be root and the source account
   * may be specified.
   **/
  | { name: 'ForceTransfer'; params: { source: AccountId32Like; dest: AccountId32Like; value: bigint } }
  /**
   * Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
   * kill the origin account.
   *
   * 99% of the time you want [`transfer_allow_death`] instead.
   *
   * [`transfer_allow_death`]: struct.Pallet.html#method.transfer
   **/
  | { name: 'TransferKeepAlive'; params: { dest: AccountId32Like; value: bigint } }
  /**
   * Transfer the entire transferable balance from the caller account.
   *
   * NOTE: This function only attempts to transfer _transferable_ balances. This means that
   * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
   * transferred by this function. To ensure that this function results in a killed account,
   * you might need to prepare the account by removing any reference counters, storage
   * deposits, etc...
   *
   * The dispatch origin of this call must be Signed.
   *
   * - `dest`: The recipient of the transfer.
   * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
   * of the funds the account has, causing the sender account to be killed (false), or
   * transfer everything except at least the existential deposit, which will guarantee to
   * keep the sender account alive (true).
   **/
  | { name: 'TransferAll'; params: { dest: AccountId32Like; keepAlive: boolean } }
  /**
   * Unreserve some balance from a user by force.
   *
   * Can only be called by ROOT.
   **/
  | { name: 'ForceUnreserve'; params: { who: AccountId32Like; amount: bigint } }
  /**
   * Upgrade a specified account.
   *
   * - `origin`: Must be `Signed`.
   * - `who`: The account to be upgraded.
   *
   * This will waive the transaction fee if at least all but 10% of the accounts needed to
   * be upgraded. (We let some not have to be upgraded just in order to allow for the
   * possibility of churn).
   **/
  | { name: 'UpgradeAccounts'; params: { who: Array<AccountId32Like> } }
  /**
   * Set the regular balance of a given account.
   *
   * The dispatch origin for this call is `root`.
   **/
  | { name: 'ForceSetBalance'; params: { who: AccountId32Like; newFree: bigint } }
  /**
   * Adjust the total issuance in a saturating way.
   *
   * Can only be called by root and always needs a positive `delta`.
   *
   * # Example
   **/
  | { name: 'ForceAdjustTotalIssuance'; params: { direction: PalletBalancesAdjustmentDirection; delta: bigint } }
  /**
   * Burn the specified liquid free balance from the origin account.
   *
   * If the origin's account ends up below the existential deposit as a result
   * of the burn and `keep_alive` is false, the account will be reaped.
   *
   * Unlike sending funds to a _burn_ address, which merely makes the funds inaccessible,
   * this `burn` operation will reduce total issuance by the amount _burned_.
   **/
  | { name: 'Burn'; params: { value: bigint; keepAlive: boolean } };

export type PalletBalancesAdjustmentDirection = 'Increase' | 'Decrease';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTransactionMultiPaymentCall =
  /**
   * Set selected currency for given account.
   *
   * This allows to set a currency for an account in which all transaction fees will be paid.
   * Account balance cannot be zero.
   *
   * In case of sufficient asset, the chosen currency must be in the list of accepted currencies
   * In case of insufficient asset, the chosen currency must have a XYK pool with DOT
   *
   * When currency is set, fixed fee is withdrawn from the account to pay for the currency change
   *
   * EVM accounts are now allowed to change thier payment currency.
   *
   * Emits `CurrencySet` event when successful.
   **/
  | { name: 'SetCurrency'; params: { currency: number } }
  /**
   * Add a currency to the list of accepted currencies.
   *
   * Only member can perform this action.
   *
   * Currency must not be already accepted. Core asset id cannot be explicitly added.
   *
   * Emits `CurrencyAdded` event when successful.
   **/
  | { name: 'AddCurrency'; params: { currency: number; price: FixedU128 } }
  /**
   * Remove currency from the list of supported currencies
   * Only selected members can perform this action
   *
   * Core asset cannot be removed.
   *
   * Emits `CurrencyRemoved` when successful.
   **/
  | { name: 'RemoveCurrency'; params: { currency: number } }
  /**
   * Reset currency of the specified account to HDX.
   * If the account is EVM account, the payment currency is reset to WETH.
   * Only selected members can perform this action.
   *
   * Emits `CurrencySet` when successful.
   **/
  | { name: 'ResetPaymentCurrency'; params: { accountId: AccountId32 } }
  /**
   * Dispatch EVM permit.
   * The main purpose of this function is to allow EVM accounts to pay for the transaction fee in non-native currency
   * by allowing them to self-dispatch pre-signed permit.
   * The EVM fee is paid in the currency set for the account.
   **/
  | {
      name: 'DispatchPermit';
      params: {
        from: H160;
        to: H160;
        value: U256;
        data: Bytes;
        gasLimit: bigint;
        deadline: U256;
        v: number;
        r: H256;
        s: H256;
      };
    };

export type PalletTransactionMultiPaymentCallLike =
  /**
   * Set selected currency for given account.
   *
   * This allows to set a currency for an account in which all transaction fees will be paid.
   * Account balance cannot be zero.
   *
   * In case of sufficient asset, the chosen currency must be in the list of accepted currencies
   * In case of insufficient asset, the chosen currency must have a XYK pool with DOT
   *
   * When currency is set, fixed fee is withdrawn from the account to pay for the currency change
   *
   * EVM accounts are now allowed to change thier payment currency.
   *
   * Emits `CurrencySet` event when successful.
   **/
  | { name: 'SetCurrency'; params: { currency: number } }
  /**
   * Add a currency to the list of accepted currencies.
   *
   * Only member can perform this action.
   *
   * Currency must not be already accepted. Core asset id cannot be explicitly added.
   *
   * Emits `CurrencyAdded` event when successful.
   **/
  | { name: 'AddCurrency'; params: { currency: number; price: FixedU128 } }
  /**
   * Remove currency from the list of supported currencies
   * Only selected members can perform this action
   *
   * Core asset cannot be removed.
   *
   * Emits `CurrencyRemoved` when successful.
   **/
  | { name: 'RemoveCurrency'; params: { currency: number } }
  /**
   * Reset currency of the specified account to HDX.
   * If the account is EVM account, the payment currency is reset to WETH.
   * Only selected members can perform this action.
   *
   * Emits `CurrencySet` when successful.
   **/
  | { name: 'ResetPaymentCurrency'; params: { accountId: AccountId32Like } }
  /**
   * Dispatch EVM permit.
   * The main purpose of this function is to allow EVM accounts to pay for the transaction fee in non-native currency
   * by allowing them to self-dispatch pre-signed permit.
   * The EVM fee is paid in the currency set for the account.
   **/
  | {
      name: 'DispatchPermit';
      params: {
        from: H160;
        to: H160;
        value: U256;
        data: BytesLike;
        gasLimit: bigint;
        deadline: U256;
        v: number;
        r: H256;
        s: H256;
      };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTreasuryCall =
  /**
   * Propose and approve a spend of treasury funds.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::SpendOrigin`] with the `Success` value being at least `amount`.
   *
   * ### Details
   * NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
   * beneficiary.
   *
   * ### Parameters
   * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
   * - `beneficiary`: The destination account for the transfer.
   *
   * ## Events
   *
   * Emits [`Event::SpendApproved`] if successful.
   **/
  | { name: 'SpendLocal'; params: { amount: bigint; beneficiary: AccountId32 } }
  /**
   * Force a previously approved proposal to be removed from the approval queue.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::RejectOrigin`].
   *
   * ## Details
   *
   * The original deposit will no longer be returned.
   *
   * ### Parameters
   * - `proposal_id`: The index of a proposal
   *
   * ### Complexity
   * - O(A) where `A` is the number of approvals
   *
   * ### Errors
   * - [`Error::ProposalNotApproved`]: The `proposal_id` supplied was not found in the
   * approval queue, i.e., the proposal has not been approved. This could also mean the
   * proposal does not exist altogether, thus there is no way it would have been approved
   * in the first place.
   **/
  | { name: 'RemoveApproval'; params: { proposalId: number } }
  /**
   * Propose and approve a spend of treasury funds.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::SpendOrigin`] with the `Success` value being at least
   * `amount` of `asset_kind` in the native asset. The amount of `asset_kind` is converted
   * for assertion using the [`Config::BalanceConverter`].
   *
   * ## Details
   *
   * Create an approved spend for transferring a specific `amount` of `asset_kind` to a
   * designated beneficiary. The spend must be claimed using the `payout` dispatchable within
   * the [`Config::PayoutPeriod`].
   *
   * ### Parameters
   * - `asset_kind`: An indicator of the specific asset class to be spent.
   * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
   * - `beneficiary`: The beneficiary of the spend.
   * - `valid_from`: The block number from which the spend can be claimed. It can refer to
   * the past if the resulting spend has not yet expired according to the
   * [`Config::PayoutPeriod`]. If `None`, the spend can be claimed immediately after
   * approval.
   *
   * ## Events
   *
   * Emits [`Event::AssetSpendApproved`] if successful.
   **/
  | {
      name: 'Spend';
      params: { assetKind: []; amount: bigint; beneficiary: AccountId32; validFrom?: number | undefined };
    }
  /**
   * Claim a spend.
   *
   * ## Dispatch Origin
   *
   * Must be signed
   *
   * ## Details
   *
   * Spends must be claimed within some temporal bounds. A spend may be claimed within one
   * [`Config::PayoutPeriod`] from the `valid_from` block.
   * In case of a payout failure, the spend status must be updated with the `check_status`
   * dispatchable before retrying with the current function.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::Paid`] if successful.
   **/
  | { name: 'Payout'; params: { index: number } }
  /**
   * Check the status of the spend and remove it from the storage if processed.
   *
   * ## Dispatch Origin
   *
   * Must be signed.
   *
   * ## Details
   *
   * The status check is a prerequisite for retrying a failed payout.
   * If a spend has either succeeded or expired, it is removed from the storage by this
   * function. In such instances, transaction fees are refunded.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::PaymentFailed`] if the spend payout has failed.
   * Emits [`Event::SpendProcessed`] if the spend payout has succeed.
   **/
  | { name: 'CheckStatus'; params: { index: number } }
  /**
   * Void previously approved spend.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::RejectOrigin`].
   *
   * ## Details
   *
   * A spend void is only possible if the payout has not been attempted yet.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::AssetSpendVoided`] if successful.
   **/
  | { name: 'VoidSpend'; params: { index: number } };

export type PalletTreasuryCallLike =
  /**
   * Propose and approve a spend of treasury funds.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::SpendOrigin`] with the `Success` value being at least `amount`.
   *
   * ### Details
   * NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
   * beneficiary.
   *
   * ### Parameters
   * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
   * - `beneficiary`: The destination account for the transfer.
   *
   * ## Events
   *
   * Emits [`Event::SpendApproved`] if successful.
   **/
  | { name: 'SpendLocal'; params: { amount: bigint; beneficiary: AccountId32Like } }
  /**
   * Force a previously approved proposal to be removed from the approval queue.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::RejectOrigin`].
   *
   * ## Details
   *
   * The original deposit will no longer be returned.
   *
   * ### Parameters
   * - `proposal_id`: The index of a proposal
   *
   * ### Complexity
   * - O(A) where `A` is the number of approvals
   *
   * ### Errors
   * - [`Error::ProposalNotApproved`]: The `proposal_id` supplied was not found in the
   * approval queue, i.e., the proposal has not been approved. This could also mean the
   * proposal does not exist altogether, thus there is no way it would have been approved
   * in the first place.
   **/
  | { name: 'RemoveApproval'; params: { proposalId: number } }
  /**
   * Propose and approve a spend of treasury funds.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::SpendOrigin`] with the `Success` value being at least
   * `amount` of `asset_kind` in the native asset. The amount of `asset_kind` is converted
   * for assertion using the [`Config::BalanceConverter`].
   *
   * ## Details
   *
   * Create an approved spend for transferring a specific `amount` of `asset_kind` to a
   * designated beneficiary. The spend must be claimed using the `payout` dispatchable within
   * the [`Config::PayoutPeriod`].
   *
   * ### Parameters
   * - `asset_kind`: An indicator of the specific asset class to be spent.
   * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
   * - `beneficiary`: The beneficiary of the spend.
   * - `valid_from`: The block number from which the spend can be claimed. It can refer to
   * the past if the resulting spend has not yet expired according to the
   * [`Config::PayoutPeriod`]. If `None`, the spend can be claimed immediately after
   * approval.
   *
   * ## Events
   *
   * Emits [`Event::AssetSpendApproved`] if successful.
   **/
  | {
      name: 'Spend';
      params: { assetKind: []; amount: bigint; beneficiary: AccountId32Like; validFrom?: number | undefined };
    }
  /**
   * Claim a spend.
   *
   * ## Dispatch Origin
   *
   * Must be signed
   *
   * ## Details
   *
   * Spends must be claimed within some temporal bounds. A spend may be claimed within one
   * [`Config::PayoutPeriod`] from the `valid_from` block.
   * In case of a payout failure, the spend status must be updated with the `check_status`
   * dispatchable before retrying with the current function.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::Paid`] if successful.
   **/
  | { name: 'Payout'; params: { index: number } }
  /**
   * Check the status of the spend and remove it from the storage if processed.
   *
   * ## Dispatch Origin
   *
   * Must be signed.
   *
   * ## Details
   *
   * The status check is a prerequisite for retrying a failed payout.
   * If a spend has either succeeded or expired, it is removed from the storage by this
   * function. In such instances, transaction fees are refunded.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::PaymentFailed`] if the spend payout has failed.
   * Emits [`Event::SpendProcessed`] if the spend payout has succeed.
   **/
  | { name: 'CheckStatus'; params: { index: number } }
  /**
   * Void previously approved spend.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::RejectOrigin`].
   *
   * ## Details
   *
   * A spend void is only possible if the payout has not been attempted yet.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::AssetSpendVoided`] if successful.
   **/
  | { name: 'VoidSpend'; params: { index: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletUtilityCall =
  /**
   * Send a batch of dispatch calls.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatched without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   *
   * This will return `Ok` in all circumstances. To determine the success of the batch, an
   * event is deposited. If a call failed and the batch was interrupted, then the
   * `BatchInterrupted` event is deposited, along with the number of successful calls made
   * and the error of the failed call. If all were successful, then the `BatchCompleted`
   * event is deposited.
   **/
  | { name: 'Batch'; params: { calls: Array<HydradxRuntimeRuntimeCall> } }
  /**
   * Send a call through an indexed pseudonym of the sender.
   *
   * Filter from origin are passed along. The call will be dispatched with an origin which
   * use the same filter as the origin of this call.
   *
   * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
   * because you expect `proxy` to have been used prior in the call stack and you do not want
   * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
   * in the Multisig pallet instead.
   *
   * NOTE: Prior to version *12, this was called `as_limited_sub`.
   *
   * The dispatch origin for this call must be _Signed_.
   **/
  | { name: 'AsDerivative'; params: { index: number; call: HydradxRuntimeRuntimeCall } }
  /**
   * Send a batch of dispatch calls and atomically execute them.
   * The whole transaction will rollback and fail if any of the calls failed.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatched without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   **/
  | { name: 'BatchAll'; params: { calls: Array<HydradxRuntimeRuntimeCall> } }
  /**
   * Dispatches a function call with a provided origin.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'DispatchAs'; params: { asOrigin: HydradxRuntimeOriginCaller; call: HydradxRuntimeRuntimeCall } }
  /**
   * Send a batch of dispatch calls.
   * Unlike `batch`, it allows errors and won't interrupt.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatch without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   **/
  | { name: 'ForceBatch'; params: { calls: Array<HydradxRuntimeRuntimeCall> } }
  /**
   * Dispatch a function call with a specified weight.
   *
   * This function does not check the weight of the call, and instead allows the
   * Root origin to specify the weight of the call.
   *
   * The dispatch origin for this call must be _Root_.
   **/
  | { name: 'WithWeight'; params: { call: HydradxRuntimeRuntimeCall; weight: SpWeightsWeightV2Weight } };

export type PalletUtilityCallLike =
  /**
   * Send a batch of dispatch calls.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatched without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   *
   * This will return `Ok` in all circumstances. To determine the success of the batch, an
   * event is deposited. If a call failed and the batch was interrupted, then the
   * `BatchInterrupted` event is deposited, along with the number of successful calls made
   * and the error of the failed call. If all were successful, then the `BatchCompleted`
   * event is deposited.
   **/
  | { name: 'Batch'; params: { calls: Array<HydradxRuntimeRuntimeCallLike> } }
  /**
   * Send a call through an indexed pseudonym of the sender.
   *
   * Filter from origin are passed along. The call will be dispatched with an origin which
   * use the same filter as the origin of this call.
   *
   * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
   * because you expect `proxy` to have been used prior in the call stack and you do not want
   * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
   * in the Multisig pallet instead.
   *
   * NOTE: Prior to version *12, this was called `as_limited_sub`.
   *
   * The dispatch origin for this call must be _Signed_.
   **/
  | { name: 'AsDerivative'; params: { index: number; call: HydradxRuntimeRuntimeCallLike } }
  /**
   * Send a batch of dispatch calls and atomically execute them.
   * The whole transaction will rollback and fail if any of the calls failed.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatched without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   **/
  | { name: 'BatchAll'; params: { calls: Array<HydradxRuntimeRuntimeCallLike> } }
  /**
   * Dispatches a function call with a provided origin.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'DispatchAs'; params: { asOrigin: HydradxRuntimeOriginCaller; call: HydradxRuntimeRuntimeCallLike } }
  /**
   * Send a batch of dispatch calls.
   * Unlike `batch`, it allows errors and won't interrupt.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatch without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   **/
  | { name: 'ForceBatch'; params: { calls: Array<HydradxRuntimeRuntimeCallLike> } }
  /**
   * Dispatch a function call with a specified weight.
   *
   * This function does not check the weight of the call, and instead allows the
   * Root origin to specify the weight of the call.
   *
   * The dispatch origin for this call must be _Root_.
   **/
  | { name: 'WithWeight'; params: { call: HydradxRuntimeRuntimeCallLike; weight: SpWeightsWeightV2Weight } };

export type HydradxRuntimeOriginCaller =
  | { type: 'System'; value: FrameSupportDispatchRawOrigin }
  | { type: 'Council'; value: PalletCollectiveRawOrigin }
  | { type: 'TechnicalCommittee'; value: PalletCollectiveRawOrigin }
  | { type: 'Origins'; value: HydradxRuntimeGovernanceOriginsPalletCustomOriginsOrigin }
  | { type: 'Ethereum'; value: PalletEthereumRawOrigin }
  | { type: 'PolkadotXcm'; value: PalletXcmOrigin }
  | { type: 'CumulusXcm'; value: CumulusPalletXcmOrigin }
  | { type: 'Void'; value: SpCoreVoid };

export type FrameSupportDispatchRawOrigin =
  | { type: 'Root' }
  | { type: 'Signed'; value: AccountId32 }
  | { type: 'None' };

export type PalletCollectiveRawOrigin =
  | { type: 'Members'; value: [number, number] }
  | { type: 'Member'; value: AccountId32 }
  | { type: 'Phantom' };

export type HydradxRuntimeGovernanceOriginsPalletCustomOriginsOrigin =
  | 'WhitelistedCaller'
  | 'ReferendumCanceller'
  | 'ReferendumKiller'
  | 'GeneralAdmin'
  | 'OmnipoolAdmin'
  | 'Treasurer'
  | 'Spender'
  | 'Tipper'
  | 'EconomicParameters';

export type PalletEthereumRawOrigin = { type: 'EthereumTransaction'; value: H160 };

export type PalletXcmOrigin =
  | { type: 'Xcm'; value: StagingXcmV4Location }
  | { type: 'Response'; value: StagingXcmV4Location };

export type StagingXcmV4Location = { parents: number; interior: StagingXcmV4Junctions };

export type StagingXcmV4Junctions =
  | { type: 'Here' }
  | { type: 'X1'; value: FixedArray<StagingXcmV4Junction, 1> }
  | { type: 'X2'; value: FixedArray<StagingXcmV4Junction, 2> }
  | { type: 'X3'; value: FixedArray<StagingXcmV4Junction, 3> }
  | { type: 'X4'; value: FixedArray<StagingXcmV4Junction, 4> }
  | { type: 'X5'; value: FixedArray<StagingXcmV4Junction, 5> }
  | { type: 'X6'; value: FixedArray<StagingXcmV4Junction, 6> }
  | { type: 'X7'; value: FixedArray<StagingXcmV4Junction, 7> }
  | { type: 'X8'; value: FixedArray<StagingXcmV4Junction, 8> };

export type StagingXcmV4Junction =
  | { type: 'Parachain'; value: number }
  | { type: 'AccountId32'; value: { network?: StagingXcmV4JunctionNetworkId | undefined; id: FixedBytes<32> } }
  | { type: 'AccountIndex64'; value: { network?: StagingXcmV4JunctionNetworkId | undefined; index: bigint } }
  | { type: 'AccountKey20'; value: { network?: StagingXcmV4JunctionNetworkId | undefined; key: FixedBytes<20> } }
  | { type: 'PalletInstance'; value: number }
  | { type: 'GeneralIndex'; value: bigint }
  | { type: 'GeneralKey'; value: { length: number; data: FixedBytes<32> } }
  | { type: 'OnlyChild' }
  | { type: 'Plurality'; value: { id: XcmV3JunctionBodyId; part: XcmV3JunctionBodyPart } }
  | { type: 'GlobalConsensus'; value: StagingXcmV4JunctionNetworkId };

export type StagingXcmV4JunctionNetworkId =
  | { type: 'ByGenesis'; value: FixedBytes<32> }
  | { type: 'ByFork'; value: { blockNumber: bigint; blockHash: FixedBytes<32> } }
  | { type: 'Polkadot' }
  | { type: 'Kusama' }
  | { type: 'Westend' }
  | { type: 'Rococo' }
  | { type: 'Wococo' }
  | { type: 'Ethereum'; value: { chainId: bigint } }
  | { type: 'BitcoinCore' }
  | { type: 'BitcoinCash' }
  | { type: 'PolkadotBulletin' };

export type XcmV3JunctionBodyId =
  | { type: 'Unit' }
  | { type: 'Moniker'; value: FixedBytes<4> }
  | { type: 'Index'; value: number }
  | { type: 'Executive' }
  | { type: 'Technical' }
  | { type: 'Legislative' }
  | { type: 'Judicial' }
  | { type: 'Defense' }
  | { type: 'Administration' }
  | { type: 'Treasury' };

export type XcmV3JunctionBodyPart =
  | { type: 'Voice' }
  | { type: 'Members'; value: { count: number } }
  | { type: 'Fraction'; value: { nom: number; denom: number } }
  | { type: 'AtLeastProportion'; value: { nom: number; denom: number } }
  | { type: 'MoreThanProportion'; value: { nom: number; denom: number } };

export type CumulusPalletXcmOrigin =
  | { type: 'Relay' }
  | { type: 'SiblingParachain'; value: PolkadotParachainPrimitivesPrimitivesId };

export type PolkadotParachainPrimitivesPrimitivesId = number;

export type SpCoreVoid = null;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletPreimageCall =
  /**
   * Register a preimage on-chain.
   *
   * If the preimage was previously requested, no fees or deposits are taken for providing
   * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
   **/
  | { name: 'NotePreimage'; params: { bytes: Bytes } }
  /**
   * Clear an unrequested preimage from the runtime storage.
   *
   * If `len` is provided, then it will be a much cheaper operation.
   *
   * - `hash`: The hash of the preimage to be removed from the store.
   * - `len`: The length of the preimage of `hash`.
   **/
  | { name: 'UnnotePreimage'; params: { hash: H256 } }
  /**
   * Request a preimage be uploaded to the chain without paying any fees or deposits.
   *
   * If the preimage requests has already been provided on-chain, we unreserve any deposit
   * a user may have paid, and take the control of the preimage out of their hands.
   **/
  | { name: 'RequestPreimage'; params: { hash: H256 } }
  /**
   * Clear a previously made request for a preimage.
   *
   * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
   **/
  | { name: 'UnrequestPreimage'; params: { hash: H256 } }
  /**
   * Ensure that the a bulk of pre-images is upgraded.
   *
   * The caller pays no fee if at least 90% of pre-images were successfully updated.
   **/
  | { name: 'EnsureUpdated'; params: { hashes: Array<H256> } };

export type PalletPreimageCallLike =
  /**
   * Register a preimage on-chain.
   *
   * If the preimage was previously requested, no fees or deposits are taken for providing
   * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
   **/
  | { name: 'NotePreimage'; params: { bytes: BytesLike } }
  /**
   * Clear an unrequested preimage from the runtime storage.
   *
   * If `len` is provided, then it will be a much cheaper operation.
   *
   * - `hash`: The hash of the preimage to be removed from the store.
   * - `len`: The length of the preimage of `hash`.
   **/
  | { name: 'UnnotePreimage'; params: { hash: H256 } }
  /**
   * Request a preimage be uploaded to the chain without paying any fees or deposits.
   *
   * If the preimage requests has already been provided on-chain, we unreserve any deposit
   * a user may have paid, and take the control of the preimage out of their hands.
   **/
  | { name: 'RequestPreimage'; params: { hash: H256 } }
  /**
   * Clear a previously made request for a preimage.
   *
   * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
   **/
  | { name: 'UnrequestPreimage'; params: { hash: H256 } }
  /**
   * Ensure that the a bulk of pre-images is upgraded.
   *
   * The caller pays no fee if at least 90% of pre-images were successfully updated.
   **/
  | { name: 'EnsureUpdated'; params: { hashes: Array<H256> } };

/**
 * Identity pallet declaration.
 **/
export type PalletIdentityCall =
  /**
   * Add a registrar to the system.
   *
   * The dispatch origin for this call must be `T::RegistrarOrigin`.
   *
   * - `account`: the account of the registrar.
   *
   * Emits `RegistrarAdded` if successful.
   **/
  | { name: 'AddRegistrar'; params: { account: AccountId32 } }
  /**
   * Set an account's identity information and reserve the appropriate deposit.
   *
   * If the account already has identity information, the deposit is taken as part payment
   * for the new deposit.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `info`: The identity information.
   *
   * Emits `IdentitySet` if successful.
   **/
  | { name: 'SetIdentity'; params: { info: PalletIdentityLegacyIdentityInfo } }
  /**
   * Set the sub-accounts of the sender.
   *
   * Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
   * and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * identity.
   *
   * - `subs`: The identity's (new) sub-accounts.
   **/
  | { name: 'SetSubs'; params: { subs: Array<[AccountId32, Data]> } }
  /**
   * Clear an account's identity info and all sub-accounts and return all deposits.
   *
   * Payment: All reserved balances on the account are returned.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * identity.
   *
   * Emits `IdentityCleared` if successful.
   **/
  | { name: 'ClearIdentity' }
  /**
   * Request a judgement from a registrar.
   *
   * Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
   * given.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a
   * registered identity.
   *
   * - `reg_index`: The index of the registrar whose judgement is requested.
   * - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
   *
   * ```nocompile
   * Registrars::<T>::get().get(reg_index).unwrap().fee
   * ```
   *
   * Emits `JudgementRequested` if successful.
   **/
  | { name: 'RequestJudgement'; params: { regIndex: number; maxFee: bigint } }
  /**
   * Cancel a previous request.
   *
   * Payment: A previously reserved deposit is returned on success.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a
   * registered identity.
   *
   * - `reg_index`: The index of the registrar whose judgement is no longer requested.
   *
   * Emits `JudgementUnrequested` if successful.
   **/
  | { name: 'CancelRequest'; params: { regIndex: number } }
  /**
   * Set the fee required for a judgement to be requested from a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `fee`: the new fee.
   **/
  | { name: 'SetFee'; params: { index: number; fee: bigint } }
  /**
   * Change the account associated with a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `new`: the new account ID.
   **/
  | { name: 'SetAccountId'; params: { index: number; new: AccountId32 } }
  /**
   * Set the field information for a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `fields`: the fields that the registrar concerns themselves with.
   **/
  | { name: 'SetFields'; params: { index: number; fields: bigint } }
  /**
   * Provide a judgement for an account's identity.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `reg_index`.
   *
   * - `reg_index`: the index of the registrar whose judgement is being made.
   * - `target`: the account whose identity the judgement is upon. This must be an account
   * with a registered identity.
   * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
   * - `identity`: The hash of the [`IdentityInformationProvider`] for that the judgement is
   * provided.
   *
   * Note: Judgements do not apply to a username.
   *
   * Emits `JudgementGiven` if successful.
   **/
  | {
      name: 'ProvideJudgement';
      params: { regIndex: number; target: AccountId32; judgement: PalletIdentityJudgement; identity: H256 };
    }
  /**
   * Remove an account's identity and sub-account information and slash the deposits.
   *
   * Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
   * `Slash`. Verification request deposits are not returned; they should be cancelled
   * manually using `cancel_request`.
   *
   * The dispatch origin for this call must match `T::ForceOrigin`.
   *
   * - `target`: the account whose identity the judgement is upon. This must be an account
   * with a registered identity.
   *
   * Emits `IdentityKilled` if successful.
   **/
  | { name: 'KillIdentity'; params: { target: AccountId32 } }
  /**
   * Add the given account to the sender's subs.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'AddSub'; params: { sub: AccountId32; data: Data } }
  /**
   * Alter the associated name of the given sub-account.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'RenameSub'; params: { sub: AccountId32; data: Data } }
  /**
   * Remove the given account from the sender's subs.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'RemoveSub'; params: { sub: AccountId32 } }
  /**
   * Remove the sender as a sub-account.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender (*not* the original depositor).
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * super-identity.
   *
   * NOTE: This should not normally be used, but is provided in the case that the non-
   * controller of an account is maliciously registered as a sub-account.
   **/
  | { name: 'QuitSub' }
  /**
   * Add an `AccountId` with permission to grant usernames with a given `suffix` appended.
   *
   * The authority can grant up to `allocation` usernames. To top up their allocation, they
   * should just issue (or request via governance) a new `add_username_authority` call.
   **/
  | { name: 'AddUsernameAuthority'; params: { authority: AccountId32; suffix: Bytes; allocation: number } }
  /**
   * Remove `authority` from the username authorities.
   **/
  | { name: 'RemoveUsernameAuthority'; params: { authority: AccountId32 } }
  /**
   * Set the username for `who`. Must be called by a username authority.
   *
   * The authority must have an `allocation`. Users can either pre-sign their usernames or
   * accept them later.
   *
   * Usernames must:
   * - Only contain lowercase ASCII characters or digits.
   * - When combined with the suffix of the issuing authority be _less than_ the
   * `MaxUsernameLength`.
   **/
  | {
      name: 'SetUsernameFor';
      params: { who: AccountId32; username: Bytes; signature?: SpRuntimeMultiSignature | undefined };
    }
  /**
   * Accept a given username that an `authority` granted. The call must include the full
   * username, as in `username.suffix`.
   **/
  | { name: 'AcceptUsername'; params: { username: Bytes } }
  /**
   * Remove an expired username approval. The username was approved by an authority but never
   * accepted by the user and must now be beyond its expiration. The call must include the
   * full username, as in `username.suffix`.
   **/
  | { name: 'RemoveExpiredApproval'; params: { username: Bytes } }
  /**
   * Set a given username as the primary. The username should include the suffix.
   **/
  | { name: 'SetPrimaryUsername'; params: { username: Bytes } }
  /**
   * Remove a username that corresponds to an account with no identity. Exists when a user
   * gets a username but then calls `clear_identity`.
   **/
  | { name: 'RemoveDanglingUsername'; params: { username: Bytes } };

export type PalletIdentityCallLike =
  /**
   * Add a registrar to the system.
   *
   * The dispatch origin for this call must be `T::RegistrarOrigin`.
   *
   * - `account`: the account of the registrar.
   *
   * Emits `RegistrarAdded` if successful.
   **/
  | { name: 'AddRegistrar'; params: { account: AccountId32Like } }
  /**
   * Set an account's identity information and reserve the appropriate deposit.
   *
   * If the account already has identity information, the deposit is taken as part payment
   * for the new deposit.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `info`: The identity information.
   *
   * Emits `IdentitySet` if successful.
   **/
  | { name: 'SetIdentity'; params: { info: PalletIdentityLegacyIdentityInfo } }
  /**
   * Set the sub-accounts of the sender.
   *
   * Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
   * and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * identity.
   *
   * - `subs`: The identity's (new) sub-accounts.
   **/
  | { name: 'SetSubs'; params: { subs: Array<[AccountId32Like, Data]> } }
  /**
   * Clear an account's identity info and all sub-accounts and return all deposits.
   *
   * Payment: All reserved balances on the account are returned.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * identity.
   *
   * Emits `IdentityCleared` if successful.
   **/
  | { name: 'ClearIdentity' }
  /**
   * Request a judgement from a registrar.
   *
   * Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
   * given.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a
   * registered identity.
   *
   * - `reg_index`: The index of the registrar whose judgement is requested.
   * - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
   *
   * ```nocompile
   * Registrars::<T>::get().get(reg_index).unwrap().fee
   * ```
   *
   * Emits `JudgementRequested` if successful.
   **/
  | { name: 'RequestJudgement'; params: { regIndex: number; maxFee: bigint } }
  /**
   * Cancel a previous request.
   *
   * Payment: A previously reserved deposit is returned on success.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a
   * registered identity.
   *
   * - `reg_index`: The index of the registrar whose judgement is no longer requested.
   *
   * Emits `JudgementUnrequested` if successful.
   **/
  | { name: 'CancelRequest'; params: { regIndex: number } }
  /**
   * Set the fee required for a judgement to be requested from a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `fee`: the new fee.
   **/
  | { name: 'SetFee'; params: { index: number; fee: bigint } }
  /**
   * Change the account associated with a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `new`: the new account ID.
   **/
  | { name: 'SetAccountId'; params: { index: number; new: AccountId32Like } }
  /**
   * Set the field information for a registrar.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `index`.
   *
   * - `index`: the index of the registrar whose fee is to be set.
   * - `fields`: the fields that the registrar concerns themselves with.
   **/
  | { name: 'SetFields'; params: { index: number; fields: bigint } }
  /**
   * Provide a judgement for an account's identity.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must be the account
   * of the registrar whose index is `reg_index`.
   *
   * - `reg_index`: the index of the registrar whose judgement is being made.
   * - `target`: the account whose identity the judgement is upon. This must be an account
   * with a registered identity.
   * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
   * - `identity`: The hash of the [`IdentityInformationProvider`] for that the judgement is
   * provided.
   *
   * Note: Judgements do not apply to a username.
   *
   * Emits `JudgementGiven` if successful.
   **/
  | {
      name: 'ProvideJudgement';
      params: { regIndex: number; target: AccountId32Like; judgement: PalletIdentityJudgement; identity: H256 };
    }
  /**
   * Remove an account's identity and sub-account information and slash the deposits.
   *
   * Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
   * `Slash`. Verification request deposits are not returned; they should be cancelled
   * manually using `cancel_request`.
   *
   * The dispatch origin for this call must match `T::ForceOrigin`.
   *
   * - `target`: the account whose identity the judgement is upon. This must be an account
   * with a registered identity.
   *
   * Emits `IdentityKilled` if successful.
   **/
  | { name: 'KillIdentity'; params: { target: AccountId32Like } }
  /**
   * Add the given account to the sender's subs.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'AddSub'; params: { sub: AccountId32Like; data: Data } }
  /**
   * Alter the associated name of the given sub-account.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'RenameSub'; params: { sub: AccountId32Like; data: Data } }
  /**
   * Remove the given account from the sender's subs.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * sub identity of `sub`.
   **/
  | { name: 'RemoveSub'; params: { sub: AccountId32Like } }
  /**
   * Remove the sender as a sub-account.
   *
   * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
   * to the sender (*not* the original depositor).
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have a registered
   * super-identity.
   *
   * NOTE: This should not normally be used, but is provided in the case that the non-
   * controller of an account is maliciously registered as a sub-account.
   **/
  | { name: 'QuitSub' }
  /**
   * Add an `AccountId` with permission to grant usernames with a given `suffix` appended.
   *
   * The authority can grant up to `allocation` usernames. To top up their allocation, they
   * should just issue (or request via governance) a new `add_username_authority` call.
   **/
  | { name: 'AddUsernameAuthority'; params: { authority: AccountId32Like; suffix: BytesLike; allocation: number } }
  /**
   * Remove `authority` from the username authorities.
   **/
  | { name: 'RemoveUsernameAuthority'; params: { authority: AccountId32Like } }
  /**
   * Set the username for `who`. Must be called by a username authority.
   *
   * The authority must have an `allocation`. Users can either pre-sign their usernames or
   * accept them later.
   *
   * Usernames must:
   * - Only contain lowercase ASCII characters or digits.
   * - When combined with the suffix of the issuing authority be _less than_ the
   * `MaxUsernameLength`.
   **/
  | {
      name: 'SetUsernameFor';
      params: { who: AccountId32Like; username: BytesLike; signature?: SpRuntimeMultiSignature | undefined };
    }
  /**
   * Accept a given username that an `authority` granted. The call must include the full
   * username, as in `username.suffix`.
   **/
  | { name: 'AcceptUsername'; params: { username: BytesLike } }
  /**
   * Remove an expired username approval. The username was approved by an authority but never
   * accepted by the user and must now be beyond its expiration. The call must include the
   * full username, as in `username.suffix`.
   **/
  | { name: 'RemoveExpiredApproval'; params: { username: BytesLike } }
  /**
   * Set a given username as the primary. The username should include the suffix.
   **/
  | { name: 'SetPrimaryUsername'; params: { username: BytesLike } }
  /**
   * Remove a username that corresponds to an account with no identity. Exists when a user
   * gets a username but then calls `clear_identity`.
   **/
  | { name: 'RemoveDanglingUsername'; params: { username: BytesLike } };

export type PalletIdentityLegacyIdentityInfo = {
  additional: Array<[Data, Data]>;
  display: Data;
  legal: Data;
  web: Data;
  riot: Data;
  email: Data;
  pgpFingerprint?: FixedBytes<20> | undefined;
  image: Data;
  twitter: Data;
};

export type PalletIdentityJudgement =
  | { type: 'Unknown' }
  | { type: 'FeePaid'; value: bigint }
  | { type: 'Reasonable' }
  | { type: 'KnownGood' }
  | { type: 'OutOfDate' }
  | { type: 'LowQuality' }
  | { type: 'Erroneous' };

export type SpRuntimeMultiSignature =
  | { type: 'Ed25519'; value: FixedBytes<64> }
  | { type: 'Sr25519'; value: FixedBytes<64> }
  | { type: 'Ecdsa'; value: FixedBytes<65> };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletDemocracyCall =
  /**
   * Propose a sensitive action to be taken.
   *
   * The dispatch origin of this call must be _Signed_ and the sender must
   * have funds to cover the deposit.
   *
   * - `proposal_hash`: The hash of the proposal preimage.
   * - `value`: The amount of deposit (must be at least `MinimumDeposit`).
   *
   * Emits `Proposed`.
   **/
  | { name: 'Propose'; params: { proposal: FrameSupportPreimagesBounded; value: bigint } }
  /**
   * Signals agreement with a particular proposal.
   *
   * The dispatch origin of this call must be _Signed_ and the sender
   * must have funds to cover the deposit, equal to the original deposit.
   *
   * - `proposal`: The index of the proposal to second.
   **/
  | { name: 'Second'; params: { proposal: number } }
  /**
   * Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;
   * otherwise it is a vote to keep the status quo.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `ref_index`: The index of the referendum to vote for.
   * - `vote`: The vote configuration.
   **/
  | { name: 'Vote'; params: { refIndex: number; vote: PalletDemocracyVoteAccountVote } }
  /**
   * Schedule an emergency cancellation of a referendum. Cannot happen twice to the same
   * referendum.
   *
   * The dispatch origin of this call must be `CancellationOrigin`.
   *
   * -`ref_index`: The index of the referendum to cancel.
   *
   * Weight: `O(1)`.
   **/
  | { name: 'EmergencyCancel'; params: { refIndex: number } }
  /**
   * Schedule a referendum to be tabled once it is legal to schedule an external
   * referendum.
   *
   * The dispatch origin of this call must be `ExternalOrigin`.
   *
   * - `proposal_hash`: The preimage hash of the proposal.
   **/
  | { name: 'ExternalPropose'; params: { proposal: FrameSupportPreimagesBounded } }
  /**
   * Schedule a majority-carries referendum to be tabled next once it is legal to schedule
   * an external referendum.
   *
   * The dispatch of this call must be `ExternalMajorityOrigin`.
   *
   * - `proposal_hash`: The preimage hash of the proposal.
   *
   * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
   * pre-scheduled `external_propose` call.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ExternalProposeMajority'; params: { proposal: FrameSupportPreimagesBounded } }
  /**
   * Schedule a negative-turnout-bias referendum to be tabled next once it is legal to
   * schedule an external referendum.
   *
   * The dispatch of this call must be `ExternalDefaultOrigin`.
   *
   * - `proposal_hash`: The preimage hash of the proposal.
   *
   * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
   * pre-scheduled `external_propose` call.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ExternalProposeDefault'; params: { proposal: FrameSupportPreimagesBounded } }
  /**
   * Schedule the currently externally-proposed majority-carries referendum to be tabled
   * immediately. If there is no externally-proposed referendum currently, or if there is one
   * but it is not a majority-carries referendum then it fails.
   *
   * The dispatch of this call must be `FastTrackOrigin`.
   *
   * - `proposal_hash`: The hash of the current external proposal.
   * - `voting_period`: The period that is allowed for voting on this proposal. Increased to
   * Must be always greater than zero.
   * For `FastTrackOrigin` must be equal or greater than `FastTrackVotingPeriod`.
   * - `delay`: The number of block after voting has ended in approval and this should be
   * enacted. This doesn't have a minimum amount.
   *
   * Emits `Started`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'FastTrack'; params: { proposalHash: H256; votingPeriod: number; delay: number } }
  /**
   * Veto and blacklist the external proposal hash.
   *
   * The dispatch origin of this call must be `VetoOrigin`.
   *
   * - `proposal_hash`: The preimage hash of the proposal to veto and blacklist.
   *
   * Emits `Vetoed`.
   *
   * Weight: `O(V + log(V))` where V is number of `existing vetoers`
   **/
  | { name: 'VetoExternal'; params: { proposalHash: H256 } }
  /**
   * Remove a referendum.
   *
   * The dispatch origin of this call must be _Root_.
   *
   * - `ref_index`: The index of the referendum to cancel.
   *
   * # Weight: `O(1)`.
   **/
  | { name: 'CancelReferendum'; params: { refIndex: number } }
  /**
   * Delegate the voting power (with some given conviction) of the sending account.
   *
   * The balance delegated is locked for as long as it's delegated, and thereafter for the
   * time appropriate for the conviction's lock period.
   *
   * The dispatch origin of this call must be _Signed_, and the signing account must either:
   * - be delegating already; or
   * - have no voting activity (if there is, then it will need to be removed/consolidated
   * through `reap_vote` or `unvote`).
   *
   * - `to`: The account whose voting the `target` account's voting power will follow.
   * - `conviction`: The conviction that will be attached to the delegated votes. When the
   * account is undelegated, the funds will be locked for the corresponding period.
   * - `balance`: The amount of the account's balance to be used in delegating. This must not
   * be more than the account's current balance.
   *
   * Emits `Delegated`.
   *
   * Weight: `O(R)` where R is the number of referendums the voter delegating to has
   * voted on. Weight is charged as if maximum votes.
   **/
  | { name: 'Delegate'; params: { to: AccountId32; conviction: PalletDemocracyConviction; balance: bigint } }
  /**
   * Undelegate the voting power of the sending account.
   *
   * Tokens may be unlocked following once an amount of time consistent with the lock period
   * of the conviction with which the delegation was issued.
   *
   * The dispatch origin of this call must be _Signed_ and the signing account must be
   * currently delegating.
   *
   * Emits `Undelegated`.
   *
   * Weight: `O(R)` where R is the number of referendums the voter delegating to has
   * voted on. Weight is charged as if maximum votes.
   **/
  | { name: 'Undelegate' }
  /**
   * Clears all public proposals.
   *
   * The dispatch origin of this call must be _Root_.
   *
   * Weight: `O(1)`.
   **/
  | { name: 'ClearPublicProposals' }
  /**
   * Unlock tokens that have an expired lock.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `target`: The account to remove the lock on.
   *
   * Weight: `O(R)` with R number of vote of target.
   **/
  | { name: 'Unlock'; params: { target: AccountId32 } }
  /**
   * Remove a vote for a referendum.
   *
   * If:
   * - the referendum was cancelled, or
   * - the referendum is ongoing, or
   * - the referendum has ended such that
   * - the vote of the account was in opposition to the result; or
   * - there was no conviction to the account's vote; or
   * - the account made a split vote
   * ...then the vote is removed cleanly and a following call to `unlock` may result in more
   * funds being available.
   *
   * If, however, the referendum has ended and:
   * - it finished corresponding to the vote of the account, and
   * - the account made a standard vote with conviction, and
   * - the lock period of the conviction is not over
   * ...then the lock will be aggregated into the overall account's lock, which may involve
   * *overlocking* (where the two locks are combined into a single lock that is the maximum
   * of both the amount locked and the time is it locked for).
   *
   * The dispatch origin of this call must be _Signed_, and the signer must have a vote
   * registered for referendum `index`.
   *
   * - `index`: The index of referendum of the vote to be removed.
   *
   * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: 'RemoveVote'; params: { index: number } }
  /**
   * Remove a vote for a referendum.
   *
   * If the `target` is equal to the signer, then this function is exactly equivalent to
   * `remove_vote`. If not equal to the signer, then the vote must have expired,
   * either because the referendum was cancelled, because the voter lost the referendum or
   * because the conviction period is over.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `target`: The account of the vote to be removed; this account must have voted for
   * referendum `index`.
   * - `index`: The index of referendum of the vote to be removed.
   *
   * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: 'RemoveOtherVote'; params: { target: AccountId32; index: number } }
  /**
   * Permanently place a proposal into the blacklist. This prevents it from ever being
   * proposed again.
   *
   * If called on a queued public or external proposal, then this will result in it being
   * removed. If the `ref_index` supplied is an active referendum with the proposal hash,
   * then it will be cancelled.
   *
   * The dispatch origin of this call must be `BlacklistOrigin`.
   *
   * - `proposal_hash`: The proposal hash to blacklist permanently.
   * - `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be
   * cancelled.
   *
   * Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a
   * reasonable value).
   **/
  | { name: 'Blacklist'; params: { proposalHash: H256; maybeRefIndex?: number | undefined } }
  /**
   * Remove a proposal.
   *
   * The dispatch origin of this call must be `CancelProposalOrigin`.
   *
   * - `prop_index`: The index of the proposal to cancel.
   *
   * Weight: `O(p)` where `p = PublicProps::<T>::decode_len()`
   **/
  | { name: 'CancelProposal'; params: { propIndex: number } }
  /**
   * Set or clear a metadata of a proposal or a referendum.
   *
   * Parameters:
   * - `origin`: Must correspond to the `MetadataOwner`.
   * - `ExternalOrigin` for an external proposal with the `SuperMajorityApprove`
   * threshold.
   * - `ExternalDefaultOrigin` for an external proposal with the `SuperMajorityAgainst`
   * threshold.
   * - `ExternalMajorityOrigin` for an external proposal with the `SimpleMajority`
   * threshold.
   * - `Signed` by a creator for a public proposal.
   * - `Signed` to clear a metadata for a finished referendum.
   * - `Root` to set a metadata for an ongoing referendum.
   * - `owner`: an identifier of a metadata owner.
   * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
   **/
  | { name: 'SetMetadata'; params: { owner: PalletDemocracyMetadataOwner; maybeHash?: H256 | undefined } }
  /**
   * Allow to force remove a vote for a referendum.
   *
   * Same as `remove_other_vote`, except the scope is overriden by forced flag.
   * The dispatch origin of this call must be `VoteRemovalOrigin`.
   *
   * Only allowed if the referendum is finished.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `target`: The account of the vote to be removed; this account must have voted for
   * referendum `index`.
   * - `index`: The index of referendum of the vote to be removed.
   *
   * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: 'ForceRemoveVote'; params: { target: AccountId32; index: number } };

export type PalletDemocracyCallLike =
  /**
   * Propose a sensitive action to be taken.
   *
   * The dispatch origin of this call must be _Signed_ and the sender must
   * have funds to cover the deposit.
   *
   * - `proposal_hash`: The hash of the proposal preimage.
   * - `value`: The amount of deposit (must be at least `MinimumDeposit`).
   *
   * Emits `Proposed`.
   **/
  | { name: 'Propose'; params: { proposal: FrameSupportPreimagesBounded; value: bigint } }
  /**
   * Signals agreement with a particular proposal.
   *
   * The dispatch origin of this call must be _Signed_ and the sender
   * must have funds to cover the deposit, equal to the original deposit.
   *
   * - `proposal`: The index of the proposal to second.
   **/
  | { name: 'Second'; params: { proposal: number } }
  /**
   * Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;
   * otherwise it is a vote to keep the status quo.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `ref_index`: The index of the referendum to vote for.
   * - `vote`: The vote configuration.
   **/
  | { name: 'Vote'; params: { refIndex: number; vote: PalletDemocracyVoteAccountVote } }
  /**
   * Schedule an emergency cancellation of a referendum. Cannot happen twice to the same
   * referendum.
   *
   * The dispatch origin of this call must be `CancellationOrigin`.
   *
   * -`ref_index`: The index of the referendum to cancel.
   *
   * Weight: `O(1)`.
   **/
  | { name: 'EmergencyCancel'; params: { refIndex: number } }
  /**
   * Schedule a referendum to be tabled once it is legal to schedule an external
   * referendum.
   *
   * The dispatch origin of this call must be `ExternalOrigin`.
   *
   * - `proposal_hash`: The preimage hash of the proposal.
   **/
  | { name: 'ExternalPropose'; params: { proposal: FrameSupportPreimagesBounded } }
  /**
   * Schedule a majority-carries referendum to be tabled next once it is legal to schedule
   * an external referendum.
   *
   * The dispatch of this call must be `ExternalMajorityOrigin`.
   *
   * - `proposal_hash`: The preimage hash of the proposal.
   *
   * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
   * pre-scheduled `external_propose` call.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ExternalProposeMajority'; params: { proposal: FrameSupportPreimagesBounded } }
  /**
   * Schedule a negative-turnout-bias referendum to be tabled next once it is legal to
   * schedule an external referendum.
   *
   * The dispatch of this call must be `ExternalDefaultOrigin`.
   *
   * - `proposal_hash`: The preimage hash of the proposal.
   *
   * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
   * pre-scheduled `external_propose` call.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ExternalProposeDefault'; params: { proposal: FrameSupportPreimagesBounded } }
  /**
   * Schedule the currently externally-proposed majority-carries referendum to be tabled
   * immediately. If there is no externally-proposed referendum currently, or if there is one
   * but it is not a majority-carries referendum then it fails.
   *
   * The dispatch of this call must be `FastTrackOrigin`.
   *
   * - `proposal_hash`: The hash of the current external proposal.
   * - `voting_period`: The period that is allowed for voting on this proposal. Increased to
   * Must be always greater than zero.
   * For `FastTrackOrigin` must be equal or greater than `FastTrackVotingPeriod`.
   * - `delay`: The number of block after voting has ended in approval and this should be
   * enacted. This doesn't have a minimum amount.
   *
   * Emits `Started`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'FastTrack'; params: { proposalHash: H256; votingPeriod: number; delay: number } }
  /**
   * Veto and blacklist the external proposal hash.
   *
   * The dispatch origin of this call must be `VetoOrigin`.
   *
   * - `proposal_hash`: The preimage hash of the proposal to veto and blacklist.
   *
   * Emits `Vetoed`.
   *
   * Weight: `O(V + log(V))` where V is number of `existing vetoers`
   **/
  | { name: 'VetoExternal'; params: { proposalHash: H256 } }
  /**
   * Remove a referendum.
   *
   * The dispatch origin of this call must be _Root_.
   *
   * - `ref_index`: The index of the referendum to cancel.
   *
   * # Weight: `O(1)`.
   **/
  | { name: 'CancelReferendum'; params: { refIndex: number } }
  /**
   * Delegate the voting power (with some given conviction) of the sending account.
   *
   * The balance delegated is locked for as long as it's delegated, and thereafter for the
   * time appropriate for the conviction's lock period.
   *
   * The dispatch origin of this call must be _Signed_, and the signing account must either:
   * - be delegating already; or
   * - have no voting activity (if there is, then it will need to be removed/consolidated
   * through `reap_vote` or `unvote`).
   *
   * - `to`: The account whose voting the `target` account's voting power will follow.
   * - `conviction`: The conviction that will be attached to the delegated votes. When the
   * account is undelegated, the funds will be locked for the corresponding period.
   * - `balance`: The amount of the account's balance to be used in delegating. This must not
   * be more than the account's current balance.
   *
   * Emits `Delegated`.
   *
   * Weight: `O(R)` where R is the number of referendums the voter delegating to has
   * voted on. Weight is charged as if maximum votes.
   **/
  | { name: 'Delegate'; params: { to: AccountId32Like; conviction: PalletDemocracyConviction; balance: bigint } }
  /**
   * Undelegate the voting power of the sending account.
   *
   * Tokens may be unlocked following once an amount of time consistent with the lock period
   * of the conviction with which the delegation was issued.
   *
   * The dispatch origin of this call must be _Signed_ and the signing account must be
   * currently delegating.
   *
   * Emits `Undelegated`.
   *
   * Weight: `O(R)` where R is the number of referendums the voter delegating to has
   * voted on. Weight is charged as if maximum votes.
   **/
  | { name: 'Undelegate' }
  /**
   * Clears all public proposals.
   *
   * The dispatch origin of this call must be _Root_.
   *
   * Weight: `O(1)`.
   **/
  | { name: 'ClearPublicProposals' }
  /**
   * Unlock tokens that have an expired lock.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `target`: The account to remove the lock on.
   *
   * Weight: `O(R)` with R number of vote of target.
   **/
  | { name: 'Unlock'; params: { target: AccountId32Like } }
  /**
   * Remove a vote for a referendum.
   *
   * If:
   * - the referendum was cancelled, or
   * - the referendum is ongoing, or
   * - the referendum has ended such that
   * - the vote of the account was in opposition to the result; or
   * - there was no conviction to the account's vote; or
   * - the account made a split vote
   * ...then the vote is removed cleanly and a following call to `unlock` may result in more
   * funds being available.
   *
   * If, however, the referendum has ended and:
   * - it finished corresponding to the vote of the account, and
   * - the account made a standard vote with conviction, and
   * - the lock period of the conviction is not over
   * ...then the lock will be aggregated into the overall account's lock, which may involve
   * *overlocking* (where the two locks are combined into a single lock that is the maximum
   * of both the amount locked and the time is it locked for).
   *
   * The dispatch origin of this call must be _Signed_, and the signer must have a vote
   * registered for referendum `index`.
   *
   * - `index`: The index of referendum of the vote to be removed.
   *
   * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: 'RemoveVote'; params: { index: number } }
  /**
   * Remove a vote for a referendum.
   *
   * If the `target` is equal to the signer, then this function is exactly equivalent to
   * `remove_vote`. If not equal to the signer, then the vote must have expired,
   * either because the referendum was cancelled, because the voter lost the referendum or
   * because the conviction period is over.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `target`: The account of the vote to be removed; this account must have voted for
   * referendum `index`.
   * - `index`: The index of referendum of the vote to be removed.
   *
   * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: 'RemoveOtherVote'; params: { target: AccountId32Like; index: number } }
  /**
   * Permanently place a proposal into the blacklist. This prevents it from ever being
   * proposed again.
   *
   * If called on a queued public or external proposal, then this will result in it being
   * removed. If the `ref_index` supplied is an active referendum with the proposal hash,
   * then it will be cancelled.
   *
   * The dispatch origin of this call must be `BlacklistOrigin`.
   *
   * - `proposal_hash`: The proposal hash to blacklist permanently.
   * - `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be
   * cancelled.
   *
   * Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a
   * reasonable value).
   **/
  | { name: 'Blacklist'; params: { proposalHash: H256; maybeRefIndex?: number | undefined } }
  /**
   * Remove a proposal.
   *
   * The dispatch origin of this call must be `CancelProposalOrigin`.
   *
   * - `prop_index`: The index of the proposal to cancel.
   *
   * Weight: `O(p)` where `p = PublicProps::<T>::decode_len()`
   **/
  | { name: 'CancelProposal'; params: { propIndex: number } }
  /**
   * Set or clear a metadata of a proposal or a referendum.
   *
   * Parameters:
   * - `origin`: Must correspond to the `MetadataOwner`.
   * - `ExternalOrigin` for an external proposal with the `SuperMajorityApprove`
   * threshold.
   * - `ExternalDefaultOrigin` for an external proposal with the `SuperMajorityAgainst`
   * threshold.
   * - `ExternalMajorityOrigin` for an external proposal with the `SimpleMajority`
   * threshold.
   * - `Signed` by a creator for a public proposal.
   * - `Signed` to clear a metadata for a finished referendum.
   * - `Root` to set a metadata for an ongoing referendum.
   * - `owner`: an identifier of a metadata owner.
   * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
   **/
  | { name: 'SetMetadata'; params: { owner: PalletDemocracyMetadataOwner; maybeHash?: H256 | undefined } }
  /**
   * Allow to force remove a vote for a referendum.
   *
   * Same as `remove_other_vote`, except the scope is overriden by forced flag.
   * The dispatch origin of this call must be `VoteRemovalOrigin`.
   *
   * Only allowed if the referendum is finished.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `target`: The account of the vote to be removed; this account must have voted for
   * referendum `index`.
   * - `index`: The index of referendum of the vote to be removed.
   *
   * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: 'ForceRemoveVote'; params: { target: AccountId32Like; index: number } };

export type PalletDemocracyConviction =
  | 'None'
  | 'Locked1x'
  | 'Locked2x'
  | 'Locked3x'
  | 'Locked4x'
  | 'Locked5x'
  | 'Locked6x';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletElectionsPhragmenCall =
  /**
   * Vote for a set of candidates for the upcoming round of election. This can be called to
   * set the initial votes, or update already existing votes.
   *
   * Upon initial voting, `value` units of `who`'s balance is locked and a deposit amount is
   * reserved. The deposit is based on the number of votes and can be updated over time.
   *
   * The `votes` should:
   * - not be empty.
   * - be less than the number of possible candidates. Note that all current members and
   * runners-up are also automatically candidates for the next round.
   *
   * If `value` is more than `who`'s free balance, then the maximum of the two is used.
   *
   * The dispatch origin of this call must be signed.
   *
   * ### Warning
   *
   * It is the responsibility of the caller to **NOT** place all of their balance into the
   * lock and keep some for further operations.
   **/
  | { name: 'Vote'; params: { votes: Array<AccountId32>; value: bigint } }
  /**
   * Remove `origin` as a voter.
   *
   * This removes the lock and returns the deposit.
   *
   * The dispatch origin of this call must be signed and be a voter.
   **/
  | { name: 'RemoveVoter' }
  /**
   * Submit oneself for candidacy. A fixed amount of deposit is recorded.
   *
   * All candidates are wiped at the end of the term. They either become a member/runner-up,
   * or leave the system while their deposit is slashed.
   *
   * The dispatch origin of this call must be signed.
   *
   * ### Warning
   *
   * Even if a candidate ends up being a member, they must call [`Call::renounce_candidacy`]
   * to get their deposit back. Losing the spot in an election will always lead to a slash.
   *
   * The number of current candidates must be provided as witness data.
   * ## Complexity
   * O(C + log(C)) where C is candidate_count.
   **/
  | { name: 'SubmitCandidacy'; params: { candidateCount: number } }
  /**
   * Renounce one's intention to be a candidate for the next election round. 3 potential
   * outcomes exist:
   *
   * - `origin` is a candidate and not elected in any set. In this case, the deposit is
   * unreserved, returned and origin is removed as a candidate.
   * - `origin` is a current runner-up. In this case, the deposit is unreserved, returned and
   * origin is removed as a runner-up.
   * - `origin` is a current member. In this case, the deposit is unreserved and origin is
   * removed as a member, consequently not being a candidate for the next round anymore.
   * Similar to [`remove_member`](Self::remove_member), if replacement runners exists, they
   * are immediately used. If the prime is renouncing, then no prime will exist until the
   * next round.
   *
   * The dispatch origin of this call must be signed, and have one of the above roles.
   * The type of renouncing must be provided as witness data.
   *
   * ## Complexity
   * - Renouncing::Candidate(count): O(count + log(count))
   * - Renouncing::Member: O(1)
   * - Renouncing::RunnerUp: O(1)
   **/
  | { name: 'RenounceCandidacy'; params: { renouncing: PalletElectionsPhragmenRenouncing } }
  /**
   * Remove a particular member from the set. This is effective immediately and the bond of
   * the outgoing member is slashed.
   *
   * If a runner-up is available, then the best runner-up will be removed and replaces the
   * outgoing member. Otherwise, if `rerun_election` is `true`, a new phragmen election is
   * started, else, nothing happens.
   *
   * If `slash_bond` is set to true, the bond of the member being removed is slashed. Else,
   * it is returned.
   *
   * The dispatch origin of this call must be root.
   *
   * Note that this does not affect the designated block number of the next election.
   *
   * ## Complexity
   * - Check details of remove_and_replace_member() and do_phragmen().
   **/
  | { name: 'RemoveMember'; params: { who: AccountId32; slashBond: boolean; rerunElection: boolean } }
  /**
   * Clean all voters who are defunct (i.e. they do not serve any purpose at all). The
   * deposit of the removed voters are returned.
   *
   * This is an root function to be used only for cleaning the state.
   *
   * The dispatch origin of this call must be root.
   *
   * ## Complexity
   * - Check is_defunct_voter() details.
   **/
  | { name: 'CleanDefunctVoters'; params: { numVoters: number; numDefunct: number } };

export type PalletElectionsPhragmenCallLike =
  /**
   * Vote for a set of candidates for the upcoming round of election. This can be called to
   * set the initial votes, or update already existing votes.
   *
   * Upon initial voting, `value` units of `who`'s balance is locked and a deposit amount is
   * reserved. The deposit is based on the number of votes and can be updated over time.
   *
   * The `votes` should:
   * - not be empty.
   * - be less than the number of possible candidates. Note that all current members and
   * runners-up are also automatically candidates for the next round.
   *
   * If `value` is more than `who`'s free balance, then the maximum of the two is used.
   *
   * The dispatch origin of this call must be signed.
   *
   * ### Warning
   *
   * It is the responsibility of the caller to **NOT** place all of their balance into the
   * lock and keep some for further operations.
   **/
  | { name: 'Vote'; params: { votes: Array<AccountId32Like>; value: bigint } }
  /**
   * Remove `origin` as a voter.
   *
   * This removes the lock and returns the deposit.
   *
   * The dispatch origin of this call must be signed and be a voter.
   **/
  | { name: 'RemoveVoter' }
  /**
   * Submit oneself for candidacy. A fixed amount of deposit is recorded.
   *
   * All candidates are wiped at the end of the term. They either become a member/runner-up,
   * or leave the system while their deposit is slashed.
   *
   * The dispatch origin of this call must be signed.
   *
   * ### Warning
   *
   * Even if a candidate ends up being a member, they must call [`Call::renounce_candidacy`]
   * to get their deposit back. Losing the spot in an election will always lead to a slash.
   *
   * The number of current candidates must be provided as witness data.
   * ## Complexity
   * O(C + log(C)) where C is candidate_count.
   **/
  | { name: 'SubmitCandidacy'; params: { candidateCount: number } }
  /**
   * Renounce one's intention to be a candidate for the next election round. 3 potential
   * outcomes exist:
   *
   * - `origin` is a candidate and not elected in any set. In this case, the deposit is
   * unreserved, returned and origin is removed as a candidate.
   * - `origin` is a current runner-up. In this case, the deposit is unreserved, returned and
   * origin is removed as a runner-up.
   * - `origin` is a current member. In this case, the deposit is unreserved and origin is
   * removed as a member, consequently not being a candidate for the next round anymore.
   * Similar to [`remove_member`](Self::remove_member), if replacement runners exists, they
   * are immediately used. If the prime is renouncing, then no prime will exist until the
   * next round.
   *
   * The dispatch origin of this call must be signed, and have one of the above roles.
   * The type of renouncing must be provided as witness data.
   *
   * ## Complexity
   * - Renouncing::Candidate(count): O(count + log(count))
   * - Renouncing::Member: O(1)
   * - Renouncing::RunnerUp: O(1)
   **/
  | { name: 'RenounceCandidacy'; params: { renouncing: PalletElectionsPhragmenRenouncing } }
  /**
   * Remove a particular member from the set. This is effective immediately and the bond of
   * the outgoing member is slashed.
   *
   * If a runner-up is available, then the best runner-up will be removed and replaces the
   * outgoing member. Otherwise, if `rerun_election` is `true`, a new phragmen election is
   * started, else, nothing happens.
   *
   * If `slash_bond` is set to true, the bond of the member being removed is slashed. Else,
   * it is returned.
   *
   * The dispatch origin of this call must be root.
   *
   * Note that this does not affect the designated block number of the next election.
   *
   * ## Complexity
   * - Check details of remove_and_replace_member() and do_phragmen().
   **/
  | { name: 'RemoveMember'; params: { who: AccountId32Like; slashBond: boolean; rerunElection: boolean } }
  /**
   * Clean all voters who are defunct (i.e. they do not serve any purpose at all). The
   * deposit of the removed voters are returned.
   *
   * This is an root function to be used only for cleaning the state.
   *
   * The dispatch origin of this call must be root.
   *
   * ## Complexity
   * - Check is_defunct_voter() details.
   **/
  | { name: 'CleanDefunctVoters'; params: { numVoters: number; numDefunct: number } };

export type PalletElectionsPhragmenRenouncing =
  | { type: 'Member' }
  | { type: 'RunnerUp' }
  | { type: 'Candidate'; value: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletCollectiveCall =
  /**
   * Set the collective's membership.
   *
   * - `new_members`: The new member list. Be nice to the chain and provide it sorted.
   * - `prime`: The prime member whose vote sets the default.
   * - `old_count`: The upper bound for the previous number of members in storage. Used for
   * weight estimation.
   *
   * The dispatch of this call must be `SetMembersOrigin`.
   *
   * NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
   * the weight estimations rely on it to estimate dispatchable weight.
   *
   * # WARNING:
   *
   * The `pallet-collective` can also be managed by logic outside of the pallet through the
   * implementation of the trait [`ChangeMembers`].
   * Any call to `set_members` must be careful that the member set doesn't get out of sync
   * with other logic managing the member set.
   *
   * ## Complexity:
   * - `O(MP + N)` where:
   * - `M` old-members-count (code- and governance-bounded)
   * - `N` new-members-count (code- and governance-bounded)
   * - `P` proposals-count (code-bounded)
   **/
  | {
      name: 'SetMembers';
      params: { newMembers: Array<AccountId32>; prime?: AccountId32 | undefined; oldCount: number };
    }
  /**
   * Dispatch a proposal from a member using the `Member` origin.
   *
   * Origin must be a member of the collective.
   *
   * ## Complexity:
   * - `O(B + M + P)` where:
   * - `B` is `proposal` size in bytes (length-fee-bounded)
   * - `M` members-count (code-bounded)
   * - `P` complexity of dispatching `proposal`
   **/
  | { name: 'Execute'; params: { proposal: HydradxRuntimeRuntimeCall; lengthBound: number } }
  /**
   * Add a new proposal to either be voted on or executed directly.
   *
   * Requires the sender to be member.
   *
   * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
   * or put up for voting.
   *
   * ## Complexity
   * - `O(B + M + P1)` or `O(B + M + P2)` where:
   * - `B` is `proposal` size in bytes (length-fee-bounded)
   * - `M` is members-count (code- and governance-bounded)
   * - branching is influenced by `threshold` where:
   * - `P1` is proposal execution complexity (`threshold < 2`)
   * - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
   **/
  | { name: 'Propose'; params: { threshold: number; proposal: HydradxRuntimeRuntimeCall; lengthBound: number } }
  /**
   * Add an aye or nay vote for the sender to the given proposal.
   *
   * Requires the sender to be a member.
   *
   * Transaction fees will be waived if the member is voting on any particular proposal
   * for the first time and the call is successful. Subsequent vote changes will charge a
   * fee.
   * ## Complexity
   * - `O(M)` where `M` is members-count (code- and governance-bounded)
   **/
  | { name: 'Vote'; params: { proposal: H256; index: number; approve: boolean } }
  /**
   * Disapprove a proposal, close, and remove it from the system, regardless of its current
   * state.
   *
   * Must be called by the Root origin.
   *
   * Parameters:
   * * `proposal_hash`: The hash of the proposal that should be disapproved.
   *
   * ## Complexity
   * O(P) where P is the number of max proposals
   **/
  | { name: 'DisapproveProposal'; params: { proposalHash: H256 } }
  /**
   * Close a vote that is either approved, disapproved or whose voting period has ended.
   *
   * May be called by any signed account in order to finish voting and close the proposal.
   *
   * If called before the end of the voting period it will only close the vote if it is
   * has enough votes to be approved or disapproved.
   *
   * If called after the end of the voting period abstentions are counted as rejections
   * unless there is a prime member set and the prime member cast an approval.
   *
   * If the close operation completes successfully with disapproval, the transaction fee will
   * be waived. Otherwise execution of the approved operation will be charged to the caller.
   *
   * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
   * proposal.
   * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
   * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
   *
   * ## Complexity
   * - `O(B + M + P1 + P2)` where:
   * - `B` is `proposal` size in bytes (length-fee-bounded)
   * - `M` is members-count (code- and governance-bounded)
   * - `P1` is the complexity of `proposal` preimage.
   * - `P2` is proposal-count (code-bounded)
   **/
  | {
      name: 'Close';
      params: { proposalHash: H256; index: number; proposalWeightBound: SpWeightsWeightV2Weight; lengthBound: number };
    };

export type PalletCollectiveCallLike =
  /**
   * Set the collective's membership.
   *
   * - `new_members`: The new member list. Be nice to the chain and provide it sorted.
   * - `prime`: The prime member whose vote sets the default.
   * - `old_count`: The upper bound for the previous number of members in storage. Used for
   * weight estimation.
   *
   * The dispatch of this call must be `SetMembersOrigin`.
   *
   * NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
   * the weight estimations rely on it to estimate dispatchable weight.
   *
   * # WARNING:
   *
   * The `pallet-collective` can also be managed by logic outside of the pallet through the
   * implementation of the trait [`ChangeMembers`].
   * Any call to `set_members` must be careful that the member set doesn't get out of sync
   * with other logic managing the member set.
   *
   * ## Complexity:
   * - `O(MP + N)` where:
   * - `M` old-members-count (code- and governance-bounded)
   * - `N` new-members-count (code- and governance-bounded)
   * - `P` proposals-count (code-bounded)
   **/
  | {
      name: 'SetMembers';
      params: { newMembers: Array<AccountId32Like>; prime?: AccountId32Like | undefined; oldCount: number };
    }
  /**
   * Dispatch a proposal from a member using the `Member` origin.
   *
   * Origin must be a member of the collective.
   *
   * ## Complexity:
   * - `O(B + M + P)` where:
   * - `B` is `proposal` size in bytes (length-fee-bounded)
   * - `M` members-count (code-bounded)
   * - `P` complexity of dispatching `proposal`
   **/
  | { name: 'Execute'; params: { proposal: HydradxRuntimeRuntimeCallLike; lengthBound: number } }
  /**
   * Add a new proposal to either be voted on or executed directly.
   *
   * Requires the sender to be member.
   *
   * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
   * or put up for voting.
   *
   * ## Complexity
   * - `O(B + M + P1)` or `O(B + M + P2)` where:
   * - `B` is `proposal` size in bytes (length-fee-bounded)
   * - `M` is members-count (code- and governance-bounded)
   * - branching is influenced by `threshold` where:
   * - `P1` is proposal execution complexity (`threshold < 2`)
   * - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
   **/
  | { name: 'Propose'; params: { threshold: number; proposal: HydradxRuntimeRuntimeCallLike; lengthBound: number } }
  /**
   * Add an aye or nay vote for the sender to the given proposal.
   *
   * Requires the sender to be a member.
   *
   * Transaction fees will be waived if the member is voting on any particular proposal
   * for the first time and the call is successful. Subsequent vote changes will charge a
   * fee.
   * ## Complexity
   * - `O(M)` where `M` is members-count (code- and governance-bounded)
   **/
  | { name: 'Vote'; params: { proposal: H256; index: number; approve: boolean } }
  /**
   * Disapprove a proposal, close, and remove it from the system, regardless of its current
   * state.
   *
   * Must be called by the Root origin.
   *
   * Parameters:
   * * `proposal_hash`: The hash of the proposal that should be disapproved.
   *
   * ## Complexity
   * O(P) where P is the number of max proposals
   **/
  | { name: 'DisapproveProposal'; params: { proposalHash: H256 } }
  /**
   * Close a vote that is either approved, disapproved or whose voting period has ended.
   *
   * May be called by any signed account in order to finish voting and close the proposal.
   *
   * If called before the end of the voting period it will only close the vote if it is
   * has enough votes to be approved or disapproved.
   *
   * If called after the end of the voting period abstentions are counted as rejections
   * unless there is a prime member set and the prime member cast an approval.
   *
   * If the close operation completes successfully with disapproval, the transaction fee will
   * be waived. Otherwise execution of the approved operation will be charged to the caller.
   *
   * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
   * proposal.
   * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
   * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
   *
   * ## Complexity
   * - `O(B + M + P1 + P2)` where:
   * - `B` is `proposal` size in bytes (length-fee-bounded)
   * - `M` is members-count (code- and governance-bounded)
   * - `P1` is the complexity of `proposal` preimage.
   * - `P2` is proposal-count (code-bounded)
   **/
  | {
      name: 'Close';
      params: { proposalHash: H256; index: number; proposalWeightBound: SpWeightsWeightV2Weight; lengthBound: number };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTipsCall =
  /**
   * Report something `reason` that deserves a tip and claim any eventual the finder's fee.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
   * `DataDepositPerByte` for each byte in `reason`.
   *
   * - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
   * a UTF-8-encoded URL.
   * - `who`: The account which should be credited for the tip.
   *
   * Emits `NewTip` if successful.
   *
   * ## Complexity
   * - `O(R)` where `R` length of `reason`.
   * - encoding and hashing of 'reason'
   **/
  | { name: 'ReportAwesome'; params: { reason: Bytes; who: AccountId32 } }
  /**
   * Retract a prior tip-report from `report_awesome`, and cancel the process of tipping.
   *
   * If successful, the original deposit will be unreserved.
   *
   * The dispatch origin for this call must be _Signed_ and the tip identified by `hash`
   * must have been reported by the signing account through `report_awesome` (and not
   * through `tip_new`).
   *
   * - `hash`: The identity of the open tip for which a tip value is declared. This is formed
   * as the hash of the tuple of the original tip `reason` and the beneficiary account ID.
   *
   * Emits `TipRetracted` if successful.
   *
   * ## Complexity
   * - `O(1)`
   * - Depends on the length of `T::Hash` which is fixed.
   **/
  | { name: 'RetractTip'; params: { hash: H256 } }
  /**
   * Give a tip for something new; no finder's fee will be taken.
   *
   * The dispatch origin for this call must be _Signed_ and the signing account must be a
   * member of the `Tippers` set.
   *
   * - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
   * a UTF-8-encoded URL.
   * - `who`: The account which should be credited for the tip.
   * - `tip_value`: The amount of tip that the sender would like to give. The median tip
   * value of active tippers will be given to the `who`.
   *
   * Emits `NewTip` if successful.
   *
   * ## Complexity
   * - `O(R + T)` where `R` length of `reason`, `T` is the number of tippers.
   * - `O(T)`: decoding `Tipper` vec of length `T`. `T` is charged as upper bound given by
   * `ContainsLengthBound`. The actual cost depends on the implementation of
   * `T::Tippers`.
   * - `O(R)`: hashing and encoding of reason of length `R`
   **/
  | { name: 'TipNew'; params: { reason: Bytes; who: AccountId32; tipValue: bigint } }
  /**
   * Declare a tip value for an already-open tip.
   *
   * The dispatch origin for this call must be _Signed_ and the signing account must be a
   * member of the `Tippers` set.
   *
   * - `hash`: The identity of the open tip for which a tip value is declared. This is formed
   * as the hash of the tuple of the hash of the original tip `reason` and the beneficiary
   * account ID.
   * - `tip_value`: The amount of tip that the sender would like to give. The median tip
   * value of active tippers will be given to the `who`.
   *
   * Emits `TipClosing` if the threshold of tippers has been reached and the countdown period
   * has started.
   *
   * ## Complexity
   * - `O(T)` where `T` is the number of tippers. decoding `Tipper` vec of length `T`, insert
   * tip and check closing, `T` is charged as upper bound given by `ContainsLengthBound`.
   * The actual cost depends on the implementation of `T::Tippers`.
   *
   * Actually weight could be lower as it depends on how many tips are in `OpenTip` but it
   * is weighted as if almost full i.e of length `T-1`.
   **/
  | { name: 'Tip'; params: { hash: H256; tipValue: bigint } }
  /**
   * Close and payout a tip.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * The tip identified by `hash` must have finished its countdown period.
   *
   * - `hash`: The identity of the open tip for which a tip value is declared. This is formed
   * as the hash of the tuple of the original tip `reason` and the beneficiary account ID.
   *
   * ## Complexity
   * - : `O(T)` where `T` is the number of tippers. decoding `Tipper` vec of length `T`. `T`
   * is charged as upper bound given by `ContainsLengthBound`. The actual cost depends on
   * the implementation of `T::Tippers`.
   **/
  | { name: 'CloseTip'; params: { hash: H256 } }
  /**
   * Remove and slash an already-open tip.
   *
   * May only be called from `T::RejectOrigin`.
   *
   * As a result, the finder is slashed and the deposits are lost.
   *
   * Emits `TipSlashed` if successful.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'SlashTip'; params: { hash: H256 } };

export type PalletTipsCallLike =
  /**
   * Report something `reason` that deserves a tip and claim any eventual the finder's fee.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
   * `DataDepositPerByte` for each byte in `reason`.
   *
   * - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
   * a UTF-8-encoded URL.
   * - `who`: The account which should be credited for the tip.
   *
   * Emits `NewTip` if successful.
   *
   * ## Complexity
   * - `O(R)` where `R` length of `reason`.
   * - encoding and hashing of 'reason'
   **/
  | { name: 'ReportAwesome'; params: { reason: BytesLike; who: AccountId32Like } }
  /**
   * Retract a prior tip-report from `report_awesome`, and cancel the process of tipping.
   *
   * If successful, the original deposit will be unreserved.
   *
   * The dispatch origin for this call must be _Signed_ and the tip identified by `hash`
   * must have been reported by the signing account through `report_awesome` (and not
   * through `tip_new`).
   *
   * - `hash`: The identity of the open tip for which a tip value is declared. This is formed
   * as the hash of the tuple of the original tip `reason` and the beneficiary account ID.
   *
   * Emits `TipRetracted` if successful.
   *
   * ## Complexity
   * - `O(1)`
   * - Depends on the length of `T::Hash` which is fixed.
   **/
  | { name: 'RetractTip'; params: { hash: H256 } }
  /**
   * Give a tip for something new; no finder's fee will be taken.
   *
   * The dispatch origin for this call must be _Signed_ and the signing account must be a
   * member of the `Tippers` set.
   *
   * - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
   * a UTF-8-encoded URL.
   * - `who`: The account which should be credited for the tip.
   * - `tip_value`: The amount of tip that the sender would like to give. The median tip
   * value of active tippers will be given to the `who`.
   *
   * Emits `NewTip` if successful.
   *
   * ## Complexity
   * - `O(R + T)` where `R` length of `reason`, `T` is the number of tippers.
   * - `O(T)`: decoding `Tipper` vec of length `T`. `T` is charged as upper bound given by
   * `ContainsLengthBound`. The actual cost depends on the implementation of
   * `T::Tippers`.
   * - `O(R)`: hashing and encoding of reason of length `R`
   **/
  | { name: 'TipNew'; params: { reason: BytesLike; who: AccountId32Like; tipValue: bigint } }
  /**
   * Declare a tip value for an already-open tip.
   *
   * The dispatch origin for this call must be _Signed_ and the signing account must be a
   * member of the `Tippers` set.
   *
   * - `hash`: The identity of the open tip for which a tip value is declared. This is formed
   * as the hash of the tuple of the hash of the original tip `reason` and the beneficiary
   * account ID.
   * - `tip_value`: The amount of tip that the sender would like to give. The median tip
   * value of active tippers will be given to the `who`.
   *
   * Emits `TipClosing` if the threshold of tippers has been reached and the countdown period
   * has started.
   *
   * ## Complexity
   * - `O(T)` where `T` is the number of tippers. decoding `Tipper` vec of length `T`, insert
   * tip and check closing, `T` is charged as upper bound given by `ContainsLengthBound`.
   * The actual cost depends on the implementation of `T::Tippers`.
   *
   * Actually weight could be lower as it depends on how many tips are in `OpenTip` but it
   * is weighted as if almost full i.e of length `T-1`.
   **/
  | { name: 'Tip'; params: { hash: H256; tipValue: bigint } }
  /**
   * Close and payout a tip.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * The tip identified by `hash` must have finished its countdown period.
   *
   * - `hash`: The identity of the open tip for which a tip value is declared. This is formed
   * as the hash of the tuple of the original tip `reason` and the beneficiary account ID.
   *
   * ## Complexity
   * - : `O(T)` where `T` is the number of tippers. decoding `Tipper` vec of length `T`. `T`
   * is charged as upper bound given by `ContainsLengthBound`. The actual cost depends on
   * the implementation of `T::Tippers`.
   **/
  | { name: 'CloseTip'; params: { hash: H256 } }
  /**
   * Remove and slash an already-open tip.
   *
   * May only be called from `T::RejectOrigin`.
   *
   * As a result, the finder is slashed and the deposits are lost.
   *
   * Emits `TipSlashed` if successful.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: 'SlashTip'; params: { hash: H256 } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletProxyCall =
  /**
   * Dispatch the given `call` from an account that the sender is authorised for through
   * `add_proxy`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
   * - `call`: The call to be made by the `real` account.
   **/
  | {
      name: 'Proxy';
      params: {
        real: AccountId32;
        forceProxyType?: HydradxRuntimeSystemProxyType | undefined;
        call: HydradxRuntimeRuntimeCall;
      };
    }
  /**
   * Register a proxy account for the sender that is able to make calls on its behalf.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `proxy`: The account that the `caller` would like to make a proxy.
   * - `proxy_type`: The permissions allowed for this proxy account.
   * - `delay`: The announcement period required of the initial proxy. Will generally be
   * zero.
   **/
  | { name: 'AddProxy'; params: { delegate: AccountId32; proxyType: HydradxRuntimeSystemProxyType; delay: number } }
  /**
   * Unregister a proxy account for the sender.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `proxy`: The account that the `caller` would like to remove as a proxy.
   * - `proxy_type`: The permissions currently enabled for the removed proxy account.
   **/
  | { name: 'RemoveProxy'; params: { delegate: AccountId32; proxyType: HydradxRuntimeSystemProxyType; delay: number } }
  /**
   * Unregister all proxy accounts for the sender.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * WARNING: This may be called on accounts created by `pure`, however if done, then
   * the unreserved fees will be inaccessible. **All access to this account will be lost.**
   **/
  | { name: 'RemoveProxies' }
  /**
   * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
   * initialize it with a proxy of `proxy_type` for `origin` sender.
   *
   * Requires a `Signed` origin.
   *
   * - `proxy_type`: The type of the proxy that the sender will be registered as over the
   * new account. This will almost always be the most permissive `ProxyType` possible to
   * allow for maximum flexibility.
   * - `index`: A disambiguation index, in case this is called multiple times in the same
   * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
   * want to use `0`.
   * - `delay`: The announcement period required of the initial proxy. Will generally be
   * zero.
   *
   * Fails with `Duplicate` if this has already been called in this transaction, from the
   * same sender, with the same parameters.
   *
   * Fails if there are insufficient funds to pay for deposit.
   **/
  | { name: 'CreatePure'; params: { proxyType: HydradxRuntimeSystemProxyType; delay: number; index: number } }
  /**
   * Removes a previously spawned pure proxy.
   *
   * WARNING: **All access to this account will be lost.** Any funds held in it will be
   * inaccessible.
   *
   * Requires a `Signed` origin, and the sender account must have been created by a call to
   * `pure` with corresponding parameters.
   *
   * - `spawner`: The account that originally called `pure` to create this account.
   * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
   * - `proxy_type`: The proxy type originally passed to `pure`.
   * - `height`: The height of the chain when the call to `pure` was processed.
   * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
   *
   * Fails with `NoPermission` in case the caller is not a previously created pure
   * account whose `pure` call has corresponding parameters.
   **/
  | {
      name: 'KillPure';
      params: {
        spawner: AccountId32;
        proxyType: HydradxRuntimeSystemProxyType;
        index: number;
        height: number;
        extIndex: number;
      };
    }
  /**
   * Publish the hash of a proxy-call that will be made in the future.
   *
   * This must be called some number of blocks before the corresponding `proxy` is attempted
   * if the delay associated with the proxy relationship is greater than zero.
   *
   * No more than `MaxPending` announcements may be made at any one time.
   *
   * This will take a deposit of `AnnouncementDepositFactor` as well as
   * `AnnouncementDepositBase` if there are no other pending announcements.
   *
   * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `call_hash`: The hash of the call to be made by the `real` account.
   **/
  | { name: 'Announce'; params: { real: AccountId32; callHash: H256 } }
  /**
   * Remove a given announcement.
   *
   * May be called by a proxy account to remove a call they previously announced and return
   * the deposit.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `call_hash`: The hash of the call to be made by the `real` account.
   **/
  | { name: 'RemoveAnnouncement'; params: { real: AccountId32; callHash: H256 } }
  /**
   * Remove the given announcement of a delegate.
   *
   * May be called by a target (proxied) account to remove a call that one of their delegates
   * (`delegate`) has announced they want to execute. The deposit is returned.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `delegate`: The account that previously announced the call.
   * - `call_hash`: The hash of the call to be made.
   **/
  | { name: 'RejectAnnouncement'; params: { delegate: AccountId32; callHash: H256 } }
  /**
   * Dispatch the given `call` from an account that the sender is authorized for through
   * `add_proxy`.
   *
   * Removes any corresponding announcement(s).
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
   * - `call`: The call to be made by the `real` account.
   **/
  | {
      name: 'ProxyAnnounced';
      params: {
        delegate: AccountId32;
        real: AccountId32;
        forceProxyType?: HydradxRuntimeSystemProxyType | undefined;
        call: HydradxRuntimeRuntimeCall;
      };
    };

export type PalletProxyCallLike =
  /**
   * Dispatch the given `call` from an account that the sender is authorised for through
   * `add_proxy`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
   * - `call`: The call to be made by the `real` account.
   **/
  | {
      name: 'Proxy';
      params: {
        real: AccountId32Like;
        forceProxyType?: HydradxRuntimeSystemProxyType | undefined;
        call: HydradxRuntimeRuntimeCallLike;
      };
    }
  /**
   * Register a proxy account for the sender that is able to make calls on its behalf.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `proxy`: The account that the `caller` would like to make a proxy.
   * - `proxy_type`: The permissions allowed for this proxy account.
   * - `delay`: The announcement period required of the initial proxy. Will generally be
   * zero.
   **/
  | { name: 'AddProxy'; params: { delegate: AccountId32Like; proxyType: HydradxRuntimeSystemProxyType; delay: number } }
  /**
   * Unregister a proxy account for the sender.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `proxy`: The account that the `caller` would like to remove as a proxy.
   * - `proxy_type`: The permissions currently enabled for the removed proxy account.
   **/
  | {
      name: 'RemoveProxy';
      params: { delegate: AccountId32Like; proxyType: HydradxRuntimeSystemProxyType; delay: number };
    }
  /**
   * Unregister all proxy accounts for the sender.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * WARNING: This may be called on accounts created by `pure`, however if done, then
   * the unreserved fees will be inaccessible. **All access to this account will be lost.**
   **/
  | { name: 'RemoveProxies' }
  /**
   * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
   * initialize it with a proxy of `proxy_type` for `origin` sender.
   *
   * Requires a `Signed` origin.
   *
   * - `proxy_type`: The type of the proxy that the sender will be registered as over the
   * new account. This will almost always be the most permissive `ProxyType` possible to
   * allow for maximum flexibility.
   * - `index`: A disambiguation index, in case this is called multiple times in the same
   * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
   * want to use `0`.
   * - `delay`: The announcement period required of the initial proxy. Will generally be
   * zero.
   *
   * Fails with `Duplicate` if this has already been called in this transaction, from the
   * same sender, with the same parameters.
   *
   * Fails if there are insufficient funds to pay for deposit.
   **/
  | { name: 'CreatePure'; params: { proxyType: HydradxRuntimeSystemProxyType; delay: number; index: number } }
  /**
   * Removes a previously spawned pure proxy.
   *
   * WARNING: **All access to this account will be lost.** Any funds held in it will be
   * inaccessible.
   *
   * Requires a `Signed` origin, and the sender account must have been created by a call to
   * `pure` with corresponding parameters.
   *
   * - `spawner`: The account that originally called `pure` to create this account.
   * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
   * - `proxy_type`: The proxy type originally passed to `pure`.
   * - `height`: The height of the chain when the call to `pure` was processed.
   * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
   *
   * Fails with `NoPermission` in case the caller is not a previously created pure
   * account whose `pure` call has corresponding parameters.
   **/
  | {
      name: 'KillPure';
      params: {
        spawner: AccountId32Like;
        proxyType: HydradxRuntimeSystemProxyType;
        index: number;
        height: number;
        extIndex: number;
      };
    }
  /**
   * Publish the hash of a proxy-call that will be made in the future.
   *
   * This must be called some number of blocks before the corresponding `proxy` is attempted
   * if the delay associated with the proxy relationship is greater than zero.
   *
   * No more than `MaxPending` announcements may be made at any one time.
   *
   * This will take a deposit of `AnnouncementDepositFactor` as well as
   * `AnnouncementDepositBase` if there are no other pending announcements.
   *
   * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `call_hash`: The hash of the call to be made by the `real` account.
   **/
  | { name: 'Announce'; params: { real: AccountId32Like; callHash: H256 } }
  /**
   * Remove a given announcement.
   *
   * May be called by a proxy account to remove a call they previously announced and return
   * the deposit.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `call_hash`: The hash of the call to be made by the `real` account.
   **/
  | { name: 'RemoveAnnouncement'; params: { real: AccountId32Like; callHash: H256 } }
  /**
   * Remove the given announcement of a delegate.
   *
   * May be called by a target (proxied) account to remove a call that one of their delegates
   * (`delegate`) has announced they want to execute. The deposit is returned.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `delegate`: The account that previously announced the call.
   * - `call_hash`: The hash of the call to be made.
   **/
  | { name: 'RejectAnnouncement'; params: { delegate: AccountId32Like; callHash: H256 } }
  /**
   * Dispatch the given `call` from an account that the sender is authorized for through
   * `add_proxy`.
   *
   * Removes any corresponding announcement(s).
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
   * - `call`: The call to be made by the `real` account.
   **/
  | {
      name: 'ProxyAnnounced';
      params: {
        delegate: AccountId32Like;
        real: AccountId32Like;
        forceProxyType?: HydradxRuntimeSystemProxyType | undefined;
        call: HydradxRuntimeRuntimeCallLike;
      };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMultisigCall =
  /**
   * Immediately dispatch a multi-signature call using a single approval from the caller.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `other_signatories`: The accounts (other than the sender) who are part of the
   * multi-signature, but do not participate in the approval process.
   * - `call`: The call to be executed.
   *
   * Result is equivalent to the dispatched result.
   *
   * ## Complexity
   * O(Z + C) where Z is the length of the call and C its execution weight.
   **/
  | { name: 'AsMultiThreshold1'; params: { otherSignatories: Array<AccountId32>; call: HydradxRuntimeRuntimeCall } }
  /**
   * Register approval for a dispatch to be made from a deterministic composite account if
   * approved by a total of `threshold - 1` of `other_signatories`.
   *
   * If there are enough, then dispatch the call.
   *
   * Payment: `DepositBase` will be reserved if this is the first approval, plus
   * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
   * is cancelled.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
   * not the first approval, then it must be `Some`, with the timepoint (block number and
   * transaction index) of the first approval transaction.
   * - `call`: The call to be executed.
   *
   * NOTE: Unless this is the final approval, you will generally want to use
   * `approve_as_multi` instead, since it only requires a hash of the call.
   *
   * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
   * on success, result is `Ok` and the result from the interior call, if it was executed,
   * may be found in the deposited `MultisigExecuted` event.
   *
   * ## Complexity
   * - `O(S + Z + Call)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
   * - One encode & hash, both of complexity `O(S)`.
   * - Up to one binary search and insert (`O(logS + S)`).
   * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
   * - One event.
   * - The weight of the `call`.
   * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
   * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
   **/
  | {
      name: 'AsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        call: HydradxRuntimeRuntimeCall;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Register approval for a dispatch to be made from a deterministic composite account if
   * approved by a total of `threshold - 1` of `other_signatories`.
   *
   * Payment: `DepositBase` will be reserved if this is the first approval, plus
   * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
   * is cancelled.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
   * not the first approval, then it must be `Some`, with the timepoint (block number and
   * transaction index) of the first approval transaction.
   * - `call_hash`: The hash of the call to be executed.
   *
   * NOTE: If this is the final approval, you will want to use `as_multi` instead.
   *
   * ## Complexity
   * - `O(S)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One encode & hash, both of complexity `O(S)`.
   * - Up to one binary search and insert (`O(logS + S)`).
   * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
   * - One event.
   * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
   * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
   **/
  | {
      name: 'ApproveAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        callHash: FixedBytes<32>;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
   * for this operation will be unreserved on success.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `timepoint`: The timepoint (block number and transaction index) of the first approval
   * transaction for this dispatch.
   * - `call_hash`: The hash of the call to be executed.
   *
   * ## Complexity
   * - `O(S)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One encode & hash, both of complexity `O(S)`.
   * - One event.
   * - I/O: 1 read `O(S)`, one remove.
   * - Storage: removes one item.
   **/
  | {
      name: 'CancelAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        timepoint: PalletMultisigTimepoint;
        callHash: FixedBytes<32>;
      };
    };

export type PalletMultisigCallLike =
  /**
   * Immediately dispatch a multi-signature call using a single approval from the caller.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `other_signatories`: The accounts (other than the sender) who are part of the
   * multi-signature, but do not participate in the approval process.
   * - `call`: The call to be executed.
   *
   * Result is equivalent to the dispatched result.
   *
   * ## Complexity
   * O(Z + C) where Z is the length of the call and C its execution weight.
   **/
  | {
      name: 'AsMultiThreshold1';
      params: { otherSignatories: Array<AccountId32Like>; call: HydradxRuntimeRuntimeCallLike };
    }
  /**
   * Register approval for a dispatch to be made from a deterministic composite account if
   * approved by a total of `threshold - 1` of `other_signatories`.
   *
   * If there are enough, then dispatch the call.
   *
   * Payment: `DepositBase` will be reserved if this is the first approval, plus
   * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
   * is cancelled.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
   * not the first approval, then it must be `Some`, with the timepoint (block number and
   * transaction index) of the first approval transaction.
   * - `call`: The call to be executed.
   *
   * NOTE: Unless this is the final approval, you will generally want to use
   * `approve_as_multi` instead, since it only requires a hash of the call.
   *
   * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
   * on success, result is `Ok` and the result from the interior call, if it was executed,
   * may be found in the deposited `MultisigExecuted` event.
   *
   * ## Complexity
   * - `O(S + Z + Call)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
   * - One encode & hash, both of complexity `O(S)`.
   * - Up to one binary search and insert (`O(logS + S)`).
   * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
   * - One event.
   * - The weight of the `call`.
   * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
   * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
   **/
  | {
      name: 'AsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        call: HydradxRuntimeRuntimeCallLike;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Register approval for a dispatch to be made from a deterministic composite account if
   * approved by a total of `threshold - 1` of `other_signatories`.
   *
   * Payment: `DepositBase` will be reserved if this is the first approval, plus
   * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
   * is cancelled.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
   * not the first approval, then it must be `Some`, with the timepoint (block number and
   * transaction index) of the first approval transaction.
   * - `call_hash`: The hash of the call to be executed.
   *
   * NOTE: If this is the final approval, you will want to use `as_multi` instead.
   *
   * ## Complexity
   * - `O(S)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One encode & hash, both of complexity `O(S)`.
   * - Up to one binary search and insert (`O(logS + S)`).
   * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
   * - One event.
   * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
   * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
   **/
  | {
      name: 'ApproveAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        callHash: FixedBytes<32>;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
   * for this operation will be unreserved on success.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `timepoint`: The timepoint (block number and transaction index) of the first approval
   * transaction for this dispatch.
   * - `call_hash`: The hash of the call to be executed.
   *
   * ## Complexity
   * - `O(S)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One encode & hash, both of complexity `O(S)`.
   * - One event.
   * - I/O: 1 read `O(S)`, one remove.
   * - Storage: removes one item.
   **/
  | {
      name: 'CancelAsMulti';
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        timepoint: PalletMultisigTimepoint;
        callHash: FixedBytes<32>;
      };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletUniquesCall =
  /**
   * Issue a new collection of non-fungible items from a public origin.
   *
   * This new collection has no items initially and its owner is the origin.
   *
   * The origin must conform to the configured `CreateOrigin` and have sufficient funds free.
   *
   * `ItemDeposit` funds of sender are reserved.
   *
   * Parameters:
   * - `collection`: The identifier of the new collection. This must not be currently in use.
   * - `admin`: The admin of this collection. The admin is the initial address of each
   * member of the collection's admin team.
   *
   * Emits `Created` event when successful.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Create'; params: { collection: bigint; admin: AccountId32 } }
  /**
   * Issue a new collection of non-fungible items from a privileged origin.
   *
   * This new collection has no items initially.
   *
   * The origin must conform to `ForceOrigin`.
   *
   * Unlike `create`, no funds are reserved.
   *
   * - `collection`: The identifier of the new item. This must not be currently in use.
   * - `owner`: The owner of this collection of items. The owner has full superuser
   * permissions
   * over this item, but may later change and configure the permissions using
   * `transfer_ownership` and `set_team`.
   *
   * Emits `ForceCreated` event when successful.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ForceCreate'; params: { collection: bigint; owner: AccountId32; freeHolding: boolean } }
  /**
   * Destroy a collection of fungible items.
   *
   * The origin must conform to `ForceOrigin` or must be `Signed` and the sender must be the
   * owner of the `collection`.
   *
   * - `collection`: The identifier of the collection to be destroyed.
   * - `witness`: Information on the items minted in the collection. This must be
   * correct.
   *
   * Emits `Destroyed` event when successful.
   *
   * Weight: `O(n + m)` where:
   * - `n = witness.items`
   * - `m = witness.item_metadatas`
   * - `a = witness.attributes`
   **/
  | { name: 'Destroy'; params: { collection: bigint; witness: PalletUniquesDestroyWitness } }
  /**
   * Mint an item of a particular collection.
   *
   * The origin must be Signed and the sender must be the Issuer of the `collection`.
   *
   * - `collection`: The collection of the item to be minted.
   * - `item`: The item value of the item to be minted.
   * - `beneficiary`: The initial owner of the minted item.
   *
   * Emits `Issued` event when successful.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Mint'; params: { collection: bigint; item: bigint; owner: AccountId32 } }
  /**
   * Destroy a single item.
   *
   * Origin must be Signed and the signing account must be either:
   * - the Admin of the `collection`;
   * - the Owner of the `item`;
   *
   * - `collection`: The collection of the item to be burned.
   * - `item`: The item of the item to be burned.
   * - `check_owner`: If `Some` then the operation will fail with `WrongOwner` unless the
   * item is owned by this value.
   *
   * Emits `Burned` with the actual amount burned.
   *
   * Weight: `O(1)`
   * Modes: `check_owner.is_some()`.
   **/
  | { name: 'Burn'; params: { collection: bigint; item: bigint; checkOwner?: AccountId32 | undefined } }
  /**
   * Move an item from the sender account to another.
   *
   * This resets the approved account of the item.
   *
   * Origin must be Signed and the signing account must be either:
   * - the Admin of the `collection`;
   * - the Owner of the `item`;
   * - the approved delegate for the `item` (in this case, the approval is reset).
   *
   * Arguments:
   * - `collection`: The collection of the item to be transferred.
   * - `item`: The item of the item to be transferred.
   * - `dest`: The account to receive ownership of the item.
   *
   * Emits `Transferred`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Transfer'; params: { collection: bigint; item: bigint; dest: AccountId32 } }
  /**
   * Reevaluate the deposits on some items.
   *
   * Origin must be Signed and the sender should be the Owner of the `collection`.
   *
   * - `collection`: The collection to be frozen.
   * - `items`: The items of the collection whose deposits will be reevaluated.
   *
   * NOTE: This exists as a best-effort function. Any items which are unknown or
   * in the case that the owner account does not have reservable funds to pay for a
   * deposit increase are ignored. Generally the owner isn't going to call this on items
   * whose existing deposit is less than the refreshed deposit as it would only cost them,
   * so it's of little consequence.
   *
   * It will still return an error in the case that the collection is unknown of the signer
   * is not permitted to call it.
   *
   * Weight: `O(items.len())`
   **/
  | { name: 'Redeposit'; params: { collection: bigint; items: Array<bigint> } }
  /**
   * Disallow further unprivileged transfer of an item.
   *
   * Origin must be Signed and the sender should be the Freezer of the `collection`.
   *
   * - `collection`: The collection of the item to be frozen.
   * - `item`: The item of the item to be frozen.
   *
   * Emits `Frozen`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Freeze'; params: { collection: bigint; item: bigint } }
  /**
   * Re-allow unprivileged transfer of an item.
   *
   * Origin must be Signed and the sender should be the Freezer of the `collection`.
   *
   * - `collection`: The collection of the item to be thawed.
   * - `item`: The item of the item to be thawed.
   *
   * Emits `Thawed`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Thaw'; params: { collection: bigint; item: bigint } }
  /**
   * Disallow further unprivileged transfers for a whole collection.
   *
   * Origin must be Signed and the sender should be the Freezer of the `collection`.
   *
   * - `collection`: The collection to be frozen.
   *
   * Emits `CollectionFrozen`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'FreezeCollection'; params: { collection: bigint } }
  /**
   * Re-allow unprivileged transfers for a whole collection.
   *
   * Origin must be Signed and the sender should be the Admin of the `collection`.
   *
   * - `collection`: The collection to be thawed.
   *
   * Emits `CollectionThawed`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ThawCollection'; params: { collection: bigint } }
  /**
   * Change the Owner of a collection.
   *
   * Origin must be Signed and the sender should be the Owner of the `collection`.
   *
   * - `collection`: The collection whose owner should be changed.
   * - `owner`: The new Owner of this collection. They must have called
   * `set_accept_ownership` with `collection` in order for this operation to succeed.
   *
   * Emits `OwnerChanged`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'TransferOwnership'; params: { collection: bigint; newOwner: AccountId32 } }
  /**
   * Change the Issuer, Admin and Freezer of a collection.
   *
   * Origin must be Signed and the sender should be the Owner of the `collection`.
   *
   * - `collection`: The collection whose team should be changed.
   * - `issuer`: The new Issuer of this collection.
   * - `admin`: The new Admin of this collection.
   * - `freezer`: The new Freezer of this collection.
   *
   * Emits `TeamChanged`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'SetTeam'; params: { collection: bigint; issuer: AccountId32; admin: AccountId32; freezer: AccountId32 } }
  /**
   * Approve an item to be transferred by a delegated third-party account.
   *
   * The origin must conform to `ForceOrigin` or must be `Signed` and the sender must be
   * either the owner of the `item` or the admin of the collection.
   *
   * - `collection`: The collection of the item to be approved for delegated transfer.
   * - `item`: The item of the item to be approved for delegated transfer.
   * - `delegate`: The account to delegate permission to transfer the item.
   *
   * Important NOTE: The `approved` account gets reset after each transfer.
   *
   * Emits `ApprovedTransfer` on success.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ApproveTransfer'; params: { collection: bigint; item: bigint; delegate: AccountId32 } }
  /**
   * Cancel the prior approval for the transfer of an item by a delegate.
   *
   * Origin must be either:
   * - the `Force` origin;
   * - `Signed` with the signer being the Admin of the `collection`;
   * - `Signed` with the signer being the Owner of the `item`;
   *
   * Arguments:
   * - `collection`: The collection of the item of whose approval will be cancelled.
   * - `item`: The item of the item of whose approval will be cancelled.
   * - `maybe_check_delegate`: If `Some` will ensure that the given account is the one to
   * which permission of transfer is delegated.
   *
   * Emits `ApprovalCancelled` on success.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'CancelApproval';
      params: { collection: bigint; item: bigint; maybeCheckDelegate?: AccountId32 | undefined };
    }
  /**
   * Alter the attributes of a given item.
   *
   * Origin must be `ForceOrigin`.
   *
   * - `collection`: The identifier of the item.
   * - `owner`: The new Owner of this item.
   * - `issuer`: The new Issuer of this item.
   * - `admin`: The new Admin of this item.
   * - `freezer`: The new Freezer of this item.
   * - `free_holding`: Whether a deposit is taken for holding an item of this collection.
   * - `is_frozen`: Whether this collection is frozen except for permissioned/admin
   * instructions.
   *
   * Emits `ItemStatusChanged` with the identity of the item.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'ForceItemStatus';
      params: {
        collection: bigint;
        owner: AccountId32;
        issuer: AccountId32;
        admin: AccountId32;
        freezer: AccountId32;
        freeHolding: boolean;
        isFrozen: boolean;
      };
    }
  /**
   * Set an attribute for a collection or item.
   *
   * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
   * `collection`.
   *
   * If the origin is Signed, then funds of signer are reserved according to the formula:
   * `MetadataDepositBase + DepositPerByte * (key.len + value.len)` taking into
   * account any already reserved funds.
   *
   * - `collection`: The identifier of the collection whose item's metadata to set.
   * - `maybe_item`: The identifier of the item whose metadata to set.
   * - `key`: The key of the attribute.
   * - `value`: The value to which to set the attribute.
   *
   * Emits `AttributeSet`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'SetAttribute'; params: { collection: bigint; maybeItem?: bigint | undefined; key: Bytes; value: Bytes } }
  /**
   * Clear an attribute for a collection or item.
   *
   * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
   * `collection`.
   *
   * Any deposit is freed for the collection's owner.
   *
   * - `collection`: The identifier of the collection whose item's metadata to clear.
   * - `maybe_item`: The identifier of the item whose metadata to clear.
   * - `key`: The key of the attribute.
   *
   * Emits `AttributeCleared`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ClearAttribute'; params: { collection: bigint; maybeItem?: bigint | undefined; key: Bytes } }
  /**
   * Set the metadata for an item.
   *
   * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
   * `collection`.
   *
   * If the origin is Signed, then funds of signer are reserved according to the formula:
   * `MetadataDepositBase + DepositPerByte * data.len` taking into
   * account any already reserved funds.
   *
   * - `collection`: The identifier of the collection whose item's metadata to set.
   * - `item`: The identifier of the item whose metadata to set.
   * - `data`: The general information of this item. Limited in length by `StringLimit`.
   * - `is_frozen`: Whether the metadata should be frozen against further changes.
   *
   * Emits `MetadataSet`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'SetMetadata'; params: { collection: bigint; item: bigint; data: Bytes; isFrozen: boolean } }
  /**
   * Clear the metadata for an item.
   *
   * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
   * `item`.
   *
   * Any deposit is freed for the collection's owner.
   *
   * - `collection`: The identifier of the collection whose item's metadata to clear.
   * - `item`: The identifier of the item whose metadata to clear.
   *
   * Emits `MetadataCleared`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ClearMetadata'; params: { collection: bigint; item: bigint } }
  /**
   * Set the metadata for a collection.
   *
   * Origin must be either `ForceOrigin` or `Signed` and the sender should be the Owner of
   * the `collection`.
   *
   * If the origin is `Signed`, then funds of signer are reserved according to the formula:
   * `MetadataDepositBase + DepositPerByte * data.len` taking into
   * account any already reserved funds.
   *
   * - `collection`: The identifier of the item whose metadata to update.
   * - `data`: The general information of this item. Limited in length by `StringLimit`.
   * - `is_frozen`: Whether the metadata should be frozen against further changes.
   *
   * Emits `CollectionMetadataSet`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'SetCollectionMetadata'; params: { collection: bigint; data: Bytes; isFrozen: boolean } }
  /**
   * Clear the metadata for a collection.
   *
   * Origin must be either `ForceOrigin` or `Signed` and the sender should be the Owner of
   * the `collection`.
   *
   * Any deposit is freed for the collection's owner.
   *
   * - `collection`: The identifier of the collection whose metadata to clear.
   *
   * Emits `CollectionMetadataCleared`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ClearCollectionMetadata'; params: { collection: bigint } }
  /**
   * Set (or reset) the acceptance of ownership for a particular account.
   *
   * Origin must be `Signed` and if `maybe_collection` is `Some`, then the signer must have a
   * provider reference.
   *
   * - `maybe_collection`: The identifier of the collection whose ownership the signer is
   * willing to accept, or if `None`, an indication that the signer is willing to accept no
   * ownership transferal.
   *
   * Emits `OwnershipAcceptanceChanged`.
   **/
  | { name: 'SetAcceptOwnership'; params: { maybeCollection?: bigint | undefined } }
  /**
   * Set the maximum amount of items a collection could have.
   *
   * Origin must be either `ForceOrigin` or `Signed` and the sender should be the Owner of
   * the `collection`.
   *
   * Note: This function can only succeed once per collection.
   *
   * - `collection`: The identifier of the collection to change.
   * - `max_supply`: The maximum amount of items a collection could have.
   *
   * Emits `CollectionMaxSupplySet` event when successful.
   **/
  | { name: 'SetCollectionMaxSupply'; params: { collection: bigint; maxSupply: number } }
  /**
   * Set (or reset) the price for an item.
   *
   * Origin must be Signed and must be the owner of the asset `item`.
   *
   * - `collection`: The collection of the item.
   * - `item`: The item to set the price for.
   * - `price`: The price for the item. Pass `None`, to reset the price.
   * - `buyer`: Restricts the buy operation to a specific account.
   *
   * Emits `ItemPriceSet` on success if the price is not `None`.
   * Emits `ItemPriceRemoved` on success if the price is `None`.
   **/
  | {
      name: 'SetPrice';
      params: {
        collection: bigint;
        item: bigint;
        price?: bigint | undefined;
        whitelistedBuyer?: AccountId32 | undefined;
      };
    }
  /**
   * Allows to buy an item if it's up for sale.
   *
   * Origin must be Signed and must not be the owner of the `item`.
   *
   * - `collection`: The collection of the item.
   * - `item`: The item the sender wants to buy.
   * - `bid_price`: The price the sender is willing to pay.
   *
   * Emits `ItemBought` on success.
   **/
  | { name: 'BuyItem'; params: { collection: bigint; item: bigint; bidPrice: bigint } };

export type PalletUniquesCallLike =
  /**
   * Issue a new collection of non-fungible items from a public origin.
   *
   * This new collection has no items initially and its owner is the origin.
   *
   * The origin must conform to the configured `CreateOrigin` and have sufficient funds free.
   *
   * `ItemDeposit` funds of sender are reserved.
   *
   * Parameters:
   * - `collection`: The identifier of the new collection. This must not be currently in use.
   * - `admin`: The admin of this collection. The admin is the initial address of each
   * member of the collection's admin team.
   *
   * Emits `Created` event when successful.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Create'; params: { collection: bigint; admin: AccountId32Like } }
  /**
   * Issue a new collection of non-fungible items from a privileged origin.
   *
   * This new collection has no items initially.
   *
   * The origin must conform to `ForceOrigin`.
   *
   * Unlike `create`, no funds are reserved.
   *
   * - `collection`: The identifier of the new item. This must not be currently in use.
   * - `owner`: The owner of this collection of items. The owner has full superuser
   * permissions
   * over this item, but may later change and configure the permissions using
   * `transfer_ownership` and `set_team`.
   *
   * Emits `ForceCreated` event when successful.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ForceCreate'; params: { collection: bigint; owner: AccountId32Like; freeHolding: boolean } }
  /**
   * Destroy a collection of fungible items.
   *
   * The origin must conform to `ForceOrigin` or must be `Signed` and the sender must be the
   * owner of the `collection`.
   *
   * - `collection`: The identifier of the collection to be destroyed.
   * - `witness`: Information on the items minted in the collection. This must be
   * correct.
   *
   * Emits `Destroyed` event when successful.
   *
   * Weight: `O(n + m)` where:
   * - `n = witness.items`
   * - `m = witness.item_metadatas`
   * - `a = witness.attributes`
   **/
  | { name: 'Destroy'; params: { collection: bigint; witness: PalletUniquesDestroyWitness } }
  /**
   * Mint an item of a particular collection.
   *
   * The origin must be Signed and the sender must be the Issuer of the `collection`.
   *
   * - `collection`: The collection of the item to be minted.
   * - `item`: The item value of the item to be minted.
   * - `beneficiary`: The initial owner of the minted item.
   *
   * Emits `Issued` event when successful.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Mint'; params: { collection: bigint; item: bigint; owner: AccountId32Like } }
  /**
   * Destroy a single item.
   *
   * Origin must be Signed and the signing account must be either:
   * - the Admin of the `collection`;
   * - the Owner of the `item`;
   *
   * - `collection`: The collection of the item to be burned.
   * - `item`: The item of the item to be burned.
   * - `check_owner`: If `Some` then the operation will fail with `WrongOwner` unless the
   * item is owned by this value.
   *
   * Emits `Burned` with the actual amount burned.
   *
   * Weight: `O(1)`
   * Modes: `check_owner.is_some()`.
   **/
  | { name: 'Burn'; params: { collection: bigint; item: bigint; checkOwner?: AccountId32Like | undefined } }
  /**
   * Move an item from the sender account to another.
   *
   * This resets the approved account of the item.
   *
   * Origin must be Signed and the signing account must be either:
   * - the Admin of the `collection`;
   * - the Owner of the `item`;
   * - the approved delegate for the `item` (in this case, the approval is reset).
   *
   * Arguments:
   * - `collection`: The collection of the item to be transferred.
   * - `item`: The item of the item to be transferred.
   * - `dest`: The account to receive ownership of the item.
   *
   * Emits `Transferred`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Transfer'; params: { collection: bigint; item: bigint; dest: AccountId32Like } }
  /**
   * Reevaluate the deposits on some items.
   *
   * Origin must be Signed and the sender should be the Owner of the `collection`.
   *
   * - `collection`: The collection to be frozen.
   * - `items`: The items of the collection whose deposits will be reevaluated.
   *
   * NOTE: This exists as a best-effort function. Any items which are unknown or
   * in the case that the owner account does not have reservable funds to pay for a
   * deposit increase are ignored. Generally the owner isn't going to call this on items
   * whose existing deposit is less than the refreshed deposit as it would only cost them,
   * so it's of little consequence.
   *
   * It will still return an error in the case that the collection is unknown of the signer
   * is not permitted to call it.
   *
   * Weight: `O(items.len())`
   **/
  | { name: 'Redeposit'; params: { collection: bigint; items: Array<bigint> } }
  /**
   * Disallow further unprivileged transfer of an item.
   *
   * Origin must be Signed and the sender should be the Freezer of the `collection`.
   *
   * - `collection`: The collection of the item to be frozen.
   * - `item`: The item of the item to be frozen.
   *
   * Emits `Frozen`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Freeze'; params: { collection: bigint; item: bigint } }
  /**
   * Re-allow unprivileged transfer of an item.
   *
   * Origin must be Signed and the sender should be the Freezer of the `collection`.
   *
   * - `collection`: The collection of the item to be thawed.
   * - `item`: The item of the item to be thawed.
   *
   * Emits `Thawed`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'Thaw'; params: { collection: bigint; item: bigint } }
  /**
   * Disallow further unprivileged transfers for a whole collection.
   *
   * Origin must be Signed and the sender should be the Freezer of the `collection`.
   *
   * - `collection`: The collection to be frozen.
   *
   * Emits `CollectionFrozen`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'FreezeCollection'; params: { collection: bigint } }
  /**
   * Re-allow unprivileged transfers for a whole collection.
   *
   * Origin must be Signed and the sender should be the Admin of the `collection`.
   *
   * - `collection`: The collection to be thawed.
   *
   * Emits `CollectionThawed`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ThawCollection'; params: { collection: bigint } }
  /**
   * Change the Owner of a collection.
   *
   * Origin must be Signed and the sender should be the Owner of the `collection`.
   *
   * - `collection`: The collection whose owner should be changed.
   * - `owner`: The new Owner of this collection. They must have called
   * `set_accept_ownership` with `collection` in order for this operation to succeed.
   *
   * Emits `OwnerChanged`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'TransferOwnership'; params: { collection: bigint; newOwner: AccountId32Like } }
  /**
   * Change the Issuer, Admin and Freezer of a collection.
   *
   * Origin must be Signed and the sender should be the Owner of the `collection`.
   *
   * - `collection`: The collection whose team should be changed.
   * - `issuer`: The new Issuer of this collection.
   * - `admin`: The new Admin of this collection.
   * - `freezer`: The new Freezer of this collection.
   *
   * Emits `TeamChanged`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'SetTeam';
      params: { collection: bigint; issuer: AccountId32Like; admin: AccountId32Like; freezer: AccountId32Like };
    }
  /**
   * Approve an item to be transferred by a delegated third-party account.
   *
   * The origin must conform to `ForceOrigin` or must be `Signed` and the sender must be
   * either the owner of the `item` or the admin of the collection.
   *
   * - `collection`: The collection of the item to be approved for delegated transfer.
   * - `item`: The item of the item to be approved for delegated transfer.
   * - `delegate`: The account to delegate permission to transfer the item.
   *
   * Important NOTE: The `approved` account gets reset after each transfer.
   *
   * Emits `ApprovedTransfer` on success.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ApproveTransfer'; params: { collection: bigint; item: bigint; delegate: AccountId32Like } }
  /**
   * Cancel the prior approval for the transfer of an item by a delegate.
   *
   * Origin must be either:
   * - the `Force` origin;
   * - `Signed` with the signer being the Admin of the `collection`;
   * - `Signed` with the signer being the Owner of the `item`;
   *
   * Arguments:
   * - `collection`: The collection of the item of whose approval will be cancelled.
   * - `item`: The item of the item of whose approval will be cancelled.
   * - `maybe_check_delegate`: If `Some` will ensure that the given account is the one to
   * which permission of transfer is delegated.
   *
   * Emits `ApprovalCancelled` on success.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'CancelApproval';
      params: { collection: bigint; item: bigint; maybeCheckDelegate?: AccountId32Like | undefined };
    }
  /**
   * Alter the attributes of a given item.
   *
   * Origin must be `ForceOrigin`.
   *
   * - `collection`: The identifier of the item.
   * - `owner`: The new Owner of this item.
   * - `issuer`: The new Issuer of this item.
   * - `admin`: The new Admin of this item.
   * - `freezer`: The new Freezer of this item.
   * - `free_holding`: Whether a deposit is taken for holding an item of this collection.
   * - `is_frozen`: Whether this collection is frozen except for permissioned/admin
   * instructions.
   *
   * Emits `ItemStatusChanged` with the identity of the item.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'ForceItemStatus';
      params: {
        collection: bigint;
        owner: AccountId32Like;
        issuer: AccountId32Like;
        admin: AccountId32Like;
        freezer: AccountId32Like;
        freeHolding: boolean;
        isFrozen: boolean;
      };
    }
  /**
   * Set an attribute for a collection or item.
   *
   * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
   * `collection`.
   *
   * If the origin is Signed, then funds of signer are reserved according to the formula:
   * `MetadataDepositBase + DepositPerByte * (key.len + value.len)` taking into
   * account any already reserved funds.
   *
   * - `collection`: The identifier of the collection whose item's metadata to set.
   * - `maybe_item`: The identifier of the item whose metadata to set.
   * - `key`: The key of the attribute.
   * - `value`: The value to which to set the attribute.
   *
   * Emits `AttributeSet`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: 'SetAttribute';
      params: { collection: bigint; maybeItem?: bigint | undefined; key: BytesLike; value: BytesLike };
    }
  /**
   * Clear an attribute for a collection or item.
   *
   * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
   * `collection`.
   *
   * Any deposit is freed for the collection's owner.
   *
   * - `collection`: The identifier of the collection whose item's metadata to clear.
   * - `maybe_item`: The identifier of the item whose metadata to clear.
   * - `key`: The key of the attribute.
   *
   * Emits `AttributeCleared`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ClearAttribute'; params: { collection: bigint; maybeItem?: bigint | undefined; key: BytesLike } }
  /**
   * Set the metadata for an item.
   *
   * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
   * `collection`.
   *
   * If the origin is Signed, then funds of signer are reserved according to the formula:
   * `MetadataDepositBase + DepositPerByte * data.len` taking into
   * account any already reserved funds.
   *
   * - `collection`: The identifier of the collection whose item's metadata to set.
   * - `item`: The identifier of the item whose metadata to set.
   * - `data`: The general information of this item. Limited in length by `StringLimit`.
   * - `is_frozen`: Whether the metadata should be frozen against further changes.
   *
   * Emits `MetadataSet`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'SetMetadata'; params: { collection: bigint; item: bigint; data: BytesLike; isFrozen: boolean } }
  /**
   * Clear the metadata for an item.
   *
   * Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the
   * `item`.
   *
   * Any deposit is freed for the collection's owner.
   *
   * - `collection`: The identifier of the collection whose item's metadata to clear.
   * - `item`: The identifier of the item whose metadata to clear.
   *
   * Emits `MetadataCleared`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ClearMetadata'; params: { collection: bigint; item: bigint } }
  /**
   * Set the metadata for a collection.
   *
   * Origin must be either `ForceOrigin` or `Signed` and the sender should be the Owner of
   * the `collection`.
   *
   * If the origin is `Signed`, then funds of signer are reserved according to the formula:
   * `MetadataDepositBase + DepositPerByte * data.len` taking into
   * account any already reserved funds.
   *
   * - `collection`: The identifier of the item whose metadata to update.
   * - `data`: The general information of this item. Limited in length by `StringLimit`.
   * - `is_frozen`: Whether the metadata should be frozen against further changes.
   *
   * Emits `CollectionMetadataSet`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'SetCollectionMetadata'; params: { collection: bigint; data: BytesLike; isFrozen: boolean } }
  /**
   * Clear the metadata for a collection.
   *
   * Origin must be either `ForceOrigin` or `Signed` and the sender should be the Owner of
   * the `collection`.
   *
   * Any deposit is freed for the collection's owner.
   *
   * - `collection`: The identifier of the collection whose metadata to clear.
   *
   * Emits `CollectionMetadataCleared`.
   *
   * Weight: `O(1)`
   **/
  | { name: 'ClearCollectionMetadata'; params: { collection: bigint } }
  /**
   * Set (or reset) the acceptance of ownership for a particular account.
   *
   * Origin must be `Signed` and if `maybe_collection` is `Some`, then the signer must have a
   * provider reference.
   *
   * - `maybe_collection`: The identifier of the collection whose ownership the signer is
   * willing to accept, or if `None`, an indication that the signer is willing to accept no
   * ownership transferal.
   *
   * Emits `OwnershipAcceptanceChanged`.
   **/
  | { name: 'SetAcceptOwnership'; params: { maybeCollection?: bigint | undefined } }
  /**
   * Set the maximum amount of items a collection could have.
   *
   * Origin must be either `ForceOrigin` or `Signed` and the sender should be the Owner of
   * the `collection`.
   *
   * Note: This function can only succeed once per collection.
   *
   * - `collection`: The identifier of the collection to change.
   * - `max_supply`: The maximum amount of items a collection could have.
   *
   * Emits `CollectionMaxSupplySet` event when successful.
   **/
  | { name: 'SetCollectionMaxSupply'; params: { collection: bigint; maxSupply: number } }
  /**
   * Set (or reset) the price for an item.
   *
   * Origin must be Signed and must be the owner of the asset `item`.
   *
   * - `collection`: The collection of the item.
   * - `item`: The item to set the price for.
   * - `price`: The price for the item. Pass `None`, to reset the price.
   * - `buyer`: Restricts the buy operation to a specific account.
   *
   * Emits `ItemPriceSet` on success if the price is not `None`.
   * Emits `ItemPriceRemoved` on success if the price is `None`.
   **/
  | {
      name: 'SetPrice';
      params: {
        collection: bigint;
        item: bigint;
        price?: bigint | undefined;
        whitelistedBuyer?: AccountId32Like | undefined;
      };
    }
  /**
   * Allows to buy an item if it's up for sale.
   *
   * Origin must be Signed and must not be the owner of the `item`.
   *
   * - `collection`: The collection of the item.
   * - `item`: The item the sender wants to buy.
   * - `bid_price`: The price the sender is willing to pay.
   *
   * Emits `ItemBought` on success.
   **/
  | { name: 'BuyItem'; params: { collection: bigint; item: bigint; bidPrice: bigint } };

export type PalletUniquesDestroyWitness = { items: number; itemMetadatas: number; attributes: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletStateTrieMigrationCall =
  /**
   * Control the automatic migration.
   *
   * The dispatch origin of this call must be [`Config::ControlOrigin`].
   **/
  | { name: 'ControlAutoMigration'; params: { maybeConfig?: PalletStateTrieMigrationMigrationLimits | undefined } }
  /**
   * Continue the migration for the given `limits`.
   *
   * The dispatch origin of this call can be any signed account.
   *
   * This transaction has NO MONETARY INCENTIVES. calling it will not reward anyone. Albeit,
   * Upon successful execution, the transaction fee is returned.
   *
   * The (potentially over-estimated) of the byte length of all the data read must be
   * provided for up-front fee-payment and weighing. In essence, the caller is guaranteeing
   * that executing the current `MigrationTask` with the given `limits` will not exceed
   * `real_size_upper` bytes of read data.
   *
   * The `witness_task` is merely a helper to prevent the caller from being slashed or
   * generally trigger a migration that they do not intend. This parameter is just a message
   * from caller, saying that they believed `witness_task` was the last state of the
   * migration, and they only wish for their transaction to do anything, if this assumption
   * holds. In case `witness_task` does not match, the transaction fails.
   *
   * Based on the documentation of [`MigrationTask::migrate_until_exhaustion`], the
   * recommended way of doing this is to pass a `limit` that only bounds `count`, as the
   * `size` limit can always be overwritten.
   **/
  | {
      name: 'ContinueMigrate';
      params: {
        limits: PalletStateTrieMigrationMigrationLimits;
        realSizeUpper: number;
        witnessTask: PalletStateTrieMigrationMigrationTask;
      };
    }
  /**
   * Migrate the list of top keys by iterating each of them one by one.
   *
   * This does not affect the global migration process tracker ([`MigrationProcess`]), and
   * should only be used in case any keys are leftover due to a bug.
   **/
  | { name: 'MigrateCustomTop'; params: { keys: Array<Bytes>; witnessSize: number } }
  /**
   * Migrate the list of child keys by iterating each of them one by one.
   *
   * All of the given child keys must be present under one `child_root`.
   *
   * This does not affect the global migration process tracker ([`MigrationProcess`]), and
   * should only be used in case any keys are leftover due to a bug.
   **/
  | { name: 'MigrateCustomChild'; params: { root: Bytes; childKeys: Array<Bytes>; totalSize: number } }
  /**
   * Set the maximum limit of the signed migration.
   **/
  | { name: 'SetSignedMaxLimits'; params: { limits: PalletStateTrieMigrationMigrationLimits } }
  /**
   * Forcefully set the progress the running migration.
   *
   * This is only useful in one case: the next key to migrate is too big to be migrated with
   * a signed account, in a parachain context, and we simply want to skip it. A reasonable
   * example of this would be `:code:`, which is both very expensive to migrate, and commonly
   * used, so probably it is already migrated.
   *
   * In case you mess things up, you can also, in principle, use this to reset the migration
   * process.
   **/
  | {
      name: 'ForceSetProgress';
      params: { progressTop: PalletStateTrieMigrationProgress; progressChild: PalletStateTrieMigrationProgress };
    };

export type PalletStateTrieMigrationCallLike =
  /**
   * Control the automatic migration.
   *
   * The dispatch origin of this call must be [`Config::ControlOrigin`].
   **/
  | { name: 'ControlAutoMigration'; params: { maybeConfig?: PalletStateTrieMigrationMigrationLimits | undefined } }
  /**
   * Continue the migration for the given `limits`.
   *
   * The dispatch origin of this call can be any signed account.
   *
   * This transaction has NO MONETARY INCENTIVES. calling it will not reward anyone. Albeit,
   * Upon successful execution, the transaction fee is returned.
   *
   * The (potentially over-estimated) of the byte length of all the data read must be
   * provided for up-front fee-payment and weighing. In essence, the caller is guaranteeing
   * that executing the current `MigrationTask` with the given `limits` will not exceed
   * `real_size_upper` bytes of read data.
   *
   * The `witness_task` is merely a helper to prevent the caller from being slashed or
   * generally trigger a migration that they do not intend. This parameter is just a message
   * from caller, saying that they believed `witness_task` was the last state of the
   * migration, and they only wish for their transaction to do anything, if this assumption
   * holds. In case `witness_task` does not match, the transaction fails.
   *
   * Based on the documentation of [`MigrationTask::migrate_until_exhaustion`], the
   * recommended way of doing this is to pass a `limit` that only bounds `count`, as the
   * `size` limit can always be overwritten.
   **/
  | {
      name: 'ContinueMigrate';
      params: {
        limits: PalletStateTrieMigrationMigrationLimits;
        realSizeUpper: number;
        witnessTask: PalletStateTrieMigrationMigrationTask;
      };
    }
  /**
   * Migrate the list of top keys by iterating each of them one by one.
   *
   * This does not affect the global migration process tracker ([`MigrationProcess`]), and
   * should only be used in case any keys are leftover due to a bug.
   **/
  | { name: 'MigrateCustomTop'; params: { keys: Array<BytesLike>; witnessSize: number } }
  /**
   * Migrate the list of child keys by iterating each of them one by one.
   *
   * All of the given child keys must be present under one `child_root`.
   *
   * This does not affect the global migration process tracker ([`MigrationProcess`]), and
   * should only be used in case any keys are leftover due to a bug.
   **/
  | { name: 'MigrateCustomChild'; params: { root: BytesLike; childKeys: Array<BytesLike>; totalSize: number } }
  /**
   * Set the maximum limit of the signed migration.
   **/
  | { name: 'SetSignedMaxLimits'; params: { limits: PalletStateTrieMigrationMigrationLimits } }
  /**
   * Forcefully set the progress the running migration.
   *
   * This is only useful in one case: the next key to migrate is too big to be migrated with
   * a signed account, in a parachain context, and we simply want to skip it. A reasonable
   * example of this would be `:code:`, which is both very expensive to migrate, and commonly
   * used, so probably it is already migrated.
   *
   * In case you mess things up, you can also, in principle, use this to reset the migration
   * process.
   **/
  | {
      name: 'ForceSetProgress';
      params: { progressTop: PalletStateTrieMigrationProgress; progressChild: PalletStateTrieMigrationProgress };
    };

export type PalletStateTrieMigrationMigrationLimits = { size: number; item: number };

export type PalletStateTrieMigrationMigrationTask = {
  progressTop: PalletStateTrieMigrationProgress;
  progressChild: PalletStateTrieMigrationProgress;
  size: number;
  topItems: number;
  childItems: number;
};

export type PalletStateTrieMigrationProgress =
  | { type: 'ToStart' }
  | { type: 'LastKey'; value: Bytes }
  | { type: 'Complete' };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletConvictionVotingCall =
  /**
   * Vote in a poll. If `vote.is_aye()`, the vote is to enact the proposal;
   * otherwise it is a vote to keep the status quo.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `poll_index`: The index of the poll to vote for.
   * - `vote`: The vote configuration.
   *
   * Weight: `O(R)` where R is the number of polls the voter has voted on.
   **/
  | { name: 'Vote'; params: { pollIndex: number; vote: PalletConvictionVotingVoteAccountVote } }
  /**
   * Delegate the voting power (with some given conviction) of the sending account for a
   * particular class of polls.
   *
   * The balance delegated is locked for as long as it's delegated, and thereafter for the
   * time appropriate for the conviction's lock period.
   *
   * The dispatch origin of this call must be _Signed_, and the signing account must either:
   * - be delegating already; or
   * - have no voting activity (if there is, then it will need to be removed through
   * `remove_vote`).
   *
   * - `to`: The account whose voting the `target` account's voting power will follow.
   * - `class`: The class of polls to delegate. To delegate multiple classes, multiple calls
   * to this function are required.
   * - `conviction`: The conviction that will be attached to the delegated votes. When the
   * account is undelegated, the funds will be locked for the corresponding period.
   * - `balance`: The amount of the account's balance to be used in delegating. This must not
   * be more than the account's current balance.
   *
   * Emits `Delegated`.
   *
   * Weight: `O(R)` where R is the number of polls the voter delegating to has
   * voted on. Weight is initially charged as if maximum votes, but is refunded later.
   **/
  | {
      name: 'Delegate';
      params: { class: number; to: AccountId32; conviction: PalletConvictionVotingConviction; balance: bigint };
    }
  /**
   * Undelegate the voting power of the sending account for a particular class of polls.
   *
   * Tokens may be unlocked following once an amount of time consistent with the lock period
   * of the conviction with which the delegation was issued has passed.
   *
   * The dispatch origin of this call must be _Signed_ and the signing account must be
   * currently delegating.
   *
   * - `class`: The class of polls to remove the delegation from.
   *
   * Emits `Undelegated`.
   *
   * Weight: `O(R)` where R is the number of polls the voter delegating to has
   * voted on. Weight is initially charged as if maximum votes, but is refunded later.
   **/
  | { name: 'Undelegate'; params: { class: number } }
  /**
   * Remove the lock caused by prior voting/delegating which has expired within a particular
   * class.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `class`: The class of polls to unlock.
   * - `target`: The account to remove the lock on.
   *
   * Weight: `O(R)` with R number of vote of target.
   **/
  | { name: 'Unlock'; params: { class: number; target: AccountId32 } }
  /**
   * Remove a vote for a poll.
   *
   * If:
   * - the poll was cancelled, or
   * - the poll is ongoing, or
   * - the poll has ended such that
   * - the vote of the account was in opposition to the result; or
   * - there was no conviction to the account's vote; or
   * - the account made a split vote
   * ...then the vote is removed cleanly and a following call to `unlock` may result in more
   * funds being available.
   *
   * If, however, the poll has ended and:
   * - it finished corresponding to the vote of the account, and
   * - the account made a standard vote with conviction, and
   * - the lock period of the conviction is not over
   * ...then the lock will be aggregated into the overall account's lock, which may involve
   * *overlocking* (where the two locks are combined into a single lock that is the maximum
   * of both the amount locked and the time is it locked for).
   *
   * The dispatch origin of this call must be _Signed_, and the signer must have a vote
   * registered for poll `index`.
   *
   * - `index`: The index of poll of the vote to be removed.
   * - `class`: Optional parameter, if given it indicates the class of the poll. For polls
   * which have finished or are cancelled, this must be `Some`.
   *
   * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: 'RemoveVote'; params: { class?: number | undefined; index: number } }
  /**
   * Remove a vote for a poll.
   *
   * If the `target` is equal to the signer, then this function is exactly equivalent to
   * `remove_vote`. If not equal to the signer, then the vote must have expired,
   * either because the poll was cancelled, because the voter lost the poll or
   * because the conviction period is over.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `target`: The account of the vote to be removed; this account must have voted for poll
   * `index`.
   * - `index`: The index of poll of the vote to be removed.
   * - `class`: The class of the poll.
   *
   * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: 'RemoveOtherVote'; params: { target: AccountId32; class: number; index: number } }
  /**
   * Allow to force remove a vote for a referendum.
   *
   * The dispatch origin of this call must be `VoteRemovalOrigin`.
   *
   * Only allowed if the referendum is finished.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `target`: The account of the vote to be removed; this account must have voted for
   * referendum `index`.
   * - `index`: The index of referendum of the vote to be removed.
   *
   * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: 'ForceRemoveVote'; params: { target: AccountId32; class: number; index: number } };

export type PalletConvictionVotingCallLike =
  /**
   * Vote in a poll. If `vote.is_aye()`, the vote is to enact the proposal;
   * otherwise it is a vote to keep the status quo.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `poll_index`: The index of the poll to vote for.
   * - `vote`: The vote configuration.
   *
   * Weight: `O(R)` where R is the number of polls the voter has voted on.
   **/
  | { name: 'Vote'; params: { pollIndex: number; vote: PalletConvictionVotingVoteAccountVote } }
  /**
   * Delegate the voting power (with some given conviction) of the sending account for a
   * particular class of polls.
   *
   * The balance delegated is locked for as long as it's delegated, and thereafter for the
   * time appropriate for the conviction's lock period.
   *
   * The dispatch origin of this call must be _Signed_, and the signing account must either:
   * - be delegating already; or
   * - have no voting activity (if there is, then it will need to be removed through
   * `remove_vote`).
   *
   * - `to`: The account whose voting the `target` account's voting power will follow.
   * - `class`: The class of polls to delegate. To delegate multiple classes, multiple calls
   * to this function are required.
   * - `conviction`: The conviction that will be attached to the delegated votes. When the
   * account is undelegated, the funds will be locked for the corresponding period.
   * - `balance`: The amount of the account's balance to be used in delegating. This must not
   * be more than the account's current balance.
   *
   * Emits `Delegated`.
   *
   * Weight: `O(R)` where R is the number of polls the voter delegating to has
   * voted on. Weight is initially charged as if maximum votes, but is refunded later.
   **/
  | {
      name: 'Delegate';
      params: { class: number; to: AccountId32Like; conviction: PalletConvictionVotingConviction; balance: bigint };
    }
  /**
   * Undelegate the voting power of the sending account for a particular class of polls.
   *
   * Tokens may be unlocked following once an amount of time consistent with the lock period
   * of the conviction with which the delegation was issued has passed.
   *
   * The dispatch origin of this call must be _Signed_ and the signing account must be
   * currently delegating.
   *
   * - `class`: The class of polls to remove the delegation from.
   *
   * Emits `Undelegated`.
   *
   * Weight: `O(R)` where R is the number of polls the voter delegating to has
   * voted on. Weight is initially charged as if maximum votes, but is refunded later.
   **/
  | { name: 'Undelegate'; params: { class: number } }
  /**
   * Remove the lock caused by prior voting/delegating which has expired within a particular
   * class.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `class`: The class of polls to unlock.
   * - `target`: The account to remove the lock on.
   *
   * Weight: `O(R)` with R number of vote of target.
   **/
  | { name: 'Unlock'; params: { class: number; target: AccountId32Like } }
  /**
   * Remove a vote for a poll.
   *
   * If:
   * - the poll was cancelled, or
   * - the poll is ongoing, or
   * - the poll has ended such that
   * - the vote of the account was in opposition to the result; or
   * - there was no conviction to the account's vote; or
   * - the account made a split vote
   * ...then the vote is removed cleanly and a following call to `unlock` may result in more
   * funds being available.
   *
   * If, however, the poll has ended and:
   * - it finished corresponding to the vote of the account, and
   * - the account made a standard vote with conviction, and
   * - the lock period of the conviction is not over
   * ...then the lock will be aggregated into the overall account's lock, which may involve
   * *overlocking* (where the two locks are combined into a single lock that is the maximum
   * of both the amount locked and the time is it locked for).
   *
   * The dispatch origin of this call must be _Signed_, and the signer must have a vote
   * registered for poll `index`.
   *
   * - `index`: The index of poll of the vote to be removed.
   * - `class`: Optional parameter, if given it indicates the class of the poll. For polls
   * which have finished or are cancelled, this must be `Some`.
   *
   * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: 'RemoveVote'; params: { class?: number | undefined; index: number } }
  /**
   * Remove a vote for a poll.
   *
   * If the `target` is equal to the signer, then this function is exactly equivalent to
   * `remove_vote`. If not equal to the signer, then the vote must have expired,
   * either because the poll was cancelled, because the voter lost the poll or
   * because the conviction period is over.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `target`: The account of the vote to be removed; this account must have voted for poll
   * `index`.
   * - `index`: The index of poll of the vote to be removed.
   * - `class`: The class of the poll.
   *
   * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: 'RemoveOtherVote'; params: { target: AccountId32Like; class: number; index: number } }
  /**
   * Allow to force remove a vote for a referendum.
   *
   * The dispatch origin of this call must be `VoteRemovalOrigin`.
   *
   * Only allowed if the referendum is finished.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `target`: The account of the vote to be removed; this account must have voted for
   * referendum `index`.
   * - `index`: The index of referendum of the vote to be removed.
   *
   * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: 'ForceRemoveVote'; params: { target: AccountId32Like; class: number; index: number } };

export type PalletConvictionVotingConviction =
  | 'None'
  | 'Locked1x'
  | 'Locked2x'
  | 'Locked3x'
  | 'Locked4x'
  | 'Locked5x'
  | 'Locked6x';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletReferendaCall =
  /**
   * Propose a referendum on a privileged action.
   *
   * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
   * available.
   * - `proposal_origin`: The origin from which the proposal should be executed.
   * - `proposal`: The proposal.
   * - `enactment_moment`: The moment that the proposal should be enacted.
   *
   * Emits `Submitted`.
   **/
  | {
      name: 'Submit';
      params: {
        proposalOrigin: HydradxRuntimeOriginCaller;
        proposal: FrameSupportPreimagesBounded;
        enactmentMoment: FrameSupportScheduleDispatchTime;
      };
    }
  /**
   * Post the Decision Deposit for a referendum.
   *
   * - `origin`: must be `Signed` and the account must have funds available for the
   * referendum's track's Decision Deposit.
   * - `index`: The index of the submitted referendum whose Decision Deposit is yet to be
   * posted.
   *
   * Emits `DecisionDepositPlaced`.
   **/
  | { name: 'PlaceDecisionDeposit'; params: { index: number } }
  /**
   * Refund the Decision Deposit for a closed referendum back to the depositor.
   *
   * - `origin`: must be `Signed` or `Root`.
   * - `index`: The index of a closed referendum whose Decision Deposit has not yet been
   * refunded.
   *
   * Emits `DecisionDepositRefunded`.
   **/
  | { name: 'RefundDecisionDeposit'; params: { index: number } }
  /**
   * Cancel an ongoing referendum.
   *
   * - `origin`: must be the `CancelOrigin`.
   * - `index`: The index of the referendum to be cancelled.
   *
   * Emits `Cancelled`.
   **/
  | { name: 'Cancel'; params: { index: number } }
  /**
   * Cancel an ongoing referendum and slash the deposits.
   *
   * - `origin`: must be the `KillOrigin`.
   * - `index`: The index of the referendum to be cancelled.
   *
   * Emits `Killed` and `DepositSlashed`.
   **/
  | { name: 'Kill'; params: { index: number } }
  /**
   * Advance a referendum onto its next logical state. Only used internally.
   *
   * - `origin`: must be `Root`.
   * - `index`: the referendum to be advanced.
   **/
  | { name: 'NudgeReferendum'; params: { index: number } }
  /**
   * Advance a track onto its next logical state. Only used internally.
   *
   * - `origin`: must be `Root`.
   * - `track`: the track to be advanced.
   *
   * Action item for when there is now one fewer referendum in the deciding phase and the
   * `DecidingCount` is not yet updated. This means that we should either:
   * - begin deciding another referendum (and leave `DecidingCount` alone); or
   * - decrement `DecidingCount`.
   **/
  | { name: 'OneFewerDeciding'; params: { track: number } }
  /**
   * Refund the Submission Deposit for a closed referendum back to the depositor.
   *
   * - `origin`: must be `Signed` or `Root`.
   * - `index`: The index of a closed referendum whose Submission Deposit has not yet been
   * refunded.
   *
   * Emits `SubmissionDepositRefunded`.
   **/
  | { name: 'RefundSubmissionDeposit'; params: { index: number } }
  /**
   * Set or clear metadata of a referendum.
   *
   * Parameters:
   * - `origin`: Must be `Signed` by a creator of a referendum or by anyone to clear a
   * metadata of a finished referendum.
   * - `index`: The index of a referendum to set or clear metadata for.
   * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
   **/
  | { name: 'SetMetadata'; params: { index: number; maybeHash?: H256 | undefined } };

export type PalletReferendaCallLike =
  /**
   * Propose a referendum on a privileged action.
   *
   * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
   * available.
   * - `proposal_origin`: The origin from which the proposal should be executed.
   * - `proposal`: The proposal.
   * - `enactment_moment`: The moment that the proposal should be enacted.
   *
   * Emits `Submitted`.
   **/
  | {
      name: 'Submit';
      params: {
        proposalOrigin: HydradxRuntimeOriginCaller;
        proposal: FrameSupportPreimagesBounded;
        enactmentMoment: FrameSupportScheduleDispatchTime;
      };
    }
  /**
   * Post the Decision Deposit for a referendum.
   *
   * - `origin`: must be `Signed` and the account must have funds available for the
   * referendum's track's Decision Deposit.
   * - `index`: The index of the submitted referendum whose Decision Deposit is yet to be
   * posted.
   *
   * Emits `DecisionDepositPlaced`.
   **/
  | { name: 'PlaceDecisionDeposit'; params: { index: number } }
  /**
   * Refund the Decision Deposit for a closed referendum back to the depositor.
   *
   * - `origin`: must be `Signed` or `Root`.
   * - `index`: The index of a closed referendum whose Decision Deposit has not yet been
   * refunded.
   *
   * Emits `DecisionDepositRefunded`.
   **/
  | { name: 'RefundDecisionDeposit'; params: { index: number } }
  /**
   * Cancel an ongoing referendum.
   *
   * - `origin`: must be the `CancelOrigin`.
   * - `index`: The index of the referendum to be cancelled.
   *
   * Emits `Cancelled`.
   **/
  | { name: 'Cancel'; params: { index: number } }
  /**
   * Cancel an ongoing referendum and slash the deposits.
   *
   * - `origin`: must be the `KillOrigin`.
   * - `index`: The index of the referendum to be cancelled.
   *
   * Emits `Killed` and `DepositSlashed`.
   **/
  | { name: 'Kill'; params: { index: number } }
  /**
   * Advance a referendum onto its next logical state. Only used internally.
   *
   * - `origin`: must be `Root`.
   * - `index`: the referendum to be advanced.
   **/
  | { name: 'NudgeReferendum'; params: { index: number } }
  /**
   * Advance a track onto its next logical state. Only used internally.
   *
   * - `origin`: must be `Root`.
   * - `track`: the track to be advanced.
   *
   * Action item for when there is now one fewer referendum in the deciding phase and the
   * `DecidingCount` is not yet updated. This means that we should either:
   * - begin deciding another referendum (and leave `DecidingCount` alone); or
   * - decrement `DecidingCount`.
   **/
  | { name: 'OneFewerDeciding'; params: { track: number } }
  /**
   * Refund the Submission Deposit for a closed referendum back to the depositor.
   *
   * - `origin`: must be `Signed` or `Root`.
   * - `index`: The index of a closed referendum whose Submission Deposit has not yet been
   * refunded.
   *
   * Emits `SubmissionDepositRefunded`.
   **/
  | { name: 'RefundSubmissionDeposit'; params: { index: number } }
  /**
   * Set or clear metadata of a referendum.
   *
   * Parameters:
   * - `origin`: Must be `Signed` by a creator of a referendum or by anyone to clear a
   * metadata of a finished referendum.
   * - `index`: The index of a referendum to set or clear metadata for.
   * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
   **/
  | { name: 'SetMetadata'; params: { index: number; maybeHash?: H256 | undefined } };

export type FrameSupportScheduleDispatchTime = { type: 'At'; value: number } | { type: 'After'; value: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletWhitelistCall =
  | { name: 'WhitelistCall'; params: { callHash: H256 } }
  | { name: 'RemoveWhitelistedCall'; params: { callHash: H256 } }
  | {
      name: 'DispatchWhitelistedCall';
      params: { callHash: H256; callEncodedLen: number; callWeightWitness: SpWeightsWeightV2Weight };
    }
  | { name: 'DispatchWhitelistedCallWithPreimage'; params: { call: HydradxRuntimeRuntimeCall } };

export type PalletWhitelistCallLike =
  | { name: 'WhitelistCall'; params: { callHash: H256 } }
  | { name: 'RemoveWhitelistedCall'; params: { callHash: H256 } }
  | {
      name: 'DispatchWhitelistedCall';
      params: { callHash: H256; callEncodedLen: number; callWeightWitness: SpWeightsWeightV2Weight };
    }
  | { name: 'DispatchWhitelistedCallWithPreimage'; params: { call: HydradxRuntimeRuntimeCallLike } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletDispatcherCall =
  | { name: 'DispatchAsTreasury'; params: { call: HydradxRuntimeRuntimeCall } }
  | { name: 'DispatchAsAaveManager'; params: { call: HydradxRuntimeRuntimeCall } }
  /**
   * Sets the Aave manager account to be used as origin for dispatching calls.
   *
   * This doesn't actually changes any ACL in the pool.
   *
   * This is intented to be mainly used in testnet environments, where the manager account
   * can be different.
   **/
  | { name: 'NoteAaveManager'; params: { account: AccountId32 } }
  /**
   * Dispatch a call with extra gas.
   *
   * This allows executing calls with additional weight (gas) limit.
   * The extra gas is not refunded, even if not used.
   **/
  | { name: 'DispatchWithExtraGas'; params: { call: HydradxRuntimeRuntimeCall; extraGas: bigint } };

export type PalletDispatcherCallLike =
  | { name: 'DispatchAsTreasury'; params: { call: HydradxRuntimeRuntimeCallLike } }
  | { name: 'DispatchAsAaveManager'; params: { call: HydradxRuntimeRuntimeCallLike } }
  /**
   * Sets the Aave manager account to be used as origin for dispatching calls.
   *
   * This doesn't actually changes any ACL in the pool.
   *
   * This is intented to be mainly used in testnet environments, where the manager account
   * can be different.
   **/
  | { name: 'NoteAaveManager'; params: { account: AccountId32Like } }
  /**
   * Dispatch a call with extra gas.
   *
   * This allows executing calls with additional weight (gas) limit.
   * The extra gas is not refunded, even if not used.
   **/
  | { name: 'DispatchWithExtraGas'; params: { call: HydradxRuntimeRuntimeCallLike; extraGas: bigint } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletAssetRegistryCall =
  /**
   * Register a new asset.
   *
   * New asset is given `NextAssetId` - sequential asset id
   *
   * Asset's id is optional and it can't be used by another asset if it's provided.
   * Provided `asset_id` must be from within reserved range.
   * If `asset_id` is `None`, new asset is given id for sequential ids.
   *
   * Asset's name is optional and it can't be used by another asset if it's provided.
   * Adds mapping between `name` and assigned `asset_id` so asset id can be retrieved by name too (Note: this approach is used in AMM implementation (xyk))
   *
   * Emits 'Registered` event when successful.
   **/
  | {
      name: 'Register';
      params: {
        assetId?: number | undefined;
        name?: Bytes | undefined;
        assetType: PalletAssetRegistryAssetType;
        existentialDeposit?: bigint | undefined;
        symbol?: Bytes | undefined;
        decimals?: number | undefined;
        location?: HydradxRuntimeXcmAssetLocation | undefined;
        xcmRateLimit?: bigint | undefined;
        isSufficient: boolean;
      };
    }
  /**
   * Update registered asset.
   *
   * All parameteres are optional and value is not updated if param is `None`.
   *
   * `decimals` - can be update by `UpdateOrigin` only if it wasn't set yet. Only
   * `RegistryOrigin` can update `decimals` if it was previously set.
   *
   * `location` - can be updated only by `RegistryOrigin`.
   *
   * Emits `Updated` event when successful.
   **/
  | {
      name: 'Update';
      params: {
        assetId: number;
        name?: Bytes | undefined;
        assetType?: PalletAssetRegistryAssetType | undefined;
        existentialDeposit?: bigint | undefined;
        xcmRateLimit?: bigint | undefined;
        isSufficient?: boolean | undefined;
        symbol?: Bytes | undefined;
        decimals?: number | undefined;
        location?: HydradxRuntimeXcmAssetLocation | undefined;
      };
    }
  | { name: 'RegisterExternal'; params: { location: HydradxRuntimeXcmAssetLocation } }
  | { name: 'BanAsset'; params: { assetId: number } }
  | { name: 'UnbanAsset'; params: { assetId: number } };

export type PalletAssetRegistryCallLike =
  /**
   * Register a new asset.
   *
   * New asset is given `NextAssetId` - sequential asset id
   *
   * Asset's id is optional and it can't be used by another asset if it's provided.
   * Provided `asset_id` must be from within reserved range.
   * If `asset_id` is `None`, new asset is given id for sequential ids.
   *
   * Asset's name is optional and it can't be used by another asset if it's provided.
   * Adds mapping between `name` and assigned `asset_id` so asset id can be retrieved by name too (Note: this approach is used in AMM implementation (xyk))
   *
   * Emits 'Registered` event when successful.
   **/
  | {
      name: 'Register';
      params: {
        assetId?: number | undefined;
        name?: BytesLike | undefined;
        assetType: PalletAssetRegistryAssetType;
        existentialDeposit?: bigint | undefined;
        symbol?: BytesLike | undefined;
        decimals?: number | undefined;
        location?: HydradxRuntimeXcmAssetLocation | undefined;
        xcmRateLimit?: bigint | undefined;
        isSufficient: boolean;
      };
    }
  /**
   * Update registered asset.
   *
   * All parameteres are optional and value is not updated if param is `None`.
   *
   * `decimals` - can be update by `UpdateOrigin` only if it wasn't set yet. Only
   * `RegistryOrigin` can update `decimals` if it was previously set.
   *
   * `location` - can be updated only by `RegistryOrigin`.
   *
   * Emits `Updated` event when successful.
   **/
  | {
      name: 'Update';
      params: {
        assetId: number;
        name?: BytesLike | undefined;
        assetType?: PalletAssetRegistryAssetType | undefined;
        existentialDeposit?: bigint | undefined;
        xcmRateLimit?: bigint | undefined;
        isSufficient?: boolean | undefined;
        symbol?: BytesLike | undefined;
        decimals?: number | undefined;
        location?: HydradxRuntimeXcmAssetLocation | undefined;
      };
    }
  | { name: 'RegisterExternal'; params: { location: HydradxRuntimeXcmAssetLocation } }
  | { name: 'BanAsset'; params: { assetId: number } }
  | { name: 'UnbanAsset'; params: { assetId: number } };

export type PalletAssetRegistryAssetType = 'Token' | 'Xyk' | 'StableSwap' | 'Bond' | 'External' | 'Erc20';

export type HydradxRuntimeXcmAssetLocation = StagingXcmV3MultilocationMultiLocation;

export type StagingXcmV3MultilocationMultiLocation = { parents: number; interior: XcmV3Junctions };

export type XcmV3Junctions =
  | { type: 'Here' }
  | { type: 'X1'; value: XcmV3Junction }
  | { type: 'X2'; value: [XcmV3Junction, XcmV3Junction] }
  | { type: 'X3'; value: [XcmV3Junction, XcmV3Junction, XcmV3Junction] }
  | { type: 'X4'; value: [XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction] }
  | { type: 'X5'; value: [XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction] }
  | { type: 'X6'; value: [XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction] }
  | {
      type: 'X7';
      value: [XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction];
    }
  | {
      type: 'X8';
      value: [
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
      ];
    };

export type XcmV3Junction =
  | { type: 'Parachain'; value: number }
  | { type: 'AccountId32'; value: { network?: XcmV3JunctionNetworkId | undefined; id: FixedBytes<32> } }
  | { type: 'AccountIndex64'; value: { network?: XcmV3JunctionNetworkId | undefined; index: bigint } }
  | { type: 'AccountKey20'; value: { network?: XcmV3JunctionNetworkId | undefined; key: FixedBytes<20> } }
  | { type: 'PalletInstance'; value: number }
  | { type: 'GeneralIndex'; value: bigint }
  | { type: 'GeneralKey'; value: { length: number; data: FixedBytes<32> } }
  | { type: 'OnlyChild' }
  | { type: 'Plurality'; value: { id: XcmV3JunctionBodyId; part: XcmV3JunctionBodyPart } }
  | { type: 'GlobalConsensus'; value: XcmV3JunctionNetworkId };

export type XcmV3JunctionNetworkId =
  | { type: 'ByGenesis'; value: FixedBytes<32> }
  | { type: 'ByFork'; value: { blockNumber: bigint; blockHash: FixedBytes<32> } }
  | { type: 'Polkadot' }
  | { type: 'Kusama' }
  | { type: 'Westend' }
  | { type: 'Rococo' }
  | { type: 'Wococo' }
  | { type: 'Ethereum'; value: { chainId: bigint } }
  | { type: 'BitcoinCore' }
  | { type: 'BitcoinCash' }
  | { type: 'PolkadotBulletin' };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletClaimsCall =
  /**
   * Claim xHDX by providing signed message with Ethereum address.
   **/
  { name: 'Claim'; params: { ethereumSignature: PalletClaimsEcdsaSignature } };

export type PalletClaimsCallLike =
  /**
   * Claim xHDX by providing signed message with Ethereum address.
   **/
  { name: 'Claim'; params: { ethereumSignature: PalletClaimsEcdsaSignature } };

export type PalletClaimsEcdsaSignature = FixedBytes<65>;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletGenesisHistoryCall = null;

export type PalletGenesisHistoryCallLike = null;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletOmnipoolCall =
  /**
   * Add new token to omnipool in quantity `amount` at price `initial_price`
   *
   * Initial liquidity must be transferred to pool's account for this new token manually prior to calling `add_token`.
   *
   * Initial liquidity is pool's account balance of the token.
   *
   * Position NFT token is minted for `position_owner`.
   *
   * Parameters:
   * - `asset`: The identifier of the new asset added to the pool. Must be registered in Asset registry
   * - `initial_price`: Initial price
   * - `position_owner`: account id for which share are distributed in form on NFT
   * - `weight_cap`: asset weight cap
   *
   * Emits `TokenAdded` event when successful.
   *
   **/
  | {
      name: 'AddToken';
      params: { asset: number; initialPrice: FixedU128; weightCap: Permill; positionOwner: AccountId32 };
    }
  /**
   * Add liquidity of asset `asset` in quantity `amount` to Omnipool
   *
   * `add_liquidity` adds specified asset amount to Omnipool and in exchange gives the origin
   * corresponding shares amount in form of NFT at current price.
   *
   * Asset's tradable state must contain ADD_LIQUIDITY flag, otherwise `NotAllowed` error is returned.
   *
   * NFT is minted using NTFHandler which implements non-fungibles traits from frame_support.
   *
   * Asset weight cap must be respected, otherwise `AssetWeightExceeded` error is returned.
   * Asset weight is ratio between new HubAsset reserve and total reserve of Hub asset in Omnipool.
   *
   * Add liquidity fails if price difference between spot price and oracle price is higher than allowed by `PriceBarrier`.
   *
   * Parameters:
   * - `asset`: The identifier of the new asset added to the pool. Must be already in the pool
   * - `amount`: Amount of asset added to omnipool
   *
   * Emits `LiquidityAdded` event when successful.
   *
   **/
  | { name: 'AddLiquidity'; params: { asset: number; amount: bigint } }
  /**
   * Add liquidity of asset `asset` in quantity `amount` to Omnipool.
   *
   * Limit protection is applied.
   *
   * `add_liquidity` adds specified asset amount to Omnipool and in exchange gives the origin
   * corresponding shares amount in form of NFT at current price.
   *
   * Asset's tradable state must contain ADD_LIQUIDITY flag, otherwise `NotAllowed` error is returned.
   *
   * NFT is minted using NTFHandler which implements non-fungibles traits from frame_support.
   *
   * Asset weight cap must be respected, otherwise `AssetWeightExceeded` error is returned.
   * Asset weight is ratio between new HubAsset reserve and total reserve of Hub asset in Omnipool.
   *
   * Add liquidity fails if price difference between spot price and oracle price is higher than allowed by `PriceBarrier`.
   *
   * Parameters:
   * - `asset`: The identifier of the new asset added to the pool. Must be already in the pool
   * - `amount`: Amount of asset added to omnipool
   * - `min_shares_limit`: The min amount of delta share asset the user should receive in the position
   *
   * Emits `LiquidityAdded` event when successful.
   *
   **/
  | { name: 'AddLiquidityWithLimit'; params: { asset: number; amount: bigint; minSharesLimit: bigint } }
  /**
   * Remove liquidity of asset `asset` in quantity `amount` from Omnipool
   *
   * `remove_liquidity` removes specified shares amount from given PositionId (NFT instance).
   *
   * Asset's tradable state must contain REMOVE_LIQUIDITY flag, otherwise `NotAllowed` error is returned.
   *
   * if all shares from given position are removed, position is destroyed and NFT is burned.
   *
   * Remove liquidity fails if price difference between spot price and oracle price is higher than allowed by `PriceBarrier`.
   *
   * Dynamic withdrawal fee is applied if withdrawal is not safe. It is calculated using spot price and external price oracle.
   * Withdrawal is considered safe when trading is disabled.
   *
   * Parameters:
   * - `position_id`: The identifier of position which liquidity is removed from.
   * - `amount`: Amount of shares removed from omnipool
   *
   * Emits `LiquidityRemoved` event when successful.
   *
   **/
  | { name: 'RemoveLiquidity'; params: { positionId: bigint; amount: bigint } }
  /**
   * Remove liquidity of asset `asset` in quantity `amount` from Omnipool
   *
   * Limit protection is applied.
   *
   * `remove_liquidity` removes specified shares amount from given PositionId (NFT instance).
   *
   * Asset's tradable state must contain REMOVE_LIQUIDITY flag, otherwise `NotAllowed` error is returned.
   *
   * if all shares from given position are removed, position is destroyed and NFT is burned.
   *
   * Remove liquidity fails if price difference between spot price and oracle price is higher than allowed by `PriceBarrier`.
   *
   * Dynamic withdrawal fee is applied if withdrawal is not safe. It is calculated using spot price and external price oracle.
   * Withdrawal is considered safe when trading is disabled.
   *
   * Parameters:
   * - `position_id`: The identifier of position which liquidity is removed from.
   * - `amount`: Amount of shares removed from omnipool
   * - `min_limit`: The min amount of asset to be removed for the user
   *
   * Emits `LiquidityRemoved` event when successful.
   *
   **/
  | { name: 'RemoveLiquidityWithLimit'; params: { positionId: bigint; amount: bigint; minLimit: bigint } }
  /**
   * Sacrifice LP position in favor of pool.
   *
   * A position is destroyed and liquidity owned by LP becomes pool owned liquidity.
   *
   * Only owner of position can perform this action.
   *
   * Emits `PositionDestroyed`.
   **/
  | { name: 'SacrificePosition'; params: { positionId: bigint } }
  /**
   * Execute a swap of `asset_in` for `asset_out`.
   *
   * Price is determined by the Omnipool.
   *
   * Hub asset is traded separately.
   *
   * Asset's tradable states must contain SELL flag for asset_in and BUY flag for asset_out, otherwise `NotAllowed` error is returned.
   *
   * Parameters:
   * - `asset_in`: ID of asset sold to the pool
   * - `asset_out`: ID of asset bought from the pool
   * - `amount`: Amount of asset sold
   * - `min_buy_amount`: Minimum amount required to receive
   *
   * Emits `SellExecuted` event when successful. Deprecated.
   * Emits `pallet_broadcast::Swapped` event when successful.
   *
   **/
  | { name: 'Sell'; params: { assetIn: number; assetOut: number; amount: bigint; minBuyAmount: bigint } }
  /**
   * Execute a swap of `asset_out` for `asset_in`.
   *
   * Price is determined by the Omnipool.
   *
   * Hub asset is traded separately.
   *
   * Asset's tradable states must contain SELL flag for asset_in and BUY flag for asset_out, otherwise `NotAllowed` error is returned.
   *
   * Parameters:
   * - `asset_in`: ID of asset sold to the pool
   * - `asset_out`: ID of asset bought from the pool
   * - `amount`: Amount of asset sold
   * - `max_sell_amount`: Maximum amount to be sold.
   *
   * Emits `BuyExecuted` event when successful. Deprecated.
   * Emits `pallet_broadcast::Swapped` event when successful.
   *
   **/
  | { name: 'Buy'; params: { assetOut: number; assetIn: number; amount: bigint; maxSellAmount: bigint } }
  /**
   * Update asset's tradable state.
   *
   * Parameters:
   * - `asset_id`: asset id
   * - `state`: new state
   *
   * Emits `TradableStateUpdated` event when successful.
   *
   **/
  | { name: 'SetAssetTradableState'; params: { assetId: number; state: PalletOmnipoolTradability } }
  /**
   * Refund given amount of asset to a recipient.
   *
   * A refund is needed when a token is refused to be added to Omnipool, and initial liquidity of the asset has been already transferred to pool's account.
   *
   * Transfer can be executed only if asset is not in Omnipool and pool's balance has sufficient amount.
   *
   * Only `AuthorityOrigin` can perform this operation.
   *
   * Emits `AssetRefunded`
   **/
  | { name: 'RefundRefusedAsset'; params: { assetId: number; amount: bigint; recipient: AccountId32 } }
  /**
   * Update asset's weight cap
   *
   * Parameters:
   * - `asset_id`: asset id
   * - `cap`: new weight cap
   *
   * Emits `AssetWeightCapUpdated` event when successful.
   *
   **/
  | { name: 'SetAssetWeightCap'; params: { assetId: number; cap: Permill } }
  /**
   * Removes protocol liquidity.
   *
   * Protocol liquidity is liquidity from sacrificed positions. In order to remove protocol liquidity,
   * we need the know the price of the position at the time of sacrifice. Hence this specific call.
   *
   * Only `AuthorityOrigin` can perform this call.
   *
   * Note that sacrifice position will be deprecated in future. There is no longer a need for that.
   *
   * It works the same way as remove liquidity call, but position is temporary reconstructed.
   *
   **/
  | {
      name: 'WithdrawProtocolLiquidity';
      params: { assetId: number; amount: bigint; price: [bigint, bigint]; dest: AccountId32 };
    }
  /**
   * Removes token from Omnipool.
   *
   * Asset's tradability must be FROZEN, otherwise `AssetNotFrozen` error is returned.
   *
   * Remaining shares must belong to protocol, otherwise `SharesRemaining` error is returned.
   *
   * Protocol's liquidity is transferred to the beneficiary account and hub asset amount is burned.
   *
   * Only `AuthorityOrigin` can perform this call.
   *
   * Emits `TokenRemoved` event when successful.
   **/
  | { name: 'RemoveToken'; params: { assetId: number; beneficiary: AccountId32 } };

export type PalletOmnipoolCallLike =
  /**
   * Add new token to omnipool in quantity `amount` at price `initial_price`
   *
   * Initial liquidity must be transferred to pool's account for this new token manually prior to calling `add_token`.
   *
   * Initial liquidity is pool's account balance of the token.
   *
   * Position NFT token is minted for `position_owner`.
   *
   * Parameters:
   * - `asset`: The identifier of the new asset added to the pool. Must be registered in Asset registry
   * - `initial_price`: Initial price
   * - `position_owner`: account id for which share are distributed in form on NFT
   * - `weight_cap`: asset weight cap
   *
   * Emits `TokenAdded` event when successful.
   *
   **/
  | {
      name: 'AddToken';
      params: { asset: number; initialPrice: FixedU128; weightCap: Permill; positionOwner: AccountId32Like };
    }
  /**
   * Add liquidity of asset `asset` in quantity `amount` to Omnipool
   *
   * `add_liquidity` adds specified asset amount to Omnipool and in exchange gives the origin
   * corresponding shares amount in form of NFT at current price.
   *
   * Asset's tradable state must contain ADD_LIQUIDITY flag, otherwise `NotAllowed` error is returned.
   *
   * NFT is minted using NTFHandler which implements non-fungibles traits from frame_support.
   *
   * Asset weight cap must be respected, otherwise `AssetWeightExceeded` error is returned.
   * Asset weight is ratio between new HubAsset reserve and total reserve of Hub asset in Omnipool.
   *
   * Add liquidity fails if price difference between spot price and oracle price is higher than allowed by `PriceBarrier`.
   *
   * Parameters:
   * - `asset`: The identifier of the new asset added to the pool. Must be already in the pool
   * - `amount`: Amount of asset added to omnipool
   *
   * Emits `LiquidityAdded` event when successful.
   *
   **/
  | { name: 'AddLiquidity'; params: { asset: number; amount: bigint } }
  /**
   * Add liquidity of asset `asset` in quantity `amount` to Omnipool.
   *
   * Limit protection is applied.
   *
   * `add_liquidity` adds specified asset amount to Omnipool and in exchange gives the origin
   * corresponding shares amount in form of NFT at current price.
   *
   * Asset's tradable state must contain ADD_LIQUIDITY flag, otherwise `NotAllowed` error is returned.
   *
   * NFT is minted using NTFHandler which implements non-fungibles traits from frame_support.
   *
   * Asset weight cap must be respected, otherwise `AssetWeightExceeded` error is returned.
   * Asset weight is ratio between new HubAsset reserve and total reserve of Hub asset in Omnipool.
   *
   * Add liquidity fails if price difference between spot price and oracle price is higher than allowed by `PriceBarrier`.
   *
   * Parameters:
   * - `asset`: The identifier of the new asset added to the pool. Must be already in the pool
   * - `amount`: Amount of asset added to omnipool
   * - `min_shares_limit`: The min amount of delta share asset the user should receive in the position
   *
   * Emits `LiquidityAdded` event when successful.
   *
   **/
  | { name: 'AddLiquidityWithLimit'; params: { asset: number; amount: bigint; minSharesLimit: bigint } }
  /**
   * Remove liquidity of asset `asset` in quantity `amount` from Omnipool
   *
   * `remove_liquidity` removes specified shares amount from given PositionId (NFT instance).
   *
   * Asset's tradable state must contain REMOVE_LIQUIDITY flag, otherwise `NotAllowed` error is returned.
   *
   * if all shares from given position are removed, position is destroyed and NFT is burned.
   *
   * Remove liquidity fails if price difference between spot price and oracle price is higher than allowed by `PriceBarrier`.
   *
   * Dynamic withdrawal fee is applied if withdrawal is not safe. It is calculated using spot price and external price oracle.
   * Withdrawal is considered safe when trading is disabled.
   *
   * Parameters:
   * - `position_id`: The identifier of position which liquidity is removed from.
   * - `amount`: Amount of shares removed from omnipool
   *
   * Emits `LiquidityRemoved` event when successful.
   *
   **/
  | { name: 'RemoveLiquidity'; params: { positionId: bigint; amount: bigint } }
  /**
   * Remove liquidity of asset `asset` in quantity `amount` from Omnipool
   *
   * Limit protection is applied.
   *
   * `remove_liquidity` removes specified shares amount from given PositionId (NFT instance).
   *
   * Asset's tradable state must contain REMOVE_LIQUIDITY flag, otherwise `NotAllowed` error is returned.
   *
   * if all shares from given position are removed, position is destroyed and NFT is burned.
   *
   * Remove liquidity fails if price difference between spot price and oracle price is higher than allowed by `PriceBarrier`.
   *
   * Dynamic withdrawal fee is applied if withdrawal is not safe. It is calculated using spot price and external price oracle.
   * Withdrawal is considered safe when trading is disabled.
   *
   * Parameters:
   * - `position_id`: The identifier of position which liquidity is removed from.
   * - `amount`: Amount of shares removed from omnipool
   * - `min_limit`: The min amount of asset to be removed for the user
   *
   * Emits `LiquidityRemoved` event when successful.
   *
   **/
  | { name: 'RemoveLiquidityWithLimit'; params: { positionId: bigint; amount: bigint; minLimit: bigint } }
  /**
   * Sacrifice LP position in favor of pool.
   *
   * A position is destroyed and liquidity owned by LP becomes pool owned liquidity.
   *
   * Only owner of position can perform this action.
   *
   * Emits `PositionDestroyed`.
   **/
  | { name: 'SacrificePosition'; params: { positionId: bigint } }
  /**
   * Execute a swap of `asset_in` for `asset_out`.
   *
   * Price is determined by the Omnipool.
   *
   * Hub asset is traded separately.
   *
   * Asset's tradable states must contain SELL flag for asset_in and BUY flag for asset_out, otherwise `NotAllowed` error is returned.
   *
   * Parameters:
   * - `asset_in`: ID of asset sold to the pool
   * - `asset_out`: ID of asset bought from the pool
   * - `amount`: Amount of asset sold
   * - `min_buy_amount`: Minimum amount required to receive
   *
   * Emits `SellExecuted` event when successful. Deprecated.
   * Emits `pallet_broadcast::Swapped` event when successful.
   *
   **/
  | { name: 'Sell'; params: { assetIn: number; assetOut: number; amount: bigint; minBuyAmount: bigint } }
  /**
   * Execute a swap of `asset_out` for `asset_in`.
   *
   * Price is determined by the Omnipool.
   *
   * Hub asset is traded separately.
   *
   * Asset's tradable states must contain SELL flag for asset_in and BUY flag for asset_out, otherwise `NotAllowed` error is returned.
   *
   * Parameters:
   * - `asset_in`: ID of asset sold to the pool
   * - `asset_out`: ID of asset bought from the pool
   * - `amount`: Amount of asset sold
   * - `max_sell_amount`: Maximum amount to be sold.
   *
   * Emits `BuyExecuted` event when successful. Deprecated.
   * Emits `pallet_broadcast::Swapped` event when successful.
   *
   **/
  | { name: 'Buy'; params: { assetOut: number; assetIn: number; amount: bigint; maxSellAmount: bigint } }
  /**
   * Update asset's tradable state.
   *
   * Parameters:
   * - `asset_id`: asset id
   * - `state`: new state
   *
   * Emits `TradableStateUpdated` event when successful.
   *
   **/
  | { name: 'SetAssetTradableState'; params: { assetId: number; state: PalletOmnipoolTradability } }
  /**
   * Refund given amount of asset to a recipient.
   *
   * A refund is needed when a token is refused to be added to Omnipool, and initial liquidity of the asset has been already transferred to pool's account.
   *
   * Transfer can be executed only if asset is not in Omnipool and pool's balance has sufficient amount.
   *
   * Only `AuthorityOrigin` can perform this operation.
   *
   * Emits `AssetRefunded`
   **/
  | { name: 'RefundRefusedAsset'; params: { assetId: number; amount: bigint; recipient: AccountId32Like } }
  /**
   * Update asset's weight cap
   *
   * Parameters:
   * - `asset_id`: asset id
   * - `cap`: new weight cap
   *
   * Emits `AssetWeightCapUpdated` event when successful.
   *
   **/
  | { name: 'SetAssetWeightCap'; params: { assetId: number; cap: Permill } }
  /**
   * Removes protocol liquidity.
   *
   * Protocol liquidity is liquidity from sacrificed positions. In order to remove protocol liquidity,
   * we need the know the price of the position at the time of sacrifice. Hence this specific call.
   *
   * Only `AuthorityOrigin` can perform this call.
   *
   * Note that sacrifice position will be deprecated in future. There is no longer a need for that.
   *
   * It works the same way as remove liquidity call, but position is temporary reconstructed.
   *
   **/
  | {
      name: 'WithdrawProtocolLiquidity';
      params: { assetId: number; amount: bigint; price: [bigint, bigint]; dest: AccountId32Like };
    }
  /**
   * Removes token from Omnipool.
   *
   * Asset's tradability must be FROZEN, otherwise `AssetNotFrozen` error is returned.
   *
   * Remaining shares must belong to protocol, otherwise `SharesRemaining` error is returned.
   *
   * Protocol's liquidity is transferred to the beneficiary account and hub asset amount is burned.
   *
   * Only `AuthorityOrigin` can perform this call.
   *
   * Emits `TokenRemoved` event when successful.
   **/
  | { name: 'RemoveToken'; params: { assetId: number; beneficiary: AccountId32Like } };

export type PalletOmnipoolTradability = { bits: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTransactionPauseCall =
  | { name: 'PauseTransaction'; params: { palletName: Bytes; functionName: Bytes } }
  | { name: 'UnpauseTransaction'; params: { palletName: Bytes; functionName: Bytes } };

export type PalletTransactionPauseCallLike =
  | { name: 'PauseTransaction'; params: { palletName: BytesLike; functionName: BytesLike } }
  | { name: 'UnpauseTransaction'; params: { palletName: BytesLike; functionName: BytesLike } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletDusterCall =
  /**
   * Dust specified account.
   * IF account balance is < min. existential deposit of given currency, and account is allowed to
   * be dusted, the remaining balance is transferred to selected account (usually treasury).
   *
   * Caller is rewarded with chosen reward in native currency.
   **/
  | { name: 'DustAccount'; params: { account: AccountId32; currencyId: number } }
  /**
   * Add account to list of non-dustable account. Account whihc are excluded from udsting.
   * If such account should be dusted - `AccountBlacklisted` error is returned.
   * Only root can perform this action.
   **/
  | { name: 'AddNondustableAccount'; params: { account: AccountId32 } }
  /**
   * Remove account from list of non-dustable accounts. That means account can be dusted again.
   **/
  | { name: 'RemoveNondustableAccount'; params: { account: AccountId32 } };

export type PalletDusterCallLike =
  /**
   * Dust specified account.
   * IF account balance is < min. existential deposit of given currency, and account is allowed to
   * be dusted, the remaining balance is transferred to selected account (usually treasury).
   *
   * Caller is rewarded with chosen reward in native currency.
   **/
  | { name: 'DustAccount'; params: { account: AccountId32Like; currencyId: number } }
  /**
   * Add account to list of non-dustable account. Account whihc are excluded from udsting.
   * If such account should be dusted - `AccountBlacklisted` error is returned.
   * Only root can perform this action.
   **/
  | { name: 'AddNondustableAccount'; params: { account: AccountId32Like } }
  /**
   * Remove account from list of non-dustable accounts. That means account can be dusted again.
   **/
  | { name: 'RemoveNondustableAccount'; params: { account: AccountId32Like } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletLiquidityMiningCall = null;

export type PalletLiquidityMiningCallLike = null;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletOmnipoolLiquidityMiningCall =
  /**
   * Create a new liquidity mining program with provided parameters.
   *
   * `owner` account has to have at least `total_rewards` balance. These funds will be
   * transferred from `owner` to farm account.
   *
   * The dispatch origin for this call must be `T::CreateOrigin`.
   * !!!WARN: `T::CreateOrigin` has power over funds of `owner`'s account and it should be
   * configured to trusted origin e.g Sudo or Governance.
   *
   * Parameters:
   * - `origin`: account allowed to create new liquidity mining program(root, governance).
   * - `total_rewards`: total rewards planned to distribute. These rewards will be
   * distributed between all yield farms in the global farm.
   * - `planned_yielding_periods`: planned number of periods to distribute `total_rewards`.
   * WARN: THIS IS NOT HARD DEADLINE. Not all rewards have to be distributed in
   * `planned_yielding_periods`. Rewards are distributed based on the situation in the yield
   * farms and can be distributed in a longer, though never in a shorter, time frame.
   * - `blocks_per_period`: number of blocks in a single period. Min. number of blocks per
   * period is 1.
   * - `reward_currency`: payoff currency of rewards.
   * - `owner`: liq. mining farm owner. This account will be able to manage created
   * liquidity mining program.
   * - `yield_per_period`: percentage return on `reward_currency` of all farms.
   * - `min_deposit`: minimum amount of LP shares to be deposited into the liquidity mining by each user.
   * - `lrna_price_adjustment`: price adjustment between `[LRNA]` and `reward_currency`.
   *
   * Emits `GlobalFarmCreated` when successful.
   *
   **/
  | {
      name: 'CreateGlobalFarm';
      params: {
        totalRewards: bigint;
        plannedYieldingPeriods: number;
        blocksPerPeriod: number;
        rewardCurrency: number;
        owner: AccountId32;
        yieldPerPeriod: Perquintill;
        minDeposit: bigint;
        lrnaPriceAdjustment: FixedU128;
      };
    }
  /**
   * Terminate existing liq. mining program.
   *
   * Only farm owner can perform this action.
   *
   * WARN: To successfully terminate a global farm, farm have to be empty
   * (all yield farms in the global farm must be terminated).
   *
   * Parameters:
   * - `origin`: global farm's owner.
   * - `global_farm_id`: id of global farm to be terminated.
   *
   * Emits `GlobalFarmTerminated` event when successful.
   *
   **/
  | { name: 'TerminateGlobalFarm'; params: { globalFarmId: number } }
  /**
   * Create yield farm for given `asset_id` in the omnipool.
   *
   * Only farm owner can perform this action.
   *
   * Asset with `asset_id` has to be registered in the omnipool.
   * At most one `active` yield farm can exist in one global farm for the same `asset_id`.
   *
   * Parameters:
   * - `origin`: global farm's owner.
   * - `global_farm_id`: global farm id to which a yield farm will be added.
   * - `asset_id`: id of a asset in the omnipool. Yield farm will be created
   * for this asset and user will be able to lock LP shares into this yield farm immediately.
   * - `multiplier`: yield farm's multiplier.
   * - `loyalty_curve`: curve to calculate loyalty multiplier to distribute rewards to users
   * with time incentive. `None` means no loyalty multiplier.
   *
   * Emits `YieldFarmCreated` event when successful.
   *
   **/
  | {
      name: 'CreateYieldFarm';
      params: {
        globalFarmId: number;
        assetId: number;
        multiplier: FixedU128;
        loyaltyCurve?: PalletLiquidityMiningLoyaltyCurve | undefined;
      };
    }
  /**
   * Update yield farm's multiplier.
   *
   * Only farm owner can perform this action.
   *
   * Parameters:
   * - `origin`: global farm's owner.
   * - `global_farm_id`: global farm id in which yield farm will be updated.
   * - `asset_id`: id of the asset identifying yield farm in the global farm.
   * - `multiplier`: new yield farm's multiplier.
   *
   * Emits `YieldFarmUpdated` event when successful.
   *
   **/
  | { name: 'UpdateYieldFarm'; params: { globalFarmId: number; assetId: number; multiplier: FixedU128 } }
  /**
   * Stop liquidity miming for specific yield farm.
   *
   * This function claims rewards from `GlobalFarm` last time and stop yield farm
   * incentivization from a `GlobalFarm`. Users will be able to only withdraw
   * shares(with claiming) after calling this function.
   * `deposit_shares()` is not allowed on stopped yield farm.
   *
   * Only farm owner can perform this action.
   *
   * Parameters:
   * - `origin`: global farm's owner.
   * - `global_farm_id`: farm id in which yield farm will be canceled.
   * - `asset_id`: id of the asset identifying yield farm in the global farm.
   *
   * Emits `YieldFarmStopped` event when successful.
   *
   **/
  | { name: 'StopYieldFarm'; params: { globalFarmId: number; assetId: number } }
  /**
   * Resume incentivization of the asset represented by yield farm.
   *
   * This function resume incentivization of the asset from the `GlobalFarm` and
   * restore full functionality or the yield farm. Users will be able to deposit,
   * claim and withdraw again.
   *
   * WARN: Yield farm(and users) is NOT rewarded for time it was stopped.
   *
   * Only farm owner can perform this action.
   *
   * Parameters:
   * - `origin`: global farm's owner.
   * - `global_farm_id`: global farm id in which yield farm will be resumed.
   * - `yield_farm_id`: id of the yield farm to be resumed.
   * - `asset_id`: id of the asset identifying yield farm in the global farm.
   * - `multiplier`: yield farm multiplier.
   *
   * Emits `YieldFarmResumed` event when successful.
   *
   **/
  | {
      name: 'ResumeYieldFarm';
      params: { globalFarmId: number; yieldFarmId: number; assetId: number; multiplier: FixedU128 };
    }
  /**
   * Terminate yield farm.
   *
   * This function marks a yield farm as ready to be removed from storage when it's empty. Users will
   * be able to only withdraw shares(without claiming rewards from yield farm). Unpaid rewards
   * will be transferred back to global farm and it will be used to distribute to other yield farms.
   *
   * Yield farm must be stopped before it can be terminated.
   *
   * Only global farm's owner can perform this action. Yield farm stays in the storage until it's
   * empty(all farm entries are withdrawn). Last withdrawn from yield farm trigger removing from
   * the storage.
   *
   * Parameters:
   * - `origin`: global farm's owner.
   * - `global_farm_id`: global farm id in which yield farm should be terminated.
   * - `yield_farm_id`: id of yield farm to be terminated.
   * - `asset_id`: id of the asset identifying yield farm.
   *
   * Emits `YieldFarmTerminated` event when successful.
   *
   **/
  | { name: 'TerminateYieldFarm'; params: { globalFarmId: number; yieldFarmId: number; assetId: number } }
  /**
   * Deposit omnipool position(LP shares) to a liquidity mining.
   *
   * This function transfers omnipool position from `origin` to pallet's account and mint NFT for
   * `origin` account. Minted NFT represents deposit in the liquidity mining. User can
   * deposit omnipool position as a whole(all the LP shares in the position).
   *
   * Parameters:
   * - `origin`: owner of the omnipool position to deposit into the liquidity mining.
   * - `global_farm_id`: id of global farm to which user wants to deposit LP shares.
   * - `yield_farm_id`: id of yield farm to deposit to.
   * - `position_id`: id of the omnipool position to be deposited into the liquidity mining.
   *
   * Emits `SharesDeposited` event when successful.
   *
   **/
  | { name: 'DepositShares'; params: { globalFarmId: number; yieldFarmId: number; positionId: bigint } }
  /**
   * Redeposit LP shares in the already locked omnipool position.
   *
   * This function create yield farm entry for existing deposit. Amount of redeposited LP
   * shares is same as amount shares which are already deposited in the deposit.
   *
   * This function DOESN'T create new deposit(NFT).
   *
   * Parameters:
   * - `origin`: owner of the deposit to redeposit.
   * - `global_farm_id`: id of the global farm to which user wants to redeposit LP shares.
   * - `yield_farm_id`: id of the yield farm to redeposit to.
   * - `deposit_id`: identifier of the deposit to redeposit.
   *
   * Emits `SharesRedeposited` event when successful.
   *
   **/
  | { name: 'RedepositShares'; params: { globalFarmId: number; yieldFarmId: number; depositId: bigint } }
  /**
   * Claim rewards from liquidity mining program for deposit represented by the `deposit_id`.
   *
   * This function calculate user rewards from liquidity mining and transfer rewards to `origin`
   * account. Claiming multiple time the same period is not allowed.
   *
   * Parameters:
   * - `origin`: owner of deposit.
   * - `deposit_id`: id of the deposit to claim rewards for.
   * - `yield_farm_id`: id of the yield farm to claim rewards from.
   *
   * Emits `RewardClaimed` event when successful.
   *
   **/
  | { name: 'ClaimRewards'; params: { depositId: bigint; yieldFarmId: number } }
  /**
   * This function claim rewards and withdraw LP shares from yield farm. Omnipool position
   * is transferred to origin only if this is last withdraw in the deposit and deposit is
   * destroyed. This function claim rewards only if yield farm is not terminated and user
   * didn't already claim rewards in current period.
   *
   * Unclaimable rewards represents rewards which user won't be able to claim because of
   * exiting early and these rewards will be transferred back to global farm for future
   * redistribution.
   *
   * Parameters:
   * - `origin`: owner of deposit.
   * - `deposit_id`: id of the deposit to claim rewards for.
   * - `yield_farm_id`: id of the yield farm to claim rewards from.
   *
   * Emits:
   * * `RewardClaimed` event if claimed rewards is > 0
   * * `SharesWithdrawn` event when successful
   * * `DepositDestroyed` event when this was last withdraw from the deposit and deposit was
   * destroyed.
   *
   **/
  | { name: 'WithdrawShares'; params: { depositId: bigint; yieldFarmId: number } }
  /**
   * This extrinsic updates global farm's main parameters.
   *
   * The dispatch origin for this call must be `T::CreateOrigin`.
   * !!!WARN: `T::CreateOrigin` has power over funds of `owner`'s account and it should be
   * configured to trusted origin e.g Sudo or Governance.
   *
   * Parameters:
   * - `origin`: account allowed to create new liquidity mining program(root, governance).
   * - `global_farm_id`: id of the global farm to update.
   * - `planned_yielding_periods`: planned number of periods to distribute `total_rewards`.
   * - `yield_per_period`: percentage return on `reward_currency` of all farms.
   * - `min_deposit`: minimum amount of LP shares to be deposited into the liquidity mining by each user.
   *
   * Emits `GlobalFarmUpdated` event when successful.
   **/
  | {
      name: 'UpdateGlobalFarm';
      params: { globalFarmId: number; plannedYieldingPeriods: number; yieldPerPeriod: Perquintill; minDeposit: bigint };
    }
  /**
   * This function allows user to join multiple farms with a single omnipool position.
   *
   * Parameters:
   * - `origin`: owner of the omnipool position to deposit into the liquidity mining.
   * - `farm_entries`: list of farms to join.
   * - `position_id`: id of the omnipool position to be deposited into the liquidity mining.
   *
   * Emits `SharesDeposited` event for the first farm entry
   * Emits `SharesRedeposited` event for each farm entry after the first one
   **/
  | { name: 'JoinFarms'; params: { farmEntries: Array<[number, number]>; positionId: bigint } }
  /**
   * This function allows user to add liquidity then use that shares to join multiple farms.
   *
   * Parameters:
   * - `origin`: owner of the omnipool position to deposit into the liquidity mining.
   * - `farm_entries`: list of farms to join.
   * - `asset`: id of the asset to be deposited into the liquidity mining.
   * - `amount`: amount of the asset to be deposited into the liquidity mining.
   * - `min_shares_limit`: The min amount of delta share asset the user should receive in the position
   *
   * Emits `SharesDeposited` event for the first farm entry
   * Emits `SharesRedeposited` event for each farm entry after the first one
   **/
  | {
      name: 'AddLiquidityAndJoinFarms';
      params: {
        farmEntries: Array<[number, number]>;
        asset: number;
        amount: bigint;
        minSharesLimit?: bigint | undefined;
      };
    }
  /**
   * Exit from all specified yield farms
   *
   * This function will attempt to withdraw shares and claim rewards (if available) from all
   * specified yield farms for a given deposit.
   *
   * Parameters:
   * - `origin`: account owner of deposit(nft).
   * - `deposit_id`: id of the deposit to claim rewards for.
   * - `yield_farm_ids`: id(s) of yield farm(s) to exit from.
   *
   * Emits:
   * * `RewardClaimed` for each successful claim
   * * `SharesWithdrawn` for each successful withdrawal
   * * `DepositDestroyed` if the deposit is fully withdrawn
   *
   **/
  | { name: 'ExitFarms'; params: { depositId: bigint; yieldFarmIds: Array<number> } }
  /**
   * This function allows user to add liquidity to stableswap pool,
   * then adding the stable shares as liquidity to omnipool
   * then use that omnipool shares to join multiple farms.
   *
   * If farm entries are not specified (empty vectoo), then the liquidities are still added to the pools
   *
   * Parameters:
   * - `origin`: owner of the omnipool position to deposit into the liquidity mining.
   * - `stable_pool_id`: id of the stableswap pool to add liquidity to.
   * - `stable_asset_amounts`: amount of each asset to be deposited into the stableswap pool.
   * - `farm_entries`: list of farms to join.
   *
   * Emits `LiquidityAdded` events from both pool
   * Emits `SharesDeposited` event for the first farm entry
   * Emits `SharesRedeposited` event for each farm entry after the first one
   *
   **/
  | {
      name: 'AddLiquidityStableswapOmnipoolAndJoinFarms';
      params: {
        stablePoolId: number;
        stableAssetAmounts: Array<HydradxTraitsStableswapAssetAmount>;
        farmEntries?: Array<[number, number]> | undefined;
      };
    };

export type PalletOmnipoolLiquidityMiningCallLike =
  /**
   * Create a new liquidity mining program with provided parameters.
   *
   * `owner` account has to have at least `total_rewards` balance. These funds will be
   * transferred from `owner` to farm account.
   *
   * The dispatch origin for this call must be `T::CreateOrigin`.
   * !!!WARN: `T::CreateOrigin` has power over funds of `owner`'s account and it should be
   * configured to trusted origin e.g Sudo or Governance.
   *
   * Parameters:
   * - `origin`: account allowed to create new liquidity mining program(root, governance).
   * - `total_rewards`: total rewards planned to distribute. These rewards will be
   * distributed between all yield farms in the global farm.
   * - `planned_yielding_periods`: planned number of periods to distribute `total_rewards`.
   * WARN: THIS IS NOT HARD DEADLINE. Not all rewards have to be distributed in
   * `planned_yielding_periods`. Rewards are distributed based on the situation in the yield
   * farms and can be distributed in a longer, though never in a shorter, time frame.
   * - `blocks_per_period`: number of blocks in a single period. Min. number of blocks per
   * period is 1.
   * - `reward_currency`: payoff currency of rewards.
   * - `owner`: liq. mining farm owner. This account will be able to manage created
   * liquidity mining program.
   * - `yield_per_period`: percentage return on `reward_currency` of all farms.
   * - `min_deposit`: minimum amount of LP shares to be deposited into the liquidity mining by each user.
   * - `lrna_price_adjustment`: price adjustment between `[LRNA]` and `reward_currency`.
   *
   * Emits `GlobalFarmCreated` when successful.
   *
   **/
  | {
      name: 'CreateGlobalFarm';
      params: {
        totalRewards: bigint;
        plannedYieldingPeriods: number;
        blocksPerPeriod: number;
        rewardCurrency: number;
        owner: AccountId32Like;
        yieldPerPeriod: Perquintill;
        minDeposit: bigint;
        lrnaPriceAdjustment: FixedU128;
      };
    }
  /**
   * Terminate existing liq. mining program.
   *
   * Only farm owner can perform this action.
   *
   * WARN: To successfully terminate a global farm, farm have to be empty
   * (all yield farms in the global farm must be terminated).
   *
   * Parameters:
   * - `origin`: global farm's owner.
   * - `global_farm_id`: id of global farm to be terminated.
   *
   * Emits `GlobalFarmTerminated` event when successful.
   *
   **/
  | { name: 'TerminateGlobalFarm'; params: { globalFarmId: number } }
  /**
   * Create yield farm for given `asset_id` in the omnipool.
   *
   * Only farm owner can perform this action.
   *
   * Asset with `asset_id` has to be registered in the omnipool.
   * At most one `active` yield farm can exist in one global farm for the same `asset_id`.
   *
   * Parameters:
   * - `origin`: global farm's owner.
   * - `global_farm_id`: global farm id to which a yield farm will be added.
   * - `asset_id`: id of a asset in the omnipool. Yield farm will be created
   * for this asset and user will be able to lock LP shares into this yield farm immediately.
   * - `multiplier`: yield farm's multiplier.
   * - `loyalty_curve`: curve to calculate loyalty multiplier to distribute rewards to users
   * with time incentive. `None` means no loyalty multiplier.
   *
   * Emits `YieldFarmCreated` event when successful.
   *
   **/
  | {
      name: 'CreateYieldFarm';
      params: {
        globalFarmId: number;
        assetId: number;
        multiplier: FixedU128;
        loyaltyCurve?: PalletLiquidityMiningLoyaltyCurve | undefined;
      };
    }
  /**
   * Update yield farm's multiplier.
   *
   * Only farm owner can perform this action.
   *
   * Parameters:
   * - `origin`: global farm's owner.
   * - `global_farm_id`: global farm id in which yield farm will be updated.
   * - `asset_id`: id of the asset identifying yield farm in the global farm.
   * - `multiplier`: new yield farm's multiplier.
   *
   * Emits `YieldFarmUpdated` event when successful.
   *
   **/
  | { name: 'UpdateYieldFarm'; params: { globalFarmId: number; assetId: number; multiplier: FixedU128 } }
  /**
   * Stop liquidity miming for specific yield farm.
   *
   * This function claims rewards from `GlobalFarm` last time and stop yield farm
   * incentivization from a `GlobalFarm`. Users will be able to only withdraw
   * shares(with claiming) after calling this function.
   * `deposit_shares()` is not allowed on stopped yield farm.
   *
   * Only farm owner can perform this action.
   *
   * Parameters:
   * - `origin`: global farm's owner.
   * - `global_farm_id`: farm id in which yield farm will be canceled.
   * - `asset_id`: id of the asset identifying yield farm in the global farm.
   *
   * Emits `YieldFarmStopped` event when successful.
   *
   **/
  | { name: 'StopYieldFarm'; params: { globalFarmId: number; assetId: number } }
  /**
   * Resume incentivization of the asset represented by yield farm.
   *
   * This function resume incentivization of the asset from the `GlobalFarm` and
   * restore full functionality or the yield farm. Users will be able to deposit,
   * claim and withdraw again.
   *
   * WARN: Yield farm(and users) is NOT rewarded for time it was stopped.
   *
   * Only farm owner can perform this action.
   *
   * Parameters:
   * - `origin`: global farm's owner.
   * - `global_farm_id`: global farm id in which yield farm will be resumed.
   * - `yield_farm_id`: id of the yield farm to be resumed.
   * - `asset_id`: id of the asset identifying yield farm in the global farm.
   * - `multiplier`: yield farm multiplier.
   *
   * Emits `YieldFarmResumed` event when successful.
   *
   **/
  | {
      name: 'ResumeYieldFarm';
      params: { globalFarmId: number; yieldFarmId: number; assetId: number; multiplier: FixedU128 };
    }
  /**
   * Terminate yield farm.
   *
   * This function marks a yield farm as ready to be removed from storage when it's empty. Users will
   * be able to only withdraw shares(without claiming rewards from yield farm). Unpaid rewards
   * will be transferred back to global farm and it will be used to distribute to other yield farms.
   *
   * Yield farm must be stopped before it can be terminated.
   *
   * Only global farm's owner can perform this action. Yield farm stays in the storage until it's
   * empty(all farm entries are withdrawn). Last withdrawn from yield farm trigger removing from
   * the storage.
   *
   * Parameters:
   * - `origin`: global farm's owner.
   * - `global_farm_id`: global farm id in which yield farm should be terminated.
   * - `yield_farm_id`: id of yield farm to be terminated.
   * - `asset_id`: id of the asset identifying yield farm.
   *
   * Emits `YieldFarmTerminated` event when successful.
   *
   **/
  | { name: 'TerminateYieldFarm'; params: { globalFarmId: number; yieldFarmId: number; assetId: number } }
  /**
   * Deposit omnipool position(LP shares) to a liquidity mining.
   *
   * This function transfers omnipool position from `origin` to pallet's account and mint NFT for
   * `origin` account. Minted NFT represents deposit in the liquidity mining. User can
   * deposit omnipool position as a whole(all the LP shares in the position).
   *
   * Parameters:
   * - `origin`: owner of the omnipool position to deposit into the liquidity mining.
   * - `global_farm_id`: id of global farm to which user wants to deposit LP shares.
   * - `yield_farm_id`: id of yield farm to deposit to.
   * - `position_id`: id of the omnipool position to be deposited into the liquidity mining.
   *
   * Emits `SharesDeposited` event when successful.
   *
   **/
  | { name: 'DepositShares'; params: { globalFarmId: number; yieldFarmId: number; positionId: bigint } }
  /**
   * Redeposit LP shares in the already locked omnipool position.
   *
   * This function create yield farm entry for existing deposit. Amount of redeposited LP
   * shares is same as amount shares which are already deposited in the deposit.
   *
   * This function DOESN'T create new deposit(NFT).
   *
   * Parameters:
   * - `origin`: owner of the deposit to redeposit.
   * - `global_farm_id`: id of the global farm to which user wants to redeposit LP shares.
   * - `yield_farm_id`: id of the yield farm to redeposit to.
   * - `deposit_id`: identifier of the deposit to redeposit.
   *
   * Emits `SharesRedeposited` event when successful.
   *
   **/
  | { name: 'RedepositShares'; params: { globalFarmId: number; yieldFarmId: number; depositId: bigint } }
  /**
   * Claim rewards from liquidity mining program for deposit represented by the `deposit_id`.
   *
   * This function calculate user rewards from liquidity mining and transfer rewards to `origin`
   * account. Claiming multiple time the same period is not allowed.
   *
   * Parameters:
   * - `origin`: owner of deposit.
   * - `deposit_id`: id of the deposit to claim rewards for.
   * - `yield_farm_id`: id of the yield farm to claim rewards from.
   *
   * Emits `RewardClaimed` event when successful.
   *
   **/
  | { name: 'ClaimRewards'; params: { depositId: bigint; yieldFarmId: number } }
  /**
   * This function claim rewards and withdraw LP shares from yield farm. Omnipool position
   * is transferred to origin only if this is last withdraw in the deposit and deposit is
   * destroyed. This function claim rewards only if yield farm is not terminated and user
   * didn't already claim rewards in current period.
   *
   * Unclaimable rewards represents rewards which user won't be able to claim because of
   * exiting early and these rewards will be transferred back to global farm for future
   * redistribution.
   *
   * Parameters:
   * - `origin`: owner of deposit.
   * - `deposit_id`: id of the deposit to claim rewards for.
   * - `yield_farm_id`: id of the yield farm to claim rewards from.
   *
   * Emits:
   * * `RewardClaimed` event if claimed rewards is > 0
   * * `SharesWithdrawn` event when successful
   * * `DepositDestroyed` event when this was last withdraw from the deposit and deposit was
   * destroyed.
   *
   **/
  | { name: 'WithdrawShares'; params: { depositId: bigint; yieldFarmId: number } }
  /**
   * This extrinsic updates global farm's main parameters.
   *
   * The dispatch origin for this call must be `T::CreateOrigin`.
   * !!!WARN: `T::CreateOrigin` has power over funds of `owner`'s account and it should be
   * configured to trusted origin e.g Sudo or Governance.
   *
   * Parameters:
   * - `origin`: account allowed to create new liquidity mining program(root, governance).
   * - `global_farm_id`: id of the global farm to update.
   * - `planned_yielding_periods`: planned number of periods to distribute `total_rewards`.
   * - `yield_per_period`: percentage return on `reward_currency` of all farms.
   * - `min_deposit`: minimum amount of LP shares to be deposited into the liquidity mining by each user.
   *
   * Emits `GlobalFarmUpdated` event when successful.
   **/
  | {
      name: 'UpdateGlobalFarm';
      params: { globalFarmId: number; plannedYieldingPeriods: number; yieldPerPeriod: Perquintill; minDeposit: bigint };
    }
  /**
   * This function allows user to join multiple farms with a single omnipool position.
   *
   * Parameters:
   * - `origin`: owner of the omnipool position to deposit into the liquidity mining.
   * - `farm_entries`: list of farms to join.
   * - `position_id`: id of the omnipool position to be deposited into the liquidity mining.
   *
   * Emits `SharesDeposited` event for the first farm entry
   * Emits `SharesRedeposited` event for each farm entry after the first one
   **/
  | { name: 'JoinFarms'; params: { farmEntries: Array<[number, number]>; positionId: bigint } }
  /**
   * This function allows user to add liquidity then use that shares to join multiple farms.
   *
   * Parameters:
   * - `origin`: owner of the omnipool position to deposit into the liquidity mining.
   * - `farm_entries`: list of farms to join.
   * - `asset`: id of the asset to be deposited into the liquidity mining.
   * - `amount`: amount of the asset to be deposited into the liquidity mining.
   * - `min_shares_limit`: The min amount of delta share asset the user should receive in the position
   *
   * Emits `SharesDeposited` event for the first farm entry
   * Emits `SharesRedeposited` event for each farm entry after the first one
   **/
  | {
      name: 'AddLiquidityAndJoinFarms';
      params: {
        farmEntries: Array<[number, number]>;
        asset: number;
        amount: bigint;
        minSharesLimit?: bigint | undefined;
      };
    }
  /**
   * Exit from all specified yield farms
   *
   * This function will attempt to withdraw shares and claim rewards (if available) from all
   * specified yield farms for a given deposit.
   *
   * Parameters:
   * - `origin`: account owner of deposit(nft).
   * - `deposit_id`: id of the deposit to claim rewards for.
   * - `yield_farm_ids`: id(s) of yield farm(s) to exit from.
   *
   * Emits:
   * * `RewardClaimed` for each successful claim
   * * `SharesWithdrawn` for each successful withdrawal
   * * `DepositDestroyed` if the deposit is fully withdrawn
   *
   **/
  | { name: 'ExitFarms'; params: { depositId: bigint; yieldFarmIds: Array<number> } }
  /**
   * This function allows user to add liquidity to stableswap pool,
   * then adding the stable shares as liquidity to omnipool
   * then use that omnipool shares to join multiple farms.
   *
   * If farm entries are not specified (empty vectoo), then the liquidities are still added to the pools
   *
   * Parameters:
   * - `origin`: owner of the omnipool position to deposit into the liquidity mining.
   * - `stable_pool_id`: id of the stableswap pool to add liquidity to.
   * - `stable_asset_amounts`: amount of each asset to be deposited into the stableswap pool.
   * - `farm_entries`: list of farms to join.
   *
   * Emits `LiquidityAdded` events from both pool
   * Emits `SharesDeposited` event for the first farm entry
   * Emits `SharesRedeposited` event for each farm entry after the first one
   *
   **/
  | {
      name: 'AddLiquidityStableswapOmnipoolAndJoinFarms';
      params: {
        stablePoolId: number;
        stableAssetAmounts: Array<HydradxTraitsStableswapAssetAmount>;
        farmEntries?: Array<[number, number]> | undefined;
      };
    };

export type PalletLiquidityMiningLoyaltyCurve = { initialRewardPercentage: FixedU128; scaleCoef: number };

export type HydradxTraitsStableswapAssetAmount = { assetId: number; amount: bigint };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletOtcCall =
  /**
   * Create a new OTC order
   *
   * Parameters:
   * - `asset_in`: Asset which is being bought
   * - `asset_out`: Asset which is being sold
   * - `amount_in`: Amount that the order is seeking to buy
   * - `amount_out`: Amount that the order is selling
   * - `partially_fillable`: Flag indicating whether users can fill the order partially
   *
   * Validations:
   * - asset_in must be registered
   * - amount_in must be higher than the existential deposit of asset_in multiplied by
   * ExistentialDepositMultiplier
   * - amount_out must be higher than the existential deposit of asset_out multiplied by
   * ExistentialDepositMultiplier
   *
   * Events:
   * - `Placed` event when successful.
   **/
  | {
      name: 'PlaceOrder';
      params: { assetIn: number; assetOut: number; amountIn: bigint; amountOut: bigint; partiallyFillable: boolean };
    }
  /**
   * Fill an OTC order (partially)
   *
   * Parameters:
   * - `order_id`: ID of the order
   * - `amount_in`: Amount with which the order is being filled
   *
   * Validations:
   * - order must be partially_fillable
   * - after the partial_fill, the remaining order.amount_in must be higher than the existential deposit
   * of asset_in multiplied by ExistentialDepositMultiplier
   * - after the partial_fill, the remaining order.amount_out must be higher than the existential deposit
   * of asset_out multiplied by ExistentialDepositMultiplier
   *
   * Events:
   * `PartiallyFilled` event when successful. Deprecated.
   * `pallet_broadcast::Swapped` event when successful.
   **/
  | { name: 'PartialFillOrder'; params: { orderId: number; amountIn: bigint } }
  /**
   * Fill an OTC order (completely)
   *
   * Parameters:
   * - `order_id`: ID of the order
   *
   * Events:
   * `Filled` event when successful. Deprecated.
   * `pallet_broadcast::Swapped` event when successful.
   **/
  | { name: 'FillOrder'; params: { orderId: number } }
  /**
   * Cancel an open OTC order
   *
   * Parameters:
   * - `order_id`: ID of the order
   * - `asset`: Asset which is being filled
   * - `amount`: Amount which is being filled
   *
   * Validations:
   * - caller is order owner
   *
   * Emits `Cancelled` event when successful.
   **/
  | { name: 'CancelOrder'; params: { orderId: number } };

export type PalletOtcCallLike =
  /**
   * Create a new OTC order
   *
   * Parameters:
   * - `asset_in`: Asset which is being bought
   * - `asset_out`: Asset which is being sold
   * - `amount_in`: Amount that the order is seeking to buy
   * - `amount_out`: Amount that the order is selling
   * - `partially_fillable`: Flag indicating whether users can fill the order partially
   *
   * Validations:
   * - asset_in must be registered
   * - amount_in must be higher than the existential deposit of asset_in multiplied by
   * ExistentialDepositMultiplier
   * - amount_out must be higher than the existential deposit of asset_out multiplied by
   * ExistentialDepositMultiplier
   *
   * Events:
   * - `Placed` event when successful.
   **/
  | {
      name: 'PlaceOrder';
      params: { assetIn: number; assetOut: number; amountIn: bigint; amountOut: bigint; partiallyFillable: boolean };
    }
  /**
   * Fill an OTC order (partially)
   *
   * Parameters:
   * - `order_id`: ID of the order
   * - `amount_in`: Amount with which the order is being filled
   *
   * Validations:
   * - order must be partially_fillable
   * - after the partial_fill, the remaining order.amount_in must be higher than the existential deposit
   * of asset_in multiplied by ExistentialDepositMultiplier
   * - after the partial_fill, the remaining order.amount_out must be higher than the existential deposit
   * of asset_out multiplied by ExistentialDepositMultiplier
   *
   * Events:
   * `PartiallyFilled` event when successful. Deprecated.
   * `pallet_broadcast::Swapped` event when successful.
   **/
  | { name: 'PartialFillOrder'; params: { orderId: number; amountIn: bigint } }
  /**
   * Fill an OTC order (completely)
   *
   * Parameters:
   * - `order_id`: ID of the order
   *
   * Events:
   * `Filled` event when successful. Deprecated.
   * `pallet_broadcast::Swapped` event when successful.
   **/
  | { name: 'FillOrder'; params: { orderId: number } }
  /**
   * Cancel an open OTC order
   *
   * Parameters:
   * - `order_id`: ID of the order
   * - `asset`: Asset which is being filled
   * - `amount`: Amount which is being filled
   *
   * Validations:
   * - caller is order owner
   *
   * Emits `Cancelled` event when successful.
   **/
  | { name: 'CancelOrder'; params: { orderId: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletCircuitBreakerCall =
  /**
   * Set trade volume limit for an asset.
   *
   * Parameters:
   * - `origin`: The dispatch origin for this call. Must be `UpdateLimitsOrigin`
   * - `asset_id`: The identifier of an asset
   * - `trade_volume_limit`: New trade volume limit represented as a percentage
   *
   * Emits `TradeVolumeLimitChanged` event when successful.
   *
   **/
  | { name: 'SetTradeVolumeLimit'; params: { assetId: number; tradeVolumeLimit: [number, number] } }
  /**
   * Set add liquidity limit for an asset.
   *
   * Parameters:
   * - `origin`: The dispatch origin for this call. Must be `UpdateLimitsOrigin`
   * - `asset_id`: The identifier of an asset
   * - `liquidity_limit`: Optional add liquidity limit represented as a percentage
   *
   * Emits `AddLiquidityLimitChanged` event when successful.
   *
   **/
  | { name: 'SetAddLiquidityLimit'; params: { assetId: number; liquidityLimit?: [number, number] | undefined } }
  /**
   * Set remove liquidity limit for an asset.
   *
   * Parameters:
   * - `origin`: The dispatch origin for this call. Must be `UpdateLimitsOrigin`
   * - `asset_id`: The identifier of an asset
   * - `liquidity_limit`: Optional remove liquidity limit represented as a percentage
   *
   * Emits `RemoveLiquidityLimitChanged` event when successful.
   *
   **/
  | { name: 'SetRemoveLiquidityLimit'; params: { assetId: number; liquidityLimit?: [number, number] | undefined } };

export type PalletCircuitBreakerCallLike =
  /**
   * Set trade volume limit for an asset.
   *
   * Parameters:
   * - `origin`: The dispatch origin for this call. Must be `UpdateLimitsOrigin`
   * - `asset_id`: The identifier of an asset
   * - `trade_volume_limit`: New trade volume limit represented as a percentage
   *
   * Emits `TradeVolumeLimitChanged` event when successful.
   *
   **/
  | { name: 'SetTradeVolumeLimit'; params: { assetId: number; tradeVolumeLimit: [number, number] } }
  /**
   * Set add liquidity limit for an asset.
   *
   * Parameters:
   * - `origin`: The dispatch origin for this call. Must be `UpdateLimitsOrigin`
   * - `asset_id`: The identifier of an asset
   * - `liquidity_limit`: Optional add liquidity limit represented as a percentage
   *
   * Emits `AddLiquidityLimitChanged` event when successful.
   *
   **/
  | { name: 'SetAddLiquidityLimit'; params: { assetId: number; liquidityLimit?: [number, number] | undefined } }
  /**
   * Set remove liquidity limit for an asset.
   *
   * Parameters:
   * - `origin`: The dispatch origin for this call. Must be `UpdateLimitsOrigin`
   * - `asset_id`: The identifier of an asset
   * - `liquidity_limit`: Optional remove liquidity limit represented as a percentage
   *
   * Emits `RemoveLiquidityLimitChanged` event when successful.
   *
   **/
  | { name: 'SetRemoveLiquidityLimit'; params: { assetId: number; liquidityLimit?: [number, number] | undefined } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletRouteExecutorCall =
  /**
   * Executes a sell with a series of trades specified in the route.
   * The price for each trade is determined by the corresponding AMM.
   *
   * - `origin`: The executor of the trade
   * - `asset_in`: The identifier of the asset to sell
   * - `asset_out`: The identifier of the asset to receive
   * - `amount_in`: The amount of `asset_in` to sell
   * - `min_amount_out`: The minimum amount of `asset_out` to receive.
   * - `route`: Series of [`Trade<AssetId>`] to be executed. A [`Trade<AssetId>`] specifies the asset pair (`asset_in`, `asset_out`) and the AMM (`pool`) in which the trade is executed.
   * If not specified, than the on-chain route is used.
   * If no on-chain is present, then omnipool route is used as default
   *
   * Emits `RouteExecuted` when successful.
   **/
  | {
      name: 'Sell';
      params: {
        assetIn: number;
        assetOut: number;
        amountIn: bigint;
        minAmountOut: bigint;
        route: Array<HydradxTraitsRouterTrade>;
      };
    }
  /**
   * Executes a buy with a series of trades specified in the route.
   * The price for each trade is determined by the corresponding AMM.
   *
   * - `origin`: The executor of the trade
   * - `asset_in`: The identifier of the asset to be swapped to buy `asset_out`
   * - `asset_out`: The identifier of the asset to buy
   * - `amount_out`: The amount of `asset_out` to buy
   * - `max_amount_in`: The max amount of `asset_in` to spend on the buy.
   * - `route`: Series of [`Trade<AssetId>`] to be executed. A [`Trade<AssetId>`] specifies the asset pair (`asset_in`, `asset_out`) and the AMM (`pool`) in which the trade is executed.
   * If not specified, than the on-chain route is used.
   * If no on-chain is present, then omnipool route is used as default
   *
   * Emits `RouteExecuted` when successful.
   **/
  | {
      name: 'Buy';
      params: {
        assetIn: number;
        assetOut: number;
        amountOut: bigint;
        maxAmountIn: bigint;
        route: Array<HydradxTraitsRouterTrade>;
      };
    }
  /**
   * Sets the on-chain route for a given asset pair.
   *
   * The new route is validated by being executed in a dry-run mode
   *
   * If there is no route explicitly set for an asset pair, then we use the omnipool route as default.
   *
   * When a new route is set, we compare it to the existing (or default) route.
   * The comparison happens by calculating sell amount_outs for the routes, but also for the inversed routes.
   *
   * The route is stored in an ordered manner, based on the oder of the ids in the asset pair.
   *
   * If the route is set successfully, then the fee is payed back.
   *
   * - `origin`: The origin of the route setter
   * - `asset_pair`: The identifier of the asset-pair for which the route is set
   * - `new_route`: Series of [`Trade<AssetId>`] to be executed. A [`Trade<AssetId>`] specifies the asset pair (`asset_in`, `asset_out`) and the AMM (`pool`) in which the trade is executed.
   *
   * Emits `RouteUpdated` when successful.
   *
   * Fails with `RouteUpdateIsNotSuccessful` error when failed to set the route
   *
   **/
  | { name: 'SetRoute'; params: { assetPair: HydradxTraitsRouterAssetPair; newRoute: Array<HydradxTraitsRouterTrade> } }
  /**
   * Force inserts the on-chain route for a given asset pair, so there is no any validation for the route
   *
   * Can only be called by T::ForceInsertOrigin
   *
   * The route is stored in an ordered manner, based on the oder of the ids in the asset pair.
   *
   * If the route is set successfully, then the fee is payed back.
   *
   * - `origin`: The origin of the route setter
   * - `asset_pair`: The identifier of the asset-pair for which the route is set
   * - `new_route`: Series of [`Trade<AssetId>`] to be executed. A [`Trade<AssetId>`] specifies the asset pair (`asset_in`, `asset_out`) and the AMM (`pool`) in which the trade is executed.
   *
   * Emits `RouteUpdated` when successful.
   *
   **/
  | {
      name: 'ForceInsertRoute';
      params: { assetPair: HydradxTraitsRouterAssetPair; newRoute: Array<HydradxTraitsRouterTrade> };
    }
  /**
   * Executes a sell with a series of trades specified in the route.
   * It sells all reducible user balance of `asset_in`
   * The price for each trade is determined by the corresponding AMM.
   *
   * - `origin`: The executor of the trade
   * - `asset_in`: The identifier of the asset to sell
   * - `asset_out`: The identifier of the asset to receive
   * - `min_amount_out`: The minimum amount of `asset_out` to receive.
   * - `route`: Series of [`Trade<AssetId>`] to be executed. A [`Trade<AssetId>`] specifies the asset pair (`asset_in`, `asset_out`) and the AMM (`pool`) in which the trade is executed.
   * If not specified, than the on-chain route is used.
   * If no on-chain is present, then omnipool route is used as default
   *
   * Emits `RouteExecuted` when successful.
   *
   **/
  | {
      name: 'SellAll';
      params: { assetIn: number; assetOut: number; minAmountOut: bigint; route: Array<HydradxTraitsRouterTrade> };
    };

export type PalletRouteExecutorCallLike =
  /**
   * Executes a sell with a series of trades specified in the route.
   * The price for each trade is determined by the corresponding AMM.
   *
   * - `origin`: The executor of the trade
   * - `asset_in`: The identifier of the asset to sell
   * - `asset_out`: The identifier of the asset to receive
   * - `amount_in`: The amount of `asset_in` to sell
   * - `min_amount_out`: The minimum amount of `asset_out` to receive.
   * - `route`: Series of [`Trade<AssetId>`] to be executed. A [`Trade<AssetId>`] specifies the asset pair (`asset_in`, `asset_out`) and the AMM (`pool`) in which the trade is executed.
   * If not specified, than the on-chain route is used.
   * If no on-chain is present, then omnipool route is used as default
   *
   * Emits `RouteExecuted` when successful.
   **/
  | {
      name: 'Sell';
      params: {
        assetIn: number;
        assetOut: number;
        amountIn: bigint;
        minAmountOut: bigint;
        route: Array<HydradxTraitsRouterTrade>;
      };
    }
  /**
   * Executes a buy with a series of trades specified in the route.
   * The price for each trade is determined by the corresponding AMM.
   *
   * - `origin`: The executor of the trade
   * - `asset_in`: The identifier of the asset to be swapped to buy `asset_out`
   * - `asset_out`: The identifier of the asset to buy
   * - `amount_out`: The amount of `asset_out` to buy
   * - `max_amount_in`: The max amount of `asset_in` to spend on the buy.
   * - `route`: Series of [`Trade<AssetId>`] to be executed. A [`Trade<AssetId>`] specifies the asset pair (`asset_in`, `asset_out`) and the AMM (`pool`) in which the trade is executed.
   * If not specified, than the on-chain route is used.
   * If no on-chain is present, then omnipool route is used as default
   *
   * Emits `RouteExecuted` when successful.
   **/
  | {
      name: 'Buy';
      params: {
        assetIn: number;
        assetOut: number;
        amountOut: bigint;
        maxAmountIn: bigint;
        route: Array<HydradxTraitsRouterTrade>;
      };
    }
  /**
   * Sets the on-chain route for a given asset pair.
   *
   * The new route is validated by being executed in a dry-run mode
   *
   * If there is no route explicitly set for an asset pair, then we use the omnipool route as default.
   *
   * When a new route is set, we compare it to the existing (or default) route.
   * The comparison happens by calculating sell amount_outs for the routes, but also for the inversed routes.
   *
   * The route is stored in an ordered manner, based on the oder of the ids in the asset pair.
   *
   * If the route is set successfully, then the fee is payed back.
   *
   * - `origin`: The origin of the route setter
   * - `asset_pair`: The identifier of the asset-pair for which the route is set
   * - `new_route`: Series of [`Trade<AssetId>`] to be executed. A [`Trade<AssetId>`] specifies the asset pair (`asset_in`, `asset_out`) and the AMM (`pool`) in which the trade is executed.
   *
   * Emits `RouteUpdated` when successful.
   *
   * Fails with `RouteUpdateIsNotSuccessful` error when failed to set the route
   *
   **/
  | { name: 'SetRoute'; params: { assetPair: HydradxTraitsRouterAssetPair; newRoute: Array<HydradxTraitsRouterTrade> } }
  /**
   * Force inserts the on-chain route for a given asset pair, so there is no any validation for the route
   *
   * Can only be called by T::ForceInsertOrigin
   *
   * The route is stored in an ordered manner, based on the oder of the ids in the asset pair.
   *
   * If the route is set successfully, then the fee is payed back.
   *
   * - `origin`: The origin of the route setter
   * - `asset_pair`: The identifier of the asset-pair for which the route is set
   * - `new_route`: Series of [`Trade<AssetId>`] to be executed. A [`Trade<AssetId>`] specifies the asset pair (`asset_in`, `asset_out`) and the AMM (`pool`) in which the trade is executed.
   *
   * Emits `RouteUpdated` when successful.
   *
   **/
  | {
      name: 'ForceInsertRoute';
      params: { assetPair: HydradxTraitsRouterAssetPair; newRoute: Array<HydradxTraitsRouterTrade> };
    }
  /**
   * Executes a sell with a series of trades specified in the route.
   * It sells all reducible user balance of `asset_in`
   * The price for each trade is determined by the corresponding AMM.
   *
   * - `origin`: The executor of the trade
   * - `asset_in`: The identifier of the asset to sell
   * - `asset_out`: The identifier of the asset to receive
   * - `min_amount_out`: The minimum amount of `asset_out` to receive.
   * - `route`: Series of [`Trade<AssetId>`] to be executed. A [`Trade<AssetId>`] specifies the asset pair (`asset_in`, `asset_out`) and the AMM (`pool`) in which the trade is executed.
   * If not specified, than the on-chain route is used.
   * If no on-chain is present, then omnipool route is used as default
   *
   * Emits `RouteExecuted` when successful.
   *
   **/
  | {
      name: 'SellAll';
      params: { assetIn: number; assetOut: number; minAmountOut: bigint; route: Array<HydradxTraitsRouterTrade> };
    };

export type HydradxTraitsRouterTrade = { pool: HydradxTraitsRouterPoolType; assetIn: number; assetOut: number };

export type HydradxTraitsRouterPoolType =
  | { type: 'Xyk' }
  | { type: 'Lbp' }
  | { type: 'Stableswap'; value: number }
  | { type: 'Omnipool' }
  | { type: 'Aave' }
  | { type: 'Hsm' };

export type HydradxTraitsRouterAssetPair = { assetIn: number; assetOut: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletDynamicFeesCall = null;

export type PalletDynamicFeesCallLike = null;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletStakingCall =
  /**
   * Staking pallet initialization. This call will reserved `pot`'s balance to prevent
   * account dusting and start collecting fees from trades as rewards.
   *
   * `pot`s account has to have a balance which will be reserved to prevent account dusting.
   *
   * Emits `StakingInitialized` event when successful.
   *
   **/
  | { name: 'InitializeStaking' }
  /**
   * Stake `amount` into a new staking position.
   *
   * `stake` locks specified `amount` into staking and creates new NFT representing staking
   * position.
   * Users can stake `NativeAssetId` balance which is not vested or already staked.
   *
   * Staking pallet must be initialized otherwise extrinsic will fail with error.
   *
   * Parameters:
   * - `amount`: Amount of native asset to be staked. `amount` can't be vested or already
   * staked
   *
   * Emits `PositionCreated` event when successful.
   *
   **/
  | { name: 'Stake'; params: { amount: bigint } }
  /**
   * Extrinsic to increase staked amount of existing staking position by specified `amount`.
   *
   * `increase_stake` increases staked amount of position specified by `postion_id` by the
   * `amount` specified by the user.
   * Staking position must exist and `origin` has to be the owner of the position.
   * Users can stake tokens which are not vested or already staked.
   * Position's params e.g points are updated to offset stake increase and rewards
   * accumulated until this point are paid and locked to the user.
   *
   * Parameters:
   * - `position_id`: The identifier of the position which stake will be increased.
   * - `amount`: Amount of native asset to be added to staked amount. `amount` can't be vested or
   * already staked
   *
   * Emits `StakeAdded` event when successful.
   *
   **/
  | { name: 'IncreaseStake'; params: { positionId: bigint; amount: bigint } }
  /**
   * Claim rewards accumulated for specific staking position.
   *
   * Function calculates amount of rewards to pay for specified staking position based on
   * the amount of points position accumulated. Function also unlocks all the rewards locked
   * from `increase_stake` based on the amount of the points.
   *
   * This action is penalized by removing all the points and returning allocated unpaid rewards
   * for redistribution.
   *
   * Parameters:
   * - `position_id`: The identifier of the position to claim rewards for.
   *
   * Emits `RewardsClaimed` event when successful.
   *
   **/
  | { name: 'Claim'; params: { positionId: bigint } }
  /**
   * Function pays rewards, unlocks all the staked assets and destroys staking position
   * specified by `position_id`.
   *
   * Function calculates and pays latest rewards, unlocks all the locked rewards and staked
   * tokens for staking position and burns NFT representing staking position.
   * Unpaid allocated rewards are returned to the Staking for redistribution.
   *
   * Parameters:
   * - `position_id`: The identifier of the position to be destroyed.
   *
   * Emits `RewardsClaimed` and `Unstaked` events when successful.
   *
   **/
  | { name: 'Unstake'; params: { positionId: bigint } };

export type PalletStakingCallLike =
  /**
   * Staking pallet initialization. This call will reserved `pot`'s balance to prevent
   * account dusting and start collecting fees from trades as rewards.
   *
   * `pot`s account has to have a balance which will be reserved to prevent account dusting.
   *
   * Emits `StakingInitialized` event when successful.
   *
   **/
  | { name: 'InitializeStaking' }
  /**
   * Stake `amount` into a new staking position.
   *
   * `stake` locks specified `amount` into staking and creates new NFT representing staking
   * position.
   * Users can stake `NativeAssetId` balance which is not vested or already staked.
   *
   * Staking pallet must be initialized otherwise extrinsic will fail with error.
   *
   * Parameters:
   * - `amount`: Amount of native asset to be staked. `amount` can't be vested or already
   * staked
   *
   * Emits `PositionCreated` event when successful.
   *
   **/
  | { name: 'Stake'; params: { amount: bigint } }
  /**
   * Extrinsic to increase staked amount of existing staking position by specified `amount`.
   *
   * `increase_stake` increases staked amount of position specified by `postion_id` by the
   * `amount` specified by the user.
   * Staking position must exist and `origin` has to be the owner of the position.
   * Users can stake tokens which are not vested or already staked.
   * Position's params e.g points are updated to offset stake increase and rewards
   * accumulated until this point are paid and locked to the user.
   *
   * Parameters:
   * - `position_id`: The identifier of the position which stake will be increased.
   * - `amount`: Amount of native asset to be added to staked amount. `amount` can't be vested or
   * already staked
   *
   * Emits `StakeAdded` event when successful.
   *
   **/
  | { name: 'IncreaseStake'; params: { positionId: bigint; amount: bigint } }
  /**
   * Claim rewards accumulated for specific staking position.
   *
   * Function calculates amount of rewards to pay for specified staking position based on
   * the amount of points position accumulated. Function also unlocks all the rewards locked
   * from `increase_stake` based on the amount of the points.
   *
   * This action is penalized by removing all the points and returning allocated unpaid rewards
   * for redistribution.
   *
   * Parameters:
   * - `position_id`: The identifier of the position to claim rewards for.
   *
   * Emits `RewardsClaimed` event when successful.
   *
   **/
  | { name: 'Claim'; params: { positionId: bigint } }
  /**
   * Function pays rewards, unlocks all the staked assets and destroys staking position
   * specified by `position_id`.
   *
   * Function calculates and pays latest rewards, unlocks all the locked rewards and staked
   * tokens for staking position and burns NFT representing staking position.
   * Unpaid allocated rewards are returned to the Staking for redistribution.
   *
   * Parameters:
   * - `position_id`: The identifier of the position to be destroyed.
   *
   * Emits `RewardsClaimed` and `Unstaked` events when successful.
   *
   **/
  | { name: 'Unstake'; params: { positionId: bigint } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletStableswapCall =
  /**
   * Create a stable pool with given list of assets.
   *
   * All assets must be correctly registered in `T::AssetRegistry`.
   * Note that this does not seed the pool with liquidity. Use `add_assets_liquidity` to provide
   * initial liquidity.
   *
   * Parameters:
   * - `origin`: Must be T::AuthorityOrigin
   * - `share_asset`: Preregistered share asset identifier
   * - `assets`: List of Asset ids
   * - `amplification`: Pool amplification
   * - `fee`: fee to be applied on trade and liquidity operations
   *
   * Emits `PoolCreated` event if successful.
   **/
  | { name: 'CreatePool'; params: { shareAsset: number; assets: Array<number>; amplification: number; fee: Permill } }
  /**
   * Update pool's fee.
   *
   * if pool does not exist, `PoolNotFound` is returned.
   *
   * Parameters:
   * - `origin`: Must be T::AuthorityOrigin
   * - `pool_id`: pool to update
   * - `fee`: new pool fee
   *
   * Emits `FeeUpdated` event if successful.
   **/
  | { name: 'UpdatePoolFee'; params: { poolId: number; fee: Permill } }
  /**
   * Update pool's amplification.
   *
   * Parameters:
   * - `origin`: Must be T::AuthorityOrigin
   * - `pool_id`: pool to update
   * - `final_amplification`: new desired pool amplification
   * - `start_block`: block number when the amplification starts to move towards final_amplication
   * - `end_block`: block number when the amplification reaches final_amplification
   *
   * Emits `AmplificationUpdated` event if successful.
   **/
  | {
      name: 'UpdateAmplification';
      params: { poolId: number; finalAmplification: number; startBlock: number; endBlock: number };
    }
  /**
   * Add liquidity to selected pool.
   *
   * Use `add_assets_liquidity` instead.
   * This extrinsics will be removed in the future.
   *
   * First call of `add_liquidity` must provide "initial liquidity" of all assets.
   *
   * If there is liquidity already in the pool, LP can provide liquidity of any number of pool assets.
   *
   * LP must have sufficient amount of each asset.
   *
   * Origin is given corresponding amount of shares.
   *
   * Parameters:
   * - `origin`: liquidity provider
   * - `pool_id`: Pool Id
   * - `assets`: asset id and liquidity amount provided
   *
   * Emits `LiquidityAdded` event when successful.
   * Emits `pallet_broadcast::Swapped` event when successful.
   **/
  | { name: 'AddLiquidity'; params: { poolId: number; assets: Array<HydradxTraitsStableswapAssetAmount> } }
  /**
   * Add liquidity to selected pool given exact amount of shares to receive.
   *
   * Similar to `add_liquidity` but LP specifies exact amount of shares to receive.
   *
   * This functionality is used mainly by on-chain routing when a swap between Omnipool asset and stable asset is performed.
   *
   * Parameters:
   * - `origin`: liquidity provider
   * - `pool_id`: Pool Id
   * - `shares`: amount of shares to receive
   * - `asset_id`: asset id of an asset to provide as liquidity
   * - `max_asset_amount`: slippage limit. Max amount of asset.
   *
   * Emits `LiquidityAdded` event when successful.
   * Emits `pallet_broadcast::Swapped` event when successful.
   **/
  | { name: 'AddLiquidityShares'; params: { poolId: number; shares: bigint; assetId: number; maxAssetAmount: bigint } }
  /**
   * Remove liquidity from selected pool.
   *
   * Withdraws liquidity of selected asset from a pool.
   *
   * Share amount is burned and LP receives corresponding amount of chosen asset.
   *
   * Withdraw fee is applied to the asset amount.
   *
   * Parameters:
   * - `origin`: liquidity provider
   * - `pool_id`: Pool Id
   * - `asset_id`: id of asset to receive
   * - 'share_amount': amount of shares to withdraw
   * - 'min_amount_out': minimum amount to receive
   *
   * Emits `LiquidityRemoved` event when successful.
   * Emits `pallet_broadcast::Swapped` event when successful.
   **/
  | {
      name: 'RemoveLiquidityOneAsset';
      params: { poolId: number; assetId: number; shareAmount: bigint; minAmountOut: bigint };
    }
  /**
   * Remove liquidity from selected pool by specifying exact amount of asset to receive.
   *
   * Similar to `remove_liquidity_one_asset` but LP specifies exact amount of asset to receive instead of share amount.
   *
   * Parameters:
   * - `origin`: liquidity provider
   * - `pool_id`: Pool Id
   * - `asset_id`: id of asset to receive
   * - 'amount': amount of asset to receive
   * - 'max_share_amount': Slippage limit. Max amount of shares to burn.
   *
   * Emits `LiquidityRemoved` event when successful.
   * Emits `pallet_broadcast::Swapped` event when successful.
   **/
  | { name: 'WithdrawAssetAmount'; params: { poolId: number; assetId: number; amount: bigint; maxShareAmount: bigint } }
  /**
   * Execute a swap of `asset_in` for `asset_out`.
   *
   * Parameters:
   * - `origin`: origin of the caller
   * - `pool_id`: Id of a pool
   * - `asset_in`: ID of asset sold to the pool
   * - `asset_out`: ID of asset bought from the pool
   * - `amount_in`: Amount of asset to be sold to the pool
   * - `min_buy_amount`: Minimum amount required to receive
   *
   * Emits `SellExecuted` event when successful. Deprecated.
   * Emits `pallet_broadcast::Swapped` event when successful.
   *
   **/
  | {
      name: 'Sell';
      params: { poolId: number; assetIn: number; assetOut: number; amountIn: bigint; minBuyAmount: bigint };
    }
  /**
   * Execute a swap of `asset_out` for `asset_in`.
   *
   * Parameters:
   * - `origin`:
   * - `pool_id`: Id of a pool
   * - `asset_out`: ID of asset bought from the pool
   * - `asset_in`: ID of asset sold to the pool
   * - `amount_out`: Amount of asset to receive from the pool
   * - `max_sell_amount`: Maximum amount allowed to be sold
   *
   * Emits `BuyExecuted` event when successful. Deprecated.
   * Emits `pallet_broadcast::Swapped` event when successful.
   *
   **/
  | {
      name: 'Buy';
      params: { poolId: number; assetOut: number; assetIn: number; amountOut: bigint; maxSellAmount: bigint };
    }
  /**
   * Update the tradable state of a specific asset in a pool.
   *
   * This function allows updating the tradability state of an asset within a pool. The tradability state determines whether the asset can be used for specific operations such as adding liquidity, removing liquidity, buying, or selling.
   *
   * Parameters:
   * - `origin`: Must be `T::UpdateTradabilityOrigin`.
   * - `pool_id`: The ID of the pool containing the asset.
   * - `asset_id`: The ID of the asset whose tradability state is to be updated.
   * - `state`: The new tradability state of the asset.
   *
   * Emits `TradableStateUpdated` event when successful.
   *
   * # Errors
   * - `PoolNotFound`: If the specified pool does not exist.
   * - `AssetNotInPool`: If the specified asset is not part of the pool.
   *
   **/
  | { name: 'SetAssetTradableState'; params: { poolId: number; assetId: number; state: PalletStableswapTradability } }
  /**
   * Remove liquidity from a selected pool uniformly.
   *
   * This function allows a liquidity provider to withdraw liquidity from a pool.
   * The provider specifies the amount of shares to burn and the minimum amounts of each asset to receive.
   *
   * Parameters:
   * - `origin`: The liquidity provider.
   * - `pool_id`: The ID of the pool from which to remove liquidity.
   * - `share_amount`: The amount of shares to burn.
   * - `min_amounts_out`: A bounded vector specifying the minimum amounts of each asset to receive.
   *
   * Emits `LiquidityRemoved` event when successful.
   * Emits `pallet_broadcast::Swapped` event when successful.
   *
   * # Errors
   * - `InvalidAssetAmount`: If the `share_amount` is zero.
   * - `InsufficientShares`: If the provider does not have enough shares.
   * - `PoolNotFound`: If the specified pool does not exist.
   * - `UnknownDecimals`: If the asset decimals cannot be retrieved.
   * - `IncorrectAssets`: If the provided `min_amounts_out` does not match the pool assets.
   * - `NotAllowed`: If the asset is not allowed for the operation.
   * - `SlippageLimit`: If the amount received is less than the specified minimum amount.
   * - `InsufficientLiquidityRemaining`: If the remaining liquidity in the pool is below the minimum required.
   *
   * # Invariants
   * - Ensures that the pool's reserves are updated correctly after liquidity removal.
   * - Ensures that the pool's invariant is maintained.
   **/
  | {
      name: 'RemoveLiquidity';
      params: { poolId: number; shareAmount: bigint; minAmountsOut: Array<HydradxTraitsStableswapAssetAmount> };
    }
  /**
   * Create a stable pool with a given list of assets and pegs.
   *
   * This function allows the creation of a new stable pool with specified assets, amplification, fee, and peg sources. The pool is identified by a share asset.
   *
   * Peg target price is determined by retrieving the target peg from the oracle - it is the price of the asset from the peg sourcedenominated in the other pool assets.
   *
   * Parameters:
   * - `origin`: Must be `T::AuthorityOrigin`.
   * - `share_asset`: Preregistered share asset identifier.
   * - `assets`: List of asset IDs to be included in the pool.
   * - `amplification`: Pool amplification parameter.
   * - `fee`: Fee to be applied on trade and liquidity operations.
   * - `peg_source`: Bounded vector specifying the source of the peg for each asset.
   * - `max_peg_update`: Maximum allowed peg update per block.
   *
   * Emits `PoolCreated` event if successful.
   * Emits `AmplificationChanging` event if successful.
   *
   * # Errors
   * - `IncorrectAssets`: If the assets are the same or less than 2 assets are provided.
   * - `MaxAssetsExceeded`: If the maximum number of assets is exceeded.
   * - `PoolExists`: If a pool with the given assets already exists.
   * - `ShareAssetInPoolAssets`: If the share asset is among the pool assets.
   * - `AssetNotRegistered`: If one or more assets are not registered in the AssetRegistry.
   * - `InvalidAmplification`: If the amplification parameter is invalid.
   * - `IncorrectInitialPegs`: If the initial pegs are incorrect.
   * - `MissingTargetPegOracle`: If the target peg oracle entry is missing.
   * - `IncorrectAssetDecimals`: If the assets have different decimals.
   *
   **/
  | {
      name: 'CreatePoolWithPegs';
      params: {
        shareAsset: number;
        assets: Array<number>;
        amplification: number;
        fee: Permill;
        pegSource: Array<PalletStableswapPegSource>;
        maxPegUpdate: Permill;
      };
    }
  /**
   * Add liquidity to selected pool.
   *
   * First call of `add_assets_liquidity` must provide "initial liquidity" of all assets.
   *
   * If there is liquidity already in the pool, LP can provide liquidity of any number of pool assets.
   *
   * LP must have sufficient amount of each asset.
   *
   * Origin is given corresponding amount of shares.
   *
   * Parameters:
   * - `origin`: liquidity provider
   * - `pool_id`: Pool Id
   * - `assets`: asset id and liquidity amount provided
   * - `min_shares`: minimum amount of shares to receive
   *
   * Emits `LiquidityAdded` event when successful.
   * Emits `pallet_broadcast::Swapped` event when successful.
   **/
  | {
      name: 'AddAssetsLiquidity';
      params: { poolId: number; assets: Array<HydradxTraitsStableswapAssetAmount>; minShares: bigint };
    }
  /**
   * Update the peg source for a specific asset in a pool.
   *
   * This function allows updating the peg source for an asset within a pool.
   * The pool must exist and have pegs configured. The asset must be part of the pool.
   * The current price is always preserved when updating the peg source.
   *
   * Parameters:
   * - `origin`: Must be `T::AuthorityOrigin`.
   * - `pool_id`: The ID of the pool containing the asset.
   * - `asset_id`: The ID of the asset whose peg source is to be updated.
   * - `peg_source`: The new peg source for the asset.
   *
   * Emits `PoolPegSourceUpdated` event when successful.
   *
   * # Errors
   * - `PoolNotFound`: If the specified pool does not exist.
   * - `NoPegSource`: If the pool does not have pegs configured.
   * - `AssetNotInPool`: If the specified asset is not part of the pool.
   *
   **/
  | { name: 'UpdateAssetPegSource'; params: { poolId: number; assetId: number; pegSource: PalletStableswapPegSource } }
  /**
   * Update the maximum peg update percentage for a pool.
   *
   * This function allows updating the maximum percentage by which peg values
   * can change in a pool with pegs configured.
   *
   * Parameters:
   * - `origin`: Must be `T::AuthorityOrigin`.
   * - `pool_id`: The ID of the pool to update.
   * - `max_peg_update`: The new maximum peg update percentage.
   *
   * Emits `PoolMaxPegUpdateUpdated` event when successful.
   *
   * # Errors
   * - `PoolNotFound`: If the specified pool does not exist.
   * - `NoPegSource`: If the pool does not have pegs configured.
   *
   **/
  | { name: 'UpdatePoolMaxPegUpdate'; params: { poolId: number; maxPegUpdate: Permill } };

export type PalletStableswapCallLike =
  /**
   * Create a stable pool with given list of assets.
   *
   * All assets must be correctly registered in `T::AssetRegistry`.
   * Note that this does not seed the pool with liquidity. Use `add_assets_liquidity` to provide
   * initial liquidity.
   *
   * Parameters:
   * - `origin`: Must be T::AuthorityOrigin
   * - `share_asset`: Preregistered share asset identifier
   * - `assets`: List of Asset ids
   * - `amplification`: Pool amplification
   * - `fee`: fee to be applied on trade and liquidity operations
   *
   * Emits `PoolCreated` event if successful.
   **/
  | { name: 'CreatePool'; params: { shareAsset: number; assets: Array<number>; amplification: number; fee: Permill } }
  /**
   * Update pool's fee.
   *
   * if pool does not exist, `PoolNotFound` is returned.
   *
   * Parameters:
   * - `origin`: Must be T::AuthorityOrigin
   * - `pool_id`: pool to update
   * - `fee`: new pool fee
   *
   * Emits `FeeUpdated` event if successful.
   **/
  | { name: 'UpdatePoolFee'; params: { poolId: number; fee: Permill } }
  /**
   * Update pool's amplification.
   *
   * Parameters:
   * - `origin`: Must be T::AuthorityOrigin
   * - `pool_id`: pool to update
   * - `final_amplification`: new desired pool amplification
   * - `start_block`: block number when the amplification starts to move towards final_amplication
   * - `end_block`: block number when the amplification reaches final_amplification
   *
   * Emits `AmplificationUpdated` event if successful.
   **/
  | {
      name: 'UpdateAmplification';
      params: { poolId: number; finalAmplification: number; startBlock: number; endBlock: number };
    }
  /**
   * Add liquidity to selected pool.
   *
   * Use `add_assets_liquidity` instead.
   * This extrinsics will be removed in the future.
   *
   * First call of `add_liquidity` must provide "initial liquidity" of all assets.
   *
   * If there is liquidity already in the pool, LP can provide liquidity of any number of pool assets.
   *
   * LP must have sufficient amount of each asset.
   *
   * Origin is given corresponding amount of shares.
   *
   * Parameters:
   * - `origin`: liquidity provider
   * - `pool_id`: Pool Id
   * - `assets`: asset id and liquidity amount provided
   *
   * Emits `LiquidityAdded` event when successful.
   * Emits `pallet_broadcast::Swapped` event when successful.
   **/
  | { name: 'AddLiquidity'; params: { poolId: number; assets: Array<HydradxTraitsStableswapAssetAmount> } }
  /**
   * Add liquidity to selected pool given exact amount of shares to receive.
   *
   * Similar to `add_liquidity` but LP specifies exact amount of shares to receive.
   *
   * This functionality is used mainly by on-chain routing when a swap between Omnipool asset and stable asset is performed.
   *
   * Parameters:
   * - `origin`: liquidity provider
   * - `pool_id`: Pool Id
   * - `shares`: amount of shares to receive
   * - `asset_id`: asset id of an asset to provide as liquidity
   * - `max_asset_amount`: slippage limit. Max amount of asset.
   *
   * Emits `LiquidityAdded` event when successful.
   * Emits `pallet_broadcast::Swapped` event when successful.
   **/
  | { name: 'AddLiquidityShares'; params: { poolId: number; shares: bigint; assetId: number; maxAssetAmount: bigint } }
  /**
   * Remove liquidity from selected pool.
   *
   * Withdraws liquidity of selected asset from a pool.
   *
   * Share amount is burned and LP receives corresponding amount of chosen asset.
   *
   * Withdraw fee is applied to the asset amount.
   *
   * Parameters:
   * - `origin`: liquidity provider
   * - `pool_id`: Pool Id
   * - `asset_id`: id of asset to receive
   * - 'share_amount': amount of shares to withdraw
   * - 'min_amount_out': minimum amount to receive
   *
   * Emits `LiquidityRemoved` event when successful.
   * Emits `pallet_broadcast::Swapped` event when successful.
   **/
  | {
      name: 'RemoveLiquidityOneAsset';
      params: { poolId: number; assetId: number; shareAmount: bigint; minAmountOut: bigint };
    }
  /**
   * Remove liquidity from selected pool by specifying exact amount of asset to receive.
   *
   * Similar to `remove_liquidity_one_asset` but LP specifies exact amount of asset to receive instead of share amount.
   *
   * Parameters:
   * - `origin`: liquidity provider
   * - `pool_id`: Pool Id
   * - `asset_id`: id of asset to receive
   * - 'amount': amount of asset to receive
   * - 'max_share_amount': Slippage limit. Max amount of shares to burn.
   *
   * Emits `LiquidityRemoved` event when successful.
   * Emits `pallet_broadcast::Swapped` event when successful.
   **/
  | { name: 'WithdrawAssetAmount'; params: { poolId: number; assetId: number; amount: bigint; maxShareAmount: bigint } }
  /**
   * Execute a swap of `asset_in` for `asset_out`.
   *
   * Parameters:
   * - `origin`: origin of the caller
   * - `pool_id`: Id of a pool
   * - `asset_in`: ID of asset sold to the pool
   * - `asset_out`: ID of asset bought from the pool
   * - `amount_in`: Amount of asset to be sold to the pool
   * - `min_buy_amount`: Minimum amount required to receive
   *
   * Emits `SellExecuted` event when successful. Deprecated.
   * Emits `pallet_broadcast::Swapped` event when successful.
   *
   **/
  | {
      name: 'Sell';
      params: { poolId: number; assetIn: number; assetOut: number; amountIn: bigint; minBuyAmount: bigint };
    }
  /**
   * Execute a swap of `asset_out` for `asset_in`.
   *
   * Parameters:
   * - `origin`:
   * - `pool_id`: Id of a pool
   * - `asset_out`: ID of asset bought from the pool
   * - `asset_in`: ID of asset sold to the pool
   * - `amount_out`: Amount of asset to receive from the pool
   * - `max_sell_amount`: Maximum amount allowed to be sold
   *
   * Emits `BuyExecuted` event when successful. Deprecated.
   * Emits `pallet_broadcast::Swapped` event when successful.
   *
   **/
  | {
      name: 'Buy';
      params: { poolId: number; assetOut: number; assetIn: number; amountOut: bigint; maxSellAmount: bigint };
    }
  /**
   * Update the tradable state of a specific asset in a pool.
   *
   * This function allows updating the tradability state of an asset within a pool. The tradability state determines whether the asset can be used for specific operations such as adding liquidity, removing liquidity, buying, or selling.
   *
   * Parameters:
   * - `origin`: Must be `T::UpdateTradabilityOrigin`.
   * - `pool_id`: The ID of the pool containing the asset.
   * - `asset_id`: The ID of the asset whose tradability state is to be updated.
   * - `state`: The new tradability state of the asset.
   *
   * Emits `TradableStateUpdated` event when successful.
   *
   * # Errors
   * - `PoolNotFound`: If the specified pool does not exist.
   * - `AssetNotInPool`: If the specified asset is not part of the pool.
   *
   **/
  | { name: 'SetAssetTradableState'; params: { poolId: number; assetId: number; state: PalletStableswapTradability } }
  /**
   * Remove liquidity from a selected pool uniformly.
   *
   * This function allows a liquidity provider to withdraw liquidity from a pool.
   * The provider specifies the amount of shares to burn and the minimum amounts of each asset to receive.
   *
   * Parameters:
   * - `origin`: The liquidity provider.
   * - `pool_id`: The ID of the pool from which to remove liquidity.
   * - `share_amount`: The amount of shares to burn.
   * - `min_amounts_out`: A bounded vector specifying the minimum amounts of each asset to receive.
   *
   * Emits `LiquidityRemoved` event when successful.
   * Emits `pallet_broadcast::Swapped` event when successful.
   *
   * # Errors
   * - `InvalidAssetAmount`: If the `share_amount` is zero.
   * - `InsufficientShares`: If the provider does not have enough shares.
   * - `PoolNotFound`: If the specified pool does not exist.
   * - `UnknownDecimals`: If the asset decimals cannot be retrieved.
   * - `IncorrectAssets`: If the provided `min_amounts_out` does not match the pool assets.
   * - `NotAllowed`: If the asset is not allowed for the operation.
   * - `SlippageLimit`: If the amount received is less than the specified minimum amount.
   * - `InsufficientLiquidityRemaining`: If the remaining liquidity in the pool is below the minimum required.
   *
   * # Invariants
   * - Ensures that the pool's reserves are updated correctly after liquidity removal.
   * - Ensures that the pool's invariant is maintained.
   **/
  | {
      name: 'RemoveLiquidity';
      params: { poolId: number; shareAmount: bigint; minAmountsOut: Array<HydradxTraitsStableswapAssetAmount> };
    }
  /**
   * Create a stable pool with a given list of assets and pegs.
   *
   * This function allows the creation of a new stable pool with specified assets, amplification, fee, and peg sources. The pool is identified by a share asset.
   *
   * Peg target price is determined by retrieving the target peg from the oracle - it is the price of the asset from the peg sourcedenominated in the other pool assets.
   *
   * Parameters:
   * - `origin`: Must be `T::AuthorityOrigin`.
   * - `share_asset`: Preregistered share asset identifier.
   * - `assets`: List of asset IDs to be included in the pool.
   * - `amplification`: Pool amplification parameter.
   * - `fee`: Fee to be applied on trade and liquidity operations.
   * - `peg_source`: Bounded vector specifying the source of the peg for each asset.
   * - `max_peg_update`: Maximum allowed peg update per block.
   *
   * Emits `PoolCreated` event if successful.
   * Emits `AmplificationChanging` event if successful.
   *
   * # Errors
   * - `IncorrectAssets`: If the assets are the same or less than 2 assets are provided.
   * - `MaxAssetsExceeded`: If the maximum number of assets is exceeded.
   * - `PoolExists`: If a pool with the given assets already exists.
   * - `ShareAssetInPoolAssets`: If the share asset is among the pool assets.
   * - `AssetNotRegistered`: If one or more assets are not registered in the AssetRegistry.
   * - `InvalidAmplification`: If the amplification parameter is invalid.
   * - `IncorrectInitialPegs`: If the initial pegs are incorrect.
   * - `MissingTargetPegOracle`: If the target peg oracle entry is missing.
   * - `IncorrectAssetDecimals`: If the assets have different decimals.
   *
   **/
  | {
      name: 'CreatePoolWithPegs';
      params: {
        shareAsset: number;
        assets: Array<number>;
        amplification: number;
        fee: Permill;
        pegSource: Array<PalletStableswapPegSource>;
        maxPegUpdate: Permill;
      };
    }
  /**
   * Add liquidity to selected pool.
   *
   * First call of `add_assets_liquidity` must provide "initial liquidity" of all assets.
   *
   * If there is liquidity already in the pool, LP can provide liquidity of any number of pool assets.
   *
   * LP must have sufficient amount of each asset.
   *
   * Origin is given corresponding amount of shares.
   *
   * Parameters:
   * - `origin`: liquidity provider
   * - `pool_id`: Pool Id
   * - `assets`: asset id and liquidity amount provided
   * - `min_shares`: minimum amount of shares to receive
   *
   * Emits `LiquidityAdded` event when successful.
   * Emits `pallet_broadcast::Swapped` event when successful.
   **/
  | {
      name: 'AddAssetsLiquidity';
      params: { poolId: number; assets: Array<HydradxTraitsStableswapAssetAmount>; minShares: bigint };
    }
  /**
   * Update the peg source for a specific asset in a pool.
   *
   * This function allows updating the peg source for an asset within a pool.
   * The pool must exist and have pegs configured. The asset must be part of the pool.
   * The current price is always preserved when updating the peg source.
   *
   * Parameters:
   * - `origin`: Must be `T::AuthorityOrigin`.
   * - `pool_id`: The ID of the pool containing the asset.
   * - `asset_id`: The ID of the asset whose peg source is to be updated.
   * - `peg_source`: The new peg source for the asset.
   *
   * Emits `PoolPegSourceUpdated` event when successful.
   *
   * # Errors
   * - `PoolNotFound`: If the specified pool does not exist.
   * - `NoPegSource`: If the pool does not have pegs configured.
   * - `AssetNotInPool`: If the specified asset is not part of the pool.
   *
   **/
  | { name: 'UpdateAssetPegSource'; params: { poolId: number; assetId: number; pegSource: PalletStableswapPegSource } }
  /**
   * Update the maximum peg update percentage for a pool.
   *
   * This function allows updating the maximum percentage by which peg values
   * can change in a pool with pegs configured.
   *
   * Parameters:
   * - `origin`: Must be `T::AuthorityOrigin`.
   * - `pool_id`: The ID of the pool to update.
   * - `max_peg_update`: The new maximum peg update percentage.
   *
   * Emits `PoolMaxPegUpdateUpdated` event when successful.
   *
   * # Errors
   * - `PoolNotFound`: If the specified pool does not exist.
   * - `NoPegSource`: If the pool does not have pegs configured.
   *
   **/
  | { name: 'UpdatePoolMaxPegUpdate'; params: { poolId: number; maxPegUpdate: Permill } };

export type PalletStableswapTradability = { bits: number };

export type PalletStableswapPegSource =
  | { type: 'Value'; value: [bigint, bigint] }
  | { type: 'Oracle'; value: [FixedBytes<8>, HydradxTraitsOracleOraclePeriod, number] }
  | { type: 'MmOracle'; value: H160 };

export type HydradxTraitsOracleOraclePeriod = 'LastBlock' | 'Short' | 'TenMinutes' | 'Hour' | 'Day' | 'Week';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBondsCall =
  /**
   * Issue new fungible bonds.
   * New asset id is registered and assigned to the bonds.
   * The number of bonds the issuer receives is 1:1 to the `amount` of the underlying asset
   * minus the protocol fee.
   * The bond asset is registered with the empty string for the asset name,
   * and with the same existential deposit as of the underlying asset.
   * Bonds can be redeemed for the underlying asset once mature.
   * Protocol fee is applied to the amount, and transferred to `T::FeeReceiver`.
   * When issuing new bonds with the underlying asset and maturity that matches existing bonds,
   * new amount of these existing bonds is issued, instead of registering new bonds.
   * It's possible to issue new bonds for bonds that are already mature.
   *
   * Parameters:
   * - `origin`: issuer of new bonds, needs to be `T::IssueOrigin`
   * - `asset_id`: underlying asset id
   * - `amount`: the amount of the underlying asset
   * - `maturity`: Unix time in milliseconds, when the bonds will be mature.
   *
   * Emits `BondTokenCreated` event when successful and new bonds were registered.
   * Emits `BondsIssued` event when successful.
   *
   **/
  | { name: 'Issue'; params: { assetId: number; amount: bigint; maturity: bigint } }
  /**
   * Redeem bonds for the underlying asset.
   * The amount of the underlying asset the `origin` receives is 1:1 to the `amount` of the bonds.
   * Anyone who holds the bonds is able to redeem them.
   * Bonds can be both partially or fully redeemed.
   *
   * Parameters:
   * - `origin`: account id
   * - `asset_id`: bond asset id
   * - `amount`: the amount of the bonds to redeem for the underlying asset
   *
   * Emits `BondsRedeemed` event when successful.
   *
   **/
  | { name: 'Redeem'; params: { bondId: number; amount: bigint } };

export type PalletBondsCallLike =
  /**
   * Issue new fungible bonds.
   * New asset id is registered and assigned to the bonds.
   * The number of bonds the issuer receives is 1:1 to the `amount` of the underlying asset
   * minus the protocol fee.
   * The bond asset is registered with the empty string for the asset name,
   * and with the same existential deposit as of the underlying asset.
   * Bonds can be redeemed for the underlying asset once mature.
   * Protocol fee is applied to the amount, and transferred to `T::FeeReceiver`.
   * When issuing new bonds with the underlying asset and maturity that matches existing bonds,
   * new amount of these existing bonds is issued, instead of registering new bonds.
   * It's possible to issue new bonds for bonds that are already mature.
   *
   * Parameters:
   * - `origin`: issuer of new bonds, needs to be `T::IssueOrigin`
   * - `asset_id`: underlying asset id
   * - `amount`: the amount of the underlying asset
   * - `maturity`: Unix time in milliseconds, when the bonds will be mature.
   *
   * Emits `BondTokenCreated` event when successful and new bonds were registered.
   * Emits `BondsIssued` event when successful.
   *
   **/
  | { name: 'Issue'; params: { assetId: number; amount: bigint; maturity: bigint } }
  /**
   * Redeem bonds for the underlying asset.
   * The amount of the underlying asset the `origin` receives is 1:1 to the `amount` of the bonds.
   * Anyone who holds the bonds is able to redeem them.
   * Bonds can be both partially or fully redeemed.
   *
   * Parameters:
   * - `origin`: account id
   * - `asset_id`: bond asset id
   * - `amount`: the amount of the bonds to redeem for the underlying asset
   *
   * Emits `BondsRedeemed` event when successful.
   *
   **/
  | { name: 'Redeem'; params: { bondId: number; amount: bigint } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletOtcSettlementsCall =
  /**
   * Close an existing OTC arbitrage opportunity.
   *
   * Executes a trade between an OTC order and some route.
   * If the OTC order is partially fillable, the extrinsic fails if the existing arbitrage
   * opportunity is not closed or reduced after the trade.
   * If the OTC order is not partially fillable, fails if there is no profit after the trade.
   *
   * `Origin` calling this extrinsic is not paying or receiving anything.
   *
   * The profit made by closing the arbitrage is transferred to `FeeReceiver`.
   *
   * Parameters:
   * - `origin`: Signed or unsigned origin. Unsigned origin doesn't pay the TX fee,
   * but can be submitted only by a collator.
   * - `otc_id`: ID of the OTC order with existing arbitrage opportunity.
   * - `amount`: Amount necessary to close the arb.
   * - `route`: The route we trade against. Required for the fee calculation.
   *
   * Emits `Executed` event when successful.
   *
   **/
  { name: 'SettleOtcOrder'; params: { otcId: number; amount: bigint; route: Array<HydradxTraitsRouterTrade> } };

export type PalletOtcSettlementsCallLike =
  /**
   * Close an existing OTC arbitrage opportunity.
   *
   * Executes a trade between an OTC order and some route.
   * If the OTC order is partially fillable, the extrinsic fails if the existing arbitrage
   * opportunity is not closed or reduced after the trade.
   * If the OTC order is not partially fillable, fails if there is no profit after the trade.
   *
   * `Origin` calling this extrinsic is not paying or receiving anything.
   *
   * The profit made by closing the arbitrage is transferred to `FeeReceiver`.
   *
   * Parameters:
   * - `origin`: Signed or unsigned origin. Unsigned origin doesn't pay the TX fee,
   * but can be submitted only by a collator.
   * - `otc_id`: ID of the OTC order with existing arbitrage opportunity.
   * - `amount`: Amount necessary to close the arb.
   * - `route`: The route we trade against. Required for the fee calculation.
   *
   * Emits `Executed` event when successful.
   *
   **/
  { name: 'SettleOtcOrder'; params: { otcId: number; amount: bigint; route: Array<HydradxTraitsRouterTrade> } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletLbpCall =
  /**
   * Create a new liquidity bootstrapping pool for given asset pair.
   *
   * For any asset pair, only one pool can exist at a time.
   *
   * The dispatch origin for this call must be `T::CreatePoolOrigin`.
   * The pool is created with initial liquidity provided by the `pool_owner` who must have
   * sufficient funds free.
   *
   * The pool starts uninitialized and update_pool call should be called once created to set the start block.
   *
   * This function should be dispatched from governing entity `T::CreatePoolOrigin`
   *
   * Parameters:
   * - `pool_owner`: the future owner of the new pool.
   * - `asset_a`: { asset_id, amount } Asset ID and initial liquidity amount.
   * - `asset_b`: { asset_id, amount } Asset ID and initial liquidity amount.
   * - `initial_weight`: Initial weight of the asset_a. 1_000_000 corresponding to 1% and 100_000_000 to 100%
   * this should be higher than final weight
   * - `final_weight`: Final weight of the asset_a. 1_000_000 corresponding to 1% and 100_000_000 to 100%
   * this should be lower than initial weight
   * - `weight_curve`: The weight function used to update the LBP weights. Currently,
   * there is only one weight function implemented, the linear function.
   * - `fee`: The trading fee charged on every trade distributed to `fee_collector`.
   * - `fee_collector`: The account to which trading fees will be transferred.
   * - `repay_target`: The amount of tokens to repay to separate fee_collector account. Until this amount is
   * reached, fee will be increased to 20% and taken from the pool
   *
   * Emits `PoolCreated` event when successful.
   *
   * BEWARE: We are taking the fee from the accumulated asset. If the accumulated asset is sold to the pool,
   * the fee cost is transferred to the pool. If its bought from the pool the buyer bears the cost.
   * This increases the price of the sold asset on every trade. Make sure to only run this with
   * previously illiquid assets.
   **/
  | {
      name: 'CreatePool';
      params: {
        poolOwner: AccountId32;
        assetA: number;
        assetAAmount: bigint;
        assetB: number;
        assetBAmount: bigint;
        initialWeight: number;
        finalWeight: number;
        weightCurve: PalletLbpWeightCurveType;
        fee: [number, number];
        feeCollector: AccountId32;
        repayTarget: bigint;
      };
    }
  /**
   * Update pool data of a pool.
   *
   * The dispatch origin for this call must be signed by the pool owner.
   *
   * The pool can be updated only if the sale has not already started.
   *
   * At least one of the following optional parameters has to be specified.
   *
   * Parameters:
   * - `pool_id`: The identifier of the pool to be updated.
   * - `start`: The new starting time of the sale. This parameter is optional.
   * - `end`: The new ending time of the sale. This parameter is optional.
   * - `initial_weight`: The new initial weight. This parameter is optional.
   * - `final_weight`: The new final weight. This parameter is optional.
   * - `fee`: The new trading fee charged on every trade. This parameter is optional.
   * - `fee_collector`: The new receiver of trading fees. This parameter is optional.
   *
   * Emits `PoolUpdated` event when successful.
   **/
  | {
      name: 'UpdatePoolData';
      params: {
        poolId: AccountId32;
        poolOwner?: AccountId32 | undefined;
        start?: number | undefined;
        end?: number | undefined;
        initialWeight?: number | undefined;
        finalWeight?: number | undefined;
        fee?: [number, number] | undefined;
        feeCollector?: AccountId32 | undefined;
        repayTarget?: bigint | undefined;
      };
    }
  /**
   * Add liquidity to a pool.
   *
   * Assets to add has to match the pool assets. At least one amount has to be non-zero.
   *
   * The dispatch origin for this call must be signed by the pool owner.
   *
   * Parameters:
   * - `pool_id`: The identifier of the pool
   * - `amount_a`: The identifier of the asset and the amount to add.
   * - `amount_b`: The identifier of the second asset and the amount to add.
   *
   * Emits `LiquidityAdded` event when successful.
   **/
  | { name: 'AddLiquidity'; params: { amountA: [number, bigint]; amountB: [number, bigint] } }
  /**
   * Transfer all the liquidity from a pool back to the pool owner and destroy the pool.
   * The pool data are also removed from the storage.
   *
   * The pool can't be destroyed during the sale.
   *
   * The dispatch origin for this call must be signed by the pool owner.
   *
   * Parameters:
   * - `amount_a`: The identifier of the asset and the amount to add.
   *
   * Emits 'LiquidityRemoved' when successful.
   **/
  | { name: 'RemoveLiquidity'; params: { poolId: AccountId32 } }
  /**
   * Trade `asset_in` for `asset_out`.
   *
   * Executes a swap of `asset_in` for `asset_out`. Price is determined by the pool and is
   * affected by the amount and proportion of the pool assets and the weights.
   *
   * Trading `fee` is distributed to the `fee_collector`.
   *
   * Parameters:
   * - `asset_in`: The identifier of the asset being transferred from the account to the pool.
   * - `asset_out`: The identifier of the asset being transferred from the pool to the account.
   * - `amount`: The amount of `asset_in`
   * - `max_limit`: minimum amount of `asset_out` / amount of asset_out to be obtained from the pool in exchange for `asset_in`.
   *
   * Emits `SellExecuted` when successful. Deprecated.
   * Emits `pallet_broadcast::Swapped` when successful.
   **/
  | { name: 'Sell'; params: { assetIn: number; assetOut: number; amount: bigint; maxLimit: bigint } }
  /**
   * Trade `asset_in` for `asset_out`.
   *
   * Executes a swap of `asset_in` for `asset_out`. Price is determined by the pool and is
   * affected by the amount and the proportion of the pool assets and the weights.
   *
   * Trading `fee` is distributed to the `fee_collector`.
   *
   * Parameters:
   * - `asset_in`: The identifier of the asset being transferred from the account to the pool.
   * - `asset_out`: The identifier of the asset being transferred from the pool to the account.
   * - `amount`: The amount of `asset_out`.
   * - `max_limit`: maximum amount of `asset_in` to be sold in exchange for `asset_out`.
   *
   * Emits `BuyExecuted` when successful. Deprecated.
   * Emits `pallet_broadcast::Swapped` when successful.
   **/
  | { name: 'Buy'; params: { assetOut: number; assetIn: number; amount: bigint; maxLimit: bigint } };

export type PalletLbpCallLike =
  /**
   * Create a new liquidity bootstrapping pool for given asset pair.
   *
   * For any asset pair, only one pool can exist at a time.
   *
   * The dispatch origin for this call must be `T::CreatePoolOrigin`.
   * The pool is created with initial liquidity provided by the `pool_owner` who must have
   * sufficient funds free.
   *
   * The pool starts uninitialized and update_pool call should be called once created to set the start block.
   *
   * This function should be dispatched from governing entity `T::CreatePoolOrigin`
   *
   * Parameters:
   * - `pool_owner`: the future owner of the new pool.
   * - `asset_a`: { asset_id, amount } Asset ID and initial liquidity amount.
   * - `asset_b`: { asset_id, amount } Asset ID and initial liquidity amount.
   * - `initial_weight`: Initial weight of the asset_a. 1_000_000 corresponding to 1% and 100_000_000 to 100%
   * this should be higher than final weight
   * - `final_weight`: Final weight of the asset_a. 1_000_000 corresponding to 1% and 100_000_000 to 100%
   * this should be lower than initial weight
   * - `weight_curve`: The weight function used to update the LBP weights. Currently,
   * there is only one weight function implemented, the linear function.
   * - `fee`: The trading fee charged on every trade distributed to `fee_collector`.
   * - `fee_collector`: The account to which trading fees will be transferred.
   * - `repay_target`: The amount of tokens to repay to separate fee_collector account. Until this amount is
   * reached, fee will be increased to 20% and taken from the pool
   *
   * Emits `PoolCreated` event when successful.
   *
   * BEWARE: We are taking the fee from the accumulated asset. If the accumulated asset is sold to the pool,
   * the fee cost is transferred to the pool. If its bought from the pool the buyer bears the cost.
   * This increases the price of the sold asset on every trade. Make sure to only run this with
   * previously illiquid assets.
   **/
  | {
      name: 'CreatePool';
      params: {
        poolOwner: AccountId32Like;
        assetA: number;
        assetAAmount: bigint;
        assetB: number;
        assetBAmount: bigint;
        initialWeight: number;
        finalWeight: number;
        weightCurve: PalletLbpWeightCurveType;
        fee: [number, number];
        feeCollector: AccountId32Like;
        repayTarget: bigint;
      };
    }
  /**
   * Update pool data of a pool.
   *
   * The dispatch origin for this call must be signed by the pool owner.
   *
   * The pool can be updated only if the sale has not already started.
   *
   * At least one of the following optional parameters has to be specified.
   *
   * Parameters:
   * - `pool_id`: The identifier of the pool to be updated.
   * - `start`: The new starting time of the sale. This parameter is optional.
   * - `end`: The new ending time of the sale. This parameter is optional.
   * - `initial_weight`: The new initial weight. This parameter is optional.
   * - `final_weight`: The new final weight. This parameter is optional.
   * - `fee`: The new trading fee charged on every trade. This parameter is optional.
   * - `fee_collector`: The new receiver of trading fees. This parameter is optional.
   *
   * Emits `PoolUpdated` event when successful.
   **/
  | {
      name: 'UpdatePoolData';
      params: {
        poolId: AccountId32Like;
        poolOwner?: AccountId32Like | undefined;
        start?: number | undefined;
        end?: number | undefined;
        initialWeight?: number | undefined;
        finalWeight?: number | undefined;
        fee?: [number, number] | undefined;
        feeCollector?: AccountId32Like | undefined;
        repayTarget?: bigint | undefined;
      };
    }
  /**
   * Add liquidity to a pool.
   *
   * Assets to add has to match the pool assets. At least one amount has to be non-zero.
   *
   * The dispatch origin for this call must be signed by the pool owner.
   *
   * Parameters:
   * - `pool_id`: The identifier of the pool
   * - `amount_a`: The identifier of the asset and the amount to add.
   * - `amount_b`: The identifier of the second asset and the amount to add.
   *
   * Emits `LiquidityAdded` event when successful.
   **/
  | { name: 'AddLiquidity'; params: { amountA: [number, bigint]; amountB: [number, bigint] } }
  /**
   * Transfer all the liquidity from a pool back to the pool owner and destroy the pool.
   * The pool data are also removed from the storage.
   *
   * The pool can't be destroyed during the sale.
   *
   * The dispatch origin for this call must be signed by the pool owner.
   *
   * Parameters:
   * - `amount_a`: The identifier of the asset and the amount to add.
   *
   * Emits 'LiquidityRemoved' when successful.
   **/
  | { name: 'RemoveLiquidity'; params: { poolId: AccountId32Like } }
  /**
   * Trade `asset_in` for `asset_out`.
   *
   * Executes a swap of `asset_in` for `asset_out`. Price is determined by the pool and is
   * affected by the amount and proportion of the pool assets and the weights.
   *
   * Trading `fee` is distributed to the `fee_collector`.
   *
   * Parameters:
   * - `asset_in`: The identifier of the asset being transferred from the account to the pool.
   * - `asset_out`: The identifier of the asset being transferred from the pool to the account.
   * - `amount`: The amount of `asset_in`
   * - `max_limit`: minimum amount of `asset_out` / amount of asset_out to be obtained from the pool in exchange for `asset_in`.
   *
   * Emits `SellExecuted` when successful. Deprecated.
   * Emits `pallet_broadcast::Swapped` when successful.
   **/
  | { name: 'Sell'; params: { assetIn: number; assetOut: number; amount: bigint; maxLimit: bigint } }
  /**
   * Trade `asset_in` for `asset_out`.
   *
   * Executes a swap of `asset_in` for `asset_out`. Price is determined by the pool and is
   * affected by the amount and the proportion of the pool assets and the weights.
   *
   * Trading `fee` is distributed to the `fee_collector`.
   *
   * Parameters:
   * - `asset_in`: The identifier of the asset being transferred from the account to the pool.
   * - `asset_out`: The identifier of the asset being transferred from the pool to the account.
   * - `amount`: The amount of `asset_out`.
   * - `max_limit`: maximum amount of `asset_in` to be sold in exchange for `asset_out`.
   *
   * Emits `BuyExecuted` when successful. Deprecated.
   * Emits `pallet_broadcast::Swapped` when successful.
   **/
  | { name: 'Buy'; params: { assetOut: number; assetIn: number; amount: bigint; maxLimit: bigint } };

export type PalletLbpWeightCurveType = 'Linear';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletXykCall =
  /**
   * Create new pool for given asset pair.
   *
   * Registers new pool for given asset pair (`asset a` and `asset b`) in asset registry.
   * Asset registry creates new id or returns previously created one if such pool existed before.
   *
   * Pool is created with initial liquidity provided by `origin`.
   * Shares are issued with specified initial price and represents proportion of asset in the pool.
   *
   * Emits `PoolCreated` event when successful.
   **/
  | { name: 'CreatePool'; params: { assetA: number; amountA: bigint; assetB: number; amountB: bigint } }
  /**
   * Add liquidity to previously created asset pair pool.
   *
   * Shares are issued with current price.
   *
   * Emits `LiquidityAdded` event when successful.
   **/
  | { name: 'AddLiquidity'; params: { assetA: number; assetB: number; amountA: bigint; amountBMaxLimit: bigint } }
  | {
      name: 'AddLiquidityWithLimits';
      params: { assetA: number; assetB: number; amountA: bigint; amountBMaxLimit: bigint; minShares: bigint };
    }
  /**
   * Remove liquidity from specific liquidity pool in the form of burning shares.
   *
   * If liquidity in the pool reaches 0, it is destroyed.
   *
   * Emits 'LiquidityRemoved' when successful.
   * Emits 'PoolDestroyed' when pool is destroyed.
   **/
  | { name: 'RemoveLiquidity'; params: { assetA: number; assetB: number; shareAmount: bigint } }
  | {
      name: 'RemoveLiquidityWithLimits';
      params: { assetA: number; assetB: number; shareAmount: bigint; minAmountA: bigint; minAmountB: bigint };
    }
  /**
   * Trade asset in for asset out.
   *
   * Executes a swap of `asset_in` for `asset_out`. Price is determined by the liquidity pool.
   *
   * `max_limit` - minimum amount of `asset_out` / amount of asset_out to be obtained from the pool in exchange for `asset_in`.
   *
   * Emits `SellExecuted` when successful. Deprecated.
   * Emits `pallet_broadcast::Swapped` when successful.
   **/
  | { name: 'Sell'; params: { assetIn: number; assetOut: number; amount: bigint; maxLimit: bigint; discount: boolean } }
  /**
   * Trade asset in for asset out.
   *
   * Executes a swap of `asset_in` for `asset_out`. Price is determined by the liquidity pool.
   *
   * `max_limit` - maximum amount of `asset_in` to be sold in exchange for `asset_out`.
   * Emits `BuyExecuted` when successful. Deprecated.
   * Emits `pallet_broadcast::Swapped` when successful.
   **/
  | { name: 'Buy'; params: { assetOut: number; assetIn: number; amount: bigint; maxLimit: bigint; discount: boolean } };

export type PalletXykCallLike =
  /**
   * Create new pool for given asset pair.
   *
   * Registers new pool for given asset pair (`asset a` and `asset b`) in asset registry.
   * Asset registry creates new id or returns previously created one if such pool existed before.
   *
   * Pool is created with initial liquidity provided by `origin`.
   * Shares are issued with specified initial price and represents proportion of asset in the pool.
   *
   * Emits `PoolCreated` event when successful.
   **/
  | { name: 'CreatePool'; params: { assetA: number; amountA: bigint; assetB: number; amountB: bigint } }
  /**
   * Add liquidity to previously created asset pair pool.
   *
   * Shares are issued with current price.
   *
   * Emits `LiquidityAdded` event when successful.
   **/
  | { name: 'AddLiquidity'; params: { assetA: number; assetB: number; amountA: bigint; amountBMaxLimit: bigint } }
  | {
      name: 'AddLiquidityWithLimits';
      params: { assetA: number; assetB: number; amountA: bigint; amountBMaxLimit: bigint; minShares: bigint };
    }
  /**
   * Remove liquidity from specific liquidity pool in the form of burning shares.
   *
   * If liquidity in the pool reaches 0, it is destroyed.
   *
   * Emits 'LiquidityRemoved' when successful.
   * Emits 'PoolDestroyed' when pool is destroyed.
   **/
  | { name: 'RemoveLiquidity'; params: { assetA: number; assetB: number; shareAmount: bigint } }
  | {
      name: 'RemoveLiquidityWithLimits';
      params: { assetA: number; assetB: number; shareAmount: bigint; minAmountA: bigint; minAmountB: bigint };
    }
  /**
   * Trade asset in for asset out.
   *
   * Executes a swap of `asset_in` for `asset_out`. Price is determined by the liquidity pool.
   *
   * `max_limit` - minimum amount of `asset_out` / amount of asset_out to be obtained from the pool in exchange for `asset_in`.
   *
   * Emits `SellExecuted` when successful. Deprecated.
   * Emits `pallet_broadcast::Swapped` when successful.
   **/
  | { name: 'Sell'; params: { assetIn: number; assetOut: number; amount: bigint; maxLimit: bigint; discount: boolean } }
  /**
   * Trade asset in for asset out.
   *
   * Executes a swap of `asset_in` for `asset_out`. Price is determined by the liquidity pool.
   *
   * `max_limit` - maximum amount of `asset_in` to be sold in exchange for `asset_out`.
   * Emits `BuyExecuted` when successful. Deprecated.
   * Emits `pallet_broadcast::Swapped` when successful.
   **/
  | { name: 'Buy'; params: { assetOut: number; assetIn: number; amount: bigint; maxLimit: bigint; discount: boolean } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletReferralsCall =
  /**
   * Register new referral code.
   *
   * `origin` pays the registration fee.
   * `code` is assigned to the given `account`.
   *
   * Length of the `code` must be at least `T::MinCodeLength`.
   * Maximum length is limited to `T::CodeLength`.
   * `code` must contain only alfa-numeric characters and all characters will be converted to upper case.
   *
   * Parameters:
   * - `code`: Code to register. Must follow the restrictions.
   *
   * Emits `CodeRegistered` event when successful.
   **/
  | { name: 'RegisterCode'; params: { code: Bytes } }
  /**
   * Link a code to an account.
   *
   * `Code` must be valid registered code. Otherwise `InvalidCode` is returned.
   *
   * Signer account is linked to the referral account of the code.
   *
   * Parameters:
   * - `code`: Code to use to link the signer account to.
   *
   * Emits `CodeLinked` event when successful.
   **/
  | { name: 'LinkCode'; params: { code: Bytes } }
  /**
   * Convert accrued asset amount to reward currency.
   *
   * Parameters:
   * - `asset_id`: Id of an asset to convert to RewardAsset.
   *
   * Emits `Converted` event when successful.
   **/
  | { name: 'Convert'; params: { assetId: number } }
  /**
   * Claim accumulated rewards
   *
   * IF there is any asset in the reward pot, all is converted to RewardCurrency first.
   *
   * Reward amount is calculated based on the shares of the signer account.
   *
   * if the signer account is referrer account, total accumulated rewards is updated as well as referrer level if reached.
   *
   * Emits `Claimed` event when successful.
   **/
  | { name: 'ClaimRewards' }
  /**
   * Set asset reward percentages
   *
   * Parameters:
   * - `asset_id`: asset id
   * - `level`: level
   * - `rewards`: reward fee percentages
   *
   * Emits `AssetRewardsUpdated` event when successful.
   **/
  | {
      name: 'SetRewardPercentage';
      params: { assetId: number; level: PalletReferralsLevel; rewards: PalletReferralsFeeDistribution };
    };

export type PalletReferralsCallLike =
  /**
   * Register new referral code.
   *
   * `origin` pays the registration fee.
   * `code` is assigned to the given `account`.
   *
   * Length of the `code` must be at least `T::MinCodeLength`.
   * Maximum length is limited to `T::CodeLength`.
   * `code` must contain only alfa-numeric characters and all characters will be converted to upper case.
   *
   * Parameters:
   * - `code`: Code to register. Must follow the restrictions.
   *
   * Emits `CodeRegistered` event when successful.
   **/
  | { name: 'RegisterCode'; params: { code: BytesLike } }
  /**
   * Link a code to an account.
   *
   * `Code` must be valid registered code. Otherwise `InvalidCode` is returned.
   *
   * Signer account is linked to the referral account of the code.
   *
   * Parameters:
   * - `code`: Code to use to link the signer account to.
   *
   * Emits `CodeLinked` event when successful.
   **/
  | { name: 'LinkCode'; params: { code: BytesLike } }
  /**
   * Convert accrued asset amount to reward currency.
   *
   * Parameters:
   * - `asset_id`: Id of an asset to convert to RewardAsset.
   *
   * Emits `Converted` event when successful.
   **/
  | { name: 'Convert'; params: { assetId: number } }
  /**
   * Claim accumulated rewards
   *
   * IF there is any asset in the reward pot, all is converted to RewardCurrency first.
   *
   * Reward amount is calculated based on the shares of the signer account.
   *
   * if the signer account is referrer account, total accumulated rewards is updated as well as referrer level if reached.
   *
   * Emits `Claimed` event when successful.
   **/
  | { name: 'ClaimRewards' }
  /**
   * Set asset reward percentages
   *
   * Parameters:
   * - `asset_id`: asset id
   * - `level`: level
   * - `rewards`: reward fee percentages
   *
   * Emits `AssetRewardsUpdated` event when successful.
   **/
  | {
      name: 'SetRewardPercentage';
      params: { assetId: number; level: PalletReferralsLevel; rewards: PalletReferralsFeeDistribution };
    };

export type PalletReferralsLevel = 'None' | 'Tier0' | 'Tier1' | 'Tier2' | 'Tier3' | 'Tier4';

export type PalletReferralsFeeDistribution = { referrer: Permill; trader: Permill; external: Permill };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletLiquidationCall =
  /**
   * Liquidates an existing money market position.
   *
   * Performs a flash loan to get funds to pay for the debt.
   * Received collateral is swapped and the profit is transferred to `FeeReceiver`.
   *
   * Parameters:
   * - `origin`: Signed origin.
   * - `collateral_asset`: Asset ID used as collateral in the MM position.
   * - `debt_asset`: Asset ID used as debt in the MM position.
   * - `user`: EVM address of the MM position that we want to liquidate.
   * - `debt_to_cover`: Amount of debt we want to liquidate.
   * - `route`: The route we trade against. Required for the fee calculation.
   *
   * Emits `Liquidated` event when successful.
   *
   **/
  | {
      name: 'Liquidate';
      params: {
        collateralAsset: number;
        debtAsset: number;
        user: H160;
        debtToCover: bigint;
        route: Array<HydradxTraitsRouterTrade>;
      };
    }
  /**
   * Set the borrowing market contract address.
   **/
  | { name: 'SetBorrowingContract'; params: { contract: H160 } };

export type PalletLiquidationCallLike =
  /**
   * Liquidates an existing money market position.
   *
   * Performs a flash loan to get funds to pay for the debt.
   * Received collateral is swapped and the profit is transferred to `FeeReceiver`.
   *
   * Parameters:
   * - `origin`: Signed origin.
   * - `collateral_asset`: Asset ID used as collateral in the MM position.
   * - `debt_asset`: Asset ID used as debt in the MM position.
   * - `user`: EVM address of the MM position that we want to liquidate.
   * - `debt_to_cover`: Amount of debt we want to liquidate.
   * - `route`: The route we trade against. Required for the fee calculation.
   *
   * Emits `Liquidated` event when successful.
   *
   **/
  | {
      name: 'Liquidate';
      params: {
        collateralAsset: number;
        debtAsset: number;
        user: H160;
        debtToCover: bigint;
        route: Array<HydradxTraitsRouterTrade>;
      };
    }
  /**
   * Set the borrowing market contract address.
   **/
  | { name: 'SetBorrowingContract'; params: { contract: H160 } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletHsmCall =
  /**
   * Add a new collateral asset
   *
   * This function adds a new asset as an approved collateral for Hollar. Only callable by
   * the governance (root origin).
   *
   * Parameters:
   * - `origin`: Must be Root
   * - `asset_id`: Asset ID to be added as collateral
   * - `pool_id`: StableSwap pool ID where this asset and Hollar are paired
   * - `purchase_fee`: Fee applied when buying Hollar with this asset (added to purchase price)
   * - `max_buy_price_coefficient`: Maximum buy price coefficient for HSM to buy back Hollar
   * - `buy_back_fee`: Fee applied when buying back Hollar (subtracted from buy price)
   * - `buyback_rate`: Parameter that controls how quickly HSM can buy Hollar with this asset
   * - `max_in_holding`: Optional maximum amount of collateral HSM can hold
   *
   * Emits:
   * - `CollateralAdded` when the collateral is successfully added
   *
   * Errors:
   * - `AssetAlreadyApproved` if the asset is already registered as a collateral
   * - `PoolAlreadyHasCollateral` if another asset from the same pool is already approved
   * - `HollarNotInPool` if Hollar is not found in the specified pool
   * - `AssetNotInPool` if the collateral asset is not found in the specified pool
   * - Other errors from underlying calls
   **/
  | {
      name: 'AddCollateralAsset';
      params: {
        assetId: number;
        poolId: number;
        purchaseFee: Permill;
        maxBuyPriceCoefficient: FixedU128;
        buyBackFee: Permill;
        buybackRate: Perbill;
        maxInHolding?: bigint | undefined;
      };
    }
  /**
   * Remove a collateral asset
   *
   * Removes an asset from the approved collaterals list. Only callable by the governance (root origin).
   * The collateral must have a zero balance in the HSM account before it can be removed.
   *
   * Parameters:
   * - `origin`: Must be Root
   * - `asset_id`: Asset ID to remove from collaterals
   *
   * Emits:
   * - `CollateralRemoved` when the collateral is successfully removed
   *
   * Errors:
   * - `AssetNotApproved` if the asset is not a registered collateral
   * - `CollateralNotEmpty` if the HSM account still holds some of this asset
   **/
  | { name: 'RemoveCollateralAsset'; params: { assetId: number } }
  /**
   * Update collateral asset parameters
   *
   * Updates the parameters for an existing collateral asset. Only callable by the governance (root origin).
   * Each parameter is optional and only provided parameters will be updated.
   *
   * Parameters:
   * - `origin`: Must be Root
   * - `asset_id`: Asset ID to update
   * - `purchase_fee`: New purchase fee (optional)
   * - `max_buy_price_coefficient`: New max buy price coefficient (optional)
   * - `buy_back_fee`: New buy back fee (optional)
   * - `buyback_rate`: New buyback rate parameter (optional)
   * - `max_in_holding`: New maximum holding amount (optional)
   *
   * Emits:
   * - `CollateralUpdated` when the collateral is successfully updated
   *
   * Errors:
   * - `AssetNotApproved` if the asset is not a registered collateral
   **/
  | {
      name: 'UpdateCollateralAsset';
      params: {
        assetId: number;
        purchaseFee?: Permill | undefined;
        maxBuyPriceCoefficient?: FixedU128 | undefined;
        buyBackFee?: Permill | undefined;
        buybackRate?: Perbill | undefined;
        maxInHolding?: bigint | undefined | undefined;
      };
    }
  /**
   * Sell asset to HSM
   *
   * This function allows users to:
   * 1. Sell Hollar back to HSM in exchange for collateral assets
   * 2. Sell collateral assets to HSM in exchange for newly minted Hollar
   *
   * The valid pairs must include Hollar as one side and an approved collateral as the other side.
   *
   * Parameters:
   * - `origin`: Account selling the asset
   * - `asset_in`: Asset ID being sold
   * - `asset_out`: Asset ID being bought
   * - `amount_in`: Amount of asset_in to sell
   * - `slippage_limit`: Minimum amount out for slippage protection
   *
   * Emits:
   * - `Swapped3` when the sell is successful
   *
   * Errors:
   * - `InvalidAssetPair` if the pair is not Hollar and an approved collateral
   * - `AssetNotApproved` if the collateral asset isn't registered
   * - `SlippageLimitExceeded` if the amount received is less than the slippage limit
   * - `MaxBuyBackExceeded` if the sell would exceed the maximum buy back rate
   * - `MaxBuyPriceExceeded` if the sell would exceed the maximum buy price
   * - `InsufficientCollateralBalance` if HSM doesn't have enough collateral
   * - `InvalidEVMInteraction` if there's an error interacting with the Hollar ERC20 contract
   * - Other errors from underlying calls
   **/
  | { name: 'Sell'; params: { assetIn: number; assetOut: number; amountIn: bigint; slippageLimit: bigint } }
  /**
   * Buy asset from HSM
   *
   * This function allows users to:
   * 1. Buy Hollar from HSM using collateral assets
   * 2. Buy collateral assets from HSM using Hollar
   *
   * The valid pairs must include Hollar as one side and an approved collateral as the other side.
   *
   * Parameters:
   * - `origin`: Account buying the asset
   * - `asset_in`: Asset ID being sold by the user
   * - `asset_out`: Asset ID being bought by the user
   * - `amount_out`: Amount of asset_out to buy
   * - `slippage_limit`: Maximum amount in for slippage protection
   *
   * Emits:
   * - `Swapped3` when the buy is successful
   *
   * Errors:
   * - `InvalidAssetPair` if the pair is not Hollar and an approved collateral
   * - `AssetNotApproved` if the collateral asset isn't registered
   * - `SlippageLimitExceeded` if the amount input exceeds the slippage limit
   * - `MaxHoldingExceeded` if the buy would cause HSM to exceed its maximum holding
   * - `InvalidEVMInteraction` if there's an error interacting with the Hollar ERC20 contract
   * - Other errors from underlying calls
   **/
  | { name: 'Buy'; params: { assetIn: number; assetOut: number; amountOut: bigint; slippageLimit: bigint } }
  /**
   * Execute arbitrage opportunity between HSM and collateral stable pool
   *
   * This call is designed to be triggered automatically by offchain workers. It:
   * 1. Detects price imbalances between HSM and a stable pool for a collateral
   * 2. If an opportunity exists, mints Hollar, swaps it for collateral on HSM
   * 3. Swaps that collateral for Hollar on the stable pool
   * 4. Burns the Hollar received from the arbitrage
   *
   * This helps maintain the peg of Hollar by profiting from and correcting price imbalances.
   * The call is unsigned and should only be executed by offchain workers.
   *
   * Parameters:
   * - `origin`: Must be None (unsigned)
   * - `collateral_asset_id`: The ID of the collateral asset to check for arbitrage
   *
   * Emits:
   * - `ArbitrageExecuted` when the arbitrage is successful
   *
   * Errors:
   * - `AssetNotApproved` if the asset is not a registered collateral
   * - `NoArbitrageOpportunity` if there's no profitable arbitrage opportunity
   * - `MaxBuyPriceExceeded` if the arbitrage would exceed the maximum buy price
   * - `InvalidEVMInteraction` if there's an error interacting with the Hollar ERC20 contract
   * - Other errors from underlying calls
   **/
  | { name: 'ExecuteArbitrage'; params: { collateralAssetId: number } }
  | { name: 'SetFlashMinter'; params: { flashMinterAddr: H160 } };

export type PalletHsmCallLike =
  /**
   * Add a new collateral asset
   *
   * This function adds a new asset as an approved collateral for Hollar. Only callable by
   * the governance (root origin).
   *
   * Parameters:
   * - `origin`: Must be Root
   * - `asset_id`: Asset ID to be added as collateral
   * - `pool_id`: StableSwap pool ID where this asset and Hollar are paired
   * - `purchase_fee`: Fee applied when buying Hollar with this asset (added to purchase price)
   * - `max_buy_price_coefficient`: Maximum buy price coefficient for HSM to buy back Hollar
   * - `buy_back_fee`: Fee applied when buying back Hollar (subtracted from buy price)
   * - `buyback_rate`: Parameter that controls how quickly HSM can buy Hollar with this asset
   * - `max_in_holding`: Optional maximum amount of collateral HSM can hold
   *
   * Emits:
   * - `CollateralAdded` when the collateral is successfully added
   *
   * Errors:
   * - `AssetAlreadyApproved` if the asset is already registered as a collateral
   * - `PoolAlreadyHasCollateral` if another asset from the same pool is already approved
   * - `HollarNotInPool` if Hollar is not found in the specified pool
   * - `AssetNotInPool` if the collateral asset is not found in the specified pool
   * - Other errors from underlying calls
   **/
  | {
      name: 'AddCollateralAsset';
      params: {
        assetId: number;
        poolId: number;
        purchaseFee: Permill;
        maxBuyPriceCoefficient: FixedU128;
        buyBackFee: Permill;
        buybackRate: Perbill;
        maxInHolding?: bigint | undefined;
      };
    }
  /**
   * Remove a collateral asset
   *
   * Removes an asset from the approved collaterals list. Only callable by the governance (root origin).
   * The collateral must have a zero balance in the HSM account before it can be removed.
   *
   * Parameters:
   * - `origin`: Must be Root
   * - `asset_id`: Asset ID to remove from collaterals
   *
   * Emits:
   * - `CollateralRemoved` when the collateral is successfully removed
   *
   * Errors:
   * - `AssetNotApproved` if the asset is not a registered collateral
   * - `CollateralNotEmpty` if the HSM account still holds some of this asset
   **/
  | { name: 'RemoveCollateralAsset'; params: { assetId: number } }
  /**
   * Update collateral asset parameters
   *
   * Updates the parameters for an existing collateral asset. Only callable by the governance (root origin).
   * Each parameter is optional and only provided parameters will be updated.
   *
   * Parameters:
   * - `origin`: Must be Root
   * - `asset_id`: Asset ID to update
   * - `purchase_fee`: New purchase fee (optional)
   * - `max_buy_price_coefficient`: New max buy price coefficient (optional)
   * - `buy_back_fee`: New buy back fee (optional)
   * - `buyback_rate`: New buyback rate parameter (optional)
   * - `max_in_holding`: New maximum holding amount (optional)
   *
   * Emits:
   * - `CollateralUpdated` when the collateral is successfully updated
   *
   * Errors:
   * - `AssetNotApproved` if the asset is not a registered collateral
   **/
  | {
      name: 'UpdateCollateralAsset';
      params: {
        assetId: number;
        purchaseFee?: Permill | undefined;
        maxBuyPriceCoefficient?: FixedU128 | undefined;
        buyBackFee?: Permill | undefined;
        buybackRate?: Perbill | undefined;
        maxInHolding?: bigint | undefined | undefined;
      };
    }
  /**
   * Sell asset to HSM
   *
   * This function allows users to:
   * 1. Sell Hollar back to HSM in exchange for collateral assets
   * 2. Sell collateral assets to HSM in exchange for newly minted Hollar
   *
   * The valid pairs must include Hollar as one side and an approved collateral as the other side.
   *
   * Parameters:
   * - `origin`: Account selling the asset
   * - `asset_in`: Asset ID being sold
   * - `asset_out`: Asset ID being bought
   * - `amount_in`: Amount of asset_in to sell
   * - `slippage_limit`: Minimum amount out for slippage protection
   *
   * Emits:
   * - `Swapped3` when the sell is successful
   *
   * Errors:
   * - `InvalidAssetPair` if the pair is not Hollar and an approved collateral
   * - `AssetNotApproved` if the collateral asset isn't registered
   * - `SlippageLimitExceeded` if the amount received is less than the slippage limit
   * - `MaxBuyBackExceeded` if the sell would exceed the maximum buy back rate
   * - `MaxBuyPriceExceeded` if the sell would exceed the maximum buy price
   * - `InsufficientCollateralBalance` if HSM doesn't have enough collateral
   * - `InvalidEVMInteraction` if there's an error interacting with the Hollar ERC20 contract
   * - Other errors from underlying calls
   **/
  | { name: 'Sell'; params: { assetIn: number; assetOut: number; amountIn: bigint; slippageLimit: bigint } }
  /**
   * Buy asset from HSM
   *
   * This function allows users to:
   * 1. Buy Hollar from HSM using collateral assets
   * 2. Buy collateral assets from HSM using Hollar
   *
   * The valid pairs must include Hollar as one side and an approved collateral as the other side.
   *
   * Parameters:
   * - `origin`: Account buying the asset
   * - `asset_in`: Asset ID being sold by the user
   * - `asset_out`: Asset ID being bought by the user
   * - `amount_out`: Amount of asset_out to buy
   * - `slippage_limit`: Maximum amount in for slippage protection
   *
   * Emits:
   * - `Swapped3` when the buy is successful
   *
   * Errors:
   * - `InvalidAssetPair` if the pair is not Hollar and an approved collateral
   * - `AssetNotApproved` if the collateral asset isn't registered
   * - `SlippageLimitExceeded` if the amount input exceeds the slippage limit
   * - `MaxHoldingExceeded` if the buy would cause HSM to exceed its maximum holding
   * - `InvalidEVMInteraction` if there's an error interacting with the Hollar ERC20 contract
   * - Other errors from underlying calls
   **/
  | { name: 'Buy'; params: { assetIn: number; assetOut: number; amountOut: bigint; slippageLimit: bigint } }
  /**
   * Execute arbitrage opportunity between HSM and collateral stable pool
   *
   * This call is designed to be triggered automatically by offchain workers. It:
   * 1. Detects price imbalances between HSM and a stable pool for a collateral
   * 2. If an opportunity exists, mints Hollar, swaps it for collateral on HSM
   * 3. Swaps that collateral for Hollar on the stable pool
   * 4. Burns the Hollar received from the arbitrage
   *
   * This helps maintain the peg of Hollar by profiting from and correcting price imbalances.
   * The call is unsigned and should only be executed by offchain workers.
   *
   * Parameters:
   * - `origin`: Must be None (unsigned)
   * - `collateral_asset_id`: The ID of the collateral asset to check for arbitrage
   *
   * Emits:
   * - `ArbitrageExecuted` when the arbitrage is successful
   *
   * Errors:
   * - `AssetNotApproved` if the asset is not a registered collateral
   * - `NoArbitrageOpportunity` if there's no profitable arbitrage opportunity
   * - `MaxBuyPriceExceeded` if the arbitrage would exceed the maximum buy price
   * - `InvalidEVMInteraction` if there's an error interacting with the Hollar ERC20 contract
   * - Other errors from underlying calls
   **/
  | { name: 'ExecuteArbitrage'; params: { collateralAssetId: number } }
  | { name: 'SetFlashMinter'; params: { flashMinterAddr: H160 } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type OrmlTokensModuleCall =
  /**
   * Transfer some liquid free balance to another account.
   *
   * `transfer` will set the `FreeBalance` of the sender and receiver.
   * It will decrease the total issuance of the system by the
   * `TransferFee`. If the sender's account is below the existential
   * deposit as a result of the transfer, the account will be reaped.
   *
   * The dispatch origin for this call must be `Signed` by the
   * transactor.
   *
   * - `dest`: The recipient of the transfer.
   * - `currency_id`: currency type.
   * - `amount`: free balance amount to tranfer.
   **/
  | { name: 'Transfer'; params: { dest: AccountId32; currencyId: number; amount: bigint } }
  /**
   * Transfer all remaining balance to the given account.
   *
   * NOTE: This function only attempts to transfer _transferable_
   * balances. This means that any locked, reserved, or existential
   * deposits (when `keep_alive` is `true`), will not be transferred by
   * this function. To ensure that this function results in a killed
   * account, you might need to prepare the account by removing any
   * reference counters, storage deposits, etc...
   *
   * The dispatch origin for this call must be `Signed` by the
   * transactor.
   *
   * - `dest`: The recipient of the transfer.
   * - `currency_id`: currency type.
   * - `keep_alive`: A boolean to determine if the `transfer_all`
   * operation should send all of the funds the account has, causing
   * the sender account to be killed (false), or transfer everything
   * except at least the existential deposit, which will guarantee to
   * keep the sender account alive (true).
   **/
  | { name: 'TransferAll'; params: { dest: AccountId32; currencyId: number; keepAlive: boolean } }
  /**
   * Same as the [`transfer`] call, but with a check that the transfer
   * will not kill the origin account.
   *
   * 99% of the time you want [`transfer`] instead.
   *
   * The dispatch origin for this call must be `Signed` by the
   * transactor.
   *
   * - `dest`: The recipient of the transfer.
   * - `currency_id`: currency type.
   * - `amount`: free balance amount to tranfer.
   **/
  | { name: 'TransferKeepAlive'; params: { dest: AccountId32; currencyId: number; amount: bigint } }
  /**
   * Exactly as `transfer`, except the origin must be root and the source
   * account may be specified.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * - `source`: The sender of the transfer.
   * - `dest`: The recipient of the transfer.
   * - `currency_id`: currency type.
   * - `amount`: free balance amount to tranfer.
   **/
  | { name: 'ForceTransfer'; params: { source: AccountId32; dest: AccountId32; currencyId: number; amount: bigint } }
  /**
   * Set the balances of a given account.
   *
   * This will alter `FreeBalance` and `ReservedBalance` in storage. it
   * will also decrease the total issuance of the system
   * (`TotalIssuance`). If the new free or reserved balance is below the
   * existential deposit, it will reap the `AccountInfo`.
   *
   * The dispatch origin for this call is `root`.
   **/
  | { name: 'SetBalance'; params: { who: AccountId32; currencyId: number; newFree: bigint; newReserved: bigint } };

export type OrmlTokensModuleCallLike =
  /**
   * Transfer some liquid free balance to another account.
   *
   * `transfer` will set the `FreeBalance` of the sender and receiver.
   * It will decrease the total issuance of the system by the
   * `TransferFee`. If the sender's account is below the existential
   * deposit as a result of the transfer, the account will be reaped.
   *
   * The dispatch origin for this call must be `Signed` by the
   * transactor.
   *
   * - `dest`: The recipient of the transfer.
   * - `currency_id`: currency type.
   * - `amount`: free balance amount to tranfer.
   **/
  | { name: 'Transfer'; params: { dest: AccountId32Like; currencyId: number; amount: bigint } }
  /**
   * Transfer all remaining balance to the given account.
   *
   * NOTE: This function only attempts to transfer _transferable_
   * balances. This means that any locked, reserved, or existential
   * deposits (when `keep_alive` is `true`), will not be transferred by
   * this function. To ensure that this function results in a killed
   * account, you might need to prepare the account by removing any
   * reference counters, storage deposits, etc...
   *
   * The dispatch origin for this call must be `Signed` by the
   * transactor.
   *
   * - `dest`: The recipient of the transfer.
   * - `currency_id`: currency type.
   * - `keep_alive`: A boolean to determine if the `transfer_all`
   * operation should send all of the funds the account has, causing
   * the sender account to be killed (false), or transfer everything
   * except at least the existential deposit, which will guarantee to
   * keep the sender account alive (true).
   **/
  | { name: 'TransferAll'; params: { dest: AccountId32Like; currencyId: number; keepAlive: boolean } }
  /**
   * Same as the [`transfer`] call, but with a check that the transfer
   * will not kill the origin account.
   *
   * 99% of the time you want [`transfer`] instead.
   *
   * The dispatch origin for this call must be `Signed` by the
   * transactor.
   *
   * - `dest`: The recipient of the transfer.
   * - `currency_id`: currency type.
   * - `amount`: free balance amount to tranfer.
   **/
  | { name: 'TransferKeepAlive'; params: { dest: AccountId32Like; currencyId: number; amount: bigint } }
  /**
   * Exactly as `transfer`, except the origin must be root and the source
   * account may be specified.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * - `source`: The sender of the transfer.
   * - `dest`: The recipient of the transfer.
   * - `currency_id`: currency type.
   * - `amount`: free balance amount to tranfer.
   **/
  | {
      name: 'ForceTransfer';
      params: { source: AccountId32Like; dest: AccountId32Like; currencyId: number; amount: bigint };
    }
  /**
   * Set the balances of a given account.
   *
   * This will alter `FreeBalance` and `ReservedBalance` in storage. it
   * will also decrease the total issuance of the system
   * (`TotalIssuance`). If the new free or reserved balance is below the
   * existential deposit, it will reap the `AccountInfo`.
   *
   * The dispatch origin for this call is `root`.
   **/
  | { name: 'SetBalance'; params: { who: AccountId32Like; currencyId: number; newFree: bigint; newReserved: bigint } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletCurrenciesModuleCall =
  /**
   * Transfer some balance to another account under `currency_id`.
   *
   * The dispatch origin for this call must be `Signed` by the
   * transactor.
   **/
  | { name: 'Transfer'; params: { dest: AccountId32; currencyId: number; amount: bigint } }
  /**
   * Transfer some native currency to another account.
   *
   * The dispatch origin for this call must be `Signed` by the
   * transactor.
   **/
  | { name: 'TransferNativeCurrency'; params: { dest: AccountId32; amount: bigint } }
  /**
   * update amount of account `who` under `currency_id`.
   *
   * The dispatch origin of this call must be _Root_.
   **/
  | { name: 'UpdateBalance'; params: { who: AccountId32; currencyId: number; amount: bigint } };

export type PalletCurrenciesModuleCallLike =
  /**
   * Transfer some balance to another account under `currency_id`.
   *
   * The dispatch origin for this call must be `Signed` by the
   * transactor.
   **/
  | { name: 'Transfer'; params: { dest: AccountId32Like; currencyId: number; amount: bigint } }
  /**
   * Transfer some native currency to another account.
   *
   * The dispatch origin for this call must be `Signed` by the
   * transactor.
   **/
  | { name: 'TransferNativeCurrency'; params: { dest: AccountId32Like; amount: bigint } }
  /**
   * update amount of account `who` under `currency_id`.
   *
   * The dispatch origin of this call must be _Root_.
   **/
  | { name: 'UpdateBalance'; params: { who: AccountId32Like; currencyId: number; amount: bigint } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type OrmlVestingModuleCall =
  | { name: 'Claim' }
  | { name: 'VestedTransfer'; params: { dest: AccountId32; schedule: OrmlVestingVestingSchedule } }
  | {
      name: 'UpdateVestingSchedules';
      params: { who: AccountId32; vestingSchedules: Array<OrmlVestingVestingSchedule> };
    }
  | { name: 'ClaimFor'; params: { dest: AccountId32 } };

export type OrmlVestingModuleCallLike =
  | { name: 'Claim' }
  | { name: 'VestedTransfer'; params: { dest: AccountId32Like; schedule: OrmlVestingVestingSchedule } }
  | {
      name: 'UpdateVestingSchedules';
      params: { who: AccountId32Like; vestingSchedules: Array<OrmlVestingVestingSchedule> };
    }
  | { name: 'ClaimFor'; params: { dest: AccountId32Like } };

export type OrmlVestingVestingSchedule = { start: number; period: number; periodCount: number; perPeriod: bigint };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletEvmCall =
  /**
   * Withdraw balance from EVM into currency/balances pallet.
   **/
  | { name: 'Withdraw'; params: { address: H160; value: bigint } }
  /**
   * Issue an EVM call operation. This is similar to a message call transaction in Ethereum.
   **/
  | {
      name: 'Call';
      params: {
        source: H160;
        target: H160;
        input: Bytes;
        value: U256;
        gasLimit: bigint;
        maxFeePerGas: U256;
        maxPriorityFeePerGas?: U256 | undefined;
        nonce?: U256 | undefined;
        accessList: Array<[H160, Array<H256>]>;
      };
    }
  /**
   * Issue an EVM create operation. This is similar to a contract creation transaction in
   * Ethereum.
   **/
  | {
      name: 'Create';
      params: {
        source: H160;
        init: Bytes;
        value: U256;
        gasLimit: bigint;
        maxFeePerGas: U256;
        maxPriorityFeePerGas?: U256 | undefined;
        nonce?: U256 | undefined;
        accessList: Array<[H160, Array<H256>]>;
      };
    }
  /**
   * Issue an EVM create2 operation.
   **/
  | {
      name: 'Create2';
      params: {
        source: H160;
        init: Bytes;
        salt: H256;
        value: U256;
        gasLimit: bigint;
        maxFeePerGas: U256;
        maxPriorityFeePerGas?: U256 | undefined;
        nonce?: U256 | undefined;
        accessList: Array<[H160, Array<H256>]>;
      };
    };

export type PalletEvmCallLike =
  /**
   * Withdraw balance from EVM into currency/balances pallet.
   **/
  | { name: 'Withdraw'; params: { address: H160; value: bigint } }
  /**
   * Issue an EVM call operation. This is similar to a message call transaction in Ethereum.
   **/
  | {
      name: 'Call';
      params: {
        source: H160;
        target: H160;
        input: BytesLike;
        value: U256;
        gasLimit: bigint;
        maxFeePerGas: U256;
        maxPriorityFeePerGas?: U256 | undefined;
        nonce?: U256 | undefined;
        accessList: Array<[H160, Array<H256>]>;
      };
    }
  /**
   * Issue an EVM create operation. This is similar to a contract creation transaction in
   * Ethereum.
   **/
  | {
      name: 'Create';
      params: {
        source: H160;
        init: BytesLike;
        value: U256;
        gasLimit: bigint;
        maxFeePerGas: U256;
        maxPriorityFeePerGas?: U256 | undefined;
        nonce?: U256 | undefined;
        accessList: Array<[H160, Array<H256>]>;
      };
    }
  /**
   * Issue an EVM create2 operation.
   **/
  | {
      name: 'Create2';
      params: {
        source: H160;
        init: BytesLike;
        salt: H256;
        value: U256;
        gasLimit: bigint;
        maxFeePerGas: U256;
        maxPriorityFeePerGas?: U256 | undefined;
        nonce?: U256 | undefined;
        accessList: Array<[H160, Array<H256>]>;
      };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletEthereumCall =
  /**
   * Transact an Ethereum transaction.
   **/
  { name: 'Transact'; params: { transaction: EthereumTransactionTransactionV2 } };

export type PalletEthereumCallLike =
  /**
   * Transact an Ethereum transaction.
   **/
  { name: 'Transact'; params: { transaction: EthereumTransactionTransactionV2 } };

export type EthereumTransactionTransactionV2 =
  | { type: 'Legacy'; value: EthereumTransactionLegacyTransaction }
  | { type: 'Eip2930'; value: EthereumTransactionEip2930Transaction }
  | { type: 'Eip1559'; value: EthereumTransactionEip1559Transaction };

export type EthereumTransactionLegacyTransaction = {
  nonce: U256;
  gasPrice: U256;
  gasLimit: U256;
  action: EthereumTransactionTransactionAction;
  value: U256;
  input: Bytes;
  signature: EthereumTransactionTransactionSignature;
};

export type EthereumTransactionTransactionAction = { type: 'Call'; value: H160 } | { type: 'Create' };

export type EthereumTransactionTransactionSignature = { v: EthereumTransactionTransactionRecoveryId; r: H256; s: H256 };

export type EthereumTransactionTransactionRecoveryId = bigint;

export type EthereumTransactionEip2930Transaction = {
  chainId: bigint;
  nonce: U256;
  gasPrice: U256;
  gasLimit: U256;
  action: EthereumTransactionTransactionAction;
  value: U256;
  input: Bytes;
  accessList: Array<EthereumTransactionAccessListItem>;
  oddYParity: boolean;
  r: H256;
  s: H256;
};

export type EthereumTransactionAccessListItem = { address: H160; storageKeys: Array<H256> };

export type EthereumTransactionEip1559Transaction = {
  chainId: bigint;
  nonce: U256;
  maxPriorityFeePerGas: U256;
  maxFeePerGas: U256;
  gasLimit: U256;
  action: EthereumTransactionTransactionAction;
  value: U256;
  input: Bytes;
  accessList: Array<EthereumTransactionAccessListItem>;
  oddYParity: boolean;
  r: H256;
  s: H256;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletEvmAccountsCall =
  /**
   * Binds a Substrate address to EVM address.
   * After binding, the EVM is able to convert an EVM address to the original Substrate address.
   * Without binding, the EVM converts an EVM address to a truncated Substrate address, which doesn't correspond
   * to the origin address.
   *
   * Binding an address is not necessary for interacting with the EVM.
   *
   * Parameters:
   * - `origin`: Substrate account binding an address
   *
   * Emits `EvmAccountBound` event when successful.
   **/
  | { name: 'BindEvmAddress' }
  /**
   * Adds an EVM address to the list of addresses that are allowed to deploy smart contracts.
   *
   * Parameters:
   * - `origin`: Substrate account whitelisting an address. Must be `ControllerOrigin`.
   * - `address`: EVM address that is whitelisted
   *
   * Emits `DeployerAdded` event when successful.
   **/
  | { name: 'AddContractDeployer'; params: { address: H160 } }
  /**
   * Removes an EVM address from the list of addresses that are allowed to deploy smart contracts.
   *
   * Parameters:
   * - `origin`: Substrate account removing the EVM address from the whitelist. Must be `ControllerOrigin`.
   * - `address`: EVM address that is removed from the whitelist
   *
   * Emits `DeployerRemoved` event when successful.
   **/
  | { name: 'RemoveContractDeployer'; params: { address: H160 } }
  /**
   * Removes the account's EVM address from the list of addresses that are allowed to deploy smart contracts.
   * Based on the best practices, this extrinsic can be called by any whitelisted account to renounce their own permission.
   *
   * Parameters:
   * - `origin`: Substrate account removing their EVM address from the whitelist.
   *
   * Emits `DeployerRemoved` event when successful.
   **/
  | { name: 'RenounceContractDeployer' }
  /**
   * Adds address of the contract to the list of approved contracts to manage balances.
   *
   * Effectively giving it allowance to for any balances and tokens.
   *
   * Parameters:
   * - `origin`: Must be `ControllerOrigin`.
   * - `address`: Contract address that will be approved
   *
   * Emits `ContractApproved` event when successful.
   **/
  | { name: 'ApproveContract'; params: { address: H160 } }
  /**
   * Removes address of the contract from the list of approved contracts to manage balances.
   *
   * Parameters:
   * - `origin`: Must be `ControllerOrigin`.
   * - `address`: Contract address that will be disapproved
   *
   * Emits `ContractDisapproved` event when successful.
   **/
  | { name: 'DisapproveContract'; params: { address: H160 } };

export type PalletEvmAccountsCallLike =
  /**
   * Binds a Substrate address to EVM address.
   * After binding, the EVM is able to convert an EVM address to the original Substrate address.
   * Without binding, the EVM converts an EVM address to a truncated Substrate address, which doesn't correspond
   * to the origin address.
   *
   * Binding an address is not necessary for interacting with the EVM.
   *
   * Parameters:
   * - `origin`: Substrate account binding an address
   *
   * Emits `EvmAccountBound` event when successful.
   **/
  | { name: 'BindEvmAddress' }
  /**
   * Adds an EVM address to the list of addresses that are allowed to deploy smart contracts.
   *
   * Parameters:
   * - `origin`: Substrate account whitelisting an address. Must be `ControllerOrigin`.
   * - `address`: EVM address that is whitelisted
   *
   * Emits `DeployerAdded` event when successful.
   **/
  | { name: 'AddContractDeployer'; params: { address: H160 } }
  /**
   * Removes an EVM address from the list of addresses that are allowed to deploy smart contracts.
   *
   * Parameters:
   * - `origin`: Substrate account removing the EVM address from the whitelist. Must be `ControllerOrigin`.
   * - `address`: EVM address that is removed from the whitelist
   *
   * Emits `DeployerRemoved` event when successful.
   **/
  | { name: 'RemoveContractDeployer'; params: { address: H160 } }
  /**
   * Removes the account's EVM address from the list of addresses that are allowed to deploy smart contracts.
   * Based on the best practices, this extrinsic can be called by any whitelisted account to renounce their own permission.
   *
   * Parameters:
   * - `origin`: Substrate account removing their EVM address from the whitelist.
   *
   * Emits `DeployerRemoved` event when successful.
   **/
  | { name: 'RenounceContractDeployer' }
  /**
   * Adds address of the contract to the list of approved contracts to manage balances.
   *
   * Effectively giving it allowance to for any balances and tokens.
   *
   * Parameters:
   * - `origin`: Must be `ControllerOrigin`.
   * - `address`: Contract address that will be approved
   *
   * Emits `ContractApproved` event when successful.
   **/
  | { name: 'ApproveContract'; params: { address: H160 } }
  /**
   * Removes address of the contract from the list of approved contracts to manage balances.
   *
   * Parameters:
   * - `origin`: Must be `ControllerOrigin`.
   * - `address`: Contract address that will be disapproved
   *
   * Emits `ContractDisapproved` event when successful.
   **/
  | { name: 'DisapproveContract'; params: { address: H160 } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletXykLiquidityMiningCall =
  /**
   * Create new liquidity mining program with provided parameters.
   *
   * `owner` account has to have at least `total_rewards` balance. This fund will be
   * transferred from `owner` to farm account.
   * In case of `reward_currency` is insufficient asset, farm's `owner` has to pay existential
   * deposit for global farm account and for liquidity mining `pot` account.
   *
   * The dispatch origin for this call must be `T::CreateOrigin`.
   * !!!WARN: `T::CreateOrigin` has power over funds of `owner`'s account and it should be
   * configured to trusted origin e.g Sudo or Governance.
   *
   * Parameters:
   * - `origin`: global farm's owner.
   * - `total_rewards`: total rewards planned to distribute. This rewards will be
   * distributed between all yield farms in the global farm.
   * - `planned_yielding_periods`: planned number of periods to distribute `total_rewards`.
   * WARN: THIS IS NOT HARD DEADLINE. Not all rewards have to be distributed in
   * `planned_yielding_periods`. Rewards are distributed based on the situation in the yield
   * farms and can be distributed in a longer time frame but never in the shorter time frame.
   * - `blocks_per_period`: number of blocks in a single period. Min. number of blocks per
   * period is 1.
   * - `incentivized_asset`: asset to be incentivized in XYK pools. All yield farms added into
   * liq. mining program have to have `incentivized_asset` in their pair.
   * - `reward_currency`: payoff currency of rewards.
   * - `owner`: liq. mining program owner.
   * - `yield_per_period`: percentage return on `reward_currency` of all farms p.a.
   * - `min_deposit`: minimum amount which can be deposited to the farm
   * - `price_adjustment`:
   * Emits `GlobalFarmCreated` event when successful.
   **/
  | {
      name: 'CreateGlobalFarm';
      params: {
        totalRewards: bigint;
        plannedYieldingPeriods: number;
        blocksPerPeriod: number;
        incentivizedAsset: number;
        rewardCurrency: number;
        owner: AccountId32;
        yieldPerPeriod: Perquintill;
        minDeposit: bigint;
        priceAdjustment: FixedU128;
      };
    }
  /**
   * Update global farm's prices adjustment.
   *
   * Only farm's owner can perform this action.
   *
   * Parameters:
   * - `origin`: global farm's owner.
   * - `global_farm_id`: id of the global farm to update
   * - `price_adjustment`: new value for price adjustment
   *
   * Emits `GlobalFarmUpdated` event when successful.
   **/
  | { name: 'UpdateGlobalFarm'; params: { globalFarmId: number; priceAdjustment: FixedU128 } }
  /**
   * Terminate existing liq. mining program.
   *
   * Only farm owner can perform this action.
   *
   * WARN: To successfully terminate a farm, farm have to be empty(all yield farms in he global farm must be terminated).
   *
   * Parameters:
   * - `origin`: global farm's owner.
   * - `global_farm_id`: id of global farm to be terminated.
   *
   * Emits `GlobalFarmTerminated` event when successful.
   **/
  | { name: 'TerminateGlobalFarm'; params: { globalFarmId: number } }
  /**
   * Add yield farm for given `asset_pair` XYK pool.
   *
   * Only farm owner can perform this action.
   *
   * Only XYKs with `asset_pair` with `incentivized_asset` can be added into the farm. XYK
   * pool for `asset_pair` has to exist to successfully create yield farm.
   * Yield farm for same `asset_pair` can exist only once in the global farm.
   *
   * Parameters:
   * - `origin`: global farm's owner.
   * - `farm_id`: global farm id to which a yield farm will be added.
   * - `asset_pair`: asset pair identifying yield farm. Liq. mining will be allowed for this
   * `asset_pair` and one of the assets in the pair must be `incentivized_asset`.
   * - `multiplier`: yield farm multiplier.
   * - `loyalty_curve`: curve to calculate loyalty multiplier to distribute rewards to users
   * with time incentive. `None` means no loyalty multiplier.
   *
   * Emits `YieldFarmCreated` event when successful.
   **/
  | {
      name: 'CreateYieldFarm';
      params: {
        globalFarmId: number;
        assetPair: PalletXykAssetPair;
        multiplier: FixedU128;
        loyaltyCurve?: PalletLiquidityMiningLoyaltyCurve | undefined;
      };
    }
  /**
   * Update yield farm multiplier.
   *
   * Only farm owner can perform this action.
   *
   * Parameters:
   * - `origin`: global farm's owner.
   * - `global_farm_id`: global farm id in which yield farm will be updated.
   * - `asset_pair`: asset pair identifying yield farm in global farm.
   * - `multiplier`: new yield farm multiplier.
   *
   * Emits `YieldFarmUpdated` event when successful.
   **/
  | { name: 'UpdateYieldFarm'; params: { globalFarmId: number; assetPair: PalletXykAssetPair; multiplier: FixedU128 } }
  /**
   * Stop liq. miming for specific yield farm.
   *
   * This function claims rewards from `GlobalFarm` last time and stops yield farm
   * incentivization from a `GlobalFarm`. Users will be able to only withdraw
   * shares(with claiming) after calling this function.
   * `deposit_shares()` and `claim_rewards()` are not allowed on canceled yield farm.
   *
   * Only farm owner can perform this action.
   *
   * Parameters:
   * - `origin`: global farm's owner.
   * - `global_farm_id`: farm id in which yield farm will be canceled.
   * - `asset_pair`: asset pair identifying yield farm in the farm.
   *
   * Emits `YieldFarmStopped` event when successful.
   **/
  | { name: 'StopYieldFarm'; params: { globalFarmId: number; assetPair: PalletXykAssetPair } }
  /**
   * Resume yield farm for stopped yield farm.
   *
   * This function resume incentivization from `GlobalFarm` and restore full functionality
   * for yield farm. Users will be able to deposit, claim and withdraw again.
   *
   * WARN: Yield farm is NOT rewarded for time it was stopped.
   *
   * Only farm owner can perform this action.
   *
   * Parameters:
   * - `origin`: global farm's owner.
   * - `global_farm_id`: global farm id in which yield farm will be resumed.
   * - `yield_farm_id`: id of yield farm to be resumed.
   * - `asset_pair`: asset pair identifying yield farm in global farm.
   * - `multiplier`: yield farm multiplier in the farm.
   *
   * Emits `YieldFarmResumed` event when successful.
   **/
  | {
      name: 'ResumeYieldFarm';
      params: { globalFarmId: number; yieldFarmId: number; assetPair: PalletXykAssetPair; multiplier: FixedU128 };
    }
  /**
   * Remove yield farm
   *
   * This function marks a yield farm as ready to be removed from storage when it's empty. Users will
   * be able to only withdraw shares(without claiming rewards from yield farm). Unpaid rewards
   * will be transferred back to global farm and will be used to distribute to other yield farms.
   *
   * Yield farm must be stopped before calling this function.
   *
   * Only global farm's owner can perform this action. Yield farm stays in the storage until it's
   * empty(all farm entries are withdrawn). Last withdrawn from yield farm trigger removing from
   * the storage.
   *
   * Parameters:
   * - `origin`: global farm's owner.
   * - `global_farm_id`: farm id from which yield farm should be terminated.
   * - `yield_farm_id`: id of yield farm to be terminated.
   * - `asset_pair`: asset pair identifying yield farm in the global farm.
   *
   * Emits `YieldFarmTerminated` event when successful.
   **/
  | { name: 'TerminateYieldFarm'; params: { globalFarmId: number; yieldFarmId: number; assetPair: PalletXykAssetPair } }
  /**
   * Deposit LP shares to a liq. mining.
   *
   * This function transfers LP shares from `origin` to pallet's account and mint nft for
   * `origin` account. Minted nft represents deposit in the liq. mining.
   *
   * Parameters:
   * - `origin`: account depositing LP shares. This account has to have at least
   * `shares_amount` of LP shares.
   * - `global_farm_id`: id of global farm to which user wants to deposit LP shares.
   * - `yield_farm_id`: id of yield farm to deposit to.
   * - `asset_pair`: asset pair identifying LP shares user wants to deposit.
   * - `shares_amount`: amount of LP shares user wants to deposit.
   *
   * Emits `SharesDeposited` event when successful.
   **/
  | {
      name: 'DepositShares';
      params: { globalFarmId: number; yieldFarmId: number; assetPair: PalletXykAssetPair; sharesAmount: bigint };
    }
  /**
   * Join multiple farms with a given share amount
   *
   * The share is deposited to the first farm of the specified fams,
   * and then redeposit the shares to the remaining farms
   *
   * Parameters:
   * - `origin`: account depositing LP shares. This account has to have at least
   * - `farm_entries`: list of global farm id and yield farm id pairs to join
   * - `asset_pair`: asset pair identifying LP shares user wants to deposit.
   * - `shares_amount`: amount of LP shares user wants to deposit.
   *
   * Emits `SharesDeposited` event for the first farm entry
   * Emits `SharesRedeposited` event for each farm entry after the first one
   **/
  | {
      name: 'JoinFarms';
      params: { farmEntries: Array<[number, number]>; assetPair: PalletXykAssetPair; sharesAmount: bigint };
    }
  /**
   * Add liquidity to XYK pool and join multiple farms with a given share amount
   *
   * The share is deposited to the first farm of the specified entries,
   * and then redeposit the shares to the remaining farms
   *
   * Parameters:
   * - `origin`: account depositing LP shares. This account has to have at least
   * - `asset_a`: asset id of the first asset in the pair
   * - `asset_b`: asset id of the second asset in the pair
   * - `amount_a`: amount of the first asset to deposit
   * - `amount_b_max_limit`: maximum amount of the second asset to deposit
   * - `farm_entries`: list of global farm id and yield farm id pairs to join
   *
   * Emits `SharesDeposited` event for the first farm entry
   * Emits `SharesRedeposited` event for each farm entry after the first one
   **/
  | {
      name: 'AddLiquidityAndJoinFarms';
      params: {
        assetA: number;
        assetB: number;
        amountA: bigint;
        amountBMaxLimit: bigint;
        farmEntries: Array<[number, number]>;
      };
    }
  /**
   * Redeposit already locked LP shares to another yield farm.
   *
   * This function create yield farm entry for existing deposit. LP shares are not transferred
   * and amount of LP shares is based on existing deposit.
   *
   * This function DOESN'T create new deposit.
   *
   * Parameters:
   * - `origin`: account depositing LP shares. This account have to have at least
   * - `global_farm_id`: global farm identifier.
   * - `yield_farm_id`: yield farm identifier redepositing to.
   * - `asset_pair`: asset pair identifying LP shares user want to deposit.
   * - `deposit_id`: identifier of the deposit.
   *
   * Emits `SharesRedeposited` event when successful.
   **/
  | {
      name: 'RedepositShares';
      params: { globalFarmId: number; yieldFarmId: number; assetPair: PalletXykAssetPair; depositId: bigint };
    }
  /**
   * Claim rewards from liq. mining for deposit represented by `nft_id`.
   *
   * This function calculate user rewards from liq. mining and transfer rewards to `origin`
   * account. Claiming in the same period is allowed only once.
   *
   * Parameters:
   * - `origin`: account owner of deposit(nft).
   * - `deposit_id`: nft id representing deposit in the yield farm.
   * - `yield_farm_id`: yield farm identifier to claim rewards from.
   *
   * Emits `RewardClaimed` event when successful.
   **/
  | { name: 'ClaimRewards'; params: { depositId: bigint; yieldFarmId: number } }
  /**
   * Withdraw LP shares from liq. mining with reward claiming if possible.
   *
   * List of possible cases of transfers of LP shares and claimed rewards:
   *
   * * yield farm is active(yield farm is not stopped) - claim and transfer rewards(if it
   * wasn't claimed in this period) and transfer LP shares.
   * * liq. mining is stopped - claim and transfer rewards(if it
   * wasn't claimed in this period) and transfer LP shares.
   * * yield farm was terminated - only LP shares will be transferred.
   * * farm was terminated - only LP shares will be transferred.
   *
   * User's unclaimable rewards will be transferred back to global farm's account.
   *
   * Parameters:
   * - `origin`: account owner of deposit(nft).
   * - `deposit_id`: nft id representing deposit in the yield farm.
   * - `yield_farm_id`: yield farm identifier to dithdraw shares from.
   * - `asset_pair`: asset pair identifying yield farm in global farm.
   *
   * Emits:
   * * `RewardClaimed` if claim happen
   * * `SharesWithdrawn` event when successful
   **/
  | { name: 'WithdrawShares'; params: { depositId: bigint; yieldFarmId: number; assetPair: PalletXykAssetPair } }
  /**
   * Exit from all specified yield farms
   *
   * This function will attempt to withdraw shares and claim rewards (if available) from all
   * specified yield farms for a given deposit.
   *
   * Parameters:
   * - `origin`: account owner of deposit(nft).
   * - `deposit_id`: nft id representing deposit in the yield farm.
   * - `asset_pair`: asset pair identifying yield farm(s) in global farm(s).
   * - `farm_entries`: id(s) of yield farm(s) to exit from.
   *
   * Emits:
   * * `RewardClaimed` for each successful claim
   * * `SharesWithdrawn` for each successful withdrawal
   * * `DepositDestroyed` if the deposit is fully withdrawn
   *
   **/
  | { name: 'ExitFarms'; params: { depositId: bigint; assetPair: PalletXykAssetPair; farmEntries: Array<number> } };

export type PalletXykLiquidityMiningCallLike =
  /**
   * Create new liquidity mining program with provided parameters.
   *
   * `owner` account has to have at least `total_rewards` balance. This fund will be
   * transferred from `owner` to farm account.
   * In case of `reward_currency` is insufficient asset, farm's `owner` has to pay existential
   * deposit for global farm account and for liquidity mining `pot` account.
   *
   * The dispatch origin for this call must be `T::CreateOrigin`.
   * !!!WARN: `T::CreateOrigin` has power over funds of `owner`'s account and it should be
   * configured to trusted origin e.g Sudo or Governance.
   *
   * Parameters:
   * - `origin`: global farm's owner.
   * - `total_rewards`: total rewards planned to distribute. This rewards will be
   * distributed between all yield farms in the global farm.
   * - `planned_yielding_periods`: planned number of periods to distribute `total_rewards`.
   * WARN: THIS IS NOT HARD DEADLINE. Not all rewards have to be distributed in
   * `planned_yielding_periods`. Rewards are distributed based on the situation in the yield
   * farms and can be distributed in a longer time frame but never in the shorter time frame.
   * - `blocks_per_period`: number of blocks in a single period. Min. number of blocks per
   * period is 1.
   * - `incentivized_asset`: asset to be incentivized in XYK pools. All yield farms added into
   * liq. mining program have to have `incentivized_asset` in their pair.
   * - `reward_currency`: payoff currency of rewards.
   * - `owner`: liq. mining program owner.
   * - `yield_per_period`: percentage return on `reward_currency` of all farms p.a.
   * - `min_deposit`: minimum amount which can be deposited to the farm
   * - `price_adjustment`:
   * Emits `GlobalFarmCreated` event when successful.
   **/
  | {
      name: 'CreateGlobalFarm';
      params: {
        totalRewards: bigint;
        plannedYieldingPeriods: number;
        blocksPerPeriod: number;
        incentivizedAsset: number;
        rewardCurrency: number;
        owner: AccountId32Like;
        yieldPerPeriod: Perquintill;
        minDeposit: bigint;
        priceAdjustment: FixedU128;
      };
    }
  /**
   * Update global farm's prices adjustment.
   *
   * Only farm's owner can perform this action.
   *
   * Parameters:
   * - `origin`: global farm's owner.
   * - `global_farm_id`: id of the global farm to update
   * - `price_adjustment`: new value for price adjustment
   *
   * Emits `GlobalFarmUpdated` event when successful.
   **/
  | { name: 'UpdateGlobalFarm'; params: { globalFarmId: number; priceAdjustment: FixedU128 } }
  /**
   * Terminate existing liq. mining program.
   *
   * Only farm owner can perform this action.
   *
   * WARN: To successfully terminate a farm, farm have to be empty(all yield farms in he global farm must be terminated).
   *
   * Parameters:
   * - `origin`: global farm's owner.
   * - `global_farm_id`: id of global farm to be terminated.
   *
   * Emits `GlobalFarmTerminated` event when successful.
   **/
  | { name: 'TerminateGlobalFarm'; params: { globalFarmId: number } }
  /**
   * Add yield farm for given `asset_pair` XYK pool.
   *
   * Only farm owner can perform this action.
   *
   * Only XYKs with `asset_pair` with `incentivized_asset` can be added into the farm. XYK
   * pool for `asset_pair` has to exist to successfully create yield farm.
   * Yield farm for same `asset_pair` can exist only once in the global farm.
   *
   * Parameters:
   * - `origin`: global farm's owner.
   * - `farm_id`: global farm id to which a yield farm will be added.
   * - `asset_pair`: asset pair identifying yield farm. Liq. mining will be allowed for this
   * `asset_pair` and one of the assets in the pair must be `incentivized_asset`.
   * - `multiplier`: yield farm multiplier.
   * - `loyalty_curve`: curve to calculate loyalty multiplier to distribute rewards to users
   * with time incentive. `None` means no loyalty multiplier.
   *
   * Emits `YieldFarmCreated` event when successful.
   **/
  | {
      name: 'CreateYieldFarm';
      params: {
        globalFarmId: number;
        assetPair: PalletXykAssetPair;
        multiplier: FixedU128;
        loyaltyCurve?: PalletLiquidityMiningLoyaltyCurve | undefined;
      };
    }
  /**
   * Update yield farm multiplier.
   *
   * Only farm owner can perform this action.
   *
   * Parameters:
   * - `origin`: global farm's owner.
   * - `global_farm_id`: global farm id in which yield farm will be updated.
   * - `asset_pair`: asset pair identifying yield farm in global farm.
   * - `multiplier`: new yield farm multiplier.
   *
   * Emits `YieldFarmUpdated` event when successful.
   **/
  | { name: 'UpdateYieldFarm'; params: { globalFarmId: number; assetPair: PalletXykAssetPair; multiplier: FixedU128 } }
  /**
   * Stop liq. miming for specific yield farm.
   *
   * This function claims rewards from `GlobalFarm` last time and stops yield farm
   * incentivization from a `GlobalFarm`. Users will be able to only withdraw
   * shares(with claiming) after calling this function.
   * `deposit_shares()` and `claim_rewards()` are not allowed on canceled yield farm.
   *
   * Only farm owner can perform this action.
   *
   * Parameters:
   * - `origin`: global farm's owner.
   * - `global_farm_id`: farm id in which yield farm will be canceled.
   * - `asset_pair`: asset pair identifying yield farm in the farm.
   *
   * Emits `YieldFarmStopped` event when successful.
   **/
  | { name: 'StopYieldFarm'; params: { globalFarmId: number; assetPair: PalletXykAssetPair } }
  /**
   * Resume yield farm for stopped yield farm.
   *
   * This function resume incentivization from `GlobalFarm` and restore full functionality
   * for yield farm. Users will be able to deposit, claim and withdraw again.
   *
   * WARN: Yield farm is NOT rewarded for time it was stopped.
   *
   * Only farm owner can perform this action.
   *
   * Parameters:
   * - `origin`: global farm's owner.
   * - `global_farm_id`: global farm id in which yield farm will be resumed.
   * - `yield_farm_id`: id of yield farm to be resumed.
   * - `asset_pair`: asset pair identifying yield farm in global farm.
   * - `multiplier`: yield farm multiplier in the farm.
   *
   * Emits `YieldFarmResumed` event when successful.
   **/
  | {
      name: 'ResumeYieldFarm';
      params: { globalFarmId: number; yieldFarmId: number; assetPair: PalletXykAssetPair; multiplier: FixedU128 };
    }
  /**
   * Remove yield farm
   *
   * This function marks a yield farm as ready to be removed from storage when it's empty. Users will
   * be able to only withdraw shares(without claiming rewards from yield farm). Unpaid rewards
   * will be transferred back to global farm and will be used to distribute to other yield farms.
   *
   * Yield farm must be stopped before calling this function.
   *
   * Only global farm's owner can perform this action. Yield farm stays in the storage until it's
   * empty(all farm entries are withdrawn). Last withdrawn from yield farm trigger removing from
   * the storage.
   *
   * Parameters:
   * - `origin`: global farm's owner.
   * - `global_farm_id`: farm id from which yield farm should be terminated.
   * - `yield_farm_id`: id of yield farm to be terminated.
   * - `asset_pair`: asset pair identifying yield farm in the global farm.
   *
   * Emits `YieldFarmTerminated` event when successful.
   **/
  | { name: 'TerminateYieldFarm'; params: { globalFarmId: number; yieldFarmId: number; assetPair: PalletXykAssetPair } }
  /**
   * Deposit LP shares to a liq. mining.
   *
   * This function transfers LP shares from `origin` to pallet's account and mint nft for
   * `origin` account. Minted nft represents deposit in the liq. mining.
   *
   * Parameters:
   * - `origin`: account depositing LP shares. This account has to have at least
   * `shares_amount` of LP shares.
   * - `global_farm_id`: id of global farm to which user wants to deposit LP shares.
   * - `yield_farm_id`: id of yield farm to deposit to.
   * - `asset_pair`: asset pair identifying LP shares user wants to deposit.
   * - `shares_amount`: amount of LP shares user wants to deposit.
   *
   * Emits `SharesDeposited` event when successful.
   **/
  | {
      name: 'DepositShares';
      params: { globalFarmId: number; yieldFarmId: number; assetPair: PalletXykAssetPair; sharesAmount: bigint };
    }
  /**
   * Join multiple farms with a given share amount
   *
   * The share is deposited to the first farm of the specified fams,
   * and then redeposit the shares to the remaining farms
   *
   * Parameters:
   * - `origin`: account depositing LP shares. This account has to have at least
   * - `farm_entries`: list of global farm id and yield farm id pairs to join
   * - `asset_pair`: asset pair identifying LP shares user wants to deposit.
   * - `shares_amount`: amount of LP shares user wants to deposit.
   *
   * Emits `SharesDeposited` event for the first farm entry
   * Emits `SharesRedeposited` event for each farm entry after the first one
   **/
  | {
      name: 'JoinFarms';
      params: { farmEntries: Array<[number, number]>; assetPair: PalletXykAssetPair; sharesAmount: bigint };
    }
  /**
   * Add liquidity to XYK pool and join multiple farms with a given share amount
   *
   * The share is deposited to the first farm of the specified entries,
   * and then redeposit the shares to the remaining farms
   *
   * Parameters:
   * - `origin`: account depositing LP shares. This account has to have at least
   * - `asset_a`: asset id of the first asset in the pair
   * - `asset_b`: asset id of the second asset in the pair
   * - `amount_a`: amount of the first asset to deposit
   * - `amount_b_max_limit`: maximum amount of the second asset to deposit
   * - `farm_entries`: list of global farm id and yield farm id pairs to join
   *
   * Emits `SharesDeposited` event for the first farm entry
   * Emits `SharesRedeposited` event for each farm entry after the first one
   **/
  | {
      name: 'AddLiquidityAndJoinFarms';
      params: {
        assetA: number;
        assetB: number;
        amountA: bigint;
        amountBMaxLimit: bigint;
        farmEntries: Array<[number, number]>;
      };
    }
  /**
   * Redeposit already locked LP shares to another yield farm.
   *
   * This function create yield farm entry for existing deposit. LP shares are not transferred
   * and amount of LP shares is based on existing deposit.
   *
   * This function DOESN'T create new deposit.
   *
   * Parameters:
   * - `origin`: account depositing LP shares. This account have to have at least
   * - `global_farm_id`: global farm identifier.
   * - `yield_farm_id`: yield farm identifier redepositing to.
   * - `asset_pair`: asset pair identifying LP shares user want to deposit.
   * - `deposit_id`: identifier of the deposit.
   *
   * Emits `SharesRedeposited` event when successful.
   **/
  | {
      name: 'RedepositShares';
      params: { globalFarmId: number; yieldFarmId: number; assetPair: PalletXykAssetPair; depositId: bigint };
    }
  /**
   * Claim rewards from liq. mining for deposit represented by `nft_id`.
   *
   * This function calculate user rewards from liq. mining and transfer rewards to `origin`
   * account. Claiming in the same period is allowed only once.
   *
   * Parameters:
   * - `origin`: account owner of deposit(nft).
   * - `deposit_id`: nft id representing deposit in the yield farm.
   * - `yield_farm_id`: yield farm identifier to claim rewards from.
   *
   * Emits `RewardClaimed` event when successful.
   **/
  | { name: 'ClaimRewards'; params: { depositId: bigint; yieldFarmId: number } }
  /**
   * Withdraw LP shares from liq. mining with reward claiming if possible.
   *
   * List of possible cases of transfers of LP shares and claimed rewards:
   *
   * * yield farm is active(yield farm is not stopped) - claim and transfer rewards(if it
   * wasn't claimed in this period) and transfer LP shares.
   * * liq. mining is stopped - claim and transfer rewards(if it
   * wasn't claimed in this period) and transfer LP shares.
   * * yield farm was terminated - only LP shares will be transferred.
   * * farm was terminated - only LP shares will be transferred.
   *
   * User's unclaimable rewards will be transferred back to global farm's account.
   *
   * Parameters:
   * - `origin`: account owner of deposit(nft).
   * - `deposit_id`: nft id representing deposit in the yield farm.
   * - `yield_farm_id`: yield farm identifier to dithdraw shares from.
   * - `asset_pair`: asset pair identifying yield farm in global farm.
   *
   * Emits:
   * * `RewardClaimed` if claim happen
   * * `SharesWithdrawn` event when successful
   **/
  | { name: 'WithdrawShares'; params: { depositId: bigint; yieldFarmId: number; assetPair: PalletXykAssetPair } }
  /**
   * Exit from all specified yield farms
   *
   * This function will attempt to withdraw shares and claim rewards (if available) from all
   * specified yield farms for a given deposit.
   *
   * Parameters:
   * - `origin`: account owner of deposit(nft).
   * - `deposit_id`: nft id representing deposit in the yield farm.
   * - `asset_pair`: asset pair identifying yield farm(s) in global farm(s).
   * - `farm_entries`: id(s) of yield farm(s) to exit from.
   *
   * Emits:
   * * `RewardClaimed` for each successful claim
   * * `SharesWithdrawn` for each successful withdrawal
   * * `DepositDestroyed` if the deposit is fully withdrawn
   *
   **/
  | { name: 'ExitFarms'; params: { depositId: bigint; assetPair: PalletXykAssetPair; farmEntries: Array<number> } };

export type PalletXykAssetPair = { assetIn: number; assetOut: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletRelaychainInfoCall = null;

export type PalletRelaychainInfoCallLike = null;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletDcaCall =
  /**
   * Creates a new DCA (Dollar-Cost Averaging) schedule and plans the next execution
   * for the specified block.
   *
   * If the block is not specified, the execution is planned for the next block.
   * If the given block is full, the execution will be planned in the subsequent block.
   *
   * Once the schedule is created, the specified `total_amount` will be reserved for DCA.
   * The reservation currency will be the `amount_in` currency of the order.
   *
   * Trades are executed as long as there is budget remaining
   * from the initial `total_amount` allocation, unless `total_amount` is 0, then trades
   * are executed until schedule is terminated.
   *
   * If a trade fails due to slippage limit or price stability errors, it will be retried.
   * If the number of retries reaches the maximum allowed,
   * the schedule will be terminated permanently.
   * In the case of a successful trade, the retry counter is reset.
   *
   * Parameters:
   * - `origin`: schedule owner
   * - `schedule`: schedule details
   * - `start_execution_block`: first possible execution block for the schedule
   *
   * Emits `Scheduled` and `ExecutionPlanned` event when successful.
   *
   **/
  | { name: 'Schedule'; params: { schedule: PalletDcaSchedule; startExecutionBlock?: number | undefined } }
  /**
   * Terminates a DCA schedule and remove it completely from the chain.
   *
   * This can be called by both schedule owner or the configured `T::TerminateOrigin`
   *
   * Parameters:
   * - `origin`: schedule owner
   * - `schedule_id`: schedule id
   * - `next_execution_block`: block number where the schedule is planned.
   *
   * Emits `Terminated` event when successful.
   *
   **/
  | { name: 'Terminate'; params: { scheduleId: number; nextExecutionBlock?: number | undefined } };

export type PalletDcaCallLike =
  /**
   * Creates a new DCA (Dollar-Cost Averaging) schedule and plans the next execution
   * for the specified block.
   *
   * If the block is not specified, the execution is planned for the next block.
   * If the given block is full, the execution will be planned in the subsequent block.
   *
   * Once the schedule is created, the specified `total_amount` will be reserved for DCA.
   * The reservation currency will be the `amount_in` currency of the order.
   *
   * Trades are executed as long as there is budget remaining
   * from the initial `total_amount` allocation, unless `total_amount` is 0, then trades
   * are executed until schedule is terminated.
   *
   * If a trade fails due to slippage limit or price stability errors, it will be retried.
   * If the number of retries reaches the maximum allowed,
   * the schedule will be terminated permanently.
   * In the case of a successful trade, the retry counter is reset.
   *
   * Parameters:
   * - `origin`: schedule owner
   * - `schedule`: schedule details
   * - `start_execution_block`: first possible execution block for the schedule
   *
   * Emits `Scheduled` and `ExecutionPlanned` event when successful.
   *
   **/
  | { name: 'Schedule'; params: { schedule: PalletDcaSchedule; startExecutionBlock?: number | undefined } }
  /**
   * Terminates a DCA schedule and remove it completely from the chain.
   *
   * This can be called by both schedule owner or the configured `T::TerminateOrigin`
   *
   * Parameters:
   * - `origin`: schedule owner
   * - `schedule_id`: schedule id
   * - `next_execution_block`: block number where the schedule is planned.
   *
   * Emits `Terminated` event when successful.
   *
   **/
  | { name: 'Terminate'; params: { scheduleId: number; nextExecutionBlock?: number | undefined } };

export type PalletDcaSchedule = {
  owner: AccountId32;
  period: number;
  totalAmount: bigint;
  maxRetries?: number | undefined;
  stabilityThreshold?: Permill | undefined;
  slippage?: Permill | undefined;
  order: PalletDcaOrder;
};

export type PalletDcaOrder =
  | {
      type: 'Sell';
      value: {
        assetIn: number;
        assetOut: number;
        amountIn: bigint;
        minAmountOut: bigint;
        route: Array<HydradxTraitsRouterTrade>;
      };
    }
  | {
      type: 'Buy';
      value: {
        assetIn: number;
        assetOut: number;
        amountOut: bigint;
        maxAmountIn: bigint;
        route: Array<HydradxTraitsRouterTrade>;
      };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSchedulerCall =
  /**
   * Anonymously schedule a task.
   **/
  | {
      name: 'Schedule';
      params: {
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: HydradxRuntimeRuntimeCall;
      };
    }
  /**
   * Cancel an anonymously scheduled task.
   **/
  | { name: 'Cancel'; params: { when: number; index: number } }
  /**
   * Schedule a named task.
   **/
  | {
      name: 'ScheduleNamed';
      params: {
        id: FixedBytes<32>;
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: HydradxRuntimeRuntimeCall;
      };
    }
  /**
   * Cancel a named scheduled task.
   **/
  | { name: 'CancelNamed'; params: { id: FixedBytes<32> } }
  /**
   * Anonymously schedule a task after a delay.
   **/
  | {
      name: 'ScheduleAfter';
      params: {
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: HydradxRuntimeRuntimeCall;
      };
    }
  /**
   * Schedule a named task after a delay.
   **/
  | {
      name: 'ScheduleNamedAfter';
      params: {
        id: FixedBytes<32>;
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: HydradxRuntimeRuntimeCall;
      };
    }
  /**
   * Set a retry configuration for a task so that, in case its scheduled run fails, it will
   * be retried after `period` blocks, for a total amount of `retries` retries or until it
   * succeeds.
   *
   * Tasks which need to be scheduled for a retry are still subject to weight metering and
   * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
   * normally while the task is retrying.
   *
   * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
   * clones of the original task. Their retry configuration will be derived from the
   * original task's configuration, but will have a lower value for `remaining` than the
   * original `total_retries`.
   **/
  | { name: 'SetRetry'; params: { task: [number, number]; retries: number; period: number } }
  /**
   * Set a retry configuration for a named task so that, in case its scheduled run fails, it
   * will be retried after `period` blocks, for a total amount of `retries` retries or until
   * it succeeds.
   *
   * Tasks which need to be scheduled for a retry are still subject to weight metering and
   * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
   * normally while the task is retrying.
   *
   * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
   * clones of the original task. Their retry configuration will be derived from the
   * original task's configuration, but will have a lower value for `remaining` than the
   * original `total_retries`.
   **/
  | { name: 'SetRetryNamed'; params: { id: FixedBytes<32>; retries: number; period: number } }
  /**
   * Removes the retry configuration of a task.
   **/
  | { name: 'CancelRetry'; params: { task: [number, number] } }
  /**
   * Cancel the retry configuration of a named task.
   **/
  | { name: 'CancelRetryNamed'; params: { id: FixedBytes<32> } };

export type PalletSchedulerCallLike =
  /**
   * Anonymously schedule a task.
   **/
  | {
      name: 'Schedule';
      params: {
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: HydradxRuntimeRuntimeCallLike;
      };
    }
  /**
   * Cancel an anonymously scheduled task.
   **/
  | { name: 'Cancel'; params: { when: number; index: number } }
  /**
   * Schedule a named task.
   **/
  | {
      name: 'ScheduleNamed';
      params: {
        id: FixedBytes<32>;
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: HydradxRuntimeRuntimeCallLike;
      };
    }
  /**
   * Cancel a named scheduled task.
   **/
  | { name: 'CancelNamed'; params: { id: FixedBytes<32> } }
  /**
   * Anonymously schedule a task after a delay.
   **/
  | {
      name: 'ScheduleAfter';
      params: {
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: HydradxRuntimeRuntimeCallLike;
      };
    }
  /**
   * Schedule a named task after a delay.
   **/
  | {
      name: 'ScheduleNamedAfter';
      params: {
        id: FixedBytes<32>;
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: HydradxRuntimeRuntimeCallLike;
      };
    }
  /**
   * Set a retry configuration for a task so that, in case its scheduled run fails, it will
   * be retried after `period` blocks, for a total amount of `retries` retries or until it
   * succeeds.
   *
   * Tasks which need to be scheduled for a retry are still subject to weight metering and
   * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
   * normally while the task is retrying.
   *
   * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
   * clones of the original task. Their retry configuration will be derived from the
   * original task's configuration, but will have a lower value for `remaining` than the
   * original `total_retries`.
   **/
  | { name: 'SetRetry'; params: { task: [number, number]; retries: number; period: number } }
  /**
   * Set a retry configuration for a named task so that, in case its scheduled run fails, it
   * will be retried after `period` blocks, for a total amount of `retries` retries or until
   * it succeeds.
   *
   * Tasks which need to be scheduled for a retry are still subject to weight metering and
   * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
   * normally while the task is retrying.
   *
   * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
   * clones of the original task. Their retry configuration will be derived from the
   * original task's configuration, but will have a lower value for `remaining` than the
   * original `total_retries`.
   **/
  | { name: 'SetRetryNamed'; params: { id: FixedBytes<32>; retries: number; period: number } }
  /**
   * Removes the retry configuration of a task.
   **/
  | { name: 'CancelRetry'; params: { task: [number, number] } }
  /**
   * Cancel the retry configuration of a named task.
   **/
  | { name: 'CancelRetryNamed'; params: { id: FixedBytes<32> } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type CumulusPalletParachainSystemCall =
  /**
   * Set the current validation data.
   *
   * This should be invoked exactly once per block. It will panic at the finalization
   * phase if the call was not invoked.
   *
   * The dispatch origin for this call must be `Inherent`
   *
   * As a side effect, this function upgrades the current validation function
   * if the appropriate time has come.
   **/
  | { name: 'SetValidationData'; params: { data: CumulusPrimitivesParachainInherentParachainInherentData } }
  | { name: 'SudoSendUpwardMessage'; params: { message: Bytes } };

export type CumulusPalletParachainSystemCallLike =
  /**
   * Set the current validation data.
   *
   * This should be invoked exactly once per block. It will panic at the finalization
   * phase if the call was not invoked.
   *
   * The dispatch origin for this call must be `Inherent`
   *
   * As a side effect, this function upgrades the current validation function
   * if the appropriate time has come.
   **/
  | { name: 'SetValidationData'; params: { data: CumulusPrimitivesParachainInherentParachainInherentData } }
  | { name: 'SudoSendUpwardMessage'; params: { message: BytesLike } };

export type CumulusPrimitivesParachainInherentParachainInherentData = {
  validationData: PolkadotPrimitivesV8PersistedValidationData;
  relayChainState: SpTrieStorageProof;
  downwardMessages: Array<PolkadotCorePrimitivesInboundDownwardMessage>;
  horizontalMessages: Array<[PolkadotParachainPrimitivesPrimitivesId, Array<PolkadotCorePrimitivesInboundHrmpMessage>]>;
};

export type PolkadotPrimitivesV8PersistedValidationData = {
  parentHead: PolkadotParachainPrimitivesPrimitivesHeadData;
  relayParentNumber: number;
  relayParentStorageRoot: H256;
  maxPovSize: number;
};

export type PolkadotParachainPrimitivesPrimitivesHeadData = Bytes;

export type SpTrieStorageProof = { trieNodes: Array<Bytes> };

export type PolkadotCorePrimitivesInboundDownwardMessage = { sentAt: number; msg: Bytes };

export type PolkadotCorePrimitivesInboundHrmpMessage = { sentAt: number; data: Bytes };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type StagingParachainInfoCall = null;

export type StagingParachainInfoCallLike = null;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletXcmCall =
  | { name: 'Send'; params: { dest: XcmVersionedLocation; message: XcmVersionedXcm } }
  /**
   * Teleport some assets from the local chain to some destination chain.
   *
   * **This function is deprecated: Use `limited_teleport_assets` instead.**
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
   * with all fees taken as needed from the asset.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` chain.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   **/
  | {
      name: 'TeleportAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
      };
    }
  /**
   * Transfer some assets from the local chain to the destination chain through their local,
   * destination or remote reserve.
   *
   * `assets` must have same reserve location and may not be teleportable to `dest`.
   * - `assets` have local reserve: transfer assets to sovereign account of destination
   * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
   * assets to `beneficiary`.
   * - `assets` have destination reserve: burn local assets and forward a notification to
   * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
   * deposit them to `beneficiary`.
   * - `assets` have remote reserve: burn local assets, forward XCM to reserve chain to move
   * reserves from this chain's SA to `dest` chain's SA, and forward another XCM to `dest`
   * to mint and deposit reserve-based assets to `beneficiary`.
   *
   * **This function is deprecated: Use `limited_reserve_transfer_assets` instead.**
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
   * with all fees taken as needed from the asset.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` (and possibly reserve) chains.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   **/
  | {
      name: 'ReserveTransferAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
      };
    }
  /**
   * Execute an XCM message from a local, signed, origin.
   *
   * An event is deposited indicating whether `msg` could be executed completely or only
   * partially.
   *
   * No more than `max_weight` will be used in its attempted execution. If this is less than
   * the maximum amount of weight that the message could take to be executed, then no
   * execution attempt will be made.
   **/
  | { name: 'Execute'; params: { message: XcmVersionedXcm; maxWeight: SpWeightsWeightV2Weight } }
  /**
   * Extoll that a particular destination can be communicated with through a particular
   * version of XCM.
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `location`: The destination that is being described.
   * - `xcm_version`: The latest version of XCM that `location` supports.
   **/
  | { name: 'ForceXcmVersion'; params: { location: StagingXcmV4Location; version: number } }
  /**
   * Set a safe XCM version (the version that XCM should be encoded with if the most recent
   * version a destination can accept is unknown).
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `maybe_xcm_version`: The default XCM encoding version, or `None` to disable.
   **/
  | { name: 'ForceDefaultXcmVersion'; params: { maybeXcmVersion?: number | undefined } }
  /**
   * Ask a location to notify us regarding their XCM version and any changes to it.
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `location`: The location to which we should subscribe for XCM version notifications.
   **/
  | { name: 'ForceSubscribeVersionNotify'; params: { location: XcmVersionedLocation } }
  /**
   * Require that a particular destination should no longer notify us regarding any XCM
   * version changes.
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `location`: The location to which we are currently subscribed for XCM version
   * notifications which we no longer desire.
   **/
  | { name: 'ForceUnsubscribeVersionNotify'; params: { location: XcmVersionedLocation } }
  /**
   * Transfer some assets from the local chain to the destination chain through their local,
   * destination or remote reserve.
   *
   * `assets` must have same reserve location and may not be teleportable to `dest`.
   * - `assets` have local reserve: transfer assets to sovereign account of destination
   * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
   * assets to `beneficiary`.
   * - `assets` have destination reserve: burn local assets and forward a notification to
   * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
   * deposit them to `beneficiary`.
   * - `assets` have remote reserve: burn local assets, forward XCM to reserve chain to move
   * reserves from this chain's SA to `dest` chain's SA, and forward another XCM to `dest`
   * to mint and deposit reserve-based assets to `beneficiary`.
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
   * is needed than `weight_limit`, then the operation will fail and the sent assets may be
   * at risk.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` (and possibly reserve) chains.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
   **/
  | {
      name: 'LimitedReserveTransferAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * Teleport some assets from the local chain to some destination chain.
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
   * is needed than `weight_limit`, then the operation will fail and the sent assets may be
   * at risk.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` chain.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
   **/
  | {
      name: 'LimitedTeleportAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * Set or unset the global suspension state of the XCM executor.
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `suspended`: `true` to suspend, `false` to resume.
   **/
  | { name: 'ForceSuspension'; params: { suspended: boolean } }
  /**
   * Transfer some assets from the local chain to the destination chain through their local,
   * destination or remote reserve, or through teleports.
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item` (hence referred to as `fees`), up to enough to pay for
   * `weight_limit` of weight. If more weight is needed than `weight_limit`, then the
   * operation will fail and the sent assets may be at risk.
   *
   * `assets` (excluding `fees`) must have same reserve location or otherwise be teleportable
   * to `dest`, no limitations imposed on `fees`.
   * - for local reserve: transfer assets to sovereign account of destination chain and
   * forward a notification XCM to `dest` to mint and deposit reserve-based assets to
   * `beneficiary`.
   * - for destination reserve: burn local assets and forward a notification to `dest` chain
   * to withdraw the reserve assets from this chain's sovereign account and deposit them
   * to `beneficiary`.
   * - for remote reserve: burn local assets, forward XCM to reserve chain to move reserves
   * from this chain's SA to `dest` chain's SA, and forward another XCM to `dest` to mint
   * and deposit reserve-based assets to `beneficiary`.
   * - for teleports: burn local assets and forward XCM to `dest` chain to mint/teleport
   * assets and deposit them to `beneficiary`.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `X2(Parent,
   * Parachain(..))` to send from parachain to parachain, or `X1(Parachain(..))` to send
   * from relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` (and possibly reserve) chains.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
   **/
  | {
      name: 'TransferAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * Claims assets trapped on this pallet because of leftover assets during XCM execution.
   *
   * - `origin`: Anyone can call this extrinsic.
   * - `assets`: The exact assets that were trapped. Use the version to specify what version
   * was the latest when they were trapped.
   * - `beneficiary`: The location/account where the claimed assets will be deposited.
   **/
  | { name: 'ClaimAssets'; params: { assets: XcmVersionedAssets; beneficiary: XcmVersionedLocation } }
  /**
   * Transfer assets from the local chain to the destination chain using explicit transfer
   * types for assets and fees.
   *
   * `assets` must have same reserve location or may be teleportable to `dest`. Caller must
   * provide the `assets_transfer_type` to be used for `assets`:
   * - `TransferType::LocalReserve`: transfer assets to sovereign account of destination
   * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
   * assets to `beneficiary`.
   * - `TransferType::DestinationReserve`: burn local assets and forward a notification to
   * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
   * deposit them to `beneficiary`.
   * - `TransferType::RemoteReserve(reserve)`: burn local assets, forward XCM to `reserve`
   * chain to move reserves from this chain's SA to `dest` chain's SA, and forward another
   * XCM to `dest` to mint and deposit reserve-based assets to `beneficiary`. Typically
   * the remote `reserve` is Asset Hub.
   * - `TransferType::Teleport`: burn local assets and forward XCM to `dest` chain to
   * mint/teleport assets and deposit them to `beneficiary`.
   *
   * On the destination chain, as well as any intermediary hops, `BuyExecution` is used to
   * buy execution using transferred `assets` identified by `remote_fees_id`.
   * Make sure enough of the specified `remote_fees_id` asset is included in the given list
   * of `assets`. `remote_fees_id` should be enough to pay for `weight_limit`. If more weight
   * is needed than `weight_limit`, then the operation will fail and the sent assets may be
   * at risk.
   *
   * `remote_fees_id` may use different transfer type than rest of `assets` and can be
   * specified through `fees_transfer_type`.
   *
   * The caller needs to specify what should happen to the transferred assets once they reach
   * the `dest` chain. This is done through the `custom_xcm_on_dest` parameter, which
   * contains the instructions to execute on `dest` as a final step.
   * This is usually as simple as:
   * `Xcm(vec![DepositAsset { assets: Wild(AllCounted(assets.len())), beneficiary }])`,
   * but could be something more exotic like sending the `assets` even further.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain, or `(parents: 2, (GlobalConsensus(..), ..))` to send from
   * parachain across a bridge to another ecosystem destination.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` (and possibly reserve) chains.
   * - `assets_transfer_type`: The XCM `TransferType` used to transfer the `assets`.
   * - `remote_fees_id`: One of the included `assets` to be used to pay fees.
   * - `fees_transfer_type`: The XCM `TransferType` used to transfer the `fees` assets.
   * - `custom_xcm_on_dest`: The XCM to be executed on `dest` chain as the last step of the
   * transfer, which also determines what happens to the assets on the destination chain.
   * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
   **/
  | {
      name: 'TransferAssetsUsingTypeAndThen';
      params: {
        dest: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        assetsTransferType: StagingXcmExecutorAssetTransferTransferType;
        remoteFeesId: XcmVersionedAssetId;
        feesTransferType: StagingXcmExecutorAssetTransferTransferType;
        customXcmOnDest: XcmVersionedXcm;
        weightLimit: XcmV3WeightLimit;
      };
    };

export type PalletXcmCallLike =
  | { name: 'Send'; params: { dest: XcmVersionedLocation; message: XcmVersionedXcm } }
  /**
   * Teleport some assets from the local chain to some destination chain.
   *
   * **This function is deprecated: Use `limited_teleport_assets` instead.**
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
   * with all fees taken as needed from the asset.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` chain.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   **/
  | {
      name: 'TeleportAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
      };
    }
  /**
   * Transfer some assets from the local chain to the destination chain through their local,
   * destination or remote reserve.
   *
   * `assets` must have same reserve location and may not be teleportable to `dest`.
   * - `assets` have local reserve: transfer assets to sovereign account of destination
   * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
   * assets to `beneficiary`.
   * - `assets` have destination reserve: burn local assets and forward a notification to
   * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
   * deposit them to `beneficiary`.
   * - `assets` have remote reserve: burn local assets, forward XCM to reserve chain to move
   * reserves from this chain's SA to `dest` chain's SA, and forward another XCM to `dest`
   * to mint and deposit reserve-based assets to `beneficiary`.
   *
   * **This function is deprecated: Use `limited_reserve_transfer_assets` instead.**
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
   * with all fees taken as needed from the asset.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` (and possibly reserve) chains.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   **/
  | {
      name: 'ReserveTransferAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
      };
    }
  /**
   * Execute an XCM message from a local, signed, origin.
   *
   * An event is deposited indicating whether `msg` could be executed completely or only
   * partially.
   *
   * No more than `max_weight` will be used in its attempted execution. If this is less than
   * the maximum amount of weight that the message could take to be executed, then no
   * execution attempt will be made.
   **/
  | { name: 'Execute'; params: { message: XcmVersionedXcm; maxWeight: SpWeightsWeightV2Weight } }
  /**
   * Extoll that a particular destination can be communicated with through a particular
   * version of XCM.
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `location`: The destination that is being described.
   * - `xcm_version`: The latest version of XCM that `location` supports.
   **/
  | { name: 'ForceXcmVersion'; params: { location: StagingXcmV4Location; version: number } }
  /**
   * Set a safe XCM version (the version that XCM should be encoded with if the most recent
   * version a destination can accept is unknown).
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `maybe_xcm_version`: The default XCM encoding version, or `None` to disable.
   **/
  | { name: 'ForceDefaultXcmVersion'; params: { maybeXcmVersion?: number | undefined } }
  /**
   * Ask a location to notify us regarding their XCM version and any changes to it.
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `location`: The location to which we should subscribe for XCM version notifications.
   **/
  | { name: 'ForceSubscribeVersionNotify'; params: { location: XcmVersionedLocation } }
  /**
   * Require that a particular destination should no longer notify us regarding any XCM
   * version changes.
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `location`: The location to which we are currently subscribed for XCM version
   * notifications which we no longer desire.
   **/
  | { name: 'ForceUnsubscribeVersionNotify'; params: { location: XcmVersionedLocation } }
  /**
   * Transfer some assets from the local chain to the destination chain through their local,
   * destination or remote reserve.
   *
   * `assets` must have same reserve location and may not be teleportable to `dest`.
   * - `assets` have local reserve: transfer assets to sovereign account of destination
   * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
   * assets to `beneficiary`.
   * - `assets` have destination reserve: burn local assets and forward a notification to
   * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
   * deposit them to `beneficiary`.
   * - `assets` have remote reserve: burn local assets, forward XCM to reserve chain to move
   * reserves from this chain's SA to `dest` chain's SA, and forward another XCM to `dest`
   * to mint and deposit reserve-based assets to `beneficiary`.
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
   * is needed than `weight_limit`, then the operation will fail and the sent assets may be
   * at risk.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` (and possibly reserve) chains.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
   **/
  | {
      name: 'LimitedReserveTransferAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * Teleport some assets from the local chain to some destination chain.
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
   * is needed than `weight_limit`, then the operation will fail and the sent assets may be
   * at risk.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` chain.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
   **/
  | {
      name: 'LimitedTeleportAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * Set or unset the global suspension state of the XCM executor.
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `suspended`: `true` to suspend, `false` to resume.
   **/
  | { name: 'ForceSuspension'; params: { suspended: boolean } }
  /**
   * Transfer some assets from the local chain to the destination chain through their local,
   * destination or remote reserve, or through teleports.
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item` (hence referred to as `fees`), up to enough to pay for
   * `weight_limit` of weight. If more weight is needed than `weight_limit`, then the
   * operation will fail and the sent assets may be at risk.
   *
   * `assets` (excluding `fees`) must have same reserve location or otherwise be teleportable
   * to `dest`, no limitations imposed on `fees`.
   * - for local reserve: transfer assets to sovereign account of destination chain and
   * forward a notification XCM to `dest` to mint and deposit reserve-based assets to
   * `beneficiary`.
   * - for destination reserve: burn local assets and forward a notification to `dest` chain
   * to withdraw the reserve assets from this chain's sovereign account and deposit them
   * to `beneficiary`.
   * - for remote reserve: burn local assets, forward XCM to reserve chain to move reserves
   * from this chain's SA to `dest` chain's SA, and forward another XCM to `dest` to mint
   * and deposit reserve-based assets to `beneficiary`.
   * - for teleports: burn local assets and forward XCM to `dest` chain to mint/teleport
   * assets and deposit them to `beneficiary`.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `X2(Parent,
   * Parachain(..))` to send from parachain to parachain, or `X1(Parachain(..))` to send
   * from relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` (and possibly reserve) chains.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
   **/
  | {
      name: 'TransferAssets';
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * Claims assets trapped on this pallet because of leftover assets during XCM execution.
   *
   * - `origin`: Anyone can call this extrinsic.
   * - `assets`: The exact assets that were trapped. Use the version to specify what version
   * was the latest when they were trapped.
   * - `beneficiary`: The location/account where the claimed assets will be deposited.
   **/
  | { name: 'ClaimAssets'; params: { assets: XcmVersionedAssets; beneficiary: XcmVersionedLocation } }
  /**
   * Transfer assets from the local chain to the destination chain using explicit transfer
   * types for assets and fees.
   *
   * `assets` must have same reserve location or may be teleportable to `dest`. Caller must
   * provide the `assets_transfer_type` to be used for `assets`:
   * - `TransferType::LocalReserve`: transfer assets to sovereign account of destination
   * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
   * assets to `beneficiary`.
   * - `TransferType::DestinationReserve`: burn local assets and forward a notification to
   * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
   * deposit them to `beneficiary`.
   * - `TransferType::RemoteReserve(reserve)`: burn local assets, forward XCM to `reserve`
   * chain to move reserves from this chain's SA to `dest` chain's SA, and forward another
   * XCM to `dest` to mint and deposit reserve-based assets to `beneficiary`. Typically
   * the remote `reserve` is Asset Hub.
   * - `TransferType::Teleport`: burn local assets and forward XCM to `dest` chain to
   * mint/teleport assets and deposit them to `beneficiary`.
   *
   * On the destination chain, as well as any intermediary hops, `BuyExecution` is used to
   * buy execution using transferred `assets` identified by `remote_fees_id`.
   * Make sure enough of the specified `remote_fees_id` asset is included in the given list
   * of `assets`. `remote_fees_id` should be enough to pay for `weight_limit`. If more weight
   * is needed than `weight_limit`, then the operation will fail and the sent assets may be
   * at risk.
   *
   * `remote_fees_id` may use different transfer type than rest of `assets` and can be
   * specified through `fees_transfer_type`.
   *
   * The caller needs to specify what should happen to the transferred assets once they reach
   * the `dest` chain. This is done through the `custom_xcm_on_dest` parameter, which
   * contains the instructions to execute on `dest` as a final step.
   * This is usually as simple as:
   * `Xcm(vec![DepositAsset { assets: Wild(AllCounted(assets.len())), beneficiary }])`,
   * but could be something more exotic like sending the `assets` even further.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain, or `(parents: 2, (GlobalConsensus(..), ..))` to send from
   * parachain across a bridge to another ecosystem destination.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` (and possibly reserve) chains.
   * - `assets_transfer_type`: The XCM `TransferType` used to transfer the `assets`.
   * - `remote_fees_id`: One of the included `assets` to be used to pay fees.
   * - `fees_transfer_type`: The XCM `TransferType` used to transfer the `fees` assets.
   * - `custom_xcm_on_dest`: The XCM to be executed on `dest` chain as the last step of the
   * transfer, which also determines what happens to the assets on the destination chain.
   * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
   **/
  | {
      name: 'TransferAssetsUsingTypeAndThen';
      params: {
        dest: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        assetsTransferType: StagingXcmExecutorAssetTransferTransferType;
        remoteFeesId: XcmVersionedAssetId;
        feesTransferType: StagingXcmExecutorAssetTransferTransferType;
        customXcmOnDest: XcmVersionedXcm;
        weightLimit: XcmV3WeightLimit;
      };
    };

export type XcmVersionedLocation =
  | { type: 'V2'; value: XcmV2MultilocationMultiLocation }
  | { type: 'V3'; value: StagingXcmV3MultilocationMultiLocation }
  | { type: 'V4'; value: StagingXcmV4Location };

export type XcmV2MultilocationMultiLocation = { parents: number; interior: XcmV2MultilocationJunctions };

export type XcmV2MultilocationJunctions =
  | { type: 'Here' }
  | { type: 'X1'; value: XcmV2Junction }
  | { type: 'X2'; value: [XcmV2Junction, XcmV2Junction] }
  | { type: 'X3'; value: [XcmV2Junction, XcmV2Junction, XcmV2Junction] }
  | { type: 'X4'; value: [XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction] }
  | { type: 'X5'; value: [XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction] }
  | { type: 'X6'; value: [XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction] }
  | {
      type: 'X7';
      value: [XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction, XcmV2Junction];
    }
  | {
      type: 'X8';
      value: [
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
        XcmV2Junction,
      ];
    };

export type XcmV2Junction =
  | { type: 'Parachain'; value: number }
  | { type: 'AccountId32'; value: { network: XcmV2NetworkId; id: FixedBytes<32> } }
  | { type: 'AccountIndex64'; value: { network: XcmV2NetworkId; index: bigint } }
  | { type: 'AccountKey20'; value: { network: XcmV2NetworkId; key: FixedBytes<20> } }
  | { type: 'PalletInstance'; value: number }
  | { type: 'GeneralIndex'; value: bigint }
  | { type: 'GeneralKey'; value: Bytes }
  | { type: 'OnlyChild' }
  | { type: 'Plurality'; value: { id: XcmV2BodyId; part: XcmV2BodyPart } };

export type XcmV2NetworkId =
  | { type: 'Any' }
  | { type: 'Named'; value: Bytes }
  | { type: 'Polkadot' }
  | { type: 'Kusama' };

export type XcmV2BodyId =
  | { type: 'Unit' }
  | { type: 'Named'; value: Bytes }
  | { type: 'Index'; value: number }
  | { type: 'Executive' }
  | { type: 'Technical' }
  | { type: 'Legislative' }
  | { type: 'Judicial' }
  | { type: 'Defense' }
  | { type: 'Administration' }
  | { type: 'Treasury' };

export type XcmV2BodyPart =
  | { type: 'Voice' }
  | { type: 'Members'; value: { count: number } }
  | { type: 'Fraction'; value: { nom: number; denom: number } }
  | { type: 'AtLeastProportion'; value: { nom: number; denom: number } }
  | { type: 'MoreThanProportion'; value: { nom: number; denom: number } };

export type XcmVersionedXcm =
  | { type: 'V2'; value: XcmV2Xcm }
  | { type: 'V3'; value: XcmV3Xcm }
  | { type: 'V4'; value: StagingXcmV4Xcm };

export type XcmV2Xcm = Array<XcmV2Instruction>;

export type XcmV2Instruction =
  | { type: 'WithdrawAsset'; value: XcmV2MultiassetMultiAssets }
  | { type: 'ReserveAssetDeposited'; value: XcmV2MultiassetMultiAssets }
  | { type: 'ReceiveTeleportedAsset'; value: XcmV2MultiassetMultiAssets }
  | { type: 'QueryResponse'; value: { queryId: bigint; response: XcmV2Response; maxWeight: bigint } }
  | {
      type: 'TransferAsset';
      value: { assets: XcmV2MultiassetMultiAssets; beneficiary: XcmV2MultilocationMultiLocation };
    }
  | {
      type: 'TransferReserveAsset';
      value: { assets: XcmV2MultiassetMultiAssets; dest: XcmV2MultilocationMultiLocation; xcm: XcmV2Xcm };
    }
  | { type: 'Transact'; value: { originType: XcmV2OriginKind; requireWeightAtMost: bigint; call: XcmDoubleEncoded } }
  | { type: 'HrmpNewChannelOpenRequest'; value: { sender: number; maxMessageSize: number; maxCapacity: number } }
  | { type: 'HrmpChannelAccepted'; value: { recipient: number } }
  | { type: 'HrmpChannelClosing'; value: { initiator: number; sender: number; recipient: number } }
  | { type: 'ClearOrigin' }
  | { type: 'DescendOrigin'; value: XcmV2MultilocationJunctions }
  | {
      type: 'ReportError';
      value: { queryId: bigint; dest: XcmV2MultilocationMultiLocation; maxResponseWeight: bigint };
    }
  | {
      type: 'DepositAsset';
      value: {
        assets: XcmV2MultiassetMultiAssetFilter;
        maxAssets: number;
        beneficiary: XcmV2MultilocationMultiLocation;
      };
    }
  | {
      type: 'DepositReserveAsset';
      value: {
        assets: XcmV2MultiassetMultiAssetFilter;
        maxAssets: number;
        dest: XcmV2MultilocationMultiLocation;
        xcm: XcmV2Xcm;
      };
    }
  | { type: 'ExchangeAsset'; value: { give: XcmV2MultiassetMultiAssetFilter; receive: XcmV2MultiassetMultiAssets } }
  | {
      type: 'InitiateReserveWithdraw';
      value: { assets: XcmV2MultiassetMultiAssetFilter; reserve: XcmV2MultilocationMultiLocation; xcm: XcmV2Xcm };
    }
  | {
      type: 'InitiateTeleport';
      value: { assets: XcmV2MultiassetMultiAssetFilter; dest: XcmV2MultilocationMultiLocation; xcm: XcmV2Xcm };
    }
  | {
      type: 'QueryHolding';
      value: {
        queryId: bigint;
        dest: XcmV2MultilocationMultiLocation;
        assets: XcmV2MultiassetMultiAssetFilter;
        maxResponseWeight: bigint;
      };
    }
  | { type: 'BuyExecution'; value: { fees: XcmV2MultiassetMultiAsset; weightLimit: XcmV2WeightLimit } }
  | { type: 'RefundSurplus' }
  | { type: 'SetErrorHandler'; value: XcmV2Xcm }
  | { type: 'SetAppendix'; value: XcmV2Xcm }
  | { type: 'ClearError' }
  | { type: 'ClaimAsset'; value: { assets: XcmV2MultiassetMultiAssets; ticket: XcmV2MultilocationMultiLocation } }
  | { type: 'Trap'; value: bigint }
  | { type: 'SubscribeVersion'; value: { queryId: bigint; maxResponseWeight: bigint } }
  | { type: 'UnsubscribeVersion' };

export type XcmV2MultiassetMultiAssets = Array<XcmV2MultiassetMultiAsset>;

export type XcmV2MultiassetMultiAsset = { id: XcmV2MultiassetAssetId; fun: XcmV2MultiassetFungibility };

export type XcmV2MultiassetAssetId =
  | { type: 'Concrete'; value: XcmV2MultilocationMultiLocation }
  | { type: 'Abstract'; value: Bytes };

export type XcmV2MultiassetFungibility =
  | { type: 'Fungible'; value: bigint }
  | { type: 'NonFungible'; value: XcmV2MultiassetAssetInstance };

export type XcmV2MultiassetAssetInstance =
  | { type: 'Undefined' }
  | { type: 'Index'; value: bigint }
  | { type: 'Array4'; value: FixedBytes<4> }
  | { type: 'Array8'; value: FixedBytes<8> }
  | { type: 'Array16'; value: FixedBytes<16> }
  | { type: 'Array32'; value: FixedBytes<32> }
  | { type: 'Blob'; value: Bytes };

export type XcmV2Response =
  | { type: 'Null' }
  | { type: 'Assets'; value: XcmV2MultiassetMultiAssets }
  | { type: 'ExecutionResult'; value?: [number, XcmV2TraitsError] | undefined }
  | { type: 'Version'; value: number };

export type XcmV2TraitsError =
  | { type: 'Overflow' }
  | { type: 'Unimplemented' }
  | { type: 'UntrustedReserveLocation' }
  | { type: 'UntrustedTeleportLocation' }
  | { type: 'MultiLocationFull' }
  | { type: 'MultiLocationNotInvertible' }
  | { type: 'BadOrigin' }
  | { type: 'InvalidLocation' }
  | { type: 'AssetNotFound' }
  | { type: 'FailedToTransactAsset' }
  | { type: 'NotWithdrawable' }
  | { type: 'LocationCannotHold' }
  | { type: 'ExceedsMaxMessageSize' }
  | { type: 'DestinationUnsupported' }
  | { type: 'Transport' }
  | { type: 'Unroutable' }
  | { type: 'UnknownClaim' }
  | { type: 'FailedToDecode' }
  | { type: 'MaxWeightInvalid' }
  | { type: 'NotHoldingFees' }
  | { type: 'TooExpensive' }
  | { type: 'Trap'; value: bigint }
  | { type: 'UnhandledXcmVersion' }
  | { type: 'WeightLimitReached'; value: bigint }
  | { type: 'Barrier' }
  | { type: 'WeightNotComputable' };

export type XcmV2OriginKind = 'Native' | 'SovereignAccount' | 'Superuser' | 'Xcm';

export type XcmDoubleEncoded = { encoded: Bytes };

export type XcmV2MultiassetMultiAssetFilter =
  | { type: 'Definite'; value: XcmV2MultiassetMultiAssets }
  | { type: 'Wild'; value: XcmV2MultiassetWildMultiAsset };

export type XcmV2MultiassetWildMultiAsset =
  | { type: 'All' }
  | { type: 'AllOf'; value: { id: XcmV2MultiassetAssetId; fun: XcmV2MultiassetWildFungibility } };

export type XcmV2MultiassetWildFungibility = 'Fungible' | 'NonFungible';

export type XcmV2WeightLimit = { type: 'Unlimited' } | { type: 'Limited'; value: bigint };

export type XcmV3Xcm = Array<XcmV3Instruction>;

export type XcmV3Instruction =
  | { type: 'WithdrawAsset'; value: XcmV3MultiassetMultiAssets }
  | { type: 'ReserveAssetDeposited'; value: XcmV3MultiassetMultiAssets }
  | { type: 'ReceiveTeleportedAsset'; value: XcmV3MultiassetMultiAssets }
  | {
      type: 'QueryResponse';
      value: {
        queryId: bigint;
        response: XcmV3Response;
        maxWeight: SpWeightsWeightV2Weight;
        querier?: StagingXcmV3MultilocationMultiLocation | undefined;
      };
    }
  | {
      type: 'TransferAsset';
      value: { assets: XcmV3MultiassetMultiAssets; beneficiary: StagingXcmV3MultilocationMultiLocation };
    }
  | {
      type: 'TransferReserveAsset';
      value: { assets: XcmV3MultiassetMultiAssets; dest: StagingXcmV3MultilocationMultiLocation; xcm: XcmV3Xcm };
    }
  | {
      type: 'Transact';
      value: { originKind: XcmV3OriginKind; requireWeightAtMost: SpWeightsWeightV2Weight; call: XcmDoubleEncoded };
    }
  | { type: 'HrmpNewChannelOpenRequest'; value: { sender: number; maxMessageSize: number; maxCapacity: number } }
  | { type: 'HrmpChannelAccepted'; value: { recipient: number } }
  | { type: 'HrmpChannelClosing'; value: { initiator: number; sender: number; recipient: number } }
  | { type: 'ClearOrigin' }
  | { type: 'DescendOrigin'; value: XcmV3Junctions }
  | { type: 'ReportError'; value: XcmV3QueryResponseInfo }
  | {
      type: 'DepositAsset';
      value: { assets: XcmV3MultiassetMultiAssetFilter; beneficiary: StagingXcmV3MultilocationMultiLocation };
    }
  | {
      type: 'DepositReserveAsset';
      value: { assets: XcmV3MultiassetMultiAssetFilter; dest: StagingXcmV3MultilocationMultiLocation; xcm: XcmV3Xcm };
    }
  | {
      type: 'ExchangeAsset';
      value: { give: XcmV3MultiassetMultiAssetFilter; want: XcmV3MultiassetMultiAssets; maximal: boolean };
    }
  | {
      type: 'InitiateReserveWithdraw';
      value: {
        assets: XcmV3MultiassetMultiAssetFilter;
        reserve: StagingXcmV3MultilocationMultiLocation;
        xcm: XcmV3Xcm;
      };
    }
  | {
      type: 'InitiateTeleport';
      value: { assets: XcmV3MultiassetMultiAssetFilter; dest: StagingXcmV3MultilocationMultiLocation; xcm: XcmV3Xcm };
    }
  | { type: 'ReportHolding'; value: { responseInfo: XcmV3QueryResponseInfo; assets: XcmV3MultiassetMultiAssetFilter } }
  | { type: 'BuyExecution'; value: { fees: XcmV3MultiassetMultiAsset; weightLimit: XcmV3WeightLimit } }
  | { type: 'RefundSurplus' }
  | { type: 'SetErrorHandler'; value: XcmV3Xcm }
  | { type: 'SetAppendix'; value: XcmV3Xcm }
  | { type: 'ClearError' }
  | {
      type: 'ClaimAsset';
      value: { assets: XcmV3MultiassetMultiAssets; ticket: StagingXcmV3MultilocationMultiLocation };
    }
  | { type: 'Trap'; value: bigint }
  | { type: 'SubscribeVersion'; value: { queryId: bigint; maxResponseWeight: SpWeightsWeightV2Weight } }
  | { type: 'UnsubscribeVersion' }
  | { type: 'BurnAsset'; value: XcmV3MultiassetMultiAssets }
  | { type: 'ExpectAsset'; value: XcmV3MultiassetMultiAssets }
  | { type: 'ExpectOrigin'; value?: StagingXcmV3MultilocationMultiLocation | undefined }
  | { type: 'ExpectError'; value?: [number, XcmV3TraitsError] | undefined }
  | { type: 'ExpectTransactStatus'; value: XcmV3MaybeErrorCode }
  | { type: 'QueryPallet'; value: { moduleName: Bytes; responseInfo: XcmV3QueryResponseInfo } }
  | {
      type: 'ExpectPallet';
      value: { index: number; name: Bytes; moduleName: Bytes; crateMajor: number; minCrateMinor: number };
    }
  | { type: 'ReportTransactStatus'; value: XcmV3QueryResponseInfo }
  | { type: 'ClearTransactStatus' }
  | { type: 'UniversalOrigin'; value: XcmV3Junction }
  | { type: 'ExportMessage'; value: { network: XcmV3JunctionNetworkId; destination: XcmV3Junctions; xcm: XcmV3Xcm } }
  | { type: 'LockAsset'; value: { asset: XcmV3MultiassetMultiAsset; unlocker: StagingXcmV3MultilocationMultiLocation } }
  | { type: 'UnlockAsset'; value: { asset: XcmV3MultiassetMultiAsset; target: StagingXcmV3MultilocationMultiLocation } }
  | {
      type: 'NoteUnlockable';
      value: { asset: XcmV3MultiassetMultiAsset; owner: StagingXcmV3MultilocationMultiLocation };
    }
  | {
      type: 'RequestUnlock';
      value: { asset: XcmV3MultiassetMultiAsset; locker: StagingXcmV3MultilocationMultiLocation };
    }
  | { type: 'SetFeesMode'; value: { jitWithdraw: boolean } }
  | { type: 'SetTopic'; value: FixedBytes<32> }
  | { type: 'ClearTopic' }
  | { type: 'AliasOrigin'; value: StagingXcmV3MultilocationMultiLocation }
  | {
      type: 'UnpaidExecution';
      value: { weightLimit: XcmV3WeightLimit; checkOrigin?: StagingXcmV3MultilocationMultiLocation | undefined };
    };

export type XcmV3MultiassetMultiAssets = Array<XcmV3MultiassetMultiAsset>;

export type XcmV3MultiassetMultiAsset = { id: XcmV3MultiassetAssetId; fun: XcmV3MultiassetFungibility };

export type XcmV3MultiassetAssetId =
  | { type: 'Concrete'; value: StagingXcmV3MultilocationMultiLocation }
  | { type: 'Abstract'; value: FixedBytes<32> };

export type XcmV3MultiassetFungibility =
  | { type: 'Fungible'; value: bigint }
  | { type: 'NonFungible'; value: XcmV3MultiassetAssetInstance };

export type XcmV3MultiassetAssetInstance =
  | { type: 'Undefined' }
  | { type: 'Index'; value: bigint }
  | { type: 'Array4'; value: FixedBytes<4> }
  | { type: 'Array8'; value: FixedBytes<8> }
  | { type: 'Array16'; value: FixedBytes<16> }
  | { type: 'Array32'; value: FixedBytes<32> };

export type XcmV3Response =
  | { type: 'Null' }
  | { type: 'Assets'; value: XcmV3MultiassetMultiAssets }
  | { type: 'ExecutionResult'; value?: [number, XcmV3TraitsError] | undefined }
  | { type: 'Version'; value: number }
  | { type: 'PalletsInfo'; value: Array<XcmV3PalletInfo> }
  | { type: 'DispatchResult'; value: XcmV3MaybeErrorCode };

export type XcmV3TraitsError =
  | { type: 'Overflow' }
  | { type: 'Unimplemented' }
  | { type: 'UntrustedReserveLocation' }
  | { type: 'UntrustedTeleportLocation' }
  | { type: 'LocationFull' }
  | { type: 'LocationNotInvertible' }
  | { type: 'BadOrigin' }
  | { type: 'InvalidLocation' }
  | { type: 'AssetNotFound' }
  | { type: 'FailedToTransactAsset' }
  | { type: 'NotWithdrawable' }
  | { type: 'LocationCannotHold' }
  | { type: 'ExceedsMaxMessageSize' }
  | { type: 'DestinationUnsupported' }
  | { type: 'Transport' }
  | { type: 'Unroutable' }
  | { type: 'UnknownClaim' }
  | { type: 'FailedToDecode' }
  | { type: 'MaxWeightInvalid' }
  | { type: 'NotHoldingFees' }
  | { type: 'TooExpensive' }
  | { type: 'Trap'; value: bigint }
  | { type: 'ExpectationFalse' }
  | { type: 'PalletNotFound' }
  | { type: 'NameMismatch' }
  | { type: 'VersionIncompatible' }
  | { type: 'HoldingWouldOverflow' }
  | { type: 'ExportError' }
  | { type: 'ReanchorFailed' }
  | { type: 'NoDeal' }
  | { type: 'FeesNotMet' }
  | { type: 'LockError' }
  | { type: 'NoPermission' }
  | { type: 'Unanchored' }
  | { type: 'NotDepositable' }
  | { type: 'UnhandledXcmVersion' }
  | { type: 'WeightLimitReached'; value: SpWeightsWeightV2Weight }
  | { type: 'Barrier' }
  | { type: 'WeightNotComputable' }
  | { type: 'ExceedsStackLimit' };

export type XcmV3PalletInfo = {
  index: number;
  name: Bytes;
  moduleName: Bytes;
  major: number;
  minor: number;
  patch: number;
};

export type XcmV3MaybeErrorCode =
  | { type: 'Success' }
  | { type: 'Error'; value: Bytes }
  | { type: 'TruncatedError'; value: Bytes };

export type XcmV3OriginKind = 'Native' | 'SovereignAccount' | 'Superuser' | 'Xcm';

export type XcmV3QueryResponseInfo = {
  destination: StagingXcmV3MultilocationMultiLocation;
  queryId: bigint;
  maxWeight: SpWeightsWeightV2Weight;
};

export type XcmV3MultiassetMultiAssetFilter =
  | { type: 'Definite'; value: XcmV3MultiassetMultiAssets }
  | { type: 'Wild'; value: XcmV3MultiassetWildMultiAsset };

export type XcmV3MultiassetWildMultiAsset =
  | { type: 'All' }
  | { type: 'AllOf'; value: { id: XcmV3MultiassetAssetId; fun: XcmV3MultiassetWildFungibility } }
  | { type: 'AllCounted'; value: number }
  | { type: 'AllOfCounted'; value: { id: XcmV3MultiassetAssetId; fun: XcmV3MultiassetWildFungibility; count: number } };

export type XcmV3MultiassetWildFungibility = 'Fungible' | 'NonFungible';

export type XcmV3WeightLimit = { type: 'Unlimited' } | { type: 'Limited'; value: SpWeightsWeightV2Weight };

export type StagingXcmV4Xcm = Array<StagingXcmV4Instruction>;

export type StagingXcmV4Instruction =
  | { type: 'WithdrawAsset'; value: StagingXcmV4AssetAssets }
  | { type: 'ReserveAssetDeposited'; value: StagingXcmV4AssetAssets }
  | { type: 'ReceiveTeleportedAsset'; value: StagingXcmV4AssetAssets }
  | {
      type: 'QueryResponse';
      value: {
        queryId: bigint;
        response: StagingXcmV4Response;
        maxWeight: SpWeightsWeightV2Weight;
        querier?: StagingXcmV4Location | undefined;
      };
    }
  | { type: 'TransferAsset'; value: { assets: StagingXcmV4AssetAssets; beneficiary: StagingXcmV4Location } }
  | {
      type: 'TransferReserveAsset';
      value: { assets: StagingXcmV4AssetAssets; dest: StagingXcmV4Location; xcm: StagingXcmV4Xcm };
    }
  | {
      type: 'Transact';
      value: { originKind: XcmV3OriginKind; requireWeightAtMost: SpWeightsWeightV2Weight; call: XcmDoubleEncoded };
    }
  | { type: 'HrmpNewChannelOpenRequest'; value: { sender: number; maxMessageSize: number; maxCapacity: number } }
  | { type: 'HrmpChannelAccepted'; value: { recipient: number } }
  | { type: 'HrmpChannelClosing'; value: { initiator: number; sender: number; recipient: number } }
  | { type: 'ClearOrigin' }
  | { type: 'DescendOrigin'; value: StagingXcmV4Junctions }
  | { type: 'ReportError'; value: StagingXcmV4QueryResponseInfo }
  | { type: 'DepositAsset'; value: { assets: StagingXcmV4AssetAssetFilter; beneficiary: StagingXcmV4Location } }
  | {
      type: 'DepositReserveAsset';
      value: { assets: StagingXcmV4AssetAssetFilter; dest: StagingXcmV4Location; xcm: StagingXcmV4Xcm };
    }
  | {
      type: 'ExchangeAsset';
      value: { give: StagingXcmV4AssetAssetFilter; want: StagingXcmV4AssetAssets; maximal: boolean };
    }
  | {
      type: 'InitiateReserveWithdraw';
      value: { assets: StagingXcmV4AssetAssetFilter; reserve: StagingXcmV4Location; xcm: StagingXcmV4Xcm };
    }
  | {
      type: 'InitiateTeleport';
      value: { assets: StagingXcmV4AssetAssetFilter; dest: StagingXcmV4Location; xcm: StagingXcmV4Xcm };
    }
  | {
      type: 'ReportHolding';
      value: { responseInfo: StagingXcmV4QueryResponseInfo; assets: StagingXcmV4AssetAssetFilter };
    }
  | { type: 'BuyExecution'; value: { fees: StagingXcmV4Asset; weightLimit: XcmV3WeightLimit } }
  | { type: 'RefundSurplus' }
  | { type: 'SetErrorHandler'; value: StagingXcmV4Xcm }
  | { type: 'SetAppendix'; value: StagingXcmV4Xcm }
  | { type: 'ClearError' }
  | { type: 'ClaimAsset'; value: { assets: StagingXcmV4AssetAssets; ticket: StagingXcmV4Location } }
  | { type: 'Trap'; value: bigint }
  | { type: 'SubscribeVersion'; value: { queryId: bigint; maxResponseWeight: SpWeightsWeightV2Weight } }
  | { type: 'UnsubscribeVersion' }
  | { type: 'BurnAsset'; value: StagingXcmV4AssetAssets }
  | { type: 'ExpectAsset'; value: StagingXcmV4AssetAssets }
  | { type: 'ExpectOrigin'; value?: StagingXcmV4Location | undefined }
  | { type: 'ExpectError'; value?: [number, XcmV3TraitsError] | undefined }
  | { type: 'ExpectTransactStatus'; value: XcmV3MaybeErrorCode }
  | { type: 'QueryPallet'; value: { moduleName: Bytes; responseInfo: StagingXcmV4QueryResponseInfo } }
  | {
      type: 'ExpectPallet';
      value: { index: number; name: Bytes; moduleName: Bytes; crateMajor: number; minCrateMinor: number };
    }
  | { type: 'ReportTransactStatus'; value: StagingXcmV4QueryResponseInfo }
  | { type: 'ClearTransactStatus' }
  | { type: 'UniversalOrigin'; value: StagingXcmV4Junction }
  | {
      type: 'ExportMessage';
      value: { network: StagingXcmV4JunctionNetworkId; destination: StagingXcmV4Junctions; xcm: StagingXcmV4Xcm };
    }
  | { type: 'LockAsset'; value: { asset: StagingXcmV4Asset; unlocker: StagingXcmV4Location } }
  | { type: 'UnlockAsset'; value: { asset: StagingXcmV4Asset; target: StagingXcmV4Location } }
  | { type: 'NoteUnlockable'; value: { asset: StagingXcmV4Asset; owner: StagingXcmV4Location } }
  | { type: 'RequestUnlock'; value: { asset: StagingXcmV4Asset; locker: StagingXcmV4Location } }
  | { type: 'SetFeesMode'; value: { jitWithdraw: boolean } }
  | { type: 'SetTopic'; value: FixedBytes<32> }
  | { type: 'ClearTopic' }
  | { type: 'AliasOrigin'; value: StagingXcmV4Location }
  | {
      type: 'UnpaidExecution';
      value: { weightLimit: XcmV3WeightLimit; checkOrigin?: StagingXcmV4Location | undefined };
    };

export type StagingXcmV4AssetAssets = Array<StagingXcmV4Asset>;

export type StagingXcmV4Asset = { id: StagingXcmV4AssetAssetId; fun: StagingXcmV4AssetFungibility };

export type StagingXcmV4AssetAssetId = StagingXcmV4Location;

export type StagingXcmV4AssetFungibility =
  | { type: 'Fungible'; value: bigint }
  | { type: 'NonFungible'; value: StagingXcmV4AssetAssetInstance };

export type StagingXcmV4AssetAssetInstance =
  | { type: 'Undefined' }
  | { type: 'Index'; value: bigint }
  | { type: 'Array4'; value: FixedBytes<4> }
  | { type: 'Array8'; value: FixedBytes<8> }
  | { type: 'Array16'; value: FixedBytes<16> }
  | { type: 'Array32'; value: FixedBytes<32> };

export type StagingXcmV4Response =
  | { type: 'Null' }
  | { type: 'Assets'; value: StagingXcmV4AssetAssets }
  | { type: 'ExecutionResult'; value?: [number, XcmV3TraitsError] | undefined }
  | { type: 'Version'; value: number }
  | { type: 'PalletsInfo'; value: Array<StagingXcmV4PalletInfo> }
  | { type: 'DispatchResult'; value: XcmV3MaybeErrorCode };

export type StagingXcmV4PalletInfo = {
  index: number;
  name: Bytes;
  moduleName: Bytes;
  major: number;
  minor: number;
  patch: number;
};

export type StagingXcmV4QueryResponseInfo = {
  destination: StagingXcmV4Location;
  queryId: bigint;
  maxWeight: SpWeightsWeightV2Weight;
};

export type StagingXcmV4AssetAssetFilter =
  | { type: 'Definite'; value: StagingXcmV4AssetAssets }
  | { type: 'Wild'; value: StagingXcmV4AssetWildAsset };

export type StagingXcmV4AssetWildAsset =
  | { type: 'All' }
  | { type: 'AllOf'; value: { id: StagingXcmV4AssetAssetId; fun: StagingXcmV4AssetWildFungibility } }
  | { type: 'AllCounted'; value: number }
  | {
      type: 'AllOfCounted';
      value: { id: StagingXcmV4AssetAssetId; fun: StagingXcmV4AssetWildFungibility; count: number };
    };

export type StagingXcmV4AssetWildFungibility = 'Fungible' | 'NonFungible';

export type XcmVersionedAssets =
  | { type: 'V2'; value: XcmV2MultiassetMultiAssets }
  | { type: 'V3'; value: XcmV3MultiassetMultiAssets }
  | { type: 'V4'; value: StagingXcmV4AssetAssets };

export type StagingXcmExecutorAssetTransferTransferType =
  | { type: 'Teleport' }
  | { type: 'LocalReserve' }
  | { type: 'DestinationReserve' }
  | { type: 'RemoteReserve'; value: XcmVersionedLocation };

export type XcmVersionedAssetId =
  | { type: 'V3'; value: XcmV3MultiassetAssetId }
  | { type: 'V4'; value: StagingXcmV4AssetAssetId };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type CumulusPalletXcmCall = null;

export type CumulusPalletXcmCallLike = null;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMessageQueueCall =
  /**
   * Remove a page which has no more messages remaining to be processed or is stale.
   **/
  | { name: 'ReapPage'; params: { messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin; pageIndex: number } }
  /**
   * Execute an overweight message.
   *
   * Temporary processing errors will be propagated whereas permanent errors are treated
   * as success condition.
   *
   * - `origin`: Must be `Signed`.
   * - `message_origin`: The origin from which the message to be executed arrived.
   * - `page`: The page in the queue in which the message to be executed is sitting.
   * - `index`: The index into the queue of the message to be executed.
   * - `weight_limit`: The maximum amount of weight allowed to be consumed in the execution
   * of the message.
   *
   * Benchmark complexity considerations: O(index + weight_limit).
   **/
  | {
      name: 'ExecuteOverweight';
      params: {
        messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin;
        page: number;
        index: number;
        weightLimit: SpWeightsWeightV2Weight;
      };
    };

export type PalletMessageQueueCallLike =
  /**
   * Remove a page which has no more messages remaining to be processed or is stale.
   **/
  | { name: 'ReapPage'; params: { messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin; pageIndex: number } }
  /**
   * Execute an overweight message.
   *
   * Temporary processing errors will be propagated whereas permanent errors are treated
   * as success condition.
   *
   * - `origin`: Must be `Signed`.
   * - `message_origin`: The origin from which the message to be executed arrived.
   * - `page`: The page in the queue in which the message to be executed is sitting.
   * - `index`: The index into the queue of the message to be executed.
   * - `weight_limit`: The maximum amount of weight allowed to be consumed in the execution
   * of the message.
   *
   * Benchmark complexity considerations: O(index + weight_limit).
   **/
  | {
      name: 'ExecuteOverweight';
      params: {
        messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin;
        page: number;
        index: number;
        weightLimit: SpWeightsWeightV2Weight;
      };
    };

export type CumulusPrimitivesCoreAggregateMessageOrigin =
  | { type: 'Here' }
  | { type: 'Parent' }
  | { type: 'Sibling'; value: PolkadotParachainPrimitivesPrimitivesId };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type OrmlXcmModuleCall =
  /**
   * Send an XCM message as parachain sovereign.
   **/
  { name: 'SendAsSovereign'; params: { dest: XcmVersionedLocation; message: XcmVersionedXcm } };

export type OrmlXcmModuleCallLike =
  /**
   * Send an XCM message as parachain sovereign.
   **/
  { name: 'SendAsSovereign'; params: { dest: XcmVersionedLocation; message: XcmVersionedXcm } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type OrmlXtokensModuleCall =
  /**
   * Transfer native currencies.
   *
   * `dest_weight_limit` is the weight for XCM execution on the dest
   * chain, and it would be charged from the transferred assets. If set
   * below requirements, the execution may fail and assets wouldn't be
   * received.
   *
   * It's a no-op if any error on local XCM execution or message sending.
   * Note sending assets out per se doesn't guarantee they would be
   * received. Receiving depends on if the XCM message could be delivered
   * by the network, and if the receiving chain would handle
   * messages correctly.
   **/
  | {
      name: 'Transfer';
      params: { currencyId: number; amount: bigint; dest: XcmVersionedLocation; destWeightLimit: XcmV3WeightLimit };
    }
  /**
   * Transfer `Asset`.
   *
   * `dest_weight_limit` is the weight for XCM execution on the dest
   * chain, and it would be charged from the transferred assets. If set
   * below requirements, the execution may fail and assets wouldn't be
   * received.
   *
   * It's a no-op if any error on local XCM execution or message sending.
   * Note sending assets out per se doesn't guarantee they would be
   * received. Receiving depends on if the XCM message could be delivered
   * by the network, and if the receiving chain would handle
   * messages correctly.
   **/
  | {
      name: 'TransferMultiasset';
      params: { asset: XcmVersionedAsset; dest: XcmVersionedLocation; destWeightLimit: XcmV3WeightLimit };
    }
  /**
   * Transfer native currencies specifying the fee and amount as
   * separate.
   *
   * `dest_weight_limit` is the weight for XCM execution on the dest
   * chain, and it would be charged from the transferred assets. If set
   * below requirements, the execution may fail and assets wouldn't be
   * received.
   *
   * `fee` is the amount to be spent to pay for execution in destination
   * chain. Both fee and amount will be subtracted form the callers
   * balance.
   *
   * If `fee` is not high enough to cover for the execution costs in the
   * destination chain, then the assets will be trapped in the
   * destination chain
   *
   * It's a no-op if any error on local XCM execution or message sending.
   * Note sending assets out per se doesn't guarantee they would be
   * received. Receiving depends on if the XCM message could be delivered
   * by the network, and if the receiving chain would handle
   * messages correctly.
   **/
  | {
      name: 'TransferWithFee';
      params: {
        currencyId: number;
        amount: bigint;
        fee: bigint;
        dest: XcmVersionedLocation;
        destWeightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * Transfer `Asset` specifying the fee and amount as separate.
   *
   * `dest_weight_limit` is the weight for XCM execution on the dest
   * chain, and it would be charged from the transferred assets. If set
   * below requirements, the execution may fail and assets wouldn't be
   * received.
   *
   * `fee` is the Asset to be spent to pay for execution in
   * destination chain. Both fee and amount will be subtracted form the
   * callers balance For now we only accept fee and asset having the same
   * `Location` id.
   *
   * If `fee` is not high enough to cover for the execution costs in the
   * destination chain, then the assets will be trapped in the
   * destination chain
   *
   * It's a no-op if any error on local XCM execution or message sending.
   * Note sending assets out per se doesn't guarantee they would be
   * received. Receiving depends on if the XCM message could be delivered
   * by the network, and if the receiving chain would handle
   * messages correctly.
   **/
  | {
      name: 'TransferMultiassetWithFee';
      params: {
        asset: XcmVersionedAsset;
        fee: XcmVersionedAsset;
        dest: XcmVersionedLocation;
        destWeightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * Transfer several currencies specifying the item to be used as fee
   *
   * `dest_weight_limit` is the weight for XCM execution on the dest
   * chain, and it would be charged from the transferred assets. If set
   * below requirements, the execution may fail and assets wouldn't be
   * received.
   *
   * `fee_item` is index of the currencies tuple that we want to use for
   * payment
   *
   * It's a no-op if any error on local XCM execution or message sending.
   * Note sending assets out per se doesn't guarantee they would be
   * received. Receiving depends on if the XCM message could be delivered
   * by the network, and if the receiving chain would handle
   * messages correctly.
   **/
  | {
      name: 'TransferMulticurrencies';
      params: {
        currencies: Array<[number, bigint]>;
        feeItem: number;
        dest: XcmVersionedLocation;
        destWeightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * Transfer several `Asset` specifying the item to be used as fee
   *
   * `dest_weight_limit` is the weight for XCM execution on the dest
   * chain, and it would be charged from the transferred assets. If set
   * below requirements, the execution may fail and assets wouldn't be
   * received.
   *
   * `fee_item` is index of the Assets that we want to use for
   * payment
   *
   * It's a no-op if any error on local XCM execution or message sending.
   * Note sending assets out per se doesn't guarantee they would be
   * received. Receiving depends on if the XCM message could be delivered
   * by the network, and if the receiving chain would handle
   * messages correctly.
   **/
  | {
      name: 'TransferMultiassets';
      params: {
        assets: XcmVersionedAssets;
        feeItem: number;
        dest: XcmVersionedLocation;
        destWeightLimit: XcmV3WeightLimit;
      };
    };

export type OrmlXtokensModuleCallLike =
  /**
   * Transfer native currencies.
   *
   * `dest_weight_limit` is the weight for XCM execution on the dest
   * chain, and it would be charged from the transferred assets. If set
   * below requirements, the execution may fail and assets wouldn't be
   * received.
   *
   * It's a no-op if any error on local XCM execution or message sending.
   * Note sending assets out per se doesn't guarantee they would be
   * received. Receiving depends on if the XCM message could be delivered
   * by the network, and if the receiving chain would handle
   * messages correctly.
   **/
  | {
      name: 'Transfer';
      params: { currencyId: number; amount: bigint; dest: XcmVersionedLocation; destWeightLimit: XcmV3WeightLimit };
    }
  /**
   * Transfer `Asset`.
   *
   * `dest_weight_limit` is the weight for XCM execution on the dest
   * chain, and it would be charged from the transferred assets. If set
   * below requirements, the execution may fail and assets wouldn't be
   * received.
   *
   * It's a no-op if any error on local XCM execution or message sending.
   * Note sending assets out per se doesn't guarantee they would be
   * received. Receiving depends on if the XCM message could be delivered
   * by the network, and if the receiving chain would handle
   * messages correctly.
   **/
  | {
      name: 'TransferMultiasset';
      params: { asset: XcmVersionedAsset; dest: XcmVersionedLocation; destWeightLimit: XcmV3WeightLimit };
    }
  /**
   * Transfer native currencies specifying the fee and amount as
   * separate.
   *
   * `dest_weight_limit` is the weight for XCM execution on the dest
   * chain, and it would be charged from the transferred assets. If set
   * below requirements, the execution may fail and assets wouldn't be
   * received.
   *
   * `fee` is the amount to be spent to pay for execution in destination
   * chain. Both fee and amount will be subtracted form the callers
   * balance.
   *
   * If `fee` is not high enough to cover for the execution costs in the
   * destination chain, then the assets will be trapped in the
   * destination chain
   *
   * It's a no-op if any error on local XCM execution or message sending.
   * Note sending assets out per se doesn't guarantee they would be
   * received. Receiving depends on if the XCM message could be delivered
   * by the network, and if the receiving chain would handle
   * messages correctly.
   **/
  | {
      name: 'TransferWithFee';
      params: {
        currencyId: number;
        amount: bigint;
        fee: bigint;
        dest: XcmVersionedLocation;
        destWeightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * Transfer `Asset` specifying the fee and amount as separate.
   *
   * `dest_weight_limit` is the weight for XCM execution on the dest
   * chain, and it would be charged from the transferred assets. If set
   * below requirements, the execution may fail and assets wouldn't be
   * received.
   *
   * `fee` is the Asset to be spent to pay for execution in
   * destination chain. Both fee and amount will be subtracted form the
   * callers balance For now we only accept fee and asset having the same
   * `Location` id.
   *
   * If `fee` is not high enough to cover for the execution costs in the
   * destination chain, then the assets will be trapped in the
   * destination chain
   *
   * It's a no-op if any error on local XCM execution or message sending.
   * Note sending assets out per se doesn't guarantee they would be
   * received. Receiving depends on if the XCM message could be delivered
   * by the network, and if the receiving chain would handle
   * messages correctly.
   **/
  | {
      name: 'TransferMultiassetWithFee';
      params: {
        asset: XcmVersionedAsset;
        fee: XcmVersionedAsset;
        dest: XcmVersionedLocation;
        destWeightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * Transfer several currencies specifying the item to be used as fee
   *
   * `dest_weight_limit` is the weight for XCM execution on the dest
   * chain, and it would be charged from the transferred assets. If set
   * below requirements, the execution may fail and assets wouldn't be
   * received.
   *
   * `fee_item` is index of the currencies tuple that we want to use for
   * payment
   *
   * It's a no-op if any error on local XCM execution or message sending.
   * Note sending assets out per se doesn't guarantee they would be
   * received. Receiving depends on if the XCM message could be delivered
   * by the network, and if the receiving chain would handle
   * messages correctly.
   **/
  | {
      name: 'TransferMulticurrencies';
      params: {
        currencies: Array<[number, bigint]>;
        feeItem: number;
        dest: XcmVersionedLocation;
        destWeightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * Transfer several `Asset` specifying the item to be used as fee
   *
   * `dest_weight_limit` is the weight for XCM execution on the dest
   * chain, and it would be charged from the transferred assets. If set
   * below requirements, the execution may fail and assets wouldn't be
   * received.
   *
   * `fee_item` is index of the Assets that we want to use for
   * payment
   *
   * It's a no-op if any error on local XCM execution or message sending.
   * Note sending assets out per se doesn't guarantee they would be
   * received. Receiving depends on if the XCM message could be delivered
   * by the network, and if the receiving chain would handle
   * messages correctly.
   **/
  | {
      name: 'TransferMultiassets';
      params: {
        assets: XcmVersionedAssets;
        feeItem: number;
        dest: XcmVersionedLocation;
        destWeightLimit: XcmV3WeightLimit;
      };
    };

export type XcmVersionedAsset =
  | { type: 'V2'; value: XcmV2MultiassetMultiAsset }
  | { type: 'V3'; value: XcmV3MultiassetMultiAsset }
  | { type: 'V4'; value: StagingXcmV4Asset };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletCollatorSelectionCall =
  /**
   * Set the list of invulnerable (fixed) collators. These collators must do some
   * preparation, namely to have registered session keys.
   *
   * The call will remove any accounts that have not registered keys from the set. That is,
   * it is non-atomic; the caller accepts all `AccountId`s passed in `new` _individually_ as
   * acceptable Invulnerables, and is not proposing a _set_ of new Invulnerables.
   *
   * This call does not maintain mutual exclusivity of `Invulnerables` and `Candidates`. It
   * is recommended to use a batch of `add_invulnerable` and `remove_invulnerable` instead. A
   * `batch_all` can also be used to enforce atomicity. If any candidates are included in
   * `new`, they should be removed with `remove_invulnerable_candidate` after execution.
   *
   * Must be called by the `UpdateOrigin`.
   **/
  | { name: 'SetInvulnerables'; params: { new: Array<AccountId32> } }
  /**
   * Set the ideal number of non-invulnerable collators. If lowering this number, then the
   * number of running collators could be higher than this figure. Aside from that edge case,
   * there should be no other way to have more candidates than the desired number.
   *
   * The origin for this call must be the `UpdateOrigin`.
   **/
  | { name: 'SetDesiredCandidates'; params: { max: number } }
  /**
   * Set the candidacy bond amount.
   *
   * If the candidacy bond is increased by this call, all current candidates which have a
   * deposit lower than the new bond will be kicked from the list and get their deposits
   * back.
   *
   * The origin for this call must be the `UpdateOrigin`.
   **/
  | { name: 'SetCandidacyBond'; params: { bond: bigint } }
  /**
   * Register this account as a collator candidate. The account must (a) already have
   * registered session keys and (b) be able to reserve the `CandidacyBond`.
   *
   * This call is not available to `Invulnerable` collators.
   **/
  | { name: 'RegisterAsCandidate' }
  /**
   * Deregister `origin` as a collator candidate. Note that the collator can only leave on
   * session change. The `CandidacyBond` will be unreserved immediately.
   *
   * This call will fail if the total number of candidates would drop below
   * `MinEligibleCollators`.
   **/
  | { name: 'LeaveIntent' }
  /**
   * Add a new account `who` to the list of `Invulnerables` collators. `who` must have
   * registered session keys. If `who` is a candidate, they will be removed.
   *
   * The origin for this call must be the `UpdateOrigin`.
   **/
  | { name: 'AddInvulnerable'; params: { who: AccountId32 } }
  /**
   * Remove an account `who` from the list of `Invulnerables` collators. `Invulnerables` must
   * be sorted.
   *
   * The origin for this call must be the `UpdateOrigin`.
   **/
  | { name: 'RemoveInvulnerable'; params: { who: AccountId32 } }
  /**
   * Update the candidacy bond of collator candidate `origin` to a new amount `new_deposit`.
   *
   * Setting a `new_deposit` that is lower than the current deposit while `origin` is
   * occupying a top-`DesiredCandidates` slot is not allowed.
   *
   * This call will fail if `origin` is not a collator candidate, the updated bond is lower
   * than the minimum candidacy bond, and/or the amount cannot be reserved.
   **/
  | { name: 'UpdateBond'; params: { newDeposit: bigint } }
  /**
   * The caller `origin` replaces a candidate `target` in the collator candidate list by
   * reserving `deposit`. The amount `deposit` reserved by the caller must be greater than
   * the existing bond of the target it is trying to replace.
   *
   * This call will fail if the caller is already a collator candidate or invulnerable, the
   * caller does not have registered session keys, the target is not a collator candidate,
   * and/or the `deposit` amount cannot be reserved.
   **/
  | { name: 'TakeCandidateSlot'; params: { deposit: bigint; target: AccountId32 } };

export type PalletCollatorSelectionCallLike =
  /**
   * Set the list of invulnerable (fixed) collators. These collators must do some
   * preparation, namely to have registered session keys.
   *
   * The call will remove any accounts that have not registered keys from the set. That is,
   * it is non-atomic; the caller accepts all `AccountId`s passed in `new` _individually_ as
   * acceptable Invulnerables, and is not proposing a _set_ of new Invulnerables.
   *
   * This call does not maintain mutual exclusivity of `Invulnerables` and `Candidates`. It
   * is recommended to use a batch of `add_invulnerable` and `remove_invulnerable` instead. A
   * `batch_all` can also be used to enforce atomicity. If any candidates are included in
   * `new`, they should be removed with `remove_invulnerable_candidate` after execution.
   *
   * Must be called by the `UpdateOrigin`.
   **/
  | { name: 'SetInvulnerables'; params: { new: Array<AccountId32Like> } }
  /**
   * Set the ideal number of non-invulnerable collators. If lowering this number, then the
   * number of running collators could be higher than this figure. Aside from that edge case,
   * there should be no other way to have more candidates than the desired number.
   *
   * The origin for this call must be the `UpdateOrigin`.
   **/
  | { name: 'SetDesiredCandidates'; params: { max: number } }
  /**
   * Set the candidacy bond amount.
   *
   * If the candidacy bond is increased by this call, all current candidates which have a
   * deposit lower than the new bond will be kicked from the list and get their deposits
   * back.
   *
   * The origin for this call must be the `UpdateOrigin`.
   **/
  | { name: 'SetCandidacyBond'; params: { bond: bigint } }
  /**
   * Register this account as a collator candidate. The account must (a) already have
   * registered session keys and (b) be able to reserve the `CandidacyBond`.
   *
   * This call is not available to `Invulnerable` collators.
   **/
  | { name: 'RegisterAsCandidate' }
  /**
   * Deregister `origin` as a collator candidate. Note that the collator can only leave on
   * session change. The `CandidacyBond` will be unreserved immediately.
   *
   * This call will fail if the total number of candidates would drop below
   * `MinEligibleCollators`.
   **/
  | { name: 'LeaveIntent' }
  /**
   * Add a new account `who` to the list of `Invulnerables` collators. `who` must have
   * registered session keys. If `who` is a candidate, they will be removed.
   *
   * The origin for this call must be the `UpdateOrigin`.
   **/
  | { name: 'AddInvulnerable'; params: { who: AccountId32Like } }
  /**
   * Remove an account `who` from the list of `Invulnerables` collators. `Invulnerables` must
   * be sorted.
   *
   * The origin for this call must be the `UpdateOrigin`.
   **/
  | { name: 'RemoveInvulnerable'; params: { who: AccountId32Like } }
  /**
   * Update the candidacy bond of collator candidate `origin` to a new amount `new_deposit`.
   *
   * Setting a `new_deposit` that is lower than the current deposit while `origin` is
   * occupying a top-`DesiredCandidates` slot is not allowed.
   *
   * This call will fail if `origin` is not a collator candidate, the updated bond is lower
   * than the minimum candidacy bond, and/or the amount cannot be reserved.
   **/
  | { name: 'UpdateBond'; params: { newDeposit: bigint } }
  /**
   * The caller `origin` replaces a candidate `target` in the collator candidate list by
   * reserving `deposit`. The amount `deposit` reserved by the caller must be greater than
   * the existing bond of the target it is trying to replace.
   *
   * This call will fail if the caller is already a collator candidate or invulnerable, the
   * caller does not have registered session keys, the target is not a collator candidate,
   * and/or the `deposit` amount cannot be reserved.
   **/
  | { name: 'TakeCandidateSlot'; params: { deposit: bigint; target: AccountId32Like } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSessionCall =
  /**
   * Sets the session key(s) of the function caller to `keys`.
   * Allows an account to set its session key prior to becoming a validator.
   * This doesn't take effect until the next session.
   *
   * The dispatch origin of this function must be signed.
   *
   * ## Complexity
   * - `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is
   * fixed.
   **/
  | { name: 'SetKeys'; params: { keys: HydradxRuntimeOpaqueSessionKeys; proof: Bytes } }
  /**
   * Removes any session key(s) of the function caller.
   *
   * This doesn't take effect until the next session.
   *
   * The dispatch origin of this function must be Signed and the account must be either be
   * convertible to a validator ID using the chain's typical addressing system (this usually
   * means being a controller account) or directly convertible into a validator ID (which
   * usually means being a stash account).
   *
   * ## Complexity
   * - `O(1)` in number of key types. Actual cost depends on the number of length of
   * `T::Keys::key_ids()` which is fixed.
   **/
  | { name: 'PurgeKeys' };

export type PalletSessionCallLike =
  /**
   * Sets the session key(s) of the function caller to `keys`.
   * Allows an account to set its session key prior to becoming a validator.
   * This doesn't take effect until the next session.
   *
   * The dispatch origin of this function must be signed.
   *
   * ## Complexity
   * - `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is
   * fixed.
   **/
  | { name: 'SetKeys'; params: { keys: HydradxRuntimeOpaqueSessionKeys; proof: BytesLike } }
  /**
   * Removes any session key(s) of the function caller.
   *
   * This doesn't take effect until the next session.
   *
   * The dispatch origin of this function must be Signed and the account must be either be
   * convertible to a validator ID using the chain's typical addressing system (this usually
   * means being a controller account) or directly convertible into a validator ID (which
   * usually means being a stash account).
   *
   * ## Complexity
   * - `O(1)` in number of key types. Actual cost depends on the number of length of
   * `T::Keys::key_ids()` which is fixed.
   **/
  | { name: 'PurgeKeys' };

export type HydradxRuntimeOpaqueSessionKeys = { aura: SpConsensusAuraSr25519AppSr25519Public };

export type SpConsensusAuraSr25519AppSr25519Public = FixedBytes<32>;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletEmaOracleCall =
  | { name: 'AddOracle'; params: { source: FixedBytes<8>; assets: [number, number] } }
  | { name: 'RemoveOracle'; params: { source: FixedBytes<8>; assets: [number, number] } }
  | {
      name: 'UpdateBifrostOracle';
      params: { assetA: XcmVersionedLocation; assetB: XcmVersionedLocation; price: [bigint, bigint] };
    };

export type PalletEmaOracleCallLike =
  | { name: 'AddOracle'; params: { source: FixedBytes<8>; assets: [number, number] } }
  | { name: 'RemoveOracle'; params: { source: FixedBytes<8>; assets: [number, number] } }
  | {
      name: 'UpdateBifrostOracle';
      params: { assetA: XcmVersionedLocation; assetB: XcmVersionedLocation; price: [bigint, bigint] };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBroadcastCall = null;

export type PalletBroadcastCallLike = null;

export type SpRuntimeBlakeTwo256 = {};

export type PalletConvictionVotingTally = { ayes: bigint; nays: bigint; support: bigint };

/**
 * The `Event` enum of this pallet
 **/
export type PalletWhitelistEvent =
  | { name: 'CallWhitelisted'; data: { callHash: H256 } }
  | { name: 'WhitelistedCallRemoved'; data: { callHash: H256 } }
  | {
      name: 'WhitelistedCallDispatched';
      data: {
        callHash: H256;
        result: Result<FrameSupportDispatchPostDispatchInfo, SpRuntimeDispatchErrorWithPostInfo>;
      };
    };

export type FrameSupportDispatchPostDispatchInfo = {
  actualWeight?: SpWeightsWeightV2Weight | undefined;
  paysFee: FrameSupportDispatchPays;
};

export type SpRuntimeDispatchErrorWithPostInfo = {
  postInfo: FrameSupportDispatchPostDispatchInfo;
  error: DispatchError;
};

/**
 * The `Event` enum of this pallet
 **/
export type PalletDispatcherEvent =
  | {
      name: 'TreasuryManagerCallDispatched';
      data: {
        callHash: H256;
        result: Result<FrameSupportDispatchPostDispatchInfo, SpRuntimeDispatchErrorWithPostInfo>;
      };
    }
  | {
      name: 'AaveManagerCallDispatched';
      data: {
        callHash: H256;
        result: Result<FrameSupportDispatchPostDispatchInfo, SpRuntimeDispatchErrorWithPostInfo>;
      };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletAssetRegistryEvent =
  /**
   * Existential deposit for insufficinet asset was paid.
   * `SufficiencyCheck` triggers this event.
   **/
  | { name: 'ExistentialDepositPaid'; data: { who: AccountId32; feeAsset: number; amount: bigint } }
  /**
   * Asset was registered.
   **/
  | {
      name: 'Registered';
      data: {
        assetId: number;
        assetName?: Bytes | undefined;
        assetType: PalletAssetRegistryAssetType;
        existentialDeposit: bigint;
        xcmRateLimit?: bigint | undefined;
        symbol?: Bytes | undefined;
        decimals?: number | undefined;
        isSufficient: boolean;
      };
    }
  /**
   * Asset was updated.
   **/
  | {
      name: 'Updated';
      data: {
        assetId: number;
        assetName?: Bytes | undefined;
        assetType: PalletAssetRegistryAssetType;
        existentialDeposit: bigint;
        xcmRateLimit?: bigint | undefined;
        symbol?: Bytes | undefined;
        decimals?: number | undefined;
        isSufficient: boolean;
      };
    }
  /**
   * Native location set for an asset.
   **/
  | { name: 'LocationSet'; data: { assetId: number; location: HydradxRuntimeXcmAssetLocation } }
  /**
   * Asset was banned.
   **/
  | { name: 'AssetBanned'; data: { assetId: number } }
  /**
   * Asset's ban was removed.
   **/
  | { name: 'AssetUnbanned'; data: { assetId: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletClaimsEvent = { name: 'Claim'; data: [AccountId32, PalletClaimsEthereumAddress, bigint] };

export type PalletClaimsEthereumAddress = FixedBytes<20>;

/**
 * The `Event` enum of this pallet
 **/
export type PalletCollatorRewardsEvent =
  /**
   * Collator was rewarded.
   **/
  { name: 'CollatorRewarded'; data: { who: AccountId32; amount: bigint; currency: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletOmnipoolEvent =
  /**
   * An asset was added to Omnipool
   **/
  | { name: 'TokenAdded'; data: { assetId: number; initialAmount: bigint; initialPrice: FixedU128 } }
  /**
   * An asset was removed from Omnipool
   **/
  | { name: 'TokenRemoved'; data: { assetId: number; amount: bigint; hubWithdrawn: bigint } }
  /**
   * Liquidity of an asset was added to Omnipool.
   **/
  | { name: 'LiquidityAdded'; data: { who: AccountId32; assetId: number; amount: bigint; positionId: bigint } }
  /**
   * Liquidity of an asset was removed from Omnipool.
   **/
  | {
      name: 'LiquidityRemoved';
      data: { who: AccountId32; positionId: bigint; assetId: number; sharesRemoved: bigint; fee: FixedU128 };
    }
  /**
   * PRotocol Liquidity was removed from Omnipool.
   **/
  | {
      name: 'ProtocolLiquidityRemoved';
      data: { who: AccountId32; assetId: number; amount: bigint; hubAmount: bigint; sharesRemoved: bigint };
    }
  /**
   * Sell trade executed.
   * Deprecated. Replaced by pallet_broadcast::Swapped
   **/
  | {
      name: 'SellExecuted';
      data: {
        who: AccountId32;
        assetIn: number;
        assetOut: number;
        amountIn: bigint;
        amountOut: bigint;
        hubAmountIn: bigint;
        hubAmountOut: bigint;
        assetFeeAmount: bigint;
        protocolFeeAmount: bigint;
      };
    }
  /**
   * Buy trade executed.
   * Deprecated. Replaced by pallet_broadcast::Swapped
   **/
  | {
      name: 'BuyExecuted';
      data: {
        who: AccountId32;
        assetIn: number;
        assetOut: number;
        amountIn: bigint;
        amountOut: bigint;
        hubAmountIn: bigint;
        hubAmountOut: bigint;
        assetFeeAmount: bigint;
        protocolFeeAmount: bigint;
      };
    }
  /**
   * LP Position was created and NFT instance minted.
   **/
  | {
      name: 'PositionCreated';
      data: { positionId: bigint; owner: AccountId32; asset: number; amount: bigint; shares: bigint; price: FixedU128 };
    }
  /**
   * LP Position was destroyed and NFT instance burned.
   **/
  | { name: 'PositionDestroyed'; data: { positionId: bigint; owner: AccountId32 } }
  /**
   * LP Position was updated.
   **/
  | {
      name: 'PositionUpdated';
      data: { positionId: bigint; owner: AccountId32; asset: number; amount: bigint; shares: bigint; price: FixedU128 };
    }
  /**
   * Asset's tradable state has been updated.
   **/
  | { name: 'TradableStateUpdated'; data: { assetId: number; state: PalletOmnipoolTradability } }
  /**
   * Amount has been refunded for asset which has not been accepted to add to omnipool.
   **/
  | { name: 'AssetRefunded'; data: { assetId: number; amount: bigint; recipient: AccountId32 } }
  /**
   * Asset's weight cap has been updated.
   **/
  | { name: 'AssetWeightCapUpdated'; data: { assetId: number; cap: Permill } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletTransactionPauseEvent =
  /**
   * Paused transaction
   **/
  | { name: 'TransactionPaused'; data: { palletNameBytes: Bytes; functionNameBytes: Bytes } }
  /**
   * Unpaused transaction
   **/
  | { name: 'TransactionUnpaused'; data: { palletNameBytes: Bytes; functionNameBytes: Bytes } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletDusterEvent =
  /**
   * Account dusted.
   **/
  | { name: 'Dusted'; data: { who: AccountId32; amount: bigint } }
  /**
   * Account added to non-dustable list.
   **/
  | { name: 'Added'; data: { who: AccountId32 } }
  /**
   * Account removed from non-dustable list.
   **/
  | { name: 'Removed'; data: { who: AccountId32 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletLiquidityMiningEvent =
  /**
   * Global farm accumulated reward per share was updated.
   **/
  | { name: 'GlobalFarmAccRPZUpdated'; data: { globalFarmId: number; accumulatedRpz: FixedU128; totalSharesZ: bigint } }
  /**
   * Yield farm accumulated reward per valued share was updated.
   **/
  | {
      name: 'YieldFarmAccRPVSUpdated';
      data: { globalFarmId: number; yieldFarmId: number; accumulatedRpvs: FixedU128; totalValuedShares: bigint };
    }
  /**
   * Global farm has no more rewards to distribute in the moment.
   **/
  | { name: 'AllRewardsDistributed'; data: { globalFarmId: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletOmnipoolLiquidityMiningEvent =
  /**
   * New global farm was created.
   **/
  | {
      name: 'GlobalFarmCreated';
      data: {
        id: number;
        owner: AccountId32;
        totalRewards: bigint;
        rewardCurrency: number;
        yieldPerPeriod: Perquintill;
        plannedYieldingPeriods: number;
        blocksPerPeriod: number;
        maxRewardPerPeriod: bigint;
        minDeposit: bigint;
        lrnaPriceAdjustment: FixedU128;
      };
    }
  /**
   * Global farm was updated
   **/
  | {
      name: 'GlobalFarmUpdated';
      data: { id: number; plannedYieldingPeriods: number; yieldPerPeriod: Perquintill; minDeposit: bigint };
    }
  /**
   * Global farm was terminated.
   **/
  | {
      name: 'GlobalFarmTerminated';
      data: { globalFarmId: number; who: AccountId32; rewardCurrency: number; undistributedRewards: bigint };
    }
  /**
   * New yield farm was added to the farm.
   **/
  | {
      name: 'YieldFarmCreated';
      data: {
        globalFarmId: number;
        yieldFarmId: number;
        assetId: number;
        multiplier: FixedU128;
        loyaltyCurve?: PalletLiquidityMiningLoyaltyCurve | undefined;
      };
    }
  /**
   * Yield farm multiplier was updated.
   **/
  | {
      name: 'YieldFarmUpdated';
      data: { globalFarmId: number; yieldFarmId: number; assetId: number; who: AccountId32; multiplier: FixedU128 };
    }
  /**
   * Yield farm for `asset_id` was stopped.
   **/
  | { name: 'YieldFarmStopped'; data: { globalFarmId: number; yieldFarmId: number; assetId: number; who: AccountId32 } }
  /**
   * Yield farm for `asset_id` was resumed.
   **/
  | {
      name: 'YieldFarmResumed';
      data: { globalFarmId: number; yieldFarmId: number; assetId: number; who: AccountId32; multiplier: FixedU128 };
    }
  /**
   * Yield farm was terminated from the global farm.
   **/
  | {
      name: 'YieldFarmTerminated';
      data: { globalFarmId: number; yieldFarmId: number; assetId: number; who: AccountId32 };
    }
  /**
   * New LP shares(LP position) were deposited.
   **/
  | {
      name: 'SharesDeposited';
      data: {
        globalFarmId: number;
        yieldFarmId: number;
        depositId: bigint;
        assetId: number;
        who: AccountId32;
        sharesAmount: bigint;
        positionId: bigint;
      };
    }
  /**
   * Already locked LP shares were redeposited to another yield farm.
   **/
  | {
      name: 'SharesRedeposited';
      data: {
        globalFarmId: number;
        yieldFarmId: number;
        depositId: bigint;
        assetId: number;
        who: AccountId32;
        sharesAmount: bigint;
        positionId: bigint;
      };
    }
  /**
   * Rewards were claimed.
   **/
  | {
      name: 'RewardClaimed';
      data: {
        globalFarmId: number;
        yieldFarmId: number;
        who: AccountId32;
        claimed: bigint;
        rewardCurrency: number;
        depositId: bigint;
      };
    }
  /**
   * LP shares were withdrawn.
   **/
  | {
      name: 'SharesWithdrawn';
      data: { globalFarmId: number; yieldFarmId: number; who: AccountId32; amount: bigint; depositId: bigint };
    }
  /**
   * All LP shares were unlocked and NFT representing deposit was destroyed.
   **/
  | { name: 'DepositDestroyed'; data: { who: AccountId32; depositId: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletOtcEvent =
  /**
   * An Order has been cancelled
   **/
  | { name: 'Cancelled'; data: { orderId: number } }
  /**
   * An Order has been completely filled
   * Deprecated. Replaced by pallet_broadcast::Swapped
   **/
  | { name: 'Filled'; data: { orderId: number; who: AccountId32; amountIn: bigint; amountOut: bigint; fee: bigint } }
  /**
   * An Order has been partially filled
   * Deprecated. Replaced by pallet_broadcast::Swapped
   **/
  | {
      name: 'PartiallyFilled';
      data: { orderId: number; who: AccountId32; amountIn: bigint; amountOut: bigint; fee: bigint };
    }
  /**
   * An Order has been placed
   **/
  | {
      name: 'Placed';
      data: {
        orderId: number;
        assetIn: number;
        assetOut: number;
        amountIn: bigint;
        amountOut: bigint;
        partiallyFillable: boolean;
      };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletCircuitBreakerEvent =
  /**
   * Trade volume limit of an asset was changed.
   **/
  | { name: 'TradeVolumeLimitChanged'; data: { assetId: number; tradeVolumeLimit: [number, number] } }
  /**
   * Add liquidity limit of an asset was changed.
   **/
  | { name: 'AddLiquidityLimitChanged'; data: { assetId: number; liquidityLimit?: [number, number] | undefined } }
  /**
   * Remove liquidity limit of an asset was changed.
   **/
  | { name: 'RemoveLiquidityLimitChanged'; data: { assetId: number; liquidityLimit?: [number, number] | undefined } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletRouteExecutorEvent =
  /**
   * The route with trades has been successfully executed
   **/
  | {
      name: 'Executed';
      data: { assetIn: number; assetOut: number; amountIn: bigint; amountOut: bigint; eventId: number };
    }
  /**
   * The route with trades has been successfully executed
   **/
  | { name: 'RouteUpdated'; data: { assetIds: Array<number> } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletDynamicFeesEvent = null;

/**
 * The `Event` enum of this pallet
 **/
export type PalletStakingEvent =
  /**
   * New staking position was created and NFT was minted.
   **/
  | { name: 'PositionCreated'; data: { who: AccountId32; positionId: bigint; stake: bigint } }
  /**
   * Staked amount for existing position was increased.
   **/
  | {
      name: 'StakeAdded';
      data: {
        who: AccountId32;
        positionId: bigint;
        stake: bigint;
        totalStake: bigint;
        lockedRewards: bigint;
        slashedPoints: bigint;
        payablePercentage: FixedU128;
      };
    }
  /**
   * Rewards were claimed.
   **/
  | {
      name: 'RewardsClaimed';
      data: {
        who: AccountId32;
        positionId: bigint;
        paidRewards: bigint;
        unlockedRewards: bigint;
        slashedPoints: bigint;
        slashedUnpaidRewards: bigint;
        payablePercentage: FixedU128;
      };
    }
  /**
   * Staked amount was withdrawn and NFT was burned.
   **/
  | { name: 'Unstaked'; data: { who: AccountId32; positionId: bigint; unlockedStake: bigint } }
  /**
   * Staking was initialized.
   **/
  | { name: 'StakingInitialized'; data: { nonDustableBalance: bigint } }
  /**
   * Staking's `accumulated_reward_per_stake` was updated.
   **/
  | { name: 'AccumulatedRpsUpdated'; data: { accumulatedRps: FixedU128; totalStake: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletStableswapEvent =
  /**
   * A pool was created.
   **/
  | {
      name: 'PoolCreated';
      data: {
        poolId: number;
        assets: Array<number>;
        amplification: NonZeroU16;
        fee: Permill;
        peg?: PalletStableswapPoolPegInfo | undefined;
      };
    }
  /**
   * Pool fee has been updated.
   **/
  | { name: 'FeeUpdated'; data: { poolId: number; fee: Permill } }
  /**
   * Liquidity of an asset was added to a pool.
   **/
  | {
      name: 'LiquidityAdded';
      data: { poolId: number; who: AccountId32; shares: bigint; assets: Array<HydradxTraitsStableswapAssetAmount> };
    }
  /**
   * Liquidity removed.
   **/
  | {
      name: 'LiquidityRemoved';
      data: {
        poolId: number;
        who: AccountId32;
        shares: bigint;
        amounts: Array<HydradxTraitsStableswapAssetAmount>;
        fee: bigint;
      };
    }
  /**
   * Sell trade executed. Trade fee paid in asset leaving the pool (already subtracted from amount_out).
   * Deprecated. Replaced by pallet_broadcast::Swapped
   **/
  | {
      name: 'SellExecuted';
      data: {
        who: AccountId32;
        poolId: number;
        assetIn: number;
        assetOut: number;
        amountIn: bigint;
        amountOut: bigint;
        fee: bigint;
      };
    }
  /**
   * Buy trade executed. Trade fee paid in asset entering the pool (already included in amount_in).
   * Deprecated. Replaced by pallet_broadcast::Swapped
   **/
  | {
      name: 'BuyExecuted';
      data: {
        who: AccountId32;
        poolId: number;
        assetIn: number;
        assetOut: number;
        amountIn: bigint;
        amountOut: bigint;
        fee: bigint;
      };
    }
  /**
   * Asset's tradable state has been updated.
   **/
  | { name: 'TradableStateUpdated'; data: { poolId: number; assetId: number; state: PalletStableswapTradability } }
  /**
   * Amplification of a pool has been scheduled to change.
   **/
  | {
      name: 'AmplificationChanging';
      data: {
        poolId: number;
        currentAmplification: NonZeroU16;
        finalAmplification: NonZeroU16;
        startBlock: number;
        endBlock: number;
      };
    }
  /**
   * A pool has been destroyed.
   **/
  | { name: 'PoolDestroyed'; data: { poolId: number } }
  /**
   * Pool peg source has been updated.
   **/
  | { name: 'PoolPegSourceUpdated'; data: { poolId: number; assetId: number; pegSource: PalletStableswapPegSource } }
  /**
   * Pool max peg update has been updated.
   **/
  | { name: 'PoolMaxPegUpdateUpdated'; data: { poolId: number; maxPegUpdate: Permill } };

export type NonZeroU16 = number;

export type PalletStableswapPoolPegInfo = {
  source: Array<PalletStableswapPegSource>;
  maxPegUpdate: Permill;
  current: Array<[bigint, bigint]>;
};

/**
 * The `Event` enum of this pallet
 **/
export type PalletBondsEvent =
  /**
   * A bond asset was registered
   **/
  | { name: 'TokenCreated'; data: { issuer: AccountId32; assetId: number; bondId: number; maturity: bigint } }
  /**
   * New bond were issued
   **/
  | { name: 'Issued'; data: { issuer: AccountId32; bondId: number; amount: bigint; fee: bigint } }
  /**
   * Bonds were redeemed
   **/
  | { name: 'Redeemed'; data: { who: AccountId32; bondId: number; amount: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletOtcSettlementsEvent =
  /**
   * A trade has been executed
   **/
  { name: 'Executed'; data: { assetId: number; profit: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletLbpEvent =
  /**
   * Pool was created by the `CreatePool` origin.
   **/
  | { name: 'PoolCreated'; data: { pool: AccountId32; data: PalletLbpPool } }
  /**
   * Pool data were updated.
   **/
  | { name: 'PoolUpdated'; data: { pool: AccountId32; data: PalletLbpPool } }
  /**
   * New liquidity was provided to the pool.
   **/
  | {
      name: 'LiquidityAdded';
      data: { who: AccountId32; assetA: number; assetB: number; amountA: bigint; amountB: bigint };
    }
  /**
   * Liquidity was removed from the pool and the pool was destroyed.
   **/
  | {
      name: 'LiquidityRemoved';
      data: { who: AccountId32; assetA: number; assetB: number; amountA: bigint; amountB: bigint };
    }
  /**
   * Sale executed.
   * Deprecated. Replaced by pallet_broadcast::Swapped
   **/
  | {
      name: 'SellExecuted';
      data: {
        who: AccountId32;
        assetIn: number;
        assetOut: number;
        amount: bigint;
        salePrice: bigint;
        feeAsset: number;
        feeAmount: bigint;
      };
    }
  /**
   * Purchase executed.
   * Deprecated. Replaced by pallet_broadcast::Swapped
   **/
  | {
      name: 'BuyExecuted';
      data: {
        who: AccountId32;
        assetOut: number;
        assetIn: number;
        amount: bigint;
        buyPrice: bigint;
        feeAsset: number;
        feeAmount: bigint;
      };
    };

export type PalletLbpPool = {
  owner: AccountId32;
  start?: number | undefined;
  end?: number | undefined;
  assets: [number, number];
  initialWeight: number;
  finalWeight: number;
  weightCurve: PalletLbpWeightCurveType;
  fee: [number, number];
  feeCollector: AccountId32;
  repayTarget: bigint;
};

/**
 * The `Event` enum of this pallet
 **/
export type PalletXykEvent =
  /**
   * New liquidity was provided to the pool.
   **/
  | {
      name: 'LiquidityAdded';
      data: { who: AccountId32; assetA: number; assetB: number; amountA: bigint; amountB: bigint };
    }
  /**
   * Liquidity was removed from the pool.
   **/
  | { name: 'LiquidityRemoved'; data: { who: AccountId32; assetA: number; assetB: number; shares: bigint } }
  /**
   * Pool was created.
   **/
  | {
      name: 'PoolCreated';
      data: {
        who: AccountId32;
        assetA: number;
        assetB: number;
        initialSharesAmount: bigint;
        shareToken: number;
        pool: AccountId32;
      };
    }
  /**
   * Pool was destroyed.
   **/
  | {
      name: 'PoolDestroyed';
      data: { who: AccountId32; assetA: number; assetB: number; shareToken: number; pool: AccountId32 };
    }
  /**
   * Asset sale executed.
   * Deprecated. Replaced by pallet_broadcast::Swapped
   **/
  | {
      name: 'SellExecuted';
      data: {
        who: AccountId32;
        assetIn: number;
        assetOut: number;
        amount: bigint;
        salePrice: bigint;
        feeAsset: number;
        feeAmount: bigint;
        pool: AccountId32;
      };
    }
  /**
   * Asset purchase executed.
   * Deprecated. Replaced by pallet_broadcast::Swapped
   **/
  | {
      name: 'BuyExecuted';
      data: {
        who: AccountId32;
        assetOut: number;
        assetIn: number;
        amount: bigint;
        buyPrice: bigint;
        feeAsset: number;
        feeAmount: bigint;
        pool: AccountId32;
      };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletReferralsEvent =
  /**
   * Referral code has been registered.
   **/
  | { name: 'CodeRegistered'; data: { code: Bytes; account: AccountId32 } }
  /**
   * Referral code has been linked to an account.
   **/
  | { name: 'CodeLinked'; data: { account: AccountId32; code: Bytes; referralAccount: AccountId32 } }
  /**
   * Asset has been converted to RewardAsset.
   **/
  | { name: 'Converted'; data: { from: PalletReferralsAssetAmount; to: PalletReferralsAssetAmount } }
  /**
   * Rewards claimed.
   **/
  | { name: 'Claimed'; data: { who: AccountId32; referrerRewards: bigint; tradeRewards: bigint } }
  /**
   * New asset rewards has been set.
   **/
  | {
      name: 'AssetRewardsUpdated';
      data: { assetId: number; level: PalletReferralsLevel; rewards: PalletReferralsFeeDistribution };
    }
  /**
   * Referrer reached new level.
   **/
  | { name: 'LevelUp'; data: { who: AccountId32; level: PalletReferralsLevel } };

export type PalletReferralsAssetAmount = { assetId: number; amount: bigint };

/**
 * The `Event` enum of this pallet
 **/
export type PalletLiquidationEvent =
  /**
   * Money market position has been liquidated
   **/
  {
    name: 'Liquidated';
    data: { user: H160; collateralAsset: number; debtAsset: number; debtToCover: bigint; profit: bigint };
  };

/**
 * The `Event` enum of this pallet
 **/
export type PalletHsmEvent =
  /**
   * A new collateral asset was added
   *
   * Parameters:
   * - `asset_id`: The ID of the asset added as collateral
   * - `pool_id`: The StableSwap pool ID where this asset belongs
   * - `purchase_fee`: Fee applied when buying Hollar with this asset
   * - `max_buy_price_coefficient`: Maximum buy price coefficient for HSM to buy back Hollar
   * - `buy_back_fee`: Fee applied when buying back Hollar
   * - `buyback_rate`: Parameter that controls how quickly HSM can buy Hollar with this asset
   **/
  | {
      name: 'CollateralAdded';
      data: {
        assetId: number;
        poolId: number;
        purchaseFee: Permill;
        maxBuyPriceCoefficient: FixedU128;
        buyBackFee: Permill;
        buybackRate: Perbill;
      };
    }
  /**
   * A collateral asset was removed
   *
   * Parameters:
   * - `asset_id`: The ID of the asset removed from collaterals
   * - `amount`: The amount of the asset that was returned (should be zero)
   **/
  | { name: 'CollateralRemoved'; data: { assetId: number; amount: bigint } }
  /**
   * A collateral asset was updated
   *
   * Parameters:
   * - `asset_id`: The ID of the updated collateral asset
   * - `purchase_fee`: New purchase fee if updated (None if not changed)
   * - `max_buy_price_coefficient`: New max buy price coefficient if updated (None if not changed)
   * - `buy_back_fee`: New buy back fee if updated (None if not changed)
   * - `buyback_rate`: New buyback rate if updated (None if not changed)
   **/
  | {
      name: 'CollateralUpdated';
      data: {
        assetId: number;
        purchaseFee?: Permill | undefined;
        maxBuyPriceCoefficient?: FixedU128 | undefined;
        buyBackFee?: Permill | undefined;
        buybackRate?: Perbill | undefined;
      };
    }
  /**
   * Arbitrage executed successfully
   *
   * Parameters:
   * - `asset_id`: The collateral asset used in the arbitrage
   * - `hollar_amount`: Amount of Hollar that was included in the arbitrage operation
   **/
  | { name: 'ArbitrageExecuted'; data: { assetId: number; hollarAmount: bigint } }
  /**
   * Flash minter address set
   *
   * Parameters:
   * - `flash_minter`: The EVM address of the flash minter contract
   **/
  | { name: 'FlashMinterSet'; data: { flashMinter: H160 } };

/**
 * The `Event` enum of this pallet
 **/
export type OrmlTokensModuleEvent =
  /**
   * An account was created with some free balance.
   **/
  | { name: 'Endowed'; data: { currencyId: number; who: AccountId32; amount: bigint } }
  /**
   * An account was removed whose balance was non-zero but below
   * ExistentialDeposit, resulting in an outright loss.
   **/
  | { name: 'DustLost'; data: { currencyId: number; who: AccountId32; amount: bigint } }
  /**
   * Transfer succeeded.
   **/
  | { name: 'Transfer'; data: { currencyId: number; from: AccountId32; to: AccountId32; amount: bigint } }
  /**
   * Some balance was reserved (moved from free to reserved).
   **/
  | { name: 'Reserved'; data: { currencyId: number; who: AccountId32; amount: bigint } }
  /**
   * Some balance was unreserved (moved from reserved to free).
   **/
  | { name: 'Unreserved'; data: { currencyId: number; who: AccountId32; amount: bigint } }
  /**
   * Some reserved balance was repatriated (moved from reserved to
   * another account).
   **/
  | {
      name: 'ReserveRepatriated';
      data: {
        currencyId: number;
        from: AccountId32;
        to: AccountId32;
        amount: bigint;
        status: FrameSupportTokensMiscBalanceStatus;
      };
    }
  /**
   * A balance was set by root.
   **/
  | { name: 'BalanceSet'; data: { currencyId: number; who: AccountId32; free: bigint; reserved: bigint } }
  /**
   * The total issuance of an currency has been set
   **/
  | { name: 'TotalIssuanceSet'; data: { currencyId: number; amount: bigint } }
  /**
   * Some balances were withdrawn (e.g. pay for transaction fee)
   **/
  | { name: 'Withdrawn'; data: { currencyId: number; who: AccountId32; amount: bigint } }
  /**
   * Some balances were slashed (e.g. due to mis-behavior)
   **/
  | { name: 'Slashed'; data: { currencyId: number; who: AccountId32; freeAmount: bigint; reservedAmount: bigint } }
  /**
   * Deposited some balance into an account
   **/
  | { name: 'Deposited'; data: { currencyId: number; who: AccountId32; amount: bigint } }
  /**
   * Some funds are locked
   **/
  | { name: 'LockSet'; data: { lockId: FixedBytes<8>; currencyId: number; who: AccountId32; amount: bigint } }
  /**
   * Some locked funds were unlocked
   **/
  | { name: 'LockRemoved'; data: { lockId: FixedBytes<8>; currencyId: number; who: AccountId32 } }
  /**
   * Some free balance was locked.
   **/
  | { name: 'Locked'; data: { currencyId: number; who: AccountId32; amount: bigint } }
  /**
   * Some locked balance was freed.
   **/
  | { name: 'Unlocked'; data: { currencyId: number; who: AccountId32; amount: bigint } }
  | { name: 'Issued'; data: { currencyId: number; amount: bigint } }
  | { name: 'Rescinded'; data: { currencyId: number; amount: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletCurrenciesModuleEvent =
  /**
   * Currency transfer success.
   **/
  | { name: 'Transferred'; data: { currencyId: number; from: AccountId32; to: AccountId32; amount: bigint } }
  /**
   * Update balance success.
   **/
  | { name: 'BalanceUpdated'; data: { currencyId: number; who: AccountId32; amount: bigint } }
  /**
   * Deposit success.
   **/
  | { name: 'Deposited'; data: { currencyId: number; who: AccountId32; amount: bigint } }
  /**
   * Withdraw success.
   **/
  | { name: 'Withdrawn'; data: { currencyId: number; who: AccountId32; amount: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type OrmlVestingModuleEvent =
  /**
   * Added new vesting schedule.
   **/
  | {
      name: 'VestingScheduleAdded';
      data: { from: AccountId32; to: AccountId32; vestingSchedule: OrmlVestingVestingSchedule };
    }
  /**
   * Claimed vesting.
   **/
  | { name: 'Claimed'; data: { who: AccountId32; amount: bigint } }
  /**
   * Updated vesting schedules.
   **/
  | { name: 'VestingSchedulesUpdated'; data: { who: AccountId32 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletEvmEvent =
  /**
   * Ethereum events from contracts.
   **/
  | { name: 'Log'; data: { log: EthereumLog } }
  /**
   * A contract has been created at given address.
   **/
  | { name: 'Created'; data: { address: H160 } }
  /**
   * A contract was attempted to be created, but the execution failed.
   **/
  | { name: 'CreatedFailed'; data: { address: H160 } }
  /**
   * A contract has been executed successfully with states applied.
   **/
  | { name: 'Executed'; data: { address: H160 } }
  /**
   * A contract has been executed with errors. States are reverted with only gas fees applied.
   **/
  | { name: 'ExecutedFailed'; data: { address: H160 } };

export type EthereumLog = { address: H160; topics: Array<H256>; data: Bytes };

/**
 * The `Event` enum of this pallet
 **/
export type PalletEthereumEvent =
  /**
   * An ethereum transaction was successfully executed.
   **/
  {
    name: 'Executed';
    data: { from: H160; to: H160; transactionHash: H256; exitReason: EvmCoreErrorExitReason; extraData: Bytes };
  };

export type EvmCoreErrorExitReason =
  | { type: 'Succeed'; value: EvmCoreErrorExitSucceed }
  | { type: 'Error'; value: EvmCoreErrorExitError }
  | { type: 'Revert'; value: EvmCoreErrorExitRevert }
  | { type: 'Fatal'; value: EvmCoreErrorExitFatal };

export type EvmCoreErrorExitSucceed = 'Stopped' | 'Returned' | 'Suicided';

export type EvmCoreErrorExitError =
  | { type: 'StackUnderflow' }
  | { type: 'StackOverflow' }
  | { type: 'InvalidJump' }
  | { type: 'InvalidRange' }
  | { type: 'DesignatedInvalid' }
  | { type: 'CallTooDeep' }
  | { type: 'CreateCollision' }
  | { type: 'CreateContractLimit' }
  | { type: 'InvalidCode'; value: EvmCoreOpcode }
  | { type: 'OutOfOffset' }
  | { type: 'OutOfGas' }
  | { type: 'OutOfFund' }
  | { type: 'PcUnderflow' }
  | { type: 'CreateEmpty' }
  | { type: 'Other'; value: string }
  | { type: 'MaxNonce' };

export type EvmCoreOpcode = number;

export type EvmCoreErrorExitRevert = 'Reverted';

export type EvmCoreErrorExitFatal =
  | { type: 'NotSupported' }
  | { type: 'UnhandledInterrupt' }
  | { type: 'CallErrorAsFatal'; value: EvmCoreErrorExitError }
  | { type: 'Other'; value: string };

/**
 * The `Event` enum of this pallet
 **/
export type PalletEvmAccountsEvent =
  /**
   * Binding was created.
   **/
  | { name: 'Bound'; data: { account: AccountId32; address: H160 } }
  /**
   * Deployer was added.
   **/
  | { name: 'DeployerAdded'; data: { who: H160 } }
  /**
   * Deployer was removed.
   **/
  | { name: 'DeployerRemoved'; data: { who: H160 } }
  /**
   * Contract was approved.
   **/
  | { name: 'ContractApproved'; data: { address: H160 } }
  /**
   * Contract was disapproved.
   **/
  | { name: 'ContractDisapproved'; data: { address: H160 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletXykLiquidityMiningEvent =
  /**
   * New global farm was created.
   **/
  | {
      name: 'GlobalFarmCreated';
      data: {
        id: number;
        owner: AccountId32;
        totalRewards: bigint;
        rewardCurrency: number;
        yieldPerPeriod: Perquintill;
        plannedYieldingPeriods: number;
        blocksPerPeriod: number;
        incentivizedAsset: number;
        maxRewardPerPeriod: bigint;
        minDeposit: bigint;
        priceAdjustment: FixedU128;
      };
    }
  /**
   * Global farm's `price_adjustment` was updated.
   **/
  | { name: 'GlobalFarmUpdated'; data: { id: number; priceAdjustment: FixedU128 } }
  /**
   * New yield farm was added into the farm.
   **/
  | {
      name: 'YieldFarmCreated';
      data: {
        globalFarmId: number;
        yieldFarmId: number;
        multiplier: FixedU128;
        assetPair: PalletXykAssetPair;
        loyaltyCurve?: PalletLiquidityMiningLoyaltyCurve | undefined;
      };
    }
  /**
   * Global farm was terminated.
   **/
  | {
      name: 'GlobalFarmTerminated';
      data: { globalFarmId: number; who: AccountId32; rewardCurrency: number; undistributedRewards: bigint };
    }
  /**
   * New LP tokens was deposited.
   **/
  | {
      name: 'SharesDeposited';
      data: {
        globalFarmId: number;
        yieldFarmId: number;
        who: AccountId32;
        amount: bigint;
        lpToken: number;
        depositId: bigint;
      };
    }
  /**
   * LP token was redeposited for a new yield farm entry
   **/
  | {
      name: 'SharesRedeposited';
      data: {
        globalFarmId: number;
        yieldFarmId: number;
        who: AccountId32;
        amount: bigint;
        lpToken: number;
        depositId: bigint;
      };
    }
  /**
   * Rewards was claimed.
   **/
  | {
      name: 'RewardClaimed';
      data: {
        globalFarmId: number;
        yieldFarmId: number;
        who: AccountId32;
        claimed: bigint;
        rewardCurrency: number;
        depositId: bigint;
      };
    }
  /**
   * LP tokens was withdrawn.
   **/
  | {
      name: 'SharesWithdrawn';
      data: {
        globalFarmId: number;
        yieldFarmId: number;
        who: AccountId32;
        lpToken: number;
        amount: bigint;
        depositId: bigint;
      };
    }
  /**
   * Yield farm for asset pair was stopped.
   **/
  | {
      name: 'YieldFarmStopped';
      data: { globalFarmId: number; yieldFarmId: number; who: AccountId32; assetPair: PalletXykAssetPair };
    }
  /**
   * Yield farm for asset pair was resumed.
   **/
  | {
      name: 'YieldFarmResumed';
      data: {
        globalFarmId: number;
        yieldFarmId: number;
        who: AccountId32;
        assetPair: PalletXykAssetPair;
        multiplier: FixedU128;
      };
    }
  /**
   * Yield farm was terminated from global farm.
   **/
  | {
      name: 'YieldFarmTerminated';
      data: { globalFarmId: number; yieldFarmId: number; who: AccountId32; assetPair: PalletXykAssetPair };
    }
  /**
   * Yield farm multiplier was updated.
   **/
  | {
      name: 'YieldFarmUpdated';
      data: {
        globalFarmId: number;
        yieldFarmId: number;
        who: AccountId32;
        assetPair: PalletXykAssetPair;
        multiplier: FixedU128;
      };
    }
  /**
   * NFT representing deposit has been destroyed
   **/
  | { name: 'DepositDestroyed'; data: { who: AccountId32; depositId: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletRelaychainInfoEvent =
  /**
   * Current block numbers
   * [ Parachain block number, Relaychain Block number ]
   **/
  { name: 'CurrentBlockNumbers'; data: { parachainBlockNumber: number; relaychainBlockNumber: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletDcaEvent =
  /**
   * The DCA execution is started
   **/
  | { name: 'ExecutionStarted'; data: { id: number; block: number } }
  /**
   * The DCA is scheduled for next execution
   **/
  | {
      name: 'Scheduled';
      data: { id: number; who: AccountId32; period: number; totalAmount: bigint; order: PalletDcaOrder };
    }
  /**
   * The DCA is planned for blocknumber
   **/
  | { name: 'ExecutionPlanned'; data: { id: number; who: AccountId32; block: number } }
  /**
   * The DCA trade is successfully executed
   **/
  | { name: 'TradeExecuted'; data: { id: number; who: AccountId32; amountIn: bigint; amountOut: bigint } }
  /**
   * The DCA trade execution is failed
   **/
  | { name: 'TradeFailed'; data: { id: number; who: AccountId32; error: DispatchError } }
  /**
   * The DCA is terminated and completely removed from the chain
   **/
  | { name: 'Terminated'; data: { id: number; who: AccountId32; error: DispatchError } }
  /**
   * The DCA is completed and completely removed from the chain
   **/
  | { name: 'Completed'; data: { id: number; who: AccountId32 } }
  /**
   * Randomness generation failed possibly coming from missing data about relay chain
   **/
  | { name: 'RandomnessGenerationFailed'; data: { block: number; error: DispatchError } };

/**
 * Events type.
 **/
export type PalletSchedulerEvent =
  /**
   * Scheduled some task.
   **/
  | { name: 'Scheduled'; data: { when: number; index: number } }
  /**
   * Canceled some task.
   **/
  | { name: 'Canceled'; data: { when: number; index: number } }
  /**
   * Dispatched some task.
   **/
  | {
      name: 'Dispatched';
      data: { task: [number, number]; id?: FixedBytes<32> | undefined; result: Result<[], DispatchError> };
    }
  /**
   * Set a retry configuration for some task.
   **/
  | {
      name: 'RetrySet';
      data: { task: [number, number]; id?: FixedBytes<32> | undefined; period: number; retries: number };
    }
  /**
   * Cancel a retry configuration for some task.
   **/
  | { name: 'RetryCancelled'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } }
  /**
   * The call for the provided hash was not found so the task has been aborted.
   **/
  | { name: 'CallUnavailable'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } }
  /**
   * The given task was unable to be renewed since the agenda is full at that block.
   **/
  | { name: 'PeriodicFailed'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } }
  /**
   * The given task was unable to be retried since the agenda is full at that block or there
   * was not enough weight to reschedule it.
   **/
  | { name: 'RetryFailed'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } }
  /**
   * The given task can never be executed since it is overweight.
   **/
  | { name: 'PermanentlyOverweight'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } };

/**
 * The `Event` enum of this pallet
 **/
export type CumulusPalletParachainSystemEvent =
  /**
   * The validation function has been scheduled to apply.
   **/
  | { name: 'ValidationFunctionStored' }
  /**
   * The validation function was applied as of the contained relay chain block number.
   **/
  | { name: 'ValidationFunctionApplied'; data: { relayChainBlockNum: number } }
  /**
   * The relay-chain aborted the upgrade process.
   **/
  | { name: 'ValidationFunctionDiscarded' }
  /**
   * Some downward messages have been received and will be processed.
   **/
  | { name: 'DownwardMessagesReceived'; data: { count: number } }
  /**
   * Downward messages were processed using the given weight.
   **/
  | { name: 'DownwardMessagesProcessed'; data: { weightUsed: SpWeightsWeightV2Weight; dmqHead: H256 } }
  /**
   * An upward message was sent to the relay chain.
   **/
  | { name: 'UpwardMessageSent'; data: { messageHash?: FixedBytes<32> | undefined } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletXcmEvent =
  /**
   * Execution of an XCM message was attempted.
   **/
  | { name: 'Attempted'; data: { outcome: StagingXcmV4TraitsOutcome } }
  /**
   * A XCM message was sent.
   **/
  | {
      name: 'Sent';
      data: {
        origin: StagingXcmV4Location;
        destination: StagingXcmV4Location;
        message: StagingXcmV4Xcm;
        messageId: FixedBytes<32>;
      };
    }
  /**
   * Query response received which does not match a registered query. This may be because a
   * matching query was never registered, it may be because it is a duplicate response, or
   * because the query timed out.
   **/
  | { name: 'UnexpectedResponse'; data: { origin: StagingXcmV4Location; queryId: bigint } }
  /**
   * Query response has been received and is ready for taking with `take_response`. There is
   * no registered notification call.
   **/
  | { name: 'ResponseReady'; data: { queryId: bigint; response: StagingXcmV4Response } }
  /**
   * Query response has been received and query is removed. The registered notification has
   * been dispatched and executed successfully.
   **/
  | { name: 'Notified'; data: { queryId: bigint; palletIndex: number; callIndex: number } }
  /**
   * Query response has been received and query is removed. The registered notification
   * could not be dispatched because the dispatch weight is greater than the maximum weight
   * originally budgeted by this runtime for the query result.
   **/
  | {
      name: 'NotifyOverweight';
      data: {
        queryId: bigint;
        palletIndex: number;
        callIndex: number;
        actualWeight: SpWeightsWeightV2Weight;
        maxBudgetedWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Query response has been received and query is removed. There was a general error with
   * dispatching the notification call.
   **/
  | { name: 'NotifyDispatchError'; data: { queryId: bigint; palletIndex: number; callIndex: number } }
  /**
   * Query response has been received and query is removed. The dispatch was unable to be
   * decoded into a `Call`; this might be due to dispatch function having a signature which
   * is not `(origin, QueryId, Response)`.
   **/
  | { name: 'NotifyDecodeFailed'; data: { queryId: bigint; palletIndex: number; callIndex: number } }
  /**
   * Expected query response has been received but the origin location of the response does
   * not match that expected. The query remains registered for a later, valid, response to
   * be received and acted upon.
   **/
  | {
      name: 'InvalidResponder';
      data: { origin: StagingXcmV4Location; queryId: bigint; expectedLocation?: StagingXcmV4Location | undefined };
    }
  /**
   * Expected query response has been received but the expected origin location placed in
   * storage by this runtime previously cannot be decoded. The query remains registered.
   *
   * This is unexpected (since a location placed in storage in a previously executing
   * runtime should be readable prior to query timeout) and dangerous since the possibly
   * valid response will be dropped. Manual governance intervention is probably going to be
   * needed.
   **/
  | { name: 'InvalidResponderVersion'; data: { origin: StagingXcmV4Location; queryId: bigint } }
  /**
   * Received query response has been read and removed.
   **/
  | { name: 'ResponseTaken'; data: { queryId: bigint } }
  /**
   * Some assets have been placed in an asset trap.
   **/
  | { name: 'AssetsTrapped'; data: { hash: H256; origin: StagingXcmV4Location; assets: XcmVersionedAssets } }
  /**
   * An XCM version change notification message has been attempted to be sent.
   *
   * The cost of sending it (borne by the chain) is included.
   **/
  | {
      name: 'VersionChangeNotified';
      data: {
        destination: StagingXcmV4Location;
        result: number;
        cost: StagingXcmV4AssetAssets;
        messageId: FixedBytes<32>;
      };
    }
  /**
   * The supported version of a location has been changed. This might be through an
   * automatic notification or a manual intervention.
   **/
  | { name: 'SupportedVersionChanged'; data: { location: StagingXcmV4Location; version: number } }
  /**
   * A given location which had a version change subscription was dropped owing to an error
   * sending the notification to it.
   **/
  | { name: 'NotifyTargetSendFail'; data: { location: StagingXcmV4Location; queryId: bigint; error: XcmV3TraitsError } }
  /**
   * A given location which had a version change subscription was dropped owing to an error
   * migrating the location to our new XCM format.
   **/
  | { name: 'NotifyTargetMigrationFail'; data: { location: XcmVersionedLocation; queryId: bigint } }
  /**
   * Expected query response has been received but the expected querier location placed in
   * storage by this runtime previously cannot be decoded. The query remains registered.
   *
   * This is unexpected (since a location placed in storage in a previously executing
   * runtime should be readable prior to query timeout) and dangerous since the possibly
   * valid response will be dropped. Manual governance intervention is probably going to be
   * needed.
   **/
  | { name: 'InvalidQuerierVersion'; data: { origin: StagingXcmV4Location; queryId: bigint } }
  /**
   * Expected query response has been received but the querier location of the response does
   * not match the expected. The query remains registered for a later, valid, response to
   * be received and acted upon.
   **/
  | {
      name: 'InvalidQuerier';
      data: {
        origin: StagingXcmV4Location;
        queryId: bigint;
        expectedQuerier: StagingXcmV4Location;
        maybeActualQuerier?: StagingXcmV4Location | undefined;
      };
    }
  /**
   * A remote has requested XCM version change notification from us and we have honored it.
   * A version information message is sent to them and its cost is included.
   **/
  | {
      name: 'VersionNotifyStarted';
      data: { destination: StagingXcmV4Location; cost: StagingXcmV4AssetAssets; messageId: FixedBytes<32> };
    }
  /**
   * We have requested that a remote chain send us XCM version change notifications.
   **/
  | {
      name: 'VersionNotifyRequested';
      data: { destination: StagingXcmV4Location; cost: StagingXcmV4AssetAssets; messageId: FixedBytes<32> };
    }
  /**
   * We have requested that a remote chain stops sending us XCM version change
   * notifications.
   **/
  | {
      name: 'VersionNotifyUnrequested';
      data: { destination: StagingXcmV4Location; cost: StagingXcmV4AssetAssets; messageId: FixedBytes<32> };
    }
  /**
   * Fees were paid from a location for an operation (often for using `SendXcm`).
   **/
  | { name: 'FeesPaid'; data: { paying: StagingXcmV4Location; fees: StagingXcmV4AssetAssets } }
  /**
   * Some assets have been claimed from an asset trap
   **/
  | { name: 'AssetsClaimed'; data: { hash: H256; origin: StagingXcmV4Location; assets: XcmVersionedAssets } }
  /**
   * A XCM version migration finished.
   **/
  | { name: 'VersionMigrationFinished'; data: { version: number } };

export type StagingXcmV4TraitsOutcome =
  | { type: 'Complete'; value: { used: SpWeightsWeightV2Weight } }
  | { type: 'Incomplete'; value: { used: SpWeightsWeightV2Weight; error: XcmV3TraitsError } }
  | { type: 'Error'; value: { error: XcmV3TraitsError } };

/**
 * The `Event` enum of this pallet
 **/
export type CumulusPalletXcmEvent =
  /**
   * Downward message is invalid XCM.
   * \[ id \]
   **/
  | { name: 'InvalidFormat'; data: FixedBytes<32> }
  /**
   * Downward message is unsupported version of XCM.
   * \[ id \]
   **/
  | { name: 'UnsupportedVersion'; data: FixedBytes<32> }
  /**
   * Downward message executed with the given outcome.
   * \[ id, outcome \]
   **/
  | { name: 'ExecutedDownward'; data: [FixedBytes<32>, StagingXcmV4TraitsOutcome] };

/**
 * The `Event` enum of this pallet
 **/
export type CumulusPalletXcmpQueueEvent =
  /**
   * An HRMP message was sent to a sibling parachain.
   **/
  { name: 'XcmpMessageSent'; data: { messageHash: FixedBytes<32> } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletMessageQueueEvent =
  /**
   * Message discarded due to an error in the `MessageProcessor` (usually a format error).
   **/
  | {
      name: 'ProcessingFailed';
      data: {
        /**
         * The `blake2_256` hash of the message.
         **/
        id: H256;

        /**
         * The queue of the message.
         **/
        origin: CumulusPrimitivesCoreAggregateMessageOrigin;

        /**
         * The error that occurred.
         *
         * This error is pretty opaque. More fine-grained errors need to be emitted as events
         * by the `MessageProcessor`.
         **/
        error: FrameSupportMessagesProcessMessageError;
      };
    }
  /**
   * Message is processed.
   **/
  | {
      name: 'Processed';
      data: {
        /**
         * The `blake2_256` hash of the message.
         **/
        id: H256;

        /**
         * The queue of the message.
         **/
        origin: CumulusPrimitivesCoreAggregateMessageOrigin;

        /**
         * How much weight was used to process the message.
         **/
        weightUsed: SpWeightsWeightV2Weight;

        /**
         * Whether the message was processed.
         *
         * Note that this does not mean that the underlying `MessageProcessor` was internally
         * successful. It *solely* means that the MQ pallet will treat this as a success
         * condition and discard the message. Any internal error needs to be emitted as events
         * by the `MessageProcessor`.
         **/
        success: boolean;
      };
    }
  /**
   * Message placed in overweight queue.
   **/
  | {
      name: 'OverweightEnqueued';
      data: {
        /**
         * The `blake2_256` hash of the message.
         **/
        id: FixedBytes<32>;

        /**
         * The queue of the message.
         **/
        origin: CumulusPrimitivesCoreAggregateMessageOrigin;

        /**
         * The page of the message.
         **/
        pageIndex: number;

        /**
         * The index of the message within the page.
         **/
        messageIndex: number;
      };
    }
  /**
   * This page was reaped.
   **/
  | {
      name: 'PageReaped';
      data: {
        /**
         * The queue of the page.
         **/
        origin: CumulusPrimitivesCoreAggregateMessageOrigin;

        /**
         * The index of the page.
         **/
        index: number;
      };
    };

export type FrameSupportMessagesProcessMessageError =
  | { type: 'BadFormat' }
  | { type: 'Corrupt' }
  | { type: 'Unsupported' }
  | { type: 'Overweight'; value: SpWeightsWeightV2Weight }
  | { type: 'Yield' }
  | { type: 'StackLimitReached' };

/**
 * The `Event` enum of this pallet
 **/
export type OrmlXcmModuleEvent =
  /**
   * XCM message sent. \[to, message\]
   **/
  { name: 'Sent'; data: { to: StagingXcmV4Location; message: StagingXcmV4Xcm } };

/**
 * The `Event` enum of this pallet
 **/
export type OrmlXtokensModuleEvent =
  /**
   * Transferred `Asset` with fee.
   **/
  {
    name: 'TransferredAssets';
    data: { sender: AccountId32; assets: StagingXcmV4AssetAssets; fee: StagingXcmV4Asset; dest: StagingXcmV4Location };
  };

/**
 * The `Event` enum of this pallet
 **/
export type OrmlUnknownTokensModuleEvent =
  /**
   * Deposit success.
   **/
  | { name: 'Deposited'; data: { asset: StagingXcmV4Asset; who: StagingXcmV4Location } }
  /**
   * Withdraw success.
   **/
  | { name: 'Withdrawn'; data: { asset: StagingXcmV4Asset; who: StagingXcmV4Location } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletCollatorSelectionEvent =
  /**
   * New Invulnerables were set.
   **/
  | { name: 'NewInvulnerables'; data: { invulnerables: Array<AccountId32> } }
  /**
   * A new Invulnerable was added.
   **/
  | { name: 'InvulnerableAdded'; data: { accountId: AccountId32 } }
  /**
   * An Invulnerable was removed.
   **/
  | { name: 'InvulnerableRemoved'; data: { accountId: AccountId32 } }
  /**
   * The number of desired candidates was set.
   **/
  | { name: 'NewDesiredCandidates'; data: { desiredCandidates: number } }
  /**
   * The candidacy bond was set.
   **/
  | { name: 'NewCandidacyBond'; data: { bondAmount: bigint } }
  /**
   * A new candidate joined.
   **/
  | { name: 'CandidateAdded'; data: { accountId: AccountId32; deposit: bigint } }
  /**
   * Bond of a candidate updated.
   **/
  | { name: 'CandidateBondUpdated'; data: { accountId: AccountId32; deposit: bigint } }
  /**
   * A candidate was removed.
   **/
  | { name: 'CandidateRemoved'; data: { accountId: AccountId32 } }
  /**
   * An account was replaced in the candidate list by another one.
   **/
  | { name: 'CandidateReplaced'; data: { old: AccountId32; new: AccountId32; deposit: bigint } }
  /**
   * An account was unable to be added to the Invulnerables because they did not have keys
   * registered. Other Invulnerables may have been set.
   **/
  | { name: 'InvalidInvulnerableSkipped'; data: { accountId: AccountId32 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletSessionEvent =
  /**
   * New session has happened. Note that the argument is the session index, not the
   * block number as the type might suggest.
   **/
  { name: 'NewSession'; data: { sessionIndex: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletEmaOracleEvent =
  /**
   * Oracle was added to the whitelist.
   **/
  | { name: 'AddedToWhitelist'; data: { source: FixedBytes<8>; assets: [number, number] } }
  /**
   * Oracle was removed from the whitelist.
   **/
  | { name: 'RemovedFromWhitelist'; data: { source: FixedBytes<8>; assets: [number, number] } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletBroadcastEvent =
  /**
   * Trade executed.
   *
   * Swapped3 is a fixed and renamed version of original Swapped,
   * as Swapped contained wrong input/output amounts for XYK buy trade
   *
   * Swapped3 is a fixed and renamed version of original Swapped3,
   * as Swapped contained wrong filler account on AAVE trades
   *
   **/
  {
    name: 'Swapped3';
    data: {
      swapper: AccountId32;
      filler: AccountId32;
      fillerType: PalletBroadcastFiller;
      operation: PalletBroadcastTradeOperation;
      inputs: Array<PalletBroadcastAsset>;
      outputs: Array<PalletBroadcastAsset>;
      fees: Array<PalletBroadcastFee>;
      operationStack: Array<PalletBroadcastExecutionType>;
    };
  };

export type PalletBroadcastFiller =
  | { type: 'Omnipool' }
  | { type: 'Stableswap'; value: number }
  | { type: 'Xyk'; value: number }
  | { type: 'Lbp' }
  | { type: 'Otc'; value: number }
  | { type: 'Aave' }
  | { type: 'Hsm' };

export type PalletBroadcastTradeOperation = 'ExactIn' | 'ExactOut' | 'Limit' | 'LiquidityAdd' | 'LiquidityRemove';

export type PalletBroadcastAsset = { asset: number; amount: bigint };

export type PalletBroadcastFee = { asset: number; amount: bigint; destination: PalletBroadcastDestination };

export type PalletBroadcastDestination = { type: 'Account'; value: AccountId32 } | { type: 'Burned' };

export type PalletBroadcastExecutionType =
  | { type: 'Router'; value: number }
  | { type: 'Dca'; value: [number, number] }
  | { type: 'Batch'; value: number }
  | { type: 'Omnipool'; value: number }
  | { type: 'XcmExchange'; value: number }
  | { type: 'Xcm'; value: [FixedBytes<32>, number] };

export type FrameSystemLastRuntimeUpgradeInfo = { specVersion: number; specName: string };

export type FrameSystemCodeUpgradeAuthorization = { codeHash: H256; checkVersion: boolean };

export type FrameSystemLimitsBlockWeights = {
  baseBlock: SpWeightsWeightV2Weight;
  maxBlock: SpWeightsWeightV2Weight;
  perClass: FrameSupportDispatchPerDispatchClassWeightsPerClass;
};

export type FrameSupportDispatchPerDispatchClassWeightsPerClass = {
  normal: FrameSystemLimitsWeightsPerClass;
  operational: FrameSystemLimitsWeightsPerClass;
  mandatory: FrameSystemLimitsWeightsPerClass;
};

export type FrameSystemLimitsWeightsPerClass = {
  baseExtrinsic: SpWeightsWeightV2Weight;
  maxExtrinsic?: SpWeightsWeightV2Weight | undefined;
  maxTotal?: SpWeightsWeightV2Weight | undefined;
  reserved?: SpWeightsWeightV2Weight | undefined;
};

export type FrameSystemLimitsBlockLength = { max: FrameSupportDispatchPerDispatchClassU32 };

export type FrameSupportDispatchPerDispatchClassU32 = { normal: number; operational: number; mandatory: number };

export type SpWeightsRuntimeDbWeight = { read: bigint; write: bigint };

/**
 * Error for the System pallet
 **/
export type FrameSystemError =
  /**
   * The name of specification does not match between the current runtime
   * and the new runtime.
   **/
  | 'InvalidSpecName'
  /**
   * The specification version is not allowed to decrease between the current runtime
   * and the new runtime.
   **/
  | 'SpecVersionNeedsToIncrease'
  /**
   * Failed to extract the runtime version from the new runtime.
   *
   * Either calling `Core_version` or decoding `RuntimeVersion` failed.
   **/
  | 'FailedToExtractRuntimeVersion'
  /**
   * Suicide called when the account has non-default composite data.
   **/
  | 'NonDefaultComposite'
  /**
   * There is a non-zero reference count preventing the account from being purged.
   **/
  | 'NonZeroRefCount'
  /**
   * The origin filter prevent the call to be dispatched.
   **/
  | 'CallFiltered'
  /**
   * A multi-block migration is ongoing and prevents the current code from being replaced.
   **/
  | 'MultiBlockMigrationsOngoing'
  /**
   * No upgrade authorized.
   **/
  | 'NothingAuthorized'
  /**
   * The submitted code is not authorized.
   **/
  | 'Unauthorized';

export type PalletBalancesBalanceLock = { id: FixedBytes<8>; amount: bigint; reasons: PalletBalancesReasons };

export type PalletBalancesReasons = 'Fee' | 'Misc' | 'All';

export type PalletBalancesReserveData = { id: FixedBytes<8>; amount: bigint };

export type FrameSupportTokensMiscIdAmount = { id: HydradxRuntimeRuntimeHoldReason; amount: bigint };

export type HydradxRuntimeRuntimeHoldReason =
  | { type: 'Preimage'; value: PalletPreimageHoldReason }
  | { type: 'StateTrieMigration'; value: PalletStateTrieMigrationHoldReason };

export type PalletPreimageHoldReason = 'Preimage';

export type PalletStateTrieMigrationHoldReason = 'SlashForMigrate';

export type FrameSupportTokensMiscIdAmount002 = { id: []; amount: bigint };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBalancesError =
  /**
   * Vesting balance too high to send value.
   **/
  | 'VestingBalance'
  /**
   * Account liquidity restrictions prevent withdrawal.
   **/
  | 'LiquidityRestrictions'
  /**
   * Balance too low to send value.
   **/
  | 'InsufficientBalance'
  /**
   * Value too low to create account due to existential deposit.
   **/
  | 'ExistentialDeposit'
  /**
   * Transfer/payment would kill account.
   **/
  | 'Expendability'
  /**
   * A vesting schedule already exists for this account.
   **/
  | 'ExistingVestingSchedule'
  /**
   * Beneficiary account must pre-exist.
   **/
  | 'DeadAccount'
  /**
   * Number of named reserves exceed `MaxReserves`.
   **/
  | 'TooManyReserves'
  /**
   * Number of holds exceed `VariantCountOf<T::RuntimeHoldReason>`.
   **/
  | 'TooManyHolds'
  /**
   * Number of freezes exceed `MaxFreezes`.
   **/
  | 'TooManyFreezes'
  /**
   * The issuance cannot be modified since it is already deactivated.
   **/
  | 'IssuanceDeactivated'
  /**
   * The delta cannot be zero.
   **/
  | 'DeltaZero';

export type PalletTransactionPaymentReleases = 'V1Ancient' | 'V2';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletTransactionMultiPaymentError =
  /**
   * Selected currency is not supported.
   **/
  | 'UnsupportedCurrency'
  /**
   * Account balance should be non-zero.
   **/
  | 'ZeroBalance'
  /**
   * Currency is already in the list of accepted currencies.
   **/
  | 'AlreadyAccepted'
  /**
   * It is not allowed to add Core Asset as accepted currency. Core asset is accepted by design.
   **/
  | 'CoreAssetNotAllowed'
  /**
   * Fallback price cannot be zero.
   **/
  | 'ZeroPrice'
  /**
   * Fallback price was not found.
   **/
  | 'FallbackPriceNotFound'
  /**
   * Math overflow
   **/
  | 'Overflow'
  /**
   * It is not allowed to change payment currency of an EVM account.
   **/
  | 'EvmAccountNotAllowed'
  /**
   * EVM permit expired.
   **/
  | 'EvmPermitExpired'
  /**
   * EVM permit is invalid.
   **/
  | 'EvmPermitInvalid'
  /**
   * EVM permit call failed.
   **/
  | 'EvmPermitCallExecutionError'
  /**
   * EVM permit call failed.
   **/
  | 'EvmPermitRunnerError';

export type PalletTreasuryProposal = { proposer: AccountId32; value: bigint; beneficiary: AccountId32; bond: bigint };

export type PalletTreasurySpendStatus = {
  assetKind: [];
  amount: bigint;
  beneficiary: AccountId32;
  validFrom: number;
  expireAt: number;
  status: PalletTreasuryPaymentState;
};

export type PalletTreasuryPaymentState =
  | { type: 'Pending' }
  | { type: 'Attempted'; value: { id: [] } }
  | { type: 'Failed' };

export type FrameSupportPalletId = FixedBytes<8>;

/**
 * Error for the treasury pallet.
 **/
export type PalletTreasuryError =
  /**
   * No proposal, bounty or spend at that index.
   **/
  | 'InvalidIndex'
  /**
   * Too many approvals in the queue.
   **/
  | 'TooManyApprovals'
  /**
   * The spend origin is valid but the amount it is allowed to spend is lower than the
   * amount to be spent.
   **/
  | 'InsufficientPermission'
  /**
   * Proposal has not been approved.
   **/
  | 'ProposalNotApproved'
  /**
   * The balance of the asset kind is not convertible to the balance of the native asset.
   **/
  | 'FailedToConvertBalance'
  /**
   * The spend has expired and cannot be claimed.
   **/
  | 'SpendExpired'
  /**
   * The spend is not yet eligible for payout.
   **/
  | 'EarlyPayout'
  /**
   * The payment has already been attempted.
   **/
  | 'AlreadyAttempted'
  /**
   * There was some issue with the mechanism of payment.
   **/
  | 'PayoutError'
  /**
   * The payout was not yet attempted/claimed.
   **/
  | 'NotAttempted'
  /**
   * The payment has neither failed nor succeeded yet.
   **/
  | 'Inconclusive';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletUtilityError =
  /**
   * Too many calls batched.
   **/
  'TooManyCalls';

export type PalletPreimageOldRequestStatus =
  | { type: 'Unrequested'; value: { deposit: [AccountId32, bigint]; len: number } }
  | {
      type: 'Requested';
      value: { deposit?: [AccountId32, bigint] | undefined; count: number; len?: number | undefined };
    };

export type PalletPreimageRequestStatus =
  | { type: 'Unrequested'; value: { ticket: [AccountId32, FrameSupportTokensFungibleHoldConsideration]; len: number } }
  | {
      type: 'Requested';
      value: {
        maybeTicket?: [AccountId32, FrameSupportTokensFungibleHoldConsideration] | undefined;
        count: number;
        maybeLen?: number | undefined;
      };
    };

export type FrameSupportTokensFungibleHoldConsideration = bigint;

/**
 * The `Error` enum of this pallet.
 **/
export type PalletPreimageError =
  /**
   * Preimage is too large to store on-chain.
   **/
  | 'TooBig'
  /**
   * Preimage has already been noted on-chain.
   **/
  | 'AlreadyNoted'
  /**
   * The user is not authorized to perform this action.
   **/
  | 'NotAuthorized'
  /**
   * The preimage cannot be removed since it has not yet been noted.
   **/
  | 'NotNoted'
  /**
   * A preimage may not be removed when there are outstanding requests.
   **/
  | 'Requested'
  /**
   * The preimage request cannot be removed since no outstanding requests exist.
   **/
  | 'NotRequested'
  /**
   * More than `MAX_HASH_UPGRADE_BULK_COUNT` hashes were requested to be upgraded at once.
   **/
  | 'TooMany'
  /**
   * Too few hashes were requested to be upgraded (i.e. zero).
   **/
  | 'TooFew';

export type PalletIdentityRegistration = {
  judgements: Array<[number, PalletIdentityJudgement]>;
  deposit: bigint;
  info: PalletIdentityLegacyIdentityInfo;
};

export type PalletIdentityRegistrarInfo = { account: AccountId32; fee: bigint; fields: bigint };

export type PalletIdentityAuthorityProperties = { suffix: Bytes; allocation: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletIdentityError =
  /**
   * Too many subs-accounts.
   **/
  | 'TooManySubAccounts'
  /**
   * Account isn't found.
   **/
  | 'NotFound'
  /**
   * Account isn't named.
   **/
  | 'NotNamed'
  /**
   * Empty index.
   **/
  | 'EmptyIndex'
  /**
   * Fee is changed.
   **/
  | 'FeeChanged'
  /**
   * No identity found.
   **/
  | 'NoIdentity'
  /**
   * Sticky judgement.
   **/
  | 'StickyJudgement'
  /**
   * Judgement given.
   **/
  | 'JudgementGiven'
  /**
   * Invalid judgement.
   **/
  | 'InvalidJudgement'
  /**
   * The index is invalid.
   **/
  | 'InvalidIndex'
  /**
   * The target is invalid.
   **/
  | 'InvalidTarget'
  /**
   * Maximum amount of registrars reached. Cannot add any more.
   **/
  | 'TooManyRegistrars'
  /**
   * Account ID is already named.
   **/
  | 'AlreadyClaimed'
  /**
   * Sender is not a sub-account.
   **/
  | 'NotSub'
  /**
   * Sub-account isn't owned by sender.
   **/
  | 'NotOwned'
  /**
   * The provided judgement was for a different identity.
   **/
  | 'JudgementForDifferentIdentity'
  /**
   * Error that occurs when there is an issue paying for judgement.
   **/
  | 'JudgementPaymentFailed'
  /**
   * The provided suffix is too long.
   **/
  | 'InvalidSuffix'
  /**
   * The sender does not have permission to issue a username.
   **/
  | 'NotUsernameAuthority'
  /**
   * The authority cannot allocate any more usernames.
   **/
  | 'NoAllocation'
  /**
   * The signature on a username was not valid.
   **/
  | 'InvalidSignature'
  /**
   * Setting this username requires a signature, but none was provided.
   **/
  | 'RequiresSignature'
  /**
   * The username does not meet the requirements.
   **/
  | 'InvalidUsername'
  /**
   * The username is already taken.
   **/
  | 'UsernameTaken'
  /**
   * The requested username does not exist.
   **/
  | 'NoUsername'
  /**
   * The username cannot be forcefully removed because it can still be accepted.
   **/
  | 'NotExpired';

export type PalletDemocracyReferendumInfo =
  | { type: 'Ongoing'; value: PalletDemocracyReferendumStatus }
  | { type: 'Finished'; value: { approved: boolean; end: number } };

export type PalletDemocracyReferendumStatus = {
  end: number;
  proposal: FrameSupportPreimagesBounded;
  threshold: PalletDemocracyVoteThreshold;
  delay: number;
  tally: PalletDemocracyTally;
};

export type PalletDemocracyTally = { ayes: bigint; nays: bigint; turnout: bigint };

export type PalletDemocracyVoteVoting =
  | {
      type: 'Direct';
      value: {
        votes: Array<[number, PalletDemocracyVoteAccountVote]>;
        delegations: PalletDemocracyDelegations;
        prior: PalletDemocracyVotePriorLock;
      };
    }
  | {
      type: 'Delegating';
      value: {
        balance: bigint;
        target: AccountId32;
        conviction: PalletDemocracyConviction;
        delegations: PalletDemocracyDelegations;
        prior: PalletDemocracyVotePriorLock;
      };
    };

export type PalletDemocracyDelegations = { votes: bigint; capital: bigint };

export type PalletDemocracyVotePriorLock = [number, bigint];

/**
 * The `Error` enum of this pallet.
 **/
export type PalletDemocracyError =
  /**
   * Value too low
   **/
  | 'ValueLow'
  /**
   * Proposal does not exist
   **/
  | 'ProposalMissing'
  /**
   * Cannot cancel the same proposal twice
   **/
  | 'AlreadyCanceled'
  /**
   * Proposal already made
   **/
  | 'DuplicateProposal'
  /**
   * Proposal still blacklisted
   **/
  | 'ProposalBlacklisted'
  /**
   * Next external proposal not simple majority
   **/
  | 'NotSimpleMajority'
  /**
   * Invalid hash
   **/
  | 'InvalidHash'
  /**
   * No external proposal
   **/
  | 'NoProposal'
  /**
   * Identity may not veto a proposal twice
   **/
  | 'AlreadyVetoed'
  /**
   * Vote given for invalid referendum
   **/
  | 'ReferendumInvalid'
  /**
   * No proposals waiting
   **/
  | 'NoneWaiting'
  /**
   * The given account did not vote on the referendum.
   **/
  | 'NotVoter'
  /**
   * The actor has no permission to conduct the action.
   **/
  | 'NoPermission'
  /**
   * The account is already delegating.
   **/
  | 'AlreadyDelegating'
  /**
   * Too high a balance was provided that the account cannot afford.
   **/
  | 'InsufficientFunds'
  /**
   * The account is not currently delegating.
   **/
  | 'NotDelegating'
  /**
   * The account currently has votes attached to it and the operation cannot succeed until
   * these are removed, either through `unvote` or `reap_vote`.
   **/
  | 'VotesExist'
  /**
   * The instant referendum origin is currently disallowed.
   **/
  | 'InstantNotAllowed'
  /**
   * Delegation to oneself makes no sense.
   **/
  | 'Nonsense'
  /**
   * Invalid upper bound.
   **/
  | 'WrongUpperBound'
  /**
   * Maximum number of votes reached.
   **/
  | 'MaxVotesReached'
  /**
   * Maximum number of items reached.
   **/
  | 'TooMany'
  /**
   * Voting period too low
   **/
  | 'VotingPeriodLow'
  /**
   * The preimage does not exist.
   **/
  | 'PreimageNotExist';

export type PalletElectionsPhragmenSeatHolder = { who: AccountId32; stake: bigint; deposit: bigint };

export type PalletElectionsPhragmenVoter = { votes: Array<AccountId32>; stake: bigint; deposit: bigint };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletElectionsPhragmenError =
  /**
   * Cannot vote when no candidates or members exist.
   **/
  | 'UnableToVote'
  /**
   * Must vote for at least one candidate.
   **/
  | 'NoVotes'
  /**
   * Cannot vote more than candidates.
   **/
  | 'TooManyVotes'
  /**
   * Cannot vote more than maximum allowed.
   **/
  | 'MaximumVotesExceeded'
  /**
   * Cannot vote with stake less than minimum balance.
   **/
  | 'LowBalance'
  /**
   * Voter can not pay voting bond.
   **/
  | 'UnableToPayBond'
  /**
   * Must be a voter.
   **/
  | 'MustBeVoter'
  /**
   * Duplicated candidate submission.
   **/
  | 'DuplicatedCandidate'
  /**
   * Too many candidates have been created.
   **/
  | 'TooManyCandidates'
  /**
   * Member cannot re-submit candidacy.
   **/
  | 'MemberSubmit'
  /**
   * Runner cannot re-submit candidacy.
   **/
  | 'RunnerUpSubmit'
  /**
   * Candidate does not have enough funds.
   **/
  | 'InsufficientCandidateFunds'
  /**
   * Not a member.
   **/
  | 'NotMember'
  /**
   * The provided count of number of candidates is incorrect.
   **/
  | 'InvalidWitnessData'
  /**
   * The provided count of number of votes is incorrect.
   **/
  | 'InvalidVoteCount'
  /**
   * The renouncing origin presented a wrong `Renouncing` parameter.
   **/
  | 'InvalidRenouncing'
  /**
   * Prediction regarding replacement after member removal is wrong.
   **/
  | 'InvalidReplacement';

export type PalletCollectiveVotes = {
  index: number;
  threshold: number;
  ayes: Array<AccountId32>;
  nays: Array<AccountId32>;
  end: number;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletCollectiveError =
  /**
   * Account is not a member
   **/
  | 'NotMember'
  /**
   * Duplicate proposals not allowed
   **/
  | 'DuplicateProposal'
  /**
   * Proposal must exist
   **/
  | 'ProposalMissing'
  /**
   * Mismatched index
   **/
  | 'WrongIndex'
  /**
   * Duplicate vote ignored
   **/
  | 'DuplicateVote'
  /**
   * Members are already initialized!
   **/
  | 'AlreadyInitialized'
  /**
   * The close call was made too early, before the end of the voting.
   **/
  | 'TooEarly'
  /**
   * There can only be a maximum of `MaxProposals` active proposals.
   **/
  | 'TooManyProposals'
  /**
   * The given weight bound for the proposal was too low.
   **/
  | 'WrongProposalWeight'
  /**
   * The given length bound for the proposal was too low.
   **/
  | 'WrongProposalLength'
  /**
   * Prime account is not a member
   **/
  | 'PrimeAccountNotMember';

export type PalletTipsOpenTip = {
  reason: H256;
  who: AccountId32;
  finder: AccountId32;
  deposit: bigint;
  closes?: number | undefined;
  tips: Array<[AccountId32, bigint]>;
  findersFee: boolean;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletTipsError =
  /**
   * The reason given is just too big.
   **/
  | 'ReasonTooBig'
  /**
   * The tip was already found/started.
   **/
  | 'AlreadyKnown'
  /**
   * The tip hash is unknown.
   **/
  | 'UnknownTip'
  /**
   * The tip given was too generous.
   **/
  | 'MaxTipAmountExceeded'
  /**
   * The account attempting to retract the tip is not the finder of the tip.
   **/
  | 'NotFinder'
  /**
   * The tip cannot be claimed/closed because there are not enough tippers yet.
   **/
  | 'StillOpen'
  /**
   * The tip cannot be claimed/closed because it's still in the countdown period.
   **/
  | 'Premature';

export type PalletProxyProxyDefinition = {
  delegate: AccountId32;
  proxyType: HydradxRuntimeSystemProxyType;
  delay: number;
};

export type PalletProxyAnnouncement = { real: AccountId32; callHash: H256; height: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletProxyError =
  /**
   * There are too many proxies registered or too many announcements pending.
   **/
  | 'TooMany'
  /**
   * Proxy registration not found.
   **/
  | 'NotFound'
  /**
   * Sender is not a proxy of the account to be proxied.
   **/
  | 'NotProxy'
  /**
   * A call which is incompatible with the proxy type's filter was attempted.
   **/
  | 'Unproxyable'
  /**
   * Account is already a proxy.
   **/
  | 'Duplicate'
  /**
   * Call may not be made by proxy because it may escalate its privileges.
   **/
  | 'NoPermission'
  /**
   * Announcement, if made at all, was made too recently.
   **/
  | 'Unannounced'
  /**
   * Cannot add self as proxy.
   **/
  | 'NoSelfProxy';

export type PalletMultisigMultisig = {
  when: PalletMultisigTimepoint;
  deposit: bigint;
  depositor: AccountId32;
  approvals: Array<AccountId32>;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletMultisigError =
  /**
   * Threshold must be 2 or greater.
   **/
  | 'MinimumThreshold'
  /**
   * Call is already approved by this signatory.
   **/
  | 'AlreadyApproved'
  /**
   * Call doesn't need any (more) approvals.
   **/
  | 'NoApprovalsNeeded'
  /**
   * There are too few signatories in the list.
   **/
  | 'TooFewSignatories'
  /**
   * There are too many signatories in the list.
   **/
  | 'TooManySignatories'
  /**
   * The signatories were provided out of order; they should be ordered.
   **/
  | 'SignatoriesOutOfOrder'
  /**
   * The sender was contained in the other signatories; it shouldn't be.
   **/
  | 'SenderInSignatories'
  /**
   * Multisig operation not found when attempting to cancel.
   **/
  | 'NotFound'
  /**
   * Only the account that originally created the multisig is able to cancel it.
   **/
  | 'NotOwner'
  /**
   * No timepoint was given, yet the multisig operation is already underway.
   **/
  | 'NoTimepoint'
  /**
   * A different timepoint was given to the multisig operation that is underway.
   **/
  | 'WrongTimepoint'
  /**
   * A timepoint was given, yet no multisig operation is underway.
   **/
  | 'UnexpectedTimepoint'
  /**
   * The maximum weight information provided was too low.
   **/
  | 'MaxWeightTooLow'
  /**
   * The data to be stored is already stored.
   **/
  | 'AlreadyStored';

export type PalletUniquesCollectionDetails = {
  owner: AccountId32;
  issuer: AccountId32;
  admin: AccountId32;
  freezer: AccountId32;
  totalDeposit: bigint;
  freeHolding: boolean;
  items: number;
  itemMetadatas: number;
  attributes: number;
  isFrozen: boolean;
};

export type PalletUniquesItemDetails = {
  owner: AccountId32;
  approved?: AccountId32 | undefined;
  isFrozen: boolean;
  deposit: bigint;
};

export type PalletUniquesCollectionMetadata = { deposit: bigint; data: Bytes; isFrozen: boolean };

export type PalletUniquesItemMetadata = { deposit: bigint; data: Bytes; isFrozen: boolean };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletUniquesError =
  /**
   * The signing account has no permission to do the operation.
   **/
  | 'NoPermission'
  /**
   * The given item ID is unknown.
   **/
  | 'UnknownCollection'
  /**
   * The item ID has already been used for an item.
   **/
  | 'AlreadyExists'
  /**
   * The owner turned out to be different to what was expected.
   **/
  | 'WrongOwner'
  /**
   * Invalid witness data given.
   **/
  | 'BadWitness'
  /**
   * The item ID is already taken.
   **/
  | 'InUse'
  /**
   * The item or collection is frozen.
   **/
  | 'Frozen'
  /**
   * The delegate turned out to be different to what was expected.
   **/
  | 'WrongDelegate'
  /**
   * There is no delegate approved.
   **/
  | 'NoDelegate'
  /**
   * No approval exists that would allow the transfer.
   **/
  | 'Unapproved'
  /**
   * The named owner has not signed ownership of the collection is acceptable.
   **/
  | 'Unaccepted'
  /**
   * The item is locked.
   **/
  | 'Locked'
  /**
   * All items have been minted.
   **/
  | 'MaxSupplyReached'
  /**
   * The max supply has already been set.
   **/
  | 'MaxSupplyAlreadySet'
  /**
   * The provided max supply is less to the amount of items a collection already has.
   **/
  | 'MaxSupplyTooSmall'
  /**
   * The given item ID is unknown.
   **/
  | 'UnknownItem'
  /**
   * Item is not for sale.
   **/
  | 'NotForSale'
  /**
   * The provided bid is too low.
   **/
  | 'BidTooLow';

export type PalletConvictionVotingVoteVoting =
  | { type: 'Casting'; value: PalletConvictionVotingVoteCasting }
  | { type: 'Delegating'; value: PalletConvictionVotingVoteDelegating };

export type PalletConvictionVotingVoteCasting = {
  votes: Array<[number, PalletConvictionVotingVoteAccountVote]>;
  delegations: PalletConvictionVotingDelegations;
  prior: PalletConvictionVotingVotePriorLock;
};

export type PalletConvictionVotingDelegations = { votes: bigint; capital: bigint };

export type PalletConvictionVotingVotePriorLock = [number, bigint];

export type PalletConvictionVotingVoteDelegating = {
  balance: bigint;
  target: AccountId32;
  conviction: PalletConvictionVotingConviction;
  delegations: PalletConvictionVotingDelegations;
  prior: PalletConvictionVotingVotePriorLock;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletConvictionVotingError =
  /**
   * Poll is not ongoing.
   **/
  | 'NotOngoing'
  /**
   * The given account did not vote on the poll.
   **/
  | 'NotVoter'
  /**
   * The actor has no permission to conduct the action.
   **/
  | 'NoPermission'
  /**
   * The actor has no permission to conduct the action right now but will do in the future.
   **/
  | 'NoPermissionYet'
  /**
   * The account is already delegating.
   **/
  | 'AlreadyDelegating'
  /**
   * The account currently has votes attached to it and the operation cannot succeed until
   * these are removed through `remove_vote`.
   **/
  | 'AlreadyVoting'
  /**
   * Too high a balance was provided that the account cannot afford.
   **/
  | 'InsufficientFunds'
  /**
   * The account is not currently delegating.
   **/
  | 'NotDelegating'
  /**
   * Delegation to oneself makes no sense.
   **/
  | 'Nonsense'
  /**
   * Maximum number of votes reached.
   **/
  | 'MaxVotesReached'
  /**
   * The class must be supplied since it is not easily determinable from the state.
   **/
  | 'ClassNeeded'
  /**
   * The class ID supplied is invalid.
   **/
  | 'BadClass';

export type PalletReferendaReferendumInfo =
  | { type: 'Ongoing'; value: PalletReferendaReferendumStatus }
  | { type: 'Approved'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { type: 'Rejected'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { type: 'Cancelled'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { type: 'TimedOut'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { type: 'Killed'; value: number };

export type PalletReferendaReferendumStatus = {
  track: number;
  origin: HydradxRuntimeOriginCaller;
  proposal: FrameSupportPreimagesBounded;
  enactment: FrameSupportScheduleDispatchTime;
  submitted: number;
  submissionDeposit: PalletReferendaDeposit;
  decisionDeposit?: PalletReferendaDeposit | undefined;
  deciding?: PalletReferendaDecidingStatus | undefined;
  tally: PalletConvictionVotingTally;
  inQueue: boolean;
  alarm?: [number, [number, number]] | undefined;
};

export type PalletReferendaDeposit = { who: AccountId32; amount: bigint };

export type PalletReferendaDecidingStatus = { since: number; confirming?: number | undefined };

export type PalletReferendaTrackInfo = {
  name: string;
  maxDeciding: number;
  decisionDeposit: bigint;
  preparePeriod: number;
  decisionPeriod: number;
  confirmPeriod: number;
  minEnactmentPeriod: number;
  minApproval: PalletReferendaCurve;
  minSupport: PalletReferendaCurve;
};

export type PalletReferendaCurve =
  | { type: 'LinearDecreasing'; value: { length: Perbill; floor: Perbill; ceil: Perbill } }
  | { type: 'SteppedDecreasing'; value: { begin: Perbill; end: Perbill; step: Perbill; period: Perbill } }
  | { type: 'Reciprocal'; value: { factor: FixedI64; xOffset: FixedI64; yOffset: FixedI64 } };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletReferendaError =
  /**
   * Referendum is not ongoing.
   **/
  | 'NotOngoing'
  /**
   * Referendum's decision deposit is already paid.
   **/
  | 'HasDeposit'
  /**
   * The track identifier given was invalid.
   **/
  | 'BadTrack'
  /**
   * There are already a full complement of referenda in progress for this track.
   **/
  | 'Full'
  /**
   * The queue of the track is empty.
   **/
  | 'QueueEmpty'
  /**
   * The referendum index provided is invalid in this context.
   **/
  | 'BadReferendum'
  /**
   * There was nothing to do in the advancement.
   **/
  | 'NothingToDo'
  /**
   * No track exists for the proposal origin.
   **/
  | 'NoTrack'
  /**
   * Any deposit cannot be refunded until after the decision is over.
   **/
  | 'Unfinished'
  /**
   * The deposit refunder is not the depositor.
   **/
  | 'NoPermission'
  /**
   * The deposit cannot be refunded since none was made.
   **/
  | 'NoDeposit'
  /**
   * The referendum status is invalid for this operation.
   **/
  | 'BadStatus'
  /**
   * The preimage does not exist.
   **/
  | 'PreimageNotExist'
  /**
   * The preimage is stored with a different length than the one provided.
   **/
  | 'PreimageStoredWithDifferentLength';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletWhitelistError =
  /**
   * The preimage of the call hash could not be loaded.
   **/
  | 'UnavailablePreImage'
  /**
   * The call could not be decoded.
   **/
  | 'UndecodableCall'
  /**
   * The weight of the decoded call was higher than the witness.
   **/
  | 'InvalidCallWeightWitness'
  /**
   * The call was not whitelisted.
   **/
  | 'CallIsNotWhitelisted'
  /**
   * The call was already whitelisted; No-Op.
   **/
  | 'CallAlreadyWhitelisted';

export type PalletAssetRegistryAssetDetails = {
  name?: Bytes | undefined;
  assetType: PalletAssetRegistryAssetType;
  existentialDeposit: bigint;
  symbol?: Bytes | undefined;
  decimals?: number | undefined;
  xcmRateLimit?: bigint | undefined;
  isSufficient: boolean;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletAssetRegistryError =
  /**
   * Asset ID is not available. This only happens when it reaches the MAX value of given id type.
   **/
  | 'NoIdAvailable'
  /**
   * Invalid asset name or symbol.
   **/
  | 'AssetNotFound'
  /**
   * Length of name or symbol is less than min. length.
   **/
  | 'TooShort'
  /**
   * Asset's symbol can't contain whitespace characters .
   **/
  | 'InvalidSymbol'
  /**
   * Asset ID is not registered in the asset-registry.
   **/
  | 'AssetNotRegistered'
  /**
   * Asset is already registered.
   **/
  | 'AssetAlreadyRegistered'
  /**
   * Incorrect number of assets provided to create shared asset.
   **/
  | 'InvalidSharedAssetLen'
  /**
   * Cannot update asset location.
   **/
  | 'CannotUpdateLocation'
  /**
   * Selected asset id is out of reserved range.
   **/
  | 'NotInReservedRange'
  /**
   * Location already registered with different asset.
   **/
  | 'LocationAlreadyRegistered'
  /**
   * Origin is forbidden to set/update value.
   **/
  | 'Forbidden'
  /**
   * Balance too low.
   **/
  | 'InsufficientBalance'
  /**
   * Sufficient assets can't be changed to insufficient.
   **/
  | 'ForbiddenSufficiencyChange'
  /**
   * Asset is already banned.
   **/
  | 'AssetAlreadyBanned'
  /**
   * Asset is not banned.
   **/
  | 'AssetNotBanned';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletClaimsError =
  /**
   * Ethereum signature is not valid
   **/
  | 'InvalidEthereumSignature'
  /**
   * Claim is not valid
   **/
  | 'NoClaimOrAlreadyClaimed'
  /**
   * Value reached maximum and cannot be incremented further
   **/
  | 'BalanceOverflow';

export type PalletGenesisHistoryChain = { genesisHash: H256; lastBlockHash: H256 };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletCollatorRewardsError = null;

export type PalletOmnipoolAssetState = {
  hubReserve: bigint;
  shares: bigint;
  protocolShares: bigint;
  cap: bigint;
  tradable: PalletOmnipoolTradability;
};

export type PalletOmnipoolPosition = { assetId: number; amount: bigint; shares: bigint; price: [bigint, bigint] };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletOmnipoolError =
  /**
   * Balance too low
   **/
  | 'InsufficientBalance'
  /**
   * Asset is already in omnipool
   **/
  | 'AssetAlreadyAdded'
  /**
   * Asset is not in omnipool
   **/
  | 'AssetNotFound'
  /**
   * Failed to add token to Omnipool due to insufficient initial liquidity.
   **/
  | 'MissingBalance'
  /**
   * Invalid initial asset price.
   **/
  | 'InvalidInitialAssetPrice'
  /**
   * Slippage protection - minimum limit has not been reached.
   **/
  | 'BuyLimitNotReached'
  /**
   * Slippage protection - maximum limit has been exceeded.
   **/
  | 'SellLimitExceeded'
  /**
   * Position has not been found.
   **/
  | 'PositionNotFound'
  /**
   * Insufficient shares in position
   **/
  | 'InsufficientShares'
  /**
   * Asset is not allowed to be traded.
   **/
  | 'NotAllowed'
  /**
   * Signed account is not owner of position instance.
   **/
  | 'Forbidden'
  /**
   * Asset weight cap has been exceeded.
   **/
  | 'AssetWeightCapExceeded'
  /**
   * Asset is not registered in asset registry
   **/
  | 'AssetNotRegistered'
  /**
   * Provided liquidity is below minimum allowed limit
   **/
  | 'InsufficientLiquidity'
  /**
   * Traded amount is below minimum allowed limit
   **/
  | 'InsufficientTradingAmount'
  /**
   * Sell or buy with same asset ids is not allowed.
   **/
  | 'SameAssetTradeNotAllowed'
  /**
   * LRNA update after trade results in positive value.
   **/
  | 'HubAssetUpdateError'
  /**
   * Amount of shares provided cannot be 0.
   **/
  | 'InvalidSharesAmount'
  /**
   * Hub asset is only allowed to be sold.
   **/
  | 'InvalidHubAssetTradableState'
  /**
   * Asset is not allowed to be refunded.
   **/
  | 'AssetRefundNotAllowed'
  /**
   * Max fraction of asset to buy has been exceeded.
   **/
  | 'MaxOutRatioExceeded'
  /**
   * Max fraction of asset to sell has been exceeded.
   **/
  | 'MaxInRatioExceeded'
  /**
   * Max allowed price difference has been exceeded.
   **/
  | 'PriceDifferenceTooHigh'
  /**
   * Invalid oracle price - division by zero.
   **/
  | 'InvalidOraclePrice'
  /**
   * Failed to calculate withdrawal fee.
   **/
  | 'InvalidWithdrawalFee'
  /**
   * More than allowed amount of fee has been transferred.
   **/
  | 'FeeOverdraft'
  /**
   * Token cannot be removed from Omnipool due to shares still owned by other users.
   **/
  | 'SharesRemaining'
  /**
   * Token cannot be removed from Omnipool because asset is not frozen.
   **/
  | 'AssetNotFrozen'
  /**
   * Calculated amount out from sell trade is zero.
   **/
  | 'ZeroAmountOut'
  /**
   * Existential deposit of asset is not available.
   **/
  | 'ExistentialDepositNotAvailable'
  /**
   * Slippage protection
   **/
  | 'SlippageLimit'
  /**
   * Extra protocol fee has not been consumed.
   **/
  | 'ProtocolFeeNotConsumed';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletTransactionPauseError =
  /**
   * can not pause
   **/
  | 'CannotPause'
  /**
   * invalid character encoding
   **/
  | 'InvalidCharacter'
  /**
   * pallet name or function name is too long
   **/
  | 'NameTooLong';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletDusterError =
  /**
   * Account is excluded from dusting.
   **/
  | 'AccountBlacklisted'
  /**
   * Account is not present in the non-dustable list.
   **/
  | 'AccountNotBlacklisted'
  /**
   * The balance is zero.
   **/
  | 'ZeroBalance'
  /**
   * The balance is sufficient to keep account open.
   **/
  | 'BalanceSufficient'
  /**
   * Dust account is not set.
   **/
  | 'DustAccountNotSet'
  /**
   * Reserve account is not set.
   **/
  | 'ReserveAccountNotSet';

export type PalletLiquidityMiningGlobalFarmData = {
  id: number;
  owner: AccountId32;
  updatedAt: number;
  totalSharesZ: bigint;
  accumulatedRpz: FixedU128;
  rewardCurrency: number;
  pendingRewards: bigint;
  accumulatedPaidRewards: bigint;
  yieldPerPeriod: Perquintill;
  plannedYieldingPeriods: number;
  blocksPerPeriod: number;
  incentivizedAsset: number;
  maxRewardPerPeriod: bigint;
  minDeposit: bigint;
  liveYieldFarmsCount: number;
  totalYieldFarmsCount: number;
  priceAdjustment: FixedU128;
  state: PalletLiquidityMiningFarmState;
};

export type PalletLiquidityMiningFarmState = 'Active' | 'Stopped' | 'Terminated';

export type PalletLiquidityMiningYieldFarmData = {
  id: number;
  updatedAt: number;
  totalShares: bigint;
  totalValuedShares: bigint;
  accumulatedRpvs: FixedU128;
  accumulatedRpz: FixedU128;
  loyaltyCurve?: PalletLiquidityMiningLoyaltyCurve | undefined;
  multiplier: FixedU128;
  state: PalletLiquidityMiningFarmState;
  entriesCount: bigint;
  leftToDistribute: bigint;
  totalStopped: number;
};

export type PalletLiquidityMiningDepositData = {
  shares: bigint;
  ammPoolId: number;
  yieldFarmEntries: Array<PalletLiquidityMiningYieldFarmEntry>;
};

export type PalletLiquidityMiningYieldFarmEntry = {
  globalFarmId: number;
  yieldFarmId: number;
  valuedShares: bigint;
  accumulatedRpvs: FixedU128;
  accumulatedClaimedRewards: bigint;
  enteredAt: number;
  updatedAt: number;
  stoppedAtCreation: number;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletLiquidityMiningError =
  /**
   * Global farm does not exist.
   **/
  | { name: 'GlobalFarmNotFound' }
  /**
   * Yield farm does not exist.
   **/
  | { name: 'YieldFarmNotFound' }
  /**
   * Multiple claims in the same period is not allowed.
   **/
  | { name: 'DoubleClaimInPeriod' }
  /**
   * Liquidity mining is canceled.
   **/
  | { name: 'LiquidityMiningCanceled' }
  /**
   * Liquidity mining is not canceled.
   **/
  | { name: 'LiquidityMiningIsActive' }
  /**
   * Liquidity mining is in `active` or `terminated` state and action cannot be completed.
   **/
  | { name: 'LiquidityMiningIsNotStopped' }
  /**
   * Account is not allowed to perform action.
   **/
  | { name: 'Forbidden' }
  /**
   * Yield farm multiplier can't be 0.
   **/
  | { name: 'InvalidMultiplier' }
  /**
   * Yield farm with given `amm_pool_id` already exists in global farm.
   **/
  | { name: 'YieldFarmAlreadyExists' }
  /**
   * Loyalty curve's initial reward percentage is not valid. Valid range is: [0, 1).
   **/
  | { name: 'InvalidInitialRewardPercentage' }
  /**
   * One or more yield farms exist in global farm.
   **/
  | { name: 'GlobalFarmIsNotEmpty' }
  /**
   * Farm's `incentivized_asset` is missing in provided asset pair.
   **/
  | { name: 'MissingIncentivizedAsset' }
  /**
   * Reward currency balance is not sufficient.
   **/
  | { name: 'InsufficientRewardCurrencyBalance' }
  /**
   * Blocks per period can't be 0.
   **/
  | { name: 'InvalidBlocksPerPeriod' }
  /**
   * Yield per period can't be 0.
   **/
  | { name: 'InvalidYieldPerPeriod' }
  /**
   * Total rewards is less than `MinTotalFarmRewards`.
   **/
  | { name: 'InvalidTotalRewards' }
  /**
   * Planned yielding periods is less than `MinPlannedYieldingPeriods`.
   **/
  | { name: 'InvalidPlannedYieldingPeriods' }
  /**
   * Maximum number of locks reached for deposit.
   **/
  | { name: 'MaxEntriesPerDeposit' }
  /**
   * Trying to lock LP shares into already locked yield farm.
   **/
  | { name: 'DoubleLock' }
  /**
   * Yield farm entry doesn't exist for given deposit.
   **/
  | { name: 'YieldFarmEntryNotFound' }
  /**
   * Max number of yield farms in global farm was reached. Global farm can't accept new
   * yield farms until some yield farm is not removed from storage.
   **/
  | { name: 'GlobalFarmIsFull' }
  /**
   * Invalid min. deposit was set for global farm.
   **/
  | { name: 'InvalidMinDeposit' }
  /**
   * Price adjustment multiplier can't be 0.
   **/
  | { name: 'InvalidPriceAdjustment' }
  /**
   * Account creation from id failed.
   **/
  | { name: 'ErrorGetAccountId' }
  /**
   * Value of deposited shares amount in reward currency is bellow min. limit.
   **/
  | { name: 'IncorrectValuedShares' }
  /**
   * `reward_currency` is not registered in asset registry.
   **/
  | { name: 'RewardCurrencyNotRegistered' }
  /**
   * `incentivized_asset` is not registered in asset registry.
   **/
  | { name: 'IncentivizedAssetNotRegistered' }
  /**
   * Action cannot be completed because unexpected error has occurred. This should be reported
   * to protocol maintainers.
   **/
  | { name: 'InconsistentState'; data: PalletLiquidityMiningInconsistentStateError };

export type PalletLiquidityMiningInconsistentStateError =
  | 'YieldFarmNotFound'
  | 'GlobalFarmNotFound'
  | 'LiquidityIsNotActive'
  | 'GlobalFarmIsNotActive'
  | 'DepositNotFound'
  | 'InvalidPeriod'
  | 'NotEnoughRewardsInYieldFarm'
  | 'InvalidLiveYielFarmsCount'
  | 'InvalidTotalYieldFarmsCount'
  | 'InvalidYieldFarmEntriesCount'
  | 'InvalidTotalShares'
  | 'InvalidValuedShares'
  | 'InvalidTotalSharesZ'
  | 'InvalidPaidAccumulatedRewards'
  | 'InvalidFarmId'
  | 'InvalidLoyaltyMultiplier'
  | 'NoExistentialDepositForAsset';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletOmnipoolLiquidityMiningError =
  /**
   * Asset is not in the omnipool.
   **/
  | { name: 'AssetNotFound' }
  /**
   * Signed account is not owner of the deposit.
   **/
  | { name: 'Forbidden' }
  /**
   * Rewards to claim are 0.
   **/
  | { name: 'ZeroClaimedRewards' }
  /**
   * Action cannot be completed because unexpected error has occurred. This should be reported
   * to protocol maintainers.
   **/
  | { name: 'InconsistentState'; data: PalletOmnipoolLiquidityMiningInconsistentStateError }
  /**
   * Oracle could not be found for requested assets.
   **/
  | { name: 'OracleNotAvailable' }
  /**
   * Oracle providing `price_adjustment` could not be found for requested assets.
   **/
  | { name: 'PriceAdjustmentNotAvailable' }
  /**
   * No farms specified to join
   **/
  | { name: 'NoFarmEntriesSpecified' };

export type PalletOmnipoolLiquidityMiningInconsistentStateError = 'MissingLpPosition' | 'DepositDataNotFound';

export type PalletOtcOrder = {
  owner: AccountId32;
  assetIn: number;
  assetOut: number;
  amountIn: bigint;
  amountOut: bigint;
  partiallyFillable: boolean;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletOtcError =
  /**
   * Asset does not exist in registry
   **/
  | 'AssetNotRegistered'
  /**
   * Order cannot be found
   **/
  | 'OrderNotFound'
  /**
   * Size of order ID exceeds the bound
   **/
  | 'OrderIdOutOfBound'
  /**
   * Cannot partially fill an order which is not partially fillable
   **/
  | 'OrderNotPartiallyFillable'
  /**
   * Order amount_in and amount_out must at all times be greater than the existential deposit
   * for the asset multiplied by the ExistentialDepositMultiplier.
   * A fill order may not leave behind amounts smaller than this.
   **/
  | 'OrderAmountTooSmall'
  /**
   * Error with math calculations
   **/
  | 'MathError'
  /**
   * The caller does not have permission to complete the action
   **/
  | 'Forbidden'
  /**
   * Reserved amount not sufficient.
   **/
  | 'InsufficientReservedAmount';

export type PalletCircuitBreakerTradeVolumeLimit = { volumeIn: bigint; volumeOut: bigint; limit: bigint };

export type PalletCircuitBreakerLiquidityLimit = { liquidity: bigint; limit: bigint };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletCircuitBreakerError =
  /**
   * Invalid value for a limit. Limit must be non-zero.
   **/
  | 'InvalidLimitValue'
  /**
   * Allowed liquidity limit is not stored for asset
   **/
  | 'LiquidityLimitNotStoredForAsset'
  /**
   * Token trade outflow per block has been reached
   **/
  | 'TokenOutflowLimitReached'
  /**
   * Token trade influx per block has been reached
   **/
  | 'TokenInfluxLimitReached'
  /**
   * Maximum pool's liquidity limit per block has been reached
   **/
  | 'MaxLiquidityLimitPerBlockReached'
  /**
   * Asset is not allowed to have a limit
   **/
  | 'NotAllowed';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletRouteExecutorError =
  /**
   * The trading limit has been reached
   **/
  | 'TradingLimitReached'
  /**
   * The the max number of trades limit is reached
   **/
  | 'MaxTradesExceeded'
  /**
   * The AMM pool is not supported for executing trades
   **/
  | 'PoolNotSupported'
  /**
   * The user has not enough balance to execute the trade
   **/
  | 'InsufficientBalance'
  /**
   * The calculation of route trade amounts failed in the underlying AMM
   **/
  | 'RouteCalculationFailed'
  /**
   * The route is invalid
   **/
  | 'InvalidRoute'
  /**
   * The route update was not successful
   **/
  | 'RouteUpdateIsNotSuccessful'
  /**
   * Route contains assets that has no oracle data
   **/
  | 'RouteHasNoOracle'
  /**
   * The route execution failed in the underlying AMM
   **/
  | 'InvalidRouteExecution'
  /**
   * Trading same assets is not allowed.
   **/
  | 'NotAllowed';

export type PalletDynamicFeesFeeEntry = { assetFee: Permill; protocolFee: Permill; timestamp: number };

export type PalletDynamicFeesFeeParams = {
  minFee: Permill;
  maxFee: Permill;
  decay: FixedU128;
  amplification: FixedU128;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletDynamicFeesError = null;

export type PalletStakingStakingData = {
  totalStake: bigint;
  accumulatedRewardPerStake: FixedU128;
  potReservedBalance: bigint;
};

export type PalletStakingPosition = {
  stake: bigint;
  actionPoints: bigint;
  rewardPerStake: FixedU128;
  createdAt: number;
  accumulatedSlashPoints: bigint;
  accumulatedUnpaidRewards: bigint;
  accumulatedLockedRewards: bigint;
};

export type PalletStakingVoting = { votes: Array<[number, PalletStakingVote]> };

export type PalletStakingVote = { amount: bigint; conviction: PalletStakingConviction };

export type PalletStakingConviction =
  | 'None'
  | 'Locked1x'
  | 'Locked2x'
  | 'Locked3x'
  | 'Locked4x'
  | 'Locked5x'
  | 'Locked6x';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletStakingError =
  /**
   * Balance is too low.
   **/
  | { name: 'InsufficientBalance' }
  /**
   * Staked amount is too low.
   **/
  | { name: 'InsufficientStake' }
  /**
   * Staking position has not been found.
   **/
  | { name: 'PositionNotFound' }
  /**
   * Maximum amount of votes were reached for staking position.
   **/
  | { name: 'MaxVotesReached' }
  /**
   * Staking is not initialized.
   **/
  | { name: 'NotInitialized' }
  /**
   * Staking is already initialized.
   **/
  | { name: 'AlreadyInitialized' }
  /**
   * Arithmetic error.
   **/
  | { name: 'Arithmetic' }
  /**
   * Pot's balance is zero.
   **/
  | { name: 'MissingPotBalance' }
  /**
   * Account's position already exists.
   **/
  | { name: 'PositionAlreadyExists' }
  /**
   * Signer is not an owner of the staking position.
   **/
  | { name: 'Forbidden' }
  /**
   * Position contains registered votes.
   **/
  | { name: 'ExistingVotes' }
  /**
   * Position contains processed votes. Removed these votes first before increasing stake or claiming.
   **/
  | { name: 'ExistingProcessedVotes' }
  /**
   * Action cannot be completed because unexpected error has occurred. This should be reported
   * to protocol maintainers.
   **/
  | { name: 'InconsistentState'; data: PalletStakingInconsistentStateError };

export type PalletStakingInconsistentStateError =
  | 'PositionNotFound'
  | 'NegativePendingRewards'
  | 'NegativeUnpaidRewards'
  | 'TooManyPositions'
  | 'Arithmetic';

export type PalletStableswapPoolInfo = {
  assets: Array<number>;
  initialAmplification: NonZeroU16;
  finalAmplification: NonZeroU16;
  initialBlock: number;
  finalBlock: number;
  fee: Permill;
};

export type PalletStableswapPoolSnapshot = {
  assets: Array<number>;
  reserves: Array<HydraDxMathStableswapTypesAssetReserve>;
  amplification: bigint;
  fee: Permill;
  pegs: Array<[bigint, bigint]>;
  shareIssuance: bigint;
};

export type HydraDxMathStableswapTypesAssetReserve = { amount: bigint; decimals: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletStableswapError =
  /**
   * Creating a pool with same assets or less than 2 assets is not allowed.
   **/
  | 'IncorrectAssets'
  /**
   * Maximum number of assets has been exceeded.
   **/
  | 'MaxAssetsExceeded'
  /**
   * A pool with given assets does not exist.
   **/
  | 'PoolNotFound'
  /**
   * A pool with given assets already exists.
   **/
  | 'PoolExists'
  /**
   * Asset is not in the pool.
   **/
  | 'AssetNotInPool'
  /**
   * Share asset is not registered in Registry.
   **/
  | 'ShareAssetNotRegistered'
  /**
   * Share asset is amount assets when creating a pool.
   **/
  | 'ShareAssetInPoolAssets'
  /**
   * One or more assets are not registered in AssetRegistry
   **/
  | 'AssetNotRegistered'
  /**
   * Invalid asset amount provided. Amount must be greater than zero.
   **/
  | 'InvalidAssetAmount'
  /**
   * Balance of an asset is not sufficient to perform a trade.
   **/
  | 'InsufficientBalance'
  /**
   * Balance of a share asset is not sufficient to withdraw liquidity.
   **/
  | 'InsufficientShares'
  /**
   * Liquidity has not reached the required minimum.
   **/
  | 'InsufficientLiquidity'
  /**
   * Insufficient liquidity left in the pool after withdrawal.
   **/
  | 'InsufficientLiquidityRemaining'
  /**
   * Amount is less than the minimum trading amount configured.
   **/
  | 'InsufficientTradingAmount'
  /**
   * Minimum limit has not been reached during trade.
   **/
  | 'BuyLimitNotReached'
  /**
   * Maximum limit has been exceeded during trade.
   **/
  | 'SellLimitExceeded'
  /**
   * Initial liquidity of asset must be > 0.
   **/
  | 'InvalidInitialLiquidity'
  /**
   * Amplification is outside configured range.
   **/
  | 'InvalidAmplification'
  /**
   * Remaining balance of share asset is below asset's existential deposit.
   **/
  | 'InsufficientShareBalance'
  /**
   * Not allowed to perform an operation on given asset.
   **/
  | 'NotAllowed'
  /**
   * Future block number is in the past.
   **/
  | 'PastBlock'
  /**
   * New amplification is equal to the previous value.
   **/
  | 'SameAmplification'
  /**
   * Slippage protection.
   **/
  | 'SlippageLimit'
  /**
   * Failed to retrieve asset decimals.
   **/
  | 'UnknownDecimals'
  /**
   * List of provided pegs is incorrect.
   **/
  | 'IncorrectInitialPegs'
  /**
   * Failed to retrieve oracle entry.
   **/
  | 'MissingTargetPegOracle'
  /**
   * Creating pool with pegs is not allowed for asset with different decimals.
   **/
  | 'IncorrectAssetDecimals'
  /**
   * Pool does not have pegs configured.
   **/
  | 'NoPegSource';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBondsError =
  /**
   * Bond not registered
   **/
  | 'NotRegistered'
  /**
   * Bond is not mature
   **/
  | 'NotMature'
  /**
   * Maturity not long enough
   **/
  | 'InvalidMaturity'
  /**
   * Asset type not allowed for underlying asset
   **/
  | 'DisallowedAsset'
  /**
   * Asset is not registered in `AssetRegistry`
   **/
  | 'AssetNotFound'
  /**
   * Generated name is not valid.
   **/
  | 'InvalidBondName'
  /**
   * Bond's name parsing was now successful
   **/
  | 'FailToParseName';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletOtcSettlementsError =
  /**
   * Otc order not found
   **/
  | 'OrderNotFound'
  /**
   * OTC order is not partially fillable
   **/
  | 'NotPartiallyFillable'
  /**
   * Provided route doesn't match the existing route
   **/
  | 'InvalidRoute'
  /**
   * Initial and final balance are different
   **/
  | 'BalanceInconsistency'
  /**
   * Trade amount higher than necessary
   **/
  | 'TradeAmountTooHigh'
  /**
   * Trade amount lower than necessary
   **/
  | 'TradeAmountTooLow'
  /**
   * Price for a route is not available
   **/
  | 'PriceNotAvailable';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletLbpError =
  /**
   * Pool assets can not be the same
   **/
  | 'CannotCreatePoolWithSameAssets'
  /**
   * Account is not a pool owner
   **/
  | 'NotOwner'
  /**
   * Sale already started
   **/
  | 'SaleStarted'
  /**
   * Sale is still in progress
   **/
  | 'SaleNotEnded'
  /**
   * Sale is not running
   **/
  | 'SaleIsNotRunning'
  /**
   * Sale duration is too long
   **/
  | 'MaxSaleDurationExceeded'
  /**
   * Liquidity being added should not be zero
   **/
  | 'CannotAddZeroLiquidity'
  /**
   * Asset balance too low
   **/
  | 'InsufficientAssetBalance'
  /**
   * Pool does not exist
   **/
  | 'PoolNotFound'
  /**
   * Pool has been already created
   **/
  | 'PoolAlreadyExists'
  /**
   * Invalid block range
   **/
  | 'InvalidBlockRange'
  /**
   * Calculation error
   **/
  | 'WeightCalculationError'
  /**
   * Weight set is out of range
   **/
  | 'InvalidWeight'
  /**
   * Can not perform a trade with zero amount
   **/
  | 'ZeroAmount'
  /**
   * Trade amount is too high
   **/
  | 'MaxInRatioExceeded'
  /**
   * Trade amount is too high
   **/
  | 'MaxOutRatioExceeded'
  /**
   * Invalid fee amount
   **/
  | 'FeeAmountInvalid'
  /**
   * Trading limit reached
   **/
  | 'TradingLimitReached'
  /**
   * An unexpected integer overflow occurred
   **/
  | 'Overflow'
  /**
   * Nothing to update
   **/
  | 'NothingToUpdate'
  /**
   * Liquidity has not reached the required minimum.
   **/
  | 'InsufficientLiquidity'
  /**
   * Amount is less than minimum trading limit.
   **/
  | 'InsufficientTradingAmount'
  /**
   * Not more than one fee collector per asset id
   **/
  | 'FeeCollectorWithAssetAlreadyUsed';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletXykError =
  /**
   * It is not allowed to create a pool between same assets.
   **/
  | 'CannotCreatePoolWithSameAssets'
  /**
   * Liquidity has not reached the required minimum.
   **/
  | 'InsufficientLiquidity'
  /**
   * Amount is less than min trading limit.
   **/
  | 'InsufficientTradingAmount'
  /**
   * Liquidity is zero.
   **/
  | 'ZeroLiquidity'
  /**
   * It is not allowed to create a pool with zero initial price.
   * Not used, kept for backward compatibility
   **/
  | 'ZeroInitialPrice'
  /**
   * Overflow
   * Not used, kept for backward compatibility
   **/
  | 'CreatePoolAssetAmountInvalid'
  /**
   * Overflow
   **/
  | 'InvalidMintedLiquidity'
  /**
   * Overflow
   **/
  | 'InvalidLiquidityAmount'
  /**
   * Asset amount has exceeded given limit.
   **/
  | 'AssetAmountExceededLimit'
  /**
   * Asset amount has not reached given limit.
   **/
  | 'AssetAmountNotReachedLimit'
  /**
   * Asset balance is not sufficient.
   **/
  | 'InsufficientAssetBalance'
  /**
   * Not enough asset liquidity in the pool.
   **/
  | 'InsufficientPoolAssetBalance'
  /**
   * Not enough core asset liquidity in the pool.
   **/
  | 'InsufficientNativeCurrencyBalance'
  /**
   * Liquidity pool for given assets does not exist.
   **/
  | 'TokenPoolNotFound'
  /**
   * Liquidity pool for given assets already exists.
   **/
  | 'TokenPoolAlreadyExists'
  /**
   * Overflow
   **/
  | 'AddAssetAmountInvalid'
  /**
   * Overflow
   **/
  | 'RemoveAssetAmountInvalid'
  /**
   * Overflow
   **/
  | 'SellAssetAmountInvalid'
  /**
   * Overflow
   **/
  | 'BuyAssetAmountInvalid'
  /**
   * Overflow
   **/
  | 'FeeAmountInvalid'
  /**
   * Overflow
   **/
  | 'CannotApplyDiscount'
  /**
   * Max fraction of pool to buy in single transaction has been exceeded.
   **/
  | 'MaxOutRatioExceeded'
  /**
   * Max fraction of pool to sell in single transaction has been exceeded.
   **/
  | 'MaxInRatioExceeded'
  /**
   * Overflow
   **/
  | 'Overflow'
  /**
   * Pool cannot be created due to outside factors.
   **/
  | 'CannotCreatePool'
  /**
   * Slippage protection.
   **/
  | 'SlippageLimit';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletReferralsError =
  /**
   * Referral code is too long.
   **/
  | 'TooLong'
  /**
   * Referral code is too short.
   **/
  | 'TooShort'
  /**
   * Referral code contains invalid character. Only alphanumeric characters are allowed.
   **/
  | 'InvalidCharacter'
  /**
   * Referral code already exists.
   **/
  | 'AlreadyExists'
  /**
   * Provided referral code is invalid. Either does not exist or is too long.
   **/
  | 'InvalidCode'
  /**
   * Account is already linked to another referral account.
   **/
  | 'AlreadyLinked'
  /**
   * Nothing in the referral pot account for the asset.
   **/
  | 'ZeroAmount'
  /**
   * Linking an account to the same referral account is not allowed.
   **/
  | 'LinkNotAllowed'
  /**
   * Calculated rewards are more than the fee amount. This can happen if percentages are incorrectly set.
   **/
  | 'IncorrectRewardCalculation'
  /**
   * Given referrer and trader percentages exceeds 100% percent.
   **/
  | 'IncorrectRewardPercentage'
  /**
   * The account has already a code registered.
   **/
  | 'AlreadyRegistered'
  /**
   * Price for given asset pair not found.
   **/
  | 'PriceNotFound'
  /**
   * Minimum trading amount for conversion has not been reached.
   **/
  | 'ConversionMinTradingAmountNotReached'
  /**
   * Zero amount received from conversion.
   **/
  | 'ConversionZeroAmountReceived';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletLiquidationError =
  /**
   * AssetId to EVM address conversion failed
   **/
  | 'AssetConversionFailed'
  /**
   * Liquidation call failed
   **/
  | 'LiquidationCallFailed'
  /**
   * Provided route doesn't match the existing route
   **/
  | 'InvalidRoute'
  /**
   * Liquidation was not profitable enough to repay flash loan
   **/
  | 'NotProfitable'
  /**
   * Flash minter contract address not set. It is required for Hollar liquidations.
   **/
  | 'FlashMinterNotSet'
  /**
   * Invalid liquidation data provided
   **/
  | 'InvalidLiquidationData';

export type PalletHsmCollateralInfo = {
  poolId: number;
  purchaseFee: Permill;
  maxBuyPriceCoefficient: FixedU128;
  buybackRate: Perbill;
  buyBackFee: Permill;
  maxInHolding?: bigint | undefined;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletHsmError =
  /**
   * Asset is not approved as collateral
   *
   * The operation attempted to use an asset that is not registered as an approved collateral.
   **/
  | 'AssetNotApproved'
  /**
   * Asset is already approved as collateral
   *
   * Attempted to add an asset that is already registered as a collateral.
   **/
  | 'AssetAlreadyApproved'
  /**
   * Another asset from the same pool is already approved
   *
   * Only one asset from each StableSwap pool can be used as collateral.
   **/
  | 'PoolAlreadyHasCollateral'
  /**
   * Invalid asset pair, must be Hollar and approved collateral
   *
   * The asset pair for buy/sell operations must include Hollar as one side and an approved collateral as the other.
   **/
  | 'InvalidAssetPair'
  /**
   * Max buy price exceeded
   *
   * The calculated buy price exceeds the maximum allowed buy price for the collateral.
   **/
  | 'MaxBuyPriceExceeded'
  /**
   * Max buy back amount in single block exceeded
   *
   * The amount of Hollar being sold to HSM exceeds the maximum allowed in a single block for this collateral.
   **/
  | 'MaxBuyBackExceeded'
  /**
   * Max holding amount for collateral exceeded
   *
   * The operation would cause the HSM to hold more of the collateral than the configured maximum.
   **/
  | 'MaxHoldingExceeded'
  /**
   * Slippage limit exceeded
   *
   * The calculated amount is worse than the provided slippage limit.
   **/
  | 'SlippageLimitExceeded'
  /**
   * Invalid EVM contract interaction
   *
   * The call to the EVM contract (GHO Hollar token) failed.
   **/
  | 'InvalidEVMInteraction'
  /**
   * Decimal retrieval failed
   *
   * Failed to retrieve the decimal information for an asset.
   **/
  | 'DecimalRetrievalFailed'
  /**
   * No arbitrage opportunity
   *
   * There is no profitable arbitrage opportunity for the specified collateral.
   **/
  | 'NoArbitrageOpportunity'
  /**
   * Offchain lock error
   *
   * Failed to acquire the lock for offchain workers, likely because another operation is in progress.
   **/
  | 'OffchainLockError'
  /**
   * Asset not in the pool
   *
   * The specified asset was not found in the pool.
   **/
  | 'AssetNotFound'
  /**
   * Provided pool state is invalid
   *
   * The retrieved pool state has inconsistent or invalid data.
   **/
  | 'InvalidPoolState'
  /**
   * Collateral is not empty
   *
   * Cannot remove a collateral asset that still has a non-zero balance in the HSM account.
   **/
  | 'CollateralNotEmpty'
  /**
   * Asset not in the pool
   *
   * The collateral asset is not present in the specified pool.
   **/
  | 'AssetNotInPool'
  /**
   * Hollar is not in the pool
   *
   * The Hollar asset is not present in the specified pool.
   **/
  | 'HollarNotInPool'
  /**
   * Insufficient collateral balance
   *
   * The HSM does not have enough of the collateral asset to complete the operation.
   **/
  | 'InsufficientCollateralBalance'
  /**
   * GHO Contract address not found
   *
   * The EVM address for the GHO (Hollar) token contract was not found.
   **/
  | 'HollarContractAddressNotFound'
  /**
   * HSM contains maximum number of allowed collateral assets.
   **/
  | 'MaxNumberOfCollateralsReached'
  /**
   * Flash minter address not set
   **/
  | 'FlashMinterNotSet'
  /**
   * Provided arbitrage data is invalid
   **/
  | 'InvalidArbitrageData';

export type OrmlTokensBalanceLock = { id: FixedBytes<8>; amount: bigint };

export type OrmlTokensAccountData = { free: bigint; reserved: bigint; frozen: bigint };

export type OrmlTokensReserveData = { id: FixedBytes<8>; amount: bigint };

/**
 * The `Error` enum of this pallet.
 **/
export type OrmlTokensModuleError =
  /**
   * The balance is too low
   **/
  | 'BalanceTooLow'
  /**
   * Cannot convert Amount into Balance type
   **/
  | 'AmountIntoBalanceFailed'
  /**
   * Failed because liquidity restrictions due to locking
   **/
  | 'LiquidityRestrictions'
  /**
   * Failed because the maximum locks was exceeded
   **/
  | 'MaxLocksExceeded'
  /**
   * Transfer/payment would kill account
   **/
  | 'KeepAlive'
  /**
   * Value too low to create account due to existential deposit
   **/
  | 'ExistentialDeposit'
  /**
   * Beneficiary account must pre-exist
   **/
  | 'DeadAccount'
  | 'TooManyReserves';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletCurrenciesModuleError =
  /**
   * Unable to convert the Amount type into Balance.
   **/
  | 'AmountIntoBalanceFailed'
  /**
   * Balance is too low.
   **/
  | 'BalanceTooLow'
  /**
   * Deposit result is not expected
   **/
  | 'DepositFailed'
  /**
   * Operation is not supported for this currency
   **/
  | 'NotSupported';

/**
 * The `Error` enum of this pallet.
 **/
export type OrmlVestingModuleError =
  /**
   * Vesting period is zero
   **/
  | 'ZeroVestingPeriod'
  /**
   * Number of vests is zero
   **/
  | 'ZeroVestingPeriodCount'
  /**
   * Insufficient amount of balance to lock
   **/
  | 'InsufficientBalanceToLock'
  /**
   * This account have too many vesting schedules
   **/
  | 'TooManyVestingSchedules'
  /**
   * The vested transfer amount is too low
   **/
  | 'AmountLow'
  /**
   * Failed because the maximum vesting schedules was exceeded
   **/
  | 'MaxVestingSchedulesExceeded';

export type PalletEvmCodeMetadata = { size: bigint; hash: H256 };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletEvmError =
  /**
   * Not enough balance to perform action
   **/
  | 'BalanceLow'
  /**
   * Calculating total fee overflowed
   **/
  | 'FeeOverflow'
  /**
   * Calculating total payment overflowed
   **/
  | 'PaymentOverflow'
  /**
   * Withdraw fee failed
   **/
  | 'WithdrawFailed'
  /**
   * Gas price is too low.
   **/
  | 'GasPriceTooLow'
  /**
   * Nonce is invalid
   **/
  | 'InvalidNonce'
  /**
   * Gas limit is too low.
   **/
  | 'GasLimitTooLow'
  /**
   * Gas limit is too high.
   **/
  | 'GasLimitTooHigh'
  /**
   * The chain id is invalid.
   **/
  | 'InvalidChainId'
  /**
   * the signature is invalid.
   **/
  | 'InvalidSignature'
  /**
   * EVM reentrancy
   **/
  | 'Reentrancy'
  /**
   * EIP-3607,
   **/
  | 'TransactionMustComeFromEOA'
  /**
   * Undefined error.
   **/
  | 'Undefined';

export type FpRpcTransactionStatus = {
  transactionHash: H256;
  transactionIndex: number;
  from: H160;
  to?: H160 | undefined;
  contractAddress?: H160 | undefined;
  logs: Array<EthereumLog>;
  logsBloom: EthbloomBloom;
};

export type EthbloomBloom = FixedBytes<256>;

export type EthereumReceiptReceiptV3 =
  | { type: 'Legacy'; value: EthereumReceiptEip658ReceiptData }
  | { type: 'Eip2930'; value: EthereumReceiptEip658ReceiptData }
  | { type: 'Eip1559'; value: EthereumReceiptEip658ReceiptData };

export type EthereumReceiptEip658ReceiptData = {
  statusCode: number;
  usedGas: U256;
  logsBloom: EthbloomBloom;
  logs: Array<EthereumLog>;
};

export type EthereumBlock = {
  header: EthereumHeader;
  transactions: Array<EthereumTransactionTransactionV2>;
  ommers: Array<EthereumHeader>;
};

export type EthereumHeader = {
  parentHash: H256;
  ommersHash: H256;
  beneficiary: H160;
  stateRoot: H256;
  transactionsRoot: H256;
  receiptsRoot: H256;
  logsBloom: EthbloomBloom;
  difficulty: U256;
  number: U256;
  gasLimit: U256;
  gasUsed: U256;
  timestamp: bigint;
  extraData: Bytes;
  mixHash: H256;
  nonce: EthereumTypesHashH64;
};

export type EthereumTypesHashH64 = FixedBytes<8>;

/**
 * The `Error` enum of this pallet.
 **/
export type PalletEthereumError =
  /**
   * Signature is invalid.
   **/
  | 'InvalidSignature'
  /**
   * Pre-log is present, therefore transact is not allowed.
   **/
  | 'PreLogExists';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletEvmAccountsError =
  /**
   * Active EVM account cannot be bound
   **/
  | 'TruncatedAccountAlreadyUsed'
  /**
   * Address is already bound
   **/
  | 'AddressAlreadyBound'
  /**
   * Bound address cannot be used
   **/
  | 'BoundAddressCannotBeUsed'
  /**
   * Address not whitelisted
   **/
  | 'AddressNotWhitelisted';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletXykLiquidityMiningError =
  /**
   * Nft pallet didn't return an owner.
   **/
  | 'CantFindDepositOwner'
  /**
   * Account balance of XYK pool shares is not sufficient.
   **/
  | 'InsufficientXykSharesBalance'
  /**
   * XYK pool does not exist
   **/
  | 'XykPoolDoesntExist'
  /**
   * Account is not deposit owner.
   **/
  | 'NotDepositOwner'
  /**
   * XYK did not return assets for given pool id
   **/
  | 'CantGetXykAssets'
  /**
   * Deposit data not found
   **/
  | 'DepositDataNotFound'
  /**
   * Calculated reward to claim is 0.
   **/
  | 'ZeroClaimedRewards'
  /**
   * Asset is not in the `AssetPair`.
   **/
  | 'AssetNotInAssetPair'
  /**
   * Provided `AssetPair` is not used by the deposit.
   **/
  | 'InvalidAssetPair'
  /**
   * Asset is not registered in asset registry.
   **/
  | 'AssetNotRegistered'
  /**
   * Failed to calculate `pot`'s account.
   **/
  | 'FailToGetPotId'
  /**
   * No global farm - yield farm pairs specified to join
   **/
  | 'NoFarmsSpecified';

export type PalletLiquidityMiningDepositData002 = {
  shares: bigint;
  ammPoolId: AccountId32;
  yieldFarmEntries: Array<PalletLiquidityMiningYieldFarmEntry>;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletRelaychainInfoError = null;

/**
 * The `Error` enum of this pallet.
 **/
export type PalletDcaError =
  /**
   * Schedule not exist
   **/
  | 'ScheduleNotFound'
  /**
   * The min trade amount is not reached
   **/
  | 'MinTradeAmountNotReached'
  /**
   * Forbidden as the user is not the owner of the schedule
   **/
  | 'Forbidden'
  /**
   * The next execution block number is not in the future
   **/
  | 'BlockNumberIsNotInFuture'
  /**
   * Price is unstable as price change from oracle data is bigger than max allowed
   **/
  | 'PriceUnstable'
  /**
   * Order was randomly rescheduled to next block
   **/
  | 'Bumped'
  /**
   * Error occurred when calculating price
   **/
  | 'CalculatingPriceError'
  /**
   * The total amount to be reserved is smaller than min budget
   **/
  | 'TotalAmountIsSmallerThanMinBudget'
  /**
   * The budget is too low for executing at least two orders
   **/
  | 'BudgetTooLow'
  /**
   * There is no free block found to plan DCA execution
   **/
  | 'NoFreeBlockFound'
  /**
   * The DCA schedule has been manually terminated
   **/
  | 'ManuallyTerminated'
  /**
   * Max number of retries reached for schedule
   **/
  | 'MaxRetryReached'
  /**
   * Absolutely trade limit reached, leading to retry
   **/
  | 'TradeLimitReached'
  /**
   * Slippage limit calculated from oracle is reached, leading to retry
   **/
  | 'SlippageLimitReached'
  /**
   * No parent hash has been found from relay chain
   **/
  | 'NoParentHashFound'
  /**
   * Error that should not really happen only in case of invalid state of the schedule storage entries
   **/
  | 'InvalidState'
  /**
   * Period should be longer than 5 blocks
   **/
  | 'PeriodTooShort'
  /**
   * Stability threshold cannot be higher than `MaxConfigurablePriceDifferenceBetweenBlock`
   **/
  | 'StabilityThresholdTooHigh';

export type PalletSchedulerScheduled = {
  maybeId?: FixedBytes<32> | undefined;
  priority: number;
  call: FrameSupportPreimagesBounded;
  maybePeriodic?: [number, number] | undefined;
  origin: HydradxRuntimeOriginCaller;
};

export type PalletSchedulerRetryConfig = { totalRetries: number; remaining: number; period: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletSchedulerError =
  /**
   * Failed to schedule a call
   **/
  | 'FailedToSchedule'
  /**
   * Cannot find the scheduled call.
   **/
  | 'NotFound'
  /**
   * Given target block number is in the past.
   **/
  | 'TargetBlockNumberInPast'
  /**
   * Reschedule failed because it does not change scheduled time.
   **/
  | 'RescheduleNoChange'
  /**
   * Attempt to use a non-named function on a named task.
   **/
  | 'Named';

export type CumulusPalletParachainSystemUnincludedSegmentAncestor = {
  usedBandwidth: CumulusPalletParachainSystemUnincludedSegmentUsedBandwidth;
  paraHeadHash?: H256 | undefined;
  consumedGoAheadSignal?: PolkadotPrimitivesV8UpgradeGoAhead | undefined;
};

export type CumulusPalletParachainSystemUnincludedSegmentUsedBandwidth = {
  umpMsgCount: number;
  umpTotalBytes: number;
  hrmpOutgoing: Array<
    [PolkadotParachainPrimitivesPrimitivesId, CumulusPalletParachainSystemUnincludedSegmentHrmpChannelUpdate]
  >;
};

export type CumulusPalletParachainSystemUnincludedSegmentHrmpChannelUpdate = { msgCount: number; totalBytes: number };

export type PolkadotPrimitivesV8UpgradeGoAhead = 'Abort' | 'GoAhead';

export type CumulusPalletParachainSystemUnincludedSegmentSegmentTracker = {
  usedBandwidth: CumulusPalletParachainSystemUnincludedSegmentUsedBandwidth;
  hrmpWatermark?: number | undefined;
  consumedGoAheadSignal?: PolkadotPrimitivesV8UpgradeGoAhead | undefined;
};

export type PolkadotPrimitivesV8UpgradeRestriction = 'Present';

export type CumulusPalletParachainSystemRelayStateSnapshotMessagingStateSnapshot = {
  dmqMqcHead: H256;
  relayDispatchQueueRemainingCapacity: CumulusPalletParachainSystemRelayStateSnapshotRelayDispatchQueueRemainingCapacity;
  ingressChannels: Array<[PolkadotParachainPrimitivesPrimitivesId, PolkadotPrimitivesV8AbridgedHrmpChannel]>;
  egressChannels: Array<[PolkadotParachainPrimitivesPrimitivesId, PolkadotPrimitivesV8AbridgedHrmpChannel]>;
};

export type CumulusPalletParachainSystemRelayStateSnapshotRelayDispatchQueueRemainingCapacity = {
  remainingCount: number;
  remainingSize: number;
};

export type PolkadotPrimitivesV8AbridgedHrmpChannel = {
  maxCapacity: number;
  maxTotalSize: number;
  maxMessageSize: number;
  msgCount: number;
  totalSize: number;
  mqcHead?: H256 | undefined;
};

export type PolkadotPrimitivesV8AbridgedHostConfiguration = {
  maxCodeSize: number;
  maxHeadDataSize: number;
  maxUpwardQueueCount: number;
  maxUpwardQueueSize: number;
  maxUpwardMessageSize: number;
  maxUpwardMessageNumPerCandidate: number;
  hrmpMaxMessageNumPerCandidate: number;
  validationUpgradeCooldown: number;
  validationUpgradeDelay: number;
  asyncBackingParams: PolkadotPrimitivesV8AsyncBackingAsyncBackingParams;
};

export type PolkadotPrimitivesV8AsyncBackingAsyncBackingParams = {
  maxCandidateDepth: number;
  allowedAncestryLen: number;
};

export type CumulusPrimitivesParachainInherentMessageQueueChain = H256;

export type PolkadotCorePrimitivesOutboundHrmpMessage = {
  recipient: PolkadotParachainPrimitivesPrimitivesId;
  data: Bytes;
};

/**
 * The `Error` enum of this pallet.
 **/
export type CumulusPalletParachainSystemError =
  /**
   * Attempt to upgrade validation function while existing upgrade pending.
   **/
  | 'OverlappingUpgrades'
  /**
   * Polkadot currently prohibits this parachain from upgrading its validation function.
   **/
  | 'ProhibitedByPolkadot'
  /**
   * The supplied validation function has compiled into a blob larger than Polkadot is
   * willing to run.
   **/
  | 'TooBig'
  /**
   * The inherent which supplies the validation data did not run this block.
   **/
  | 'ValidationDataNotAvailable'
  /**
   * The inherent which supplies the host configuration did not run this block.
   **/
  | 'HostConfigurationNotAvailable'
  /**
   * No validation function upgrade is currently scheduled.
   **/
  | 'NotScheduled'
  /**
   * No code upgrade has been authorized.
   **/
  | 'NothingAuthorized'
  /**
   * The given code upgrade has not been authorized.
   **/
  | 'Unauthorized';

export type PalletXcmQueryStatus =
  | {
      type: 'Pending';
      value: {
        responder: XcmVersionedLocation;
        maybeMatchQuerier?: XcmVersionedLocation | undefined;
        maybeNotify?: [number, number] | undefined;
        timeout: number;
      };
    }
  | { type: 'VersionNotifier'; value: { origin: XcmVersionedLocation; isActive: boolean } }
  | { type: 'Ready'; value: { response: XcmVersionedResponse; at: number } };

export type XcmVersionedResponse =
  | { type: 'V2'; value: XcmV2Response }
  | { type: 'V3'; value: XcmV3Response }
  | { type: 'V4'; value: StagingXcmV4Response };

export type PalletXcmVersionMigrationStage =
  | { type: 'MigrateSupportedVersion' }
  | { type: 'MigrateVersionNotifiers' }
  | { type: 'NotifyCurrentTargets'; value?: Bytes | undefined }
  | { type: 'MigrateAndNotifyOldTargets' };

export type PalletXcmRemoteLockedFungibleRecord = {
  amount: bigint;
  owner: XcmVersionedLocation;
  locker: XcmVersionedLocation;
  consumers: Array<[[], bigint]>;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletXcmError =
  /**
   * The desired destination was unreachable, generally because there is a no way of routing
   * to it.
   **/
  | 'Unreachable'
  /**
   * There was some other issue (i.e. not to do with routing) in sending the message.
   * Perhaps a lack of space for buffering the message.
   **/
  | 'SendFailure'
  /**
   * The message execution fails the filter.
   **/
  | 'Filtered'
  /**
   * The message's weight could not be determined.
   **/
  | 'UnweighableMessage'
  /**
   * The destination `Location` provided cannot be inverted.
   **/
  | 'DestinationNotInvertible'
  /**
   * The assets to be sent are empty.
   **/
  | 'Empty'
  /**
   * Could not re-anchor the assets to declare the fees for the destination chain.
   **/
  | 'CannotReanchor'
  /**
   * Too many assets have been attempted for transfer.
   **/
  | 'TooManyAssets'
  /**
   * Origin is invalid for sending.
   **/
  | 'InvalidOrigin'
  /**
   * The version of the `Versioned` value used is not able to be interpreted.
   **/
  | 'BadVersion'
  /**
   * The given location could not be used (e.g. because it cannot be expressed in the
   * desired version of XCM).
   **/
  | 'BadLocation'
  /**
   * The referenced subscription could not be found.
   **/
  | 'NoSubscription'
  /**
   * The location is invalid since it already has a subscription from us.
   **/
  | 'AlreadySubscribed'
  /**
   * Could not check-out the assets for teleportation to the destination chain.
   **/
  | 'CannotCheckOutTeleport'
  /**
   * The owner does not own (all) of the asset that they wish to do the operation on.
   **/
  | 'LowBalance'
  /**
   * The asset owner has too many locks on the asset.
   **/
  | 'TooManyLocks'
  /**
   * The given account is not an identifiable sovereign account for any location.
   **/
  | 'AccountNotSovereign'
  /**
   * The operation required fees to be paid which the initiator could not meet.
   **/
  | 'FeesNotMet'
  /**
   * A remote lock with the corresponding data could not be found.
   **/
  | 'LockNotFound'
  /**
   * The unlock operation cannot succeed because there are still consumers of the lock.
   **/
  | 'InUse'
  /**
   * Invalid asset, reserve chain could not be determined for it.
   **/
  | 'InvalidAssetUnknownReserve'
  /**
   * Invalid asset, do not support remote asset reserves with different fees reserves.
   **/
  | 'InvalidAssetUnsupportedReserve'
  /**
   * Too many assets with different reserve locations have been attempted for transfer.
   **/
  | 'TooManyReserves'
  /**
   * Local XCM execution incomplete.
   **/
  | 'LocalExecutionIncomplete';

export type CumulusPalletXcmpQueueOutboundChannelDetails = {
  recipient: PolkadotParachainPrimitivesPrimitivesId;
  state: CumulusPalletXcmpQueueOutboundState;
  signalsExist: boolean;
  firstIndex: number;
  lastIndex: number;
};

export type CumulusPalletXcmpQueueOutboundState = 'Ok' | 'Suspended';

export type CumulusPalletXcmpQueueQueueConfigData = {
  suspendThreshold: number;
  dropThreshold: number;
  resumeThreshold: number;
};

/**
 * The `Error` enum of this pallet.
 **/
export type CumulusPalletXcmpQueueError =
  /**
   * Setting the queue config failed since one of its values was invalid.
   **/
  | 'BadQueueConfig'
  /**
   * The execution is already suspended.
   **/
  | 'AlreadySuspended'
  /**
   * The execution is already resumed.
   **/
  | 'AlreadyResumed'
  /**
   * There are too many active outbound channels.
   **/
  | 'TooManyActiveOutboundChannels'
  /**
   * The message is too big.
   **/
  | 'TooBig';

export type PalletMessageQueueBookState = {
  begin: number;
  end: number;
  count: number;
  readyNeighbours?: PalletMessageQueueNeighbours | undefined;
  messageCount: bigint;
  size: bigint;
};

export type PalletMessageQueueNeighbours = {
  prev: CumulusPrimitivesCoreAggregateMessageOrigin;
  next: CumulusPrimitivesCoreAggregateMessageOrigin;
};

export type PalletMessageQueuePage = {
  remaining: number;
  remainingSize: number;
  firstIndex: number;
  first: number;
  last: number;
  heap: Bytes;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletMessageQueueError =
  /**
   * Page is not reapable because it has items remaining to be processed and is not old
   * enough.
   **/
  | 'NotReapable'
  /**
   * Page to be reaped does not exist.
   **/
  | 'NoPage'
  /**
   * The referenced message could not be found.
   **/
  | 'NoMessage'
  /**
   * The message was already processed and cannot be processed again.
   **/
  | 'AlreadyProcessed'
  /**
   * The message is queued for future execution.
   **/
  | 'Queued'
  /**
   * There is temporarily not enough weight to continue servicing messages.
   **/
  | 'InsufficientWeight'
  /**
   * This message is temporarily unprocessable.
   *
   * Such errors are expected, but not guaranteed, to resolve themselves eventually through
   * retrying.
   **/
  | 'TemporarilyUnprocessable'
  /**
   * The queue is paused and no message can be executed from it.
   *
   * This can change at any time and may resolve in the future by re-trying.
   **/
  | 'QueuePaused'
  /**
   * Another call is in progress and needs to finish before this call can happen.
   **/
  | 'RecursiveDisallowed';

/**
 * The `Error` enum of this pallet.
 **/
export type OrmlXcmModuleError =
  /**
   * The message and destination combination was not recognized as being
   * reachable.
   **/
  | 'Unreachable'
  /**
   * The message and destination was recognized as being reachable but
   * the operation could not be completed.
   **/
  | 'SendFailure'
  /**
   * The version of the `Versioned` value used is not able to be
   * interpreted.
   **/
  | 'BadVersion';

/**
 * The `Error` enum of this pallet.
 **/
export type OrmlXtokensModuleError =
  /**
   * Asset has no reserve location.
   **/
  | 'AssetHasNoReserve'
  /**
   * Not cross-chain transfer.
   **/
  | 'NotCrossChainTransfer'
  /**
   * Invalid transfer destination.
   **/
  | 'InvalidDest'
  /**
   * Currency is not cross-chain transferable.
   **/
  | 'NotCrossChainTransferableCurrency'
  /**
   * The message's weight could not be determined.
   **/
  | 'UnweighableMessage'
  /**
   * XCM execution failed.
   **/
  | 'XcmExecutionFailed'
  /**
   * Could not re-anchor the assets to declare the fees for the
   * destination chain.
   **/
  | 'CannotReanchor'
  /**
   * Could not get ancestry of asset reserve location.
   **/
  | 'InvalidAncestry'
  /**
   * The Asset is invalid.
   **/
  | 'InvalidAsset'
  /**
   * The destination `Location` provided cannot be inverted.
   **/
  | 'DestinationNotInvertible'
  /**
   * The version of the `Versioned` value used is not able to be
   * interpreted.
   **/
  | 'BadVersion'
  /**
   * We tried sending distinct asset and fee but they have different
   * reserve chains.
   **/
  | 'DistinctReserveForAssetAndFee'
  /**
   * The fee is zero.
   **/
  | 'ZeroFee'
  /**
   * The transfering asset amount is zero.
   **/
  | 'ZeroAmount'
  /**
   * The number of assets to be sent is over the maximum.
   **/
  | 'TooManyAssetsBeingSent'
  /**
   * The specified index does not exist in a Assets struct.
   **/
  | 'AssetIndexNonExistent'
  /**
   * Fee is not enough.
   **/
  | 'FeeNotEnough'
  /**
   * Not supported Location
   **/
  | 'NotSupportedLocation'
  /**
   * MinXcmFee not registered for certain reserve location
   **/
  | 'MinXcmFeeNotDefined'
  /**
   * Asset transfer is limited by RateLimiter.
   **/
  | 'RateLimited';

/**
 * The `Error` enum of this pallet.
 **/
export type OrmlUnknownTokensModuleError =
  /**
   * The balance is too low.
   **/
  | 'BalanceTooLow'
  /**
   * The operation will cause balance to overflow.
   **/
  | 'BalanceOverflow'
  /**
   * Unhandled asset.
   **/
  | 'UnhandledAsset';

export type PalletCollatorSelectionCandidateInfo = { who: AccountId32; deposit: bigint };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletCollatorSelectionError =
  /**
   * The pallet has too many candidates.
   **/
  | 'TooManyCandidates'
  /**
   * Leaving would result in too few candidates.
   **/
  | 'TooFewEligibleCollators'
  /**
   * Account is already a candidate.
   **/
  | 'AlreadyCandidate'
  /**
   * Account is not a candidate.
   **/
  | 'NotCandidate'
  /**
   * There are too many Invulnerables.
   **/
  | 'TooManyInvulnerables'
  /**
   * Account is already an Invulnerable.
   **/
  | 'AlreadyInvulnerable'
  /**
   * Account is not an Invulnerable.
   **/
  | 'NotInvulnerable'
  /**
   * Account has no associated validator ID.
   **/
  | 'NoAssociatedValidatorId'
  /**
   * Validator ID is not yet registered.
   **/
  | 'ValidatorNotRegistered'
  /**
   * Could not insert in the candidate list.
   **/
  | 'InsertToCandidateListFailed'
  /**
   * Could not remove from the candidate list.
   **/
  | 'RemoveFromCandidateListFailed'
  /**
   * New deposit amount would be below the minimum candidacy bond.
   **/
  | 'DepositTooLow'
  /**
   * Could not update the candidate list.
   **/
  | 'UpdateCandidateListFailed'
  /**
   * Deposit amount is too low to take the target's slot in the candidate list.
   **/
  | 'InsufficientBond'
  /**
   * The target account to be replaced in the candidate list is not a candidate.
   **/
  | 'TargetIsNotCandidate'
  /**
   * The updated deposit amount is equal to the amount already reserved.
   **/
  | 'IdenticalDeposit'
  /**
   * Cannot lower candidacy bond while occupying a future collator slot in the list.
   **/
  | 'InvalidUnreserve';

export type SpCoreCryptoKeyTypeId = FixedBytes<4>;

/**
 * Error for the session pallet.
 **/
export type PalletSessionError =
  /**
   * Invalid ownership proof.
   **/
  | 'InvalidProof'
  /**
   * No associated validator ID for account.
   **/
  | 'NoAssociatedValidatorId'
  /**
   * Registered duplicate key.
   **/
  | 'DuplicatedKey'
  /**
   * No keys are associated with this account.
   **/
  | 'NoKeys'
  /**
   * Key setting account is not live, so it's impossible to associate keys.
   **/
  | 'NoAccount';

export type SpConsensusSlotsSlot = bigint;

export type PalletEmaOracleOracleEntry = {
  price: HydraDxMathRatio;
  volume: HydradxTraitsOracleVolume;
  liquidity: HydradxTraitsOracleLiquidity;
  updatedAt: number;
};

export type HydraDxMathRatio = { n: bigint; d: bigint };

export type HydradxTraitsOracleVolume = { aIn: bigint; bOut: bigint; aOut: bigint; bIn: bigint };

export type HydradxTraitsOracleLiquidity = { a: bigint; b: bigint };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletEmaOracleError =
  | 'TooManyUniqueEntries'
  | 'OnTradeValueZero'
  | 'OracleNotFound'
  /**
   * Asset not found
   **/
  | 'AssetNotFound'
  /**
   * The new price is outside the max allowed range
   **/
  | 'PriceOutsideAllowedRange';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBroadcastError =
  /**
   * The execution context call stack has reached its maximum size
   **/
  | 'ExecutionCallStackOverflow'
  /**
   * The execution context call stack is empty, unable to decrease level
   **/
  | 'ExecutionCallStackUnderflow';

export type FrameSystemExtensionsCheckNonZeroSender = {};

export type FrameSystemExtensionsCheckSpecVersion = {};

export type FrameSystemExtensionsCheckTxVersion = {};

export type FrameSystemExtensionsCheckGenesis = {};

export type FrameSystemExtensionsCheckMortality = Era;

export type FrameSystemExtensionsCheckNonce = number;

export type FrameSystemExtensionsCheckWeight = {};

export type PalletTransactionPaymentChargeTransactionPayment = bigint;

export type PalletClaimsValidateClaim = {};

export type FrameMetadataHashExtensionCheckMetadataHash = { mode: FrameMetadataHashExtensionMode };

export type FrameMetadataHashExtensionMode = 'Disabled' | 'Enabled';

export type CumulusPrimitivesStorageWeightReclaimStorageWeightReclaim = {};

export type HydradxRuntimeRuntime = {};

export type SpRuntimeBlock = { header: Header; extrinsics: Array<FpSelfContainedUncheckedExtrinsic> };

export type FpSelfContainedUncheckedExtrinsic = UncheckedExtrinsic;

export type SpRuntimeExtrinsicInclusionMode = 'AllExtrinsics' | 'OnlyInherents';

export type SpCoreOpaqueMetadata = Bytes;

export type SpRuntimeTransactionValidityTransactionValidityError =
  | { type: 'Invalid'; value: SpRuntimeTransactionValidityInvalidTransaction }
  | { type: 'Unknown'; value: SpRuntimeTransactionValidityUnknownTransaction };

export type SpRuntimeTransactionValidityInvalidTransaction =
  | { type: 'Call' }
  | { type: 'Payment' }
  | { type: 'Future' }
  | { type: 'Stale' }
  | { type: 'BadProof' }
  | { type: 'AncientBirthBlock' }
  | { type: 'ExhaustsResources' }
  | { type: 'Custom'; value: number }
  | { type: 'BadMandatory' }
  | { type: 'MandatoryValidation' }
  | { type: 'BadSigner' };

export type SpRuntimeTransactionValidityUnknownTransaction =
  | { type: 'CannotLookup' }
  | { type: 'NoUnsignedValidator' }
  | { type: 'Custom'; value: number };

export type SpInherentsInherentData = { data: Array<[FixedBytes<8>, Bytes]> };

export type SpInherentsCheckInherentsResult = { okay: boolean; fatalError: boolean; errors: SpInherentsInherentData };

export type SpRuntimeTransactionValidityTransactionSource = 'InBlock' | 'Local' | 'External';

export type SpRuntimeTransactionValidityValidTransaction = {
  priority: bigint;
  requires: Array<Bytes>;
  provides: Array<Bytes>;
  longevity: bigint;
  propagate: boolean;
};

export type SpConsensusSlotsSlotDuration = bigint;

export type CumulusPrimitivesCoreCollationInfo = {
  upwardMessages: Array<Bytes>;
  horizontalMessages: Array<PolkadotCorePrimitivesOutboundHrmpMessage>;
  newValidationCode?: PolkadotParachainPrimitivesPrimitivesValidationCode | undefined;
  processedDownwardMessages: number;
  hrmpWatermark: number;
  headData: PolkadotParachainPrimitivesPrimitivesHeadData;
};

export type PolkadotParachainPrimitivesPrimitivesValidationCode = Bytes;

export type PalletCurrenciesRpcRuntimeApiAccountData = { free: bigint; reserved: bigint; frozen: bigint };

export type PalletTransactionPaymentRuntimeDispatchInfo = {
  weight: SpWeightsWeightV2Weight;
  class: FrameSupportDispatchDispatchClass;
  partialFee: bigint;
};

export type PalletTransactionPaymentFeeDetails = {
  inclusionFee?: PalletTransactionPaymentInclusionFee | undefined;
  tip: bigint;
};

export type PalletTransactionPaymentInclusionFee = { baseFee: bigint; lenFee: bigint; adjustedWeightFee: bigint };

export type EvmBackendBasic = { balance: U256; nonce: U256 };

export type FpEvmExecutionInfoV2 = {
  exitReason: EvmCoreErrorExitReason;
  value: Bytes;
  usedGas: FpEvmUsedGas;
  weightInfo?: FpEvmWeightInfo | undefined;
  logs: Array<EthereumLog>;
};

export type FpEvmUsedGas = { standard: U256; effective: U256 };

export type FpEvmWeightInfo = {
  refTimeLimit?: bigint | undefined;
  proofSizeLimit?: bigint | undefined;
  refTimeUsage?: bigint | undefined;
  proofSizeUsage?: bigint | undefined;
};

export type FpEvmExecutionInfoV2H160 = {
  exitReason: EvmCoreErrorExitReason;
  value: H160;
  usedGas: FpEvmUsedGas;
  weightInfo?: FpEvmWeightInfo | undefined;
  logs: Array<EthereumLog>;
};

export type XcmRuntimeApisFeesError =
  | 'Unimplemented'
  | 'VersionedConversionFailed'
  | 'WeightNotComputable'
  | 'UnhandledXcmVersion'
  | 'AssetNotFound'
  | 'Unroutable';

export type XcmRuntimeApisDryRunCallDryRunEffects = {
  executionResult: Result<FrameSupportDispatchPostDispatchInfo, SpRuntimeDispatchErrorWithPostInfo>;
  emittedEvents: Array<HydradxRuntimeRuntimeEvent>;
  localXcm?: XcmVersionedXcm | undefined;
  forwardedXcms: Array<[XcmVersionedLocation, Array<XcmVersionedXcm>]>;
};

export type XcmRuntimeApisDryRunError = 'Unimplemented' | 'VersionedConversionFailed';

export type XcmRuntimeApisDryRunXcmDryRunEffects = {
  executionResult: StagingXcmV4TraitsOutcome;
  emittedEvents: Array<HydradxRuntimeRuntimeEvent>;
  forwardedXcms: Array<[XcmVersionedLocation, Array<XcmVersionedXcm>]>;
};

export type XcmRuntimeApisConversionsError = 'Unsupported' | 'VersionedConversionFailed';

export type HydradxRuntimeEvmAaveTradeExecutorPoolData = {
  reserve: number;
  atoken: number;
  liqudityIn: bigint;
  liqudityOut: bigint;
};

export type HydradxRuntimeRuntimeError =
  | { pallet: 'System'; palletError: FrameSystemError }
  | { pallet: 'Balances'; palletError: PalletBalancesError }
  | { pallet: 'MultiTransactionPayment'; palletError: PalletTransactionMultiPaymentError }
  | { pallet: 'Treasury'; palletError: PalletTreasuryError }
  | { pallet: 'Utility'; palletError: PalletUtilityError }
  | { pallet: 'Preimage'; palletError: PalletPreimageError }
  | { pallet: 'Identity'; palletError: PalletIdentityError }
  | { pallet: 'Democracy'; palletError: PalletDemocracyError }
  | { pallet: 'Elections'; palletError: PalletElectionsPhragmenError }
  | { pallet: 'Council'; palletError: PalletCollectiveError }
  | { pallet: 'TechnicalCommittee'; palletError: PalletCollectiveError }
  | { pallet: 'Tips'; palletError: PalletTipsError }
  | { pallet: 'Proxy'; palletError: PalletProxyError }
  | { pallet: 'Multisig'; palletError: PalletMultisigError }
  | { pallet: 'Uniques'; palletError: PalletUniquesError }
  | { pallet: 'StateTrieMigration'; palletError: PalletStateTrieMigrationError }
  | { pallet: 'ConvictionVoting'; palletError: PalletConvictionVotingError }
  | { pallet: 'Referenda'; palletError: PalletReferendaError }
  | { pallet: 'Whitelist'; palletError: PalletWhitelistError }
  | { pallet: 'AssetRegistry'; palletError: PalletAssetRegistryError }
  | { pallet: 'Claims'; palletError: PalletClaimsError }
  | { pallet: 'CollatorRewards'; palletError: PalletCollatorRewardsError }
  | { pallet: 'Omnipool'; palletError: PalletOmnipoolError }
  | { pallet: 'TransactionPause'; palletError: PalletTransactionPauseError }
  | { pallet: 'Duster'; palletError: PalletDusterError }
  | { pallet: 'OmnipoolWarehouseLM'; palletError: PalletLiquidityMiningError }
  | { pallet: 'OmnipoolLiquidityMining'; palletError: PalletOmnipoolLiquidityMiningError }
  | { pallet: 'Otc'; palletError: PalletOtcError }
  | { pallet: 'CircuitBreaker'; palletError: PalletCircuitBreakerError }
  | { pallet: 'Router'; palletError: PalletRouteExecutorError }
  | { pallet: 'DynamicFees'; palletError: PalletDynamicFeesError }
  | { pallet: 'Staking'; palletError: PalletStakingError }
  | { pallet: 'Stableswap'; palletError: PalletStableswapError }
  | { pallet: 'Bonds'; palletError: PalletBondsError }
  | { pallet: 'OtcSettlements'; palletError: PalletOtcSettlementsError }
  | { pallet: 'Lbp'; palletError: PalletLbpError }
  | { pallet: 'Xyk'; palletError: PalletXykError }
  | { pallet: 'Referrals'; palletError: PalletReferralsError }
  | { pallet: 'Liquidation'; palletError: PalletLiquidationError }
  | { pallet: 'Hsm'; palletError: PalletHsmError }
  | { pallet: 'Tokens'; palletError: OrmlTokensModuleError }
  | { pallet: 'Currencies'; palletError: PalletCurrenciesModuleError }
  | { pallet: 'Vesting'; palletError: OrmlVestingModuleError }
  | { pallet: 'Evm'; palletError: PalletEvmError }
  | { pallet: 'Ethereum'; palletError: PalletEthereumError }
  | { pallet: 'EvmAccounts'; palletError: PalletEvmAccountsError }
  | { pallet: 'XykLiquidityMining'; palletError: PalletXykLiquidityMiningError }
  | { pallet: 'XykWarehouseLM'; palletError: PalletLiquidityMiningError }
  | { pallet: 'RelayChainInfo'; palletError: PalletRelaychainInfoError }
  | { pallet: 'Dca'; palletError: PalletDcaError }
  | { pallet: 'Scheduler'; palletError: PalletSchedulerError }
  | { pallet: 'ParachainSystem'; palletError: CumulusPalletParachainSystemError }
  | { pallet: 'PolkadotXcm'; palletError: PalletXcmError }
  | { pallet: 'XcmpQueue'; palletError: CumulusPalletXcmpQueueError }
  | { pallet: 'MessageQueue'; palletError: PalletMessageQueueError }
  | { pallet: 'OrmlXcm'; palletError: OrmlXcmModuleError }
  | { pallet: 'XTokens'; palletError: OrmlXtokensModuleError }
  | { pallet: 'UnknownTokens'; palletError: OrmlUnknownTokensModuleError }
  | { pallet: 'CollatorSelection'; palletError: PalletCollatorSelectionError }
  | { pallet: 'Session'; palletError: PalletSessionError }
  | { pallet: 'EmaOracle'; palletError: PalletEmaOracleError }
  | { pallet: 'Broadcast'; palletError: PalletBroadcastError };
