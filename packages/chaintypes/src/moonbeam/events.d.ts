// Generated by dedot cli

import type { GenericChainEvents, GenericPalletEvent } from 'dedot/types';
import type {
  DispatchError,
  AccountId20,
  H256,
  FixedBytes,
  Percent,
  Perbill,
  Result,
  Bytes,
  H160,
  U256,
} from 'dedot/codecs';
import type {
  FrameSystemDispatchEventInfo,
  SpWeightsWeightV2Weight,
  FrameSupportTokensMiscBalanceStatus,
  PalletParachainStakingDelegationRequestsCancelledScheduledRequest,
  PalletParachainStakingDelegatorAdded,
  PalletParachainStakingInflationDistributionConfig,
  PalletAuthorSlotFilterNumNonZeroU32,
  NimbusPrimitivesNimbusCryptoPublic,
  SessionKeysPrimitivesVrfVrfCryptoPublic,
  MoonbeamRuntimeProxyType,
  PalletProxyDepositKind,
  PalletMultisigTimepoint,
  MoonbeamRuntimeRuntimeParamsRuntimeParametersKey,
  MoonbeamRuntimeRuntimeParamsRuntimeParametersValue,
  EthereumLog,
  EvmCoreErrorExitReason,
  PalletConvictionVotingVoteAccountVote,
  FrameSupportPreimagesBounded,
  PalletConvictionVotingTally,
  FrameSupportDispatchPostDispatchInfo,
  SpRuntimeDispatchErrorWithPostInfo,
  FrameSupportTokensFungibleUnionOfNativeOrWithId,
  StagingXcmV5TraitsOutcome,
  StagingXcmV5Location,
  StagingXcmV5Xcm,
  XcmV3TraitsSendError,
  XcmV5TraitsError,
  StagingXcmV5Response,
  XcmVersionedAssets,
  StagingXcmV5AssetAssets,
  XcmVersionedLocation,
  PalletXcmTransactorRemoteTransactInfoWithMaxWeight,
  PalletXcmTransactorHrmpOperation,
  CumulusPrimitivesCoreAggregateMessageOrigin,
  FrameSupportMessagesProcessMessageError,
  BpHeaderChainHeaderFinalityInfo,
  BpPolkadotCoreParachainsParaId,
  BpMessagesLaneHashedLaneId,
  BpMessagesReceivedMessages,
  BpMessagesDeliveredMessages,
  BpXcmBridgeHubBridgeId,
  StagingXcmV5Junctions,
} from './types.js';

export interface ChainEvents extends GenericChainEvents {
  /**
   * Pallet `System`'s events
   **/
  system: {
    /**
     * An extrinsic completed successfully.
     **/
    ExtrinsicSuccess: GenericPalletEvent<'System', 'ExtrinsicSuccess', { dispatchInfo: FrameSystemDispatchEventInfo }>;

    /**
     * An extrinsic failed.
     **/
    ExtrinsicFailed: GenericPalletEvent<
      'System',
      'ExtrinsicFailed',
      { dispatchError: DispatchError; dispatchInfo: FrameSystemDispatchEventInfo }
    >;

    /**
     * `:code` was updated.
     **/
    CodeUpdated: GenericPalletEvent<'System', 'CodeUpdated', null>;

    /**
     * A new account was created.
     **/
    NewAccount: GenericPalletEvent<'System', 'NewAccount', { account: AccountId20 }>;

    /**
     * An account was reaped.
     **/
    KilledAccount: GenericPalletEvent<'System', 'KilledAccount', { account: AccountId20 }>;

    /**
     * On on-chain remark happened.
     **/
    Remarked: GenericPalletEvent<'System', 'Remarked', { sender: AccountId20; hash: H256 }>;

    /**
     * An upgrade was authorized.
     **/
    UpgradeAuthorized: GenericPalletEvent<'System', 'UpgradeAuthorized', { codeHash: H256; checkVersion: boolean }>;

    /**
     * An invalid authorized upgrade was rejected while trying to apply it.
     **/
    RejectedInvalidAuthorizedUpgrade: GenericPalletEvent<
      'System',
      'RejectedInvalidAuthorizedUpgrade',
      { codeHash: H256; error: DispatchError }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `ParachainSystem`'s events
   **/
  parachainSystem: {
    /**
     * The validation function has been scheduled to apply.
     **/
    ValidationFunctionStored: GenericPalletEvent<'ParachainSystem', 'ValidationFunctionStored', null>;

    /**
     * The validation function was applied as of the contained relay chain block number.
     **/
    ValidationFunctionApplied: GenericPalletEvent<
      'ParachainSystem',
      'ValidationFunctionApplied',
      { relayChainBlockNum: number }
    >;

    /**
     * The relay-chain aborted the upgrade process.
     **/
    ValidationFunctionDiscarded: GenericPalletEvent<'ParachainSystem', 'ValidationFunctionDiscarded', null>;

    /**
     * Some downward messages have been received and will be processed.
     **/
    DownwardMessagesReceived: GenericPalletEvent<'ParachainSystem', 'DownwardMessagesReceived', { count: number }>;

    /**
     * Downward messages were processed using the given weight.
     **/
    DownwardMessagesProcessed: GenericPalletEvent<
      'ParachainSystem',
      'DownwardMessagesProcessed',
      { weightUsed: SpWeightsWeightV2Weight; dmqHead: H256 }
    >;

    /**
     * An upward message was sent to the relay chain.
     **/
    UpwardMessageSent: GenericPalletEvent<
      'ParachainSystem',
      'UpwardMessageSent',
      { messageHash?: FixedBytes<32> | undefined }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `RootTesting`'s events
   **/
  rootTesting: {
    /**
     * Event dispatched when the trigger_defensive extrinsic is called.
     **/
    DefensiveTestCall: GenericPalletEvent<'RootTesting', 'DefensiveTestCall', undefined>;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `Balances`'s events
   **/
  balances: {
    /**
     * An account was created with some free balance.
     **/
    Endowed: GenericPalletEvent<'Balances', 'Endowed', { account: AccountId20; freeBalance: bigint }>;

    /**
     * An account was removed whose balance was non-zero but below ExistentialDeposit,
     * resulting in an outright loss.
     **/
    DustLost: GenericPalletEvent<'Balances', 'DustLost', { account: AccountId20; amount: bigint }>;

    /**
     * Transfer succeeded.
     **/
    Transfer: GenericPalletEvent<'Balances', 'Transfer', { from: AccountId20; to: AccountId20; amount: bigint }>;

    /**
     * A balance was set by root.
     **/
    BalanceSet: GenericPalletEvent<'Balances', 'BalanceSet', { who: AccountId20; free: bigint }>;

    /**
     * Some balance was reserved (moved from free to reserved).
     **/
    Reserved: GenericPalletEvent<'Balances', 'Reserved', { who: AccountId20; amount: bigint }>;

    /**
     * Some balance was unreserved (moved from reserved to free).
     **/
    Unreserved: GenericPalletEvent<'Balances', 'Unreserved', { who: AccountId20; amount: bigint }>;

    /**
     * Some balance was moved from the reserve of the first account to the second account.
     * Final argument indicates the destination balance type.
     **/
    ReserveRepatriated: GenericPalletEvent<
      'Balances',
      'ReserveRepatriated',
      { from: AccountId20; to: AccountId20; amount: bigint; destinationStatus: FrameSupportTokensMiscBalanceStatus }
    >;

    /**
     * Some amount was deposited (e.g. for transaction fees).
     **/
    Deposit: GenericPalletEvent<'Balances', 'Deposit', { who: AccountId20; amount: bigint }>;

    /**
     * Some amount was withdrawn from the account (e.g. for transaction fees).
     **/
    Withdraw: GenericPalletEvent<'Balances', 'Withdraw', { who: AccountId20; amount: bigint }>;

    /**
     * Some amount was removed from the account (e.g. for misbehavior).
     **/
    Slashed: GenericPalletEvent<'Balances', 'Slashed', { who: AccountId20; amount: bigint }>;

    /**
     * Some amount was minted into an account.
     **/
    Minted: GenericPalletEvent<'Balances', 'Minted', { who: AccountId20; amount: bigint }>;

    /**
     * Some amount was burned from an account.
     **/
    Burned: GenericPalletEvent<'Balances', 'Burned', { who: AccountId20; amount: bigint }>;

    /**
     * Some amount was suspended from an account (it can be restored later).
     **/
    Suspended: GenericPalletEvent<'Balances', 'Suspended', { who: AccountId20; amount: bigint }>;

    /**
     * Some amount was restored into an account.
     **/
    Restored: GenericPalletEvent<'Balances', 'Restored', { who: AccountId20; amount: bigint }>;

    /**
     * An account was upgraded.
     **/
    Upgraded: GenericPalletEvent<'Balances', 'Upgraded', { who: AccountId20 }>;

    /**
     * Total issuance was increased by `amount`, creating a credit to be balanced.
     **/
    Issued: GenericPalletEvent<'Balances', 'Issued', { amount: bigint }>;

    /**
     * Total issuance was decreased by `amount`, creating a debt to be balanced.
     **/
    Rescinded: GenericPalletEvent<'Balances', 'Rescinded', { amount: bigint }>;

    /**
     * Some balance was locked.
     **/
    Locked: GenericPalletEvent<'Balances', 'Locked', { who: AccountId20; amount: bigint }>;

    /**
     * Some balance was unlocked.
     **/
    Unlocked: GenericPalletEvent<'Balances', 'Unlocked', { who: AccountId20; amount: bigint }>;

    /**
     * Some balance was frozen.
     **/
    Frozen: GenericPalletEvent<'Balances', 'Frozen', { who: AccountId20; amount: bigint }>;

    /**
     * Some balance was thawed.
     **/
    Thawed: GenericPalletEvent<'Balances', 'Thawed', { who: AccountId20; amount: bigint }>;

    /**
     * The `TotalIssuance` was forcefully changed.
     **/
    TotalIssuanceForced: GenericPalletEvent<'Balances', 'TotalIssuanceForced', { old: bigint; new: bigint }>;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `TransactionPayment`'s events
   **/
  transactionPayment: {
    /**
     * A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,
     * has been paid by `who`.
     **/
    TransactionFeePaid: GenericPalletEvent<
      'TransactionPayment',
      'TransactionFeePaid',
      { who: AccountId20; actualFee: bigint; tip: bigint }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `ParachainStaking`'s events
   **/
  parachainStaking: {
    /**
     * Started new round.
     **/
    NewRound: GenericPalletEvent<
      'ParachainStaking',
      'NewRound',
      { startingBlock: number; round: number; selectedCollatorsNumber: number; totalBalance: bigint }
    >;

    /**
     * Account joined the set of collator candidates.
     **/
    JoinedCollatorCandidates: GenericPalletEvent<
      'ParachainStaking',
      'JoinedCollatorCandidates',
      { account: AccountId20; amountLocked: bigint; newTotalAmtLocked: bigint }
    >;

    /**
     * Candidate selected for collators. Total Exposed Amount includes all delegations.
     **/
    CollatorChosen: GenericPalletEvent<
      'ParachainStaking',
      'CollatorChosen',
      { round: number; collatorAccount: AccountId20; totalExposedAmount: bigint }
    >;

    /**
     * Candidate requested to decrease a self bond.
     **/
    CandidateBondLessRequested: GenericPalletEvent<
      'ParachainStaking',
      'CandidateBondLessRequested',
      { candidate: AccountId20; amountToDecrease: bigint; executeRound: number }
    >;

    /**
     * Candidate has increased a self bond.
     **/
    CandidateBondedMore: GenericPalletEvent<
      'ParachainStaking',
      'CandidateBondedMore',
      { candidate: AccountId20; amount: bigint; newTotalBond: bigint }
    >;

    /**
     * Candidate has decreased a self bond.
     **/
    CandidateBondedLess: GenericPalletEvent<
      'ParachainStaking',
      'CandidateBondedLess',
      { candidate: AccountId20; amount: bigint; newBond: bigint }
    >;

    /**
     * Candidate temporarily leave the set of collator candidates without unbonding.
     **/
    CandidateWentOffline: GenericPalletEvent<'ParachainStaking', 'CandidateWentOffline', { candidate: AccountId20 }>;

    /**
     * Candidate rejoins the set of collator candidates.
     **/
    CandidateBackOnline: GenericPalletEvent<'ParachainStaking', 'CandidateBackOnline', { candidate: AccountId20 }>;

    /**
     * Candidate has requested to leave the set of candidates.
     **/
    CandidateScheduledExit: GenericPalletEvent<
      'ParachainStaking',
      'CandidateScheduledExit',
      { exitAllowedRound: number; candidate: AccountId20; scheduledExit: number }
    >;

    /**
     * Cancelled request to leave the set of candidates.
     **/
    CancelledCandidateExit: GenericPalletEvent<
      'ParachainStaking',
      'CancelledCandidateExit',
      { candidate: AccountId20 }
    >;

    /**
     * Cancelled request to decrease candidate's bond.
     **/
    CancelledCandidateBondLess: GenericPalletEvent<
      'ParachainStaking',
      'CancelledCandidateBondLess',
      { candidate: AccountId20; amount: bigint; executeRound: number }
    >;

    /**
     * Candidate has left the set of candidates.
     **/
    CandidateLeft: GenericPalletEvent<
      'ParachainStaking',
      'CandidateLeft',
      { exCandidate: AccountId20; unlockedAmount: bigint; newTotalAmtLocked: bigint }
    >;

    /**
     * Delegator requested to decrease a bond for the collator candidate.
     **/
    DelegationDecreaseScheduled: GenericPalletEvent<
      'ParachainStaking',
      'DelegationDecreaseScheduled',
      { delegator: AccountId20; candidate: AccountId20; amountToDecrease: bigint; executeRound: number }
    >;
    DelegationIncreased: GenericPalletEvent<
      'ParachainStaking',
      'DelegationIncreased',
      { delegator: AccountId20; candidate: AccountId20; amount: bigint; inTop: boolean }
    >;
    DelegationDecreased: GenericPalletEvent<
      'ParachainStaking',
      'DelegationDecreased',
      { delegator: AccountId20; candidate: AccountId20; amount: bigint; inTop: boolean }
    >;

    /**
     * Delegator requested to leave the set of delegators.
     **/
    DelegatorExitScheduled: GenericPalletEvent<
      'ParachainStaking',
      'DelegatorExitScheduled',
      { round: number; delegator: AccountId20; scheduledExit: number }
    >;

    /**
     * Delegator requested to revoke delegation.
     **/
    DelegationRevocationScheduled: GenericPalletEvent<
      'ParachainStaking',
      'DelegationRevocationScheduled',
      { round: number; delegator: AccountId20; candidate: AccountId20; scheduledExit: number }
    >;

    /**
     * Delegator has left the set of delegators.
     **/
    DelegatorLeft: GenericPalletEvent<
      'ParachainStaking',
      'DelegatorLeft',
      { delegator: AccountId20; unstakedAmount: bigint }
    >;

    /**
     * Delegation revoked.
     **/
    DelegationRevoked: GenericPalletEvent<
      'ParachainStaking',
      'DelegationRevoked',
      { delegator: AccountId20; candidate: AccountId20; unstakedAmount: bigint }
    >;

    /**
     * Delegation kicked.
     **/
    DelegationKicked: GenericPalletEvent<
      'ParachainStaking',
      'DelegationKicked',
      { delegator: AccountId20; candidate: AccountId20; unstakedAmount: bigint }
    >;

    /**
     * Cancelled a pending request to exit the set of delegators.
     **/
    DelegatorExitCancelled: GenericPalletEvent<
      'ParachainStaking',
      'DelegatorExitCancelled',
      { delegator: AccountId20 }
    >;

    /**
     * Cancelled request to change an existing delegation.
     **/
    CancelledDelegationRequest: GenericPalletEvent<
      'ParachainStaking',
      'CancelledDelegationRequest',
      {
        delegator: AccountId20;
        cancelledRequest: PalletParachainStakingDelegationRequestsCancelledScheduledRequest;
        collator: AccountId20;
      }
    >;

    /**
     * New delegation (increase of the existing one).
     **/
    Delegation: GenericPalletEvent<
      'ParachainStaking',
      'Delegation',
      {
        delegator: AccountId20;
        lockedAmount: bigint;
        candidate: AccountId20;
        delegatorPosition: PalletParachainStakingDelegatorAdded;
        autoCompound: Percent;
      }
    >;

    /**
     * Delegation from candidate state has been remove.
     **/
    DelegatorLeftCandidate: GenericPalletEvent<
      'ParachainStaking',
      'DelegatorLeftCandidate',
      { delegator: AccountId20; candidate: AccountId20; unstakedAmount: bigint; totalCandidateStaked: bigint }
    >;

    /**
     * Paid the account (delegator or collator) the balance as liquid rewards.
     **/
    Rewarded: GenericPalletEvent<'ParachainStaking', 'Rewarded', { account: AccountId20; rewards: bigint }>;

    /**
     * Transferred to account which holds funds reserved for parachain bond.
     **/
    InflationDistributed: GenericPalletEvent<
      'ParachainStaking',
      'InflationDistributed',
      { index: number; account: AccountId20; value: bigint }
    >;
    InflationDistributionConfigUpdated: GenericPalletEvent<
      'ParachainStaking',
      'InflationDistributionConfigUpdated',
      { old: PalletParachainStakingInflationDistributionConfig; new: PalletParachainStakingInflationDistributionConfig }
    >;

    /**
     * Annual inflation input (first 3) was used to derive new per-round inflation (last 3)
     **/
    InflationSet: GenericPalletEvent<
      'ParachainStaking',
      'InflationSet',
      {
        annualMin: Perbill;
        annualIdeal: Perbill;
        annualMax: Perbill;
        roundMin: Perbill;
        roundIdeal: Perbill;
        roundMax: Perbill;
      }
    >;

    /**
     * Staking expectations set.
     **/
    StakeExpectationsSet: GenericPalletEvent<
      'ParachainStaking',
      'StakeExpectationsSet',
      { expectMin: bigint; expectIdeal: bigint; expectMax: bigint }
    >;

    /**
     * Set total selected candidates to this value.
     **/
    TotalSelectedSet: GenericPalletEvent<'ParachainStaking', 'TotalSelectedSet', { old: number; new: number }>;

    /**
     * Set collator commission to this value.
     **/
    CollatorCommissionSet: GenericPalletEvent<
      'ParachainStaking',
      'CollatorCommissionSet',
      { old: Perbill; new: Perbill }
    >;

    /**
     * Set blocks per round
     **/
    BlocksPerRoundSet: GenericPalletEvent<
      'ParachainStaking',
      'BlocksPerRoundSet',
      {
        currentRound: number;
        firstBlock: number;
        old: number;
        new: number;
        newPerRoundInflationMin: Perbill;
        newPerRoundInflationIdeal: Perbill;
        newPerRoundInflationMax: Perbill;
      }
    >;

    /**
     * Auto-compounding reward percent was set for a delegation.
     **/
    AutoCompoundSet: GenericPalletEvent<
      'ParachainStaking',
      'AutoCompoundSet',
      { candidate: AccountId20; delegator: AccountId20; value: Percent }
    >;

    /**
     * Compounded a portion of rewards towards the delegation.
     **/
    Compounded: GenericPalletEvent<
      'ParachainStaking',
      'Compounded',
      { candidate: AccountId20; delegator: AccountId20; amount: bigint }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `AuthorFilter`'s events
   **/
  authorFilter: {
    /**
     * The amount of eligible authors for the filter to select has been changed.
     **/
    EligibleUpdated: GenericPalletEvent<'AuthorFilter', 'EligibleUpdated', PalletAuthorSlotFilterNumNonZeroU32>;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `AuthorMapping`'s events
   **/
  authorMapping: {
    /**
     * A NimbusId has been registered and mapped to an AccountId.
     **/
    KeysRegistered: GenericPalletEvent<
      'AuthorMapping',
      'KeysRegistered',
      {
        nimbusId: NimbusPrimitivesNimbusCryptoPublic;
        accountId: AccountId20;
        keys: SessionKeysPrimitivesVrfVrfCryptoPublic;
      }
    >;

    /**
     * An NimbusId has been de-registered, and its AccountId mapping removed.
     **/
    KeysRemoved: GenericPalletEvent<
      'AuthorMapping',
      'KeysRemoved',
      {
        nimbusId: NimbusPrimitivesNimbusCryptoPublic;
        accountId: AccountId20;
        keys: SessionKeysPrimitivesVrfVrfCryptoPublic;
      }
    >;

    /**
     * An NimbusId has been registered, replacing a previous registration and its mapping.
     **/
    KeysRotated: GenericPalletEvent<
      'AuthorMapping',
      'KeysRotated',
      {
        newNimbusId: NimbusPrimitivesNimbusCryptoPublic;
        accountId: AccountId20;
        newKeys: SessionKeysPrimitivesVrfVrfCryptoPublic;
      }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `MoonbeamOrbiters`'s events
   **/
  moonbeamOrbiters: {
    /**
     * An orbiter join a collator pool
     **/
    OrbiterJoinCollatorPool: GenericPalletEvent<
      'MoonbeamOrbiters',
      'OrbiterJoinCollatorPool',
      { collator: AccountId20; orbiter: AccountId20 }
    >;

    /**
     * An orbiter leave a collator pool
     **/
    OrbiterLeaveCollatorPool: GenericPalletEvent<
      'MoonbeamOrbiters',
      'OrbiterLeaveCollatorPool',
      { collator: AccountId20; orbiter: AccountId20 }
    >;

    /**
     * Paid the orbiter account the balance as liquid rewards.
     **/
    OrbiterRewarded: GenericPalletEvent<
      'MoonbeamOrbiters',
      'OrbiterRewarded',
      { account: AccountId20; rewards: bigint }
    >;
    OrbiterRotation: GenericPalletEvent<
      'MoonbeamOrbiters',
      'OrbiterRotation',
      { collator: AccountId20; oldOrbiter?: AccountId20 | undefined; newOrbiter?: AccountId20 | undefined }
    >;

    /**
     * An orbiter has registered
     **/
    OrbiterRegistered: GenericPalletEvent<
      'MoonbeamOrbiters',
      'OrbiterRegistered',
      { account: AccountId20; deposit: bigint }
    >;

    /**
     * An orbiter has unregistered
     **/
    OrbiterUnregistered: GenericPalletEvent<'MoonbeamOrbiters', 'OrbiterUnregistered', { account: AccountId20 }>;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `Utility`'s events
   **/
  utility: {
    /**
     * Batch of dispatches did not complete fully. Index of first failing dispatch given, as
     * well as the error.
     **/
    BatchInterrupted: GenericPalletEvent<'Utility', 'BatchInterrupted', { index: number; error: DispatchError }>;

    /**
     * Batch of dispatches completed fully with no error.
     **/
    BatchCompleted: GenericPalletEvent<'Utility', 'BatchCompleted', null>;

    /**
     * Batch of dispatches completed but has errors.
     **/
    BatchCompletedWithErrors: GenericPalletEvent<'Utility', 'BatchCompletedWithErrors', null>;

    /**
     * A single item within a Batch of dispatches has completed with no error.
     **/
    ItemCompleted: GenericPalletEvent<'Utility', 'ItemCompleted', null>;

    /**
     * A single item within a Batch of dispatches has completed with error.
     **/
    ItemFailed: GenericPalletEvent<'Utility', 'ItemFailed', { error: DispatchError }>;

    /**
     * A call was dispatched.
     **/
    DispatchedAs: GenericPalletEvent<'Utility', 'DispatchedAs', { result: Result<[], DispatchError> }>;

    /**
     * Main call was dispatched.
     **/
    IfElseMainSuccess: GenericPalletEvent<'Utility', 'IfElseMainSuccess', null>;

    /**
     * The fallback call was dispatched.
     **/
    IfElseFallbackCalled: GenericPalletEvent<'Utility', 'IfElseFallbackCalled', { mainError: DispatchError }>;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `Proxy`'s events
   **/
  proxy: {
    /**
     * A proxy was executed correctly, with the given.
     **/
    ProxyExecuted: GenericPalletEvent<'Proxy', 'ProxyExecuted', { result: Result<[], DispatchError> }>;

    /**
     * A pure account has been created by new proxy with given
     * disambiguation index and proxy type.
     **/
    PureCreated: GenericPalletEvent<
      'Proxy',
      'PureCreated',
      { pure: AccountId20; who: AccountId20; proxyType: MoonbeamRuntimeProxyType; disambiguationIndex: number }
    >;

    /**
     * An announcement was placed to make a call in the future.
     **/
    Announced: GenericPalletEvent<'Proxy', 'Announced', { real: AccountId20; proxy: AccountId20; callHash: H256 }>;

    /**
     * A proxy was added.
     **/
    ProxyAdded: GenericPalletEvent<
      'Proxy',
      'ProxyAdded',
      { delegator: AccountId20; delegatee: AccountId20; proxyType: MoonbeamRuntimeProxyType; delay: number }
    >;

    /**
     * A proxy was removed.
     **/
    ProxyRemoved: GenericPalletEvent<
      'Proxy',
      'ProxyRemoved',
      { delegator: AccountId20; delegatee: AccountId20; proxyType: MoonbeamRuntimeProxyType; delay: number }
    >;

    /**
     * A deposit stored for proxies or announcements was poked / updated.
     **/
    DepositPoked: GenericPalletEvent<
      'Proxy',
      'DepositPoked',
      { who: AccountId20; kind: PalletProxyDepositKind; oldDeposit: bigint; newDeposit: bigint }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `MaintenanceMode`'s events
   **/
  maintenanceMode: {
    /**
     * The chain was put into Maintenance Mode
     **/
    EnteredMaintenanceMode: GenericPalletEvent<'MaintenanceMode', 'EnteredMaintenanceMode', null>;

    /**
     * The chain returned to its normal operating state
     **/
    NormalOperationResumed: GenericPalletEvent<'MaintenanceMode', 'NormalOperationResumed', null>;

    /**
     * The call to suspend on_idle XCM execution failed with inner error
     **/
    FailedToSuspendIdleXcmExecution: GenericPalletEvent<
      'MaintenanceMode',
      'FailedToSuspendIdleXcmExecution',
      { error: DispatchError }
    >;

    /**
     * The call to resume on_idle XCM execution failed with inner error
     **/
    FailedToResumeIdleXcmExecution: GenericPalletEvent<
      'MaintenanceMode',
      'FailedToResumeIdleXcmExecution',
      { error: DispatchError }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `Identity`'s events
   **/
  identity: {
    /**
     * A name was set or reset (which will remove all judgements).
     **/
    IdentitySet: GenericPalletEvent<'Identity', 'IdentitySet', { who: AccountId20 }>;

    /**
     * A name was cleared, and the given balance returned.
     **/
    IdentityCleared: GenericPalletEvent<'Identity', 'IdentityCleared', { who: AccountId20; deposit: bigint }>;

    /**
     * A name was removed and the given balance slashed.
     **/
    IdentityKilled: GenericPalletEvent<'Identity', 'IdentityKilled', { who: AccountId20; deposit: bigint }>;

    /**
     * A judgement was asked from a registrar.
     **/
    JudgementRequested: GenericPalletEvent<
      'Identity',
      'JudgementRequested',
      { who: AccountId20; registrarIndex: number }
    >;

    /**
     * A judgement request was retracted.
     **/
    JudgementUnrequested: GenericPalletEvent<
      'Identity',
      'JudgementUnrequested',
      { who: AccountId20; registrarIndex: number }
    >;

    /**
     * A judgement was given by a registrar.
     **/
    JudgementGiven: GenericPalletEvent<'Identity', 'JudgementGiven', { target: AccountId20; registrarIndex: number }>;

    /**
     * A registrar was added.
     **/
    RegistrarAdded: GenericPalletEvent<'Identity', 'RegistrarAdded', { registrarIndex: number }>;

    /**
     * A sub-identity was added to an identity and the deposit paid.
     **/
    SubIdentityAdded: GenericPalletEvent<
      'Identity',
      'SubIdentityAdded',
      { sub: AccountId20; main: AccountId20; deposit: bigint }
    >;

    /**
     * An account's sub-identities were set (in bulk).
     **/
    SubIdentitiesSet: GenericPalletEvent<
      'Identity',
      'SubIdentitiesSet',
      { main: AccountId20; numberOfSubs: number; newDeposit: bigint }
    >;

    /**
     * A given sub-account's associated name was changed by its super-identity.
     **/
    SubIdentityRenamed: GenericPalletEvent<'Identity', 'SubIdentityRenamed', { sub: AccountId20; main: AccountId20 }>;

    /**
     * A sub-identity was removed from an identity and the deposit freed.
     **/
    SubIdentityRemoved: GenericPalletEvent<
      'Identity',
      'SubIdentityRemoved',
      { sub: AccountId20; main: AccountId20; deposit: bigint }
    >;

    /**
     * A sub-identity was cleared, and the given deposit repatriated from the
     * main identity account to the sub-identity account.
     **/
    SubIdentityRevoked: GenericPalletEvent<
      'Identity',
      'SubIdentityRevoked',
      { sub: AccountId20; main: AccountId20; deposit: bigint }
    >;

    /**
     * A username authority was added.
     **/
    AuthorityAdded: GenericPalletEvent<'Identity', 'AuthorityAdded', { authority: AccountId20 }>;

    /**
     * A username authority was removed.
     **/
    AuthorityRemoved: GenericPalletEvent<'Identity', 'AuthorityRemoved', { authority: AccountId20 }>;

    /**
     * A username was set for `who`.
     **/
    UsernameSet: GenericPalletEvent<'Identity', 'UsernameSet', { who: AccountId20; username: Bytes }>;

    /**
     * A username was queued, but `who` must accept it prior to `expiration`.
     **/
    UsernameQueued: GenericPalletEvent<
      'Identity',
      'UsernameQueued',
      { who: AccountId20; username: Bytes; expiration: number }
    >;

    /**
     * A queued username passed its expiration without being claimed and was removed.
     **/
    PreapprovalExpired: GenericPalletEvent<'Identity', 'PreapprovalExpired', { whose: AccountId20 }>;

    /**
     * A username was set as a primary and can be looked up from `who`.
     **/
    PrimaryUsernameSet: GenericPalletEvent<'Identity', 'PrimaryUsernameSet', { who: AccountId20; username: Bytes }>;

    /**
     * A dangling username (as in, a username corresponding to an account that has removed its
     * identity) has been removed.
     **/
    DanglingUsernameRemoved: GenericPalletEvent<
      'Identity',
      'DanglingUsernameRemoved',
      { who: AccountId20; username: Bytes }
    >;

    /**
     * A username has been unbound.
     **/
    UsernameUnbound: GenericPalletEvent<'Identity', 'UsernameUnbound', { username: Bytes }>;

    /**
     * A username has been removed.
     **/
    UsernameRemoved: GenericPalletEvent<'Identity', 'UsernameRemoved', { username: Bytes }>;

    /**
     * A username has been killed.
     **/
    UsernameKilled: GenericPalletEvent<'Identity', 'UsernameKilled', { username: Bytes }>;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `Multisig`'s events
   **/
  multisig: {
    /**
     * A new multisig operation has begun.
     **/
    NewMultisig: GenericPalletEvent<
      'Multisig',
      'NewMultisig',
      { approving: AccountId20; multisig: AccountId20; callHash: FixedBytes<32> }
    >;

    /**
     * A multisig operation has been approved by someone.
     **/
    MultisigApproval: GenericPalletEvent<
      'Multisig',
      'MultisigApproval',
      { approving: AccountId20; timepoint: PalletMultisigTimepoint; multisig: AccountId20; callHash: FixedBytes<32> }
    >;

    /**
     * A multisig operation has been executed.
     **/
    MultisigExecuted: GenericPalletEvent<
      'Multisig',
      'MultisigExecuted',
      {
        approving: AccountId20;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId20;
        callHash: FixedBytes<32>;
        result: Result<[], DispatchError>;
      }
    >;

    /**
     * A multisig operation has been cancelled.
     **/
    MultisigCancelled: GenericPalletEvent<
      'Multisig',
      'MultisigCancelled',
      { cancelling: AccountId20; timepoint: PalletMultisigTimepoint; multisig: AccountId20; callHash: FixedBytes<32> }
    >;

    /**
     * The deposit for a multisig operation has been updated/poked.
     **/
    DepositPoked: GenericPalletEvent<
      'Multisig',
      'DepositPoked',
      { who: AccountId20; callHash: FixedBytes<32>; oldDeposit: bigint; newDeposit: bigint }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `Parameters`'s events
   **/
  parameters: {
    /**
     * A Parameter was set.
     *
     * Is also emitted when the value was not changed.
     **/
    Updated: GenericPalletEvent<
      'Parameters',
      'Updated',
      {
        /**
         * The key that was updated.
         **/
        key: MoonbeamRuntimeRuntimeParamsRuntimeParametersKey;

        /**
         * The old value before this call.
         **/
        oldValue?: MoonbeamRuntimeRuntimeParamsRuntimeParametersValue | undefined;

        /**
         * The new value after this call.
         **/
        newValue?: MoonbeamRuntimeRuntimeParamsRuntimeParametersValue | undefined;
      }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `EVM`'s events
   **/
  evm: {
    /**
     * Ethereum events from contracts.
     **/
    Log: GenericPalletEvent<'EVM', 'Log', { log: EthereumLog }>;

    /**
     * A contract has been created at given address.
     **/
    Created: GenericPalletEvent<'EVM', 'Created', { address: H160 }>;

    /**
     * A contract was attempted to be created, but the execution failed.
     **/
    CreatedFailed: GenericPalletEvent<'EVM', 'CreatedFailed', { address: H160 }>;

    /**
     * A contract has been executed successfully with states applied.
     **/
    Executed: GenericPalletEvent<'EVM', 'Executed', { address: H160 }>;

    /**
     * A contract has been executed with errors. States are reverted with only gas fees applied.
     **/
    ExecutedFailed: GenericPalletEvent<'EVM', 'ExecutedFailed', { address: H160 }>;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `Ethereum`'s events
   **/
  ethereum: {
    /**
     * An ethereum transaction was successfully executed.
     **/
    Executed: GenericPalletEvent<
      'Ethereum',
      'Executed',
      { from: H160; to: H160; transactionHash: H256; exitReason: EvmCoreErrorExitReason; extraData: Bytes }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `Scheduler`'s events
   **/
  scheduler: {
    /**
     * Scheduled some task.
     **/
    Scheduled: GenericPalletEvent<'Scheduler', 'Scheduled', { when: number; index: number }>;

    /**
     * Canceled some task.
     **/
    Canceled: GenericPalletEvent<'Scheduler', 'Canceled', { when: number; index: number }>;

    /**
     * Dispatched some task.
     **/
    Dispatched: GenericPalletEvent<
      'Scheduler',
      'Dispatched',
      { task: [number, number]; id?: FixedBytes<32> | undefined; result: Result<[], DispatchError> }
    >;

    /**
     * Set a retry configuration for some task.
     **/
    RetrySet: GenericPalletEvent<
      'Scheduler',
      'RetrySet',
      { task: [number, number]; id?: FixedBytes<32> | undefined; period: number; retries: number }
    >;

    /**
     * Cancel a retry configuration for some task.
     **/
    RetryCancelled: GenericPalletEvent<
      'Scheduler',
      'RetryCancelled',
      { task: [number, number]; id?: FixedBytes<32> | undefined }
    >;

    /**
     * The call for the provided hash was not found so the task has been aborted.
     **/
    CallUnavailable: GenericPalletEvent<
      'Scheduler',
      'CallUnavailable',
      { task: [number, number]; id?: FixedBytes<32> | undefined }
    >;

    /**
     * The given task was unable to be renewed since the agenda is full at that block.
     **/
    PeriodicFailed: GenericPalletEvent<
      'Scheduler',
      'PeriodicFailed',
      { task: [number, number]; id?: FixedBytes<32> | undefined }
    >;

    /**
     * The given task was unable to be retried since the agenda is full at that block or there
     * was not enough weight to reschedule it.
     **/
    RetryFailed: GenericPalletEvent<
      'Scheduler',
      'RetryFailed',
      { task: [number, number]; id?: FixedBytes<32> | undefined }
    >;

    /**
     * The given task can never be executed since it is overweight.
     **/
    PermanentlyOverweight: GenericPalletEvent<
      'Scheduler',
      'PermanentlyOverweight',
      { task: [number, number]; id?: FixedBytes<32> | undefined }
    >;

    /**
     * Agenda is incomplete from `when`.
     **/
    AgendaIncomplete: GenericPalletEvent<'Scheduler', 'AgendaIncomplete', { when: number }>;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `Preimage`'s events
   **/
  preimage: {
    /**
     * A preimage has been noted.
     **/
    Noted: GenericPalletEvent<'Preimage', 'Noted', { hash: H256 }>;

    /**
     * A preimage has been requested.
     **/
    Requested: GenericPalletEvent<'Preimage', 'Requested', { hash: H256 }>;

    /**
     * A preimage has ben cleared.
     **/
    Cleared: GenericPalletEvent<'Preimage', 'Cleared', { hash: H256 }>;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `ConvictionVoting`'s events
   **/
  convictionVoting: {
    /**
     * An account has delegated their vote to another account. \[who, target\]
     **/
    Delegated: GenericPalletEvent<'ConvictionVoting', 'Delegated', [AccountId20, AccountId20]>;

    /**
     * An \[account\] has cancelled a previous delegation operation.
     **/
    Undelegated: GenericPalletEvent<'ConvictionVoting', 'Undelegated', AccountId20>;

    /**
     * An account has voted
     **/
    Voted: GenericPalletEvent<
      'ConvictionVoting',
      'Voted',
      { who: AccountId20; vote: PalletConvictionVotingVoteAccountVote }
    >;

    /**
     * A vote has been removed
     **/
    VoteRemoved: GenericPalletEvent<
      'ConvictionVoting',
      'VoteRemoved',
      { who: AccountId20; vote: PalletConvictionVotingVoteAccountVote }
    >;

    /**
     * The lockup period of a conviction vote expired, and the funds have been unlocked.
     **/
    VoteUnlocked: GenericPalletEvent<'ConvictionVoting', 'VoteUnlocked', { who: AccountId20; class: number }>;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `Referenda`'s events
   **/
  referenda: {
    /**
     * A referendum has been submitted.
     **/
    Submitted: GenericPalletEvent<
      'Referenda',
      'Submitted',
      {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The track (and by extension proposal dispatch origin) of this referendum.
         **/
        track: number;

        /**
         * The proposal for the referendum.
         **/
        proposal: FrameSupportPreimagesBounded;
      }
    >;

    /**
     * The decision deposit has been placed.
     **/
    DecisionDepositPlaced: GenericPalletEvent<
      'Referenda',
      'DecisionDepositPlaced',
      {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId20;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      }
    >;

    /**
     * The decision deposit has been refunded.
     **/
    DecisionDepositRefunded: GenericPalletEvent<
      'Referenda',
      'DecisionDepositRefunded',
      {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId20;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      }
    >;

    /**
     * A deposit has been slashed.
     **/
    DepositSlashed: GenericPalletEvent<
      'Referenda',
      'DepositSlashed',
      {
        /**
         * The account who placed the deposit.
         **/
        who: AccountId20;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      }
    >;

    /**
     * A referendum has moved into the deciding phase.
     **/
    DecisionStarted: GenericPalletEvent<
      'Referenda',
      'DecisionStarted',
      {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The track (and by extension proposal dispatch origin) of this referendum.
         **/
        track: number;

        /**
         * The proposal for the referendum.
         **/
        proposal: FrameSupportPreimagesBounded;

        /**
         * The current tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      }
    >;
    ConfirmStarted: GenericPalletEvent<
      'Referenda',
      'ConfirmStarted',
      {
        /**
         * Index of the referendum.
         **/
        index: number;
      }
    >;
    ConfirmAborted: GenericPalletEvent<
      'Referenda',
      'ConfirmAborted',
      {
        /**
         * Index of the referendum.
         **/
        index: number;
      }
    >;

    /**
     * A referendum has ended its confirmation phase and is ready for approval.
     **/
    Confirmed: GenericPalletEvent<
      'Referenda',
      'Confirmed',
      {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      }
    >;

    /**
     * A referendum has been approved and its proposal has been scheduled.
     **/
    Approved: GenericPalletEvent<
      'Referenda',
      'Approved',
      {
        /**
         * Index of the referendum.
         **/
        index: number;
      }
    >;

    /**
     * A proposal has been rejected by referendum.
     **/
    Rejected: GenericPalletEvent<
      'Referenda',
      'Rejected',
      {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      }
    >;

    /**
     * A referendum has been timed out without being decided.
     **/
    TimedOut: GenericPalletEvent<
      'Referenda',
      'TimedOut',
      {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      }
    >;

    /**
     * A referendum has been cancelled.
     **/
    Cancelled: GenericPalletEvent<
      'Referenda',
      'Cancelled',
      {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      }
    >;

    /**
     * A referendum has been killed.
     **/
    Killed: GenericPalletEvent<
      'Referenda',
      'Killed',
      {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      }
    >;

    /**
     * The submission deposit has been refunded.
     **/
    SubmissionDepositRefunded: GenericPalletEvent<
      'Referenda',
      'SubmissionDepositRefunded',
      {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId20;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      }
    >;

    /**
     * Metadata for a referendum has been set.
     **/
    MetadataSet: GenericPalletEvent<
      'Referenda',
      'MetadataSet',
      {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * Preimage hash.
         **/
        hash: H256;
      }
    >;

    /**
     * Metadata for a referendum has been cleared.
     **/
    MetadataCleared: GenericPalletEvent<
      'Referenda',
      'MetadataCleared',
      {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * Preimage hash.
         **/
        hash: H256;
      }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `Whitelist`'s events
   **/
  whitelist: {
    CallWhitelisted: GenericPalletEvent<'Whitelist', 'CallWhitelisted', { callHash: H256 }>;
    WhitelistedCallRemoved: GenericPalletEvent<'Whitelist', 'WhitelistedCallRemoved', { callHash: H256 }>;
    WhitelistedCallDispatched: GenericPalletEvent<
      'Whitelist',
      'WhitelistedCallDispatched',
      { callHash: H256; result: Result<FrameSupportDispatchPostDispatchInfo, SpRuntimeDispatchErrorWithPostInfo> }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `TreasuryCouncilCollective`'s events
   **/
  treasuryCouncilCollective: {
    /**
     * A motion (given hash) has been proposed (by given account) with a threshold (given
     * `MemberCount`).
     **/
    Proposed: GenericPalletEvent<
      'TreasuryCouncilCollective',
      'Proposed',
      { account: AccountId20; proposalIndex: number; proposalHash: H256; threshold: number }
    >;

    /**
     * A motion (given hash) has been voted on by given account, leaving
     * a tally (yes votes and no votes given respectively as `MemberCount`).
     **/
    Voted: GenericPalletEvent<
      'TreasuryCouncilCollective',
      'Voted',
      { account: AccountId20; proposalHash: H256; voted: boolean; yes: number; no: number }
    >;

    /**
     * A motion was approved by the required threshold.
     **/
    Approved: GenericPalletEvent<'TreasuryCouncilCollective', 'Approved', { proposalHash: H256 }>;

    /**
     * A motion was not approved by the required threshold.
     **/
    Disapproved: GenericPalletEvent<'TreasuryCouncilCollective', 'Disapproved', { proposalHash: H256 }>;

    /**
     * A motion was executed; result will be `Ok` if it returned without error.
     **/
    Executed: GenericPalletEvent<
      'TreasuryCouncilCollective',
      'Executed',
      { proposalHash: H256; result: Result<[], DispatchError> }
    >;

    /**
     * A single member did some action; result will be `Ok` if it returned without error.
     **/
    MemberExecuted: GenericPalletEvent<
      'TreasuryCouncilCollective',
      'MemberExecuted',
      { proposalHash: H256; result: Result<[], DispatchError> }
    >;

    /**
     * A proposal was closed because its threshold was reached or after its duration was up.
     **/
    Closed: GenericPalletEvent<'TreasuryCouncilCollective', 'Closed', { proposalHash: H256; yes: number; no: number }>;

    /**
     * A proposal was killed.
     **/
    Killed: GenericPalletEvent<'TreasuryCouncilCollective', 'Killed', { proposalHash: H256 }>;

    /**
     * Some cost for storing a proposal was burned.
     **/
    ProposalCostBurned: GenericPalletEvent<
      'TreasuryCouncilCollective',
      'ProposalCostBurned',
      { proposalHash: H256; who: AccountId20 }
    >;

    /**
     * Some cost for storing a proposal was released.
     **/
    ProposalCostReleased: GenericPalletEvent<
      'TreasuryCouncilCollective',
      'ProposalCostReleased',
      { proposalHash: H256; who: AccountId20 }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `OpenTechCommitteeCollective`'s events
   **/
  openTechCommitteeCollective: {
    /**
     * A motion (given hash) has been proposed (by given account) with a threshold (given
     * `MemberCount`).
     **/
    Proposed: GenericPalletEvent<
      'OpenTechCommitteeCollective',
      'Proposed',
      { account: AccountId20; proposalIndex: number; proposalHash: H256; threshold: number }
    >;

    /**
     * A motion (given hash) has been voted on by given account, leaving
     * a tally (yes votes and no votes given respectively as `MemberCount`).
     **/
    Voted: GenericPalletEvent<
      'OpenTechCommitteeCollective',
      'Voted',
      { account: AccountId20; proposalHash: H256; voted: boolean; yes: number; no: number }
    >;

    /**
     * A motion was approved by the required threshold.
     **/
    Approved: GenericPalletEvent<'OpenTechCommitteeCollective', 'Approved', { proposalHash: H256 }>;

    /**
     * A motion was not approved by the required threshold.
     **/
    Disapproved: GenericPalletEvent<'OpenTechCommitteeCollective', 'Disapproved', { proposalHash: H256 }>;

    /**
     * A motion was executed; result will be `Ok` if it returned without error.
     **/
    Executed: GenericPalletEvent<
      'OpenTechCommitteeCollective',
      'Executed',
      { proposalHash: H256; result: Result<[], DispatchError> }
    >;

    /**
     * A single member did some action; result will be `Ok` if it returned without error.
     **/
    MemberExecuted: GenericPalletEvent<
      'OpenTechCommitteeCollective',
      'MemberExecuted',
      { proposalHash: H256; result: Result<[], DispatchError> }
    >;

    /**
     * A proposal was closed because its threshold was reached or after its duration was up.
     **/
    Closed: GenericPalletEvent<
      'OpenTechCommitteeCollective',
      'Closed',
      { proposalHash: H256; yes: number; no: number }
    >;

    /**
     * A proposal was killed.
     **/
    Killed: GenericPalletEvent<'OpenTechCommitteeCollective', 'Killed', { proposalHash: H256 }>;

    /**
     * Some cost for storing a proposal was burned.
     **/
    ProposalCostBurned: GenericPalletEvent<
      'OpenTechCommitteeCollective',
      'ProposalCostBurned',
      { proposalHash: H256; who: AccountId20 }
    >;

    /**
     * Some cost for storing a proposal was released.
     **/
    ProposalCostReleased: GenericPalletEvent<
      'OpenTechCommitteeCollective',
      'ProposalCostReleased',
      { proposalHash: H256; who: AccountId20 }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `Treasury`'s events
   **/
  treasury: {
    /**
     * We have ended a spend period and will now allocate funds.
     **/
    Spending: GenericPalletEvent<'Treasury', 'Spending', { budgetRemaining: bigint }>;

    /**
     * Some funds have been allocated.
     **/
    Awarded: GenericPalletEvent<'Treasury', 'Awarded', { proposalIndex: number; award: bigint; account: AccountId20 }>;

    /**
     * Some of our funds have been burnt.
     **/
    Burnt: GenericPalletEvent<'Treasury', 'Burnt', { burntFunds: bigint }>;

    /**
     * Spending has finished; this is the amount that rolls over until next spend.
     **/
    Rollover: GenericPalletEvent<'Treasury', 'Rollover', { rolloverBalance: bigint }>;

    /**
     * Some funds have been deposited.
     **/
    Deposit: GenericPalletEvent<'Treasury', 'Deposit', { value: bigint }>;

    /**
     * A new spend proposal has been approved.
     **/
    SpendApproved: GenericPalletEvent<
      'Treasury',
      'SpendApproved',
      { proposalIndex: number; amount: bigint; beneficiary: AccountId20 }
    >;

    /**
     * The inactive funds of the pallet have been updated.
     **/
    UpdatedInactive: GenericPalletEvent<'Treasury', 'UpdatedInactive', { reactivated: bigint; deactivated: bigint }>;

    /**
     * A new asset spend proposal has been approved.
     **/
    AssetSpendApproved: GenericPalletEvent<
      'Treasury',
      'AssetSpendApproved',
      {
        index: number;
        assetKind: FrameSupportTokensFungibleUnionOfNativeOrWithId;
        amount: bigint;
        beneficiary: AccountId20;
        validFrom: number;
        expireAt: number;
      }
    >;

    /**
     * An approved spend was voided.
     **/
    AssetSpendVoided: GenericPalletEvent<'Treasury', 'AssetSpendVoided', { index: number }>;

    /**
     * A payment happened.
     **/
    Paid: GenericPalletEvent<'Treasury', 'Paid', { index: number; paymentId: [] }>;

    /**
     * A payment failed and can be retried.
     **/
    PaymentFailed: GenericPalletEvent<'Treasury', 'PaymentFailed', { index: number; paymentId: [] }>;

    /**
     * A spend was processed and removed from the storage. It might have been successfully
     * paid or it may have expired.
     **/
    SpendProcessed: GenericPalletEvent<'Treasury', 'SpendProcessed', { index: number }>;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `CrowdloanRewards`'s events
   **/
  crowdloanRewards: {
    /**
     * The initial payment of InitializationPayment % was paid
     **/
    InitialPaymentMade: GenericPalletEvent<'CrowdloanRewards', 'InitialPaymentMade', [AccountId20, bigint]>;

    /**
     * Someone has proven they made a contribution and associated a native identity with it.
     * Data is the relay account, native account and the total amount of _rewards_ that will be paid
     **/
    NativeIdentityAssociated: GenericPalletEvent<
      'CrowdloanRewards',
      'NativeIdentityAssociated',
      [FixedBytes<32>, AccountId20, bigint]
    >;

    /**
     * A contributor has claimed some rewards.
     * Data is the account getting paid and the amount of rewards paid.
     **/
    RewardsPaid: GenericPalletEvent<'CrowdloanRewards', 'RewardsPaid', [AccountId20, bigint]>;

    /**
     * A contributor has updated the reward address.
     **/
    RewardAddressUpdated: GenericPalletEvent<'CrowdloanRewards', 'RewardAddressUpdated', [AccountId20, AccountId20]>;

    /**
     * When initializing the reward vec an already initialized account was found
     **/
    InitializedAlreadyInitializedAccount: GenericPalletEvent<
      'CrowdloanRewards',
      'InitializedAlreadyInitializedAccount',
      [FixedBytes<32>, AccountId20 | undefined, bigint]
    >;

    /**
     * When initializing the reward vec an already initialized account was found
     **/
    InitializedAccountWithNotEnoughContribution: GenericPalletEvent<
      'CrowdloanRewards',
      'InitializedAccountWithNotEnoughContribution',
      [FixedBytes<32>, AccountId20 | undefined, bigint]
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `XcmpQueue`'s events
   **/
  xcmpQueue: {
    /**
     * An HRMP message was sent to a sibling parachain.
     **/
    XcmpMessageSent: GenericPalletEvent<'XcmpQueue', 'XcmpMessageSent', { messageHash: FixedBytes<32> }>;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `CumulusXcm`'s events
   **/
  cumulusXcm: {
    /**
     * Downward message is invalid XCM.
     * \[ id \]
     **/
    InvalidFormat: GenericPalletEvent<'CumulusXcm', 'InvalidFormat', FixedBytes<32>>;

    /**
     * Downward message is unsupported version of XCM.
     * \[ id \]
     **/
    UnsupportedVersion: GenericPalletEvent<'CumulusXcm', 'UnsupportedVersion', FixedBytes<32>>;

    /**
     * Downward message executed with the given outcome.
     * \[ id, outcome \]
     **/
    ExecutedDownward: GenericPalletEvent<'CumulusXcm', 'ExecutedDownward', [FixedBytes<32>, StagingXcmV5TraitsOutcome]>;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `PolkadotXcm`'s events
   **/
  polkadotXcm: {
    /**
     * Execution of an XCM message was attempted.
     **/
    Attempted: GenericPalletEvent<'PolkadotXcm', 'Attempted', { outcome: StagingXcmV5TraitsOutcome }>;

    /**
     * An XCM message was sent.
     **/
    Sent: GenericPalletEvent<
      'PolkadotXcm',
      'Sent',
      {
        origin: StagingXcmV5Location;
        destination: StagingXcmV5Location;
        message: StagingXcmV5Xcm;
        messageId: FixedBytes<32>;
      }
    >;

    /**
     * An XCM message failed to send.
     **/
    SendFailed: GenericPalletEvent<
      'PolkadotXcm',
      'SendFailed',
      {
        origin: StagingXcmV5Location;
        destination: StagingXcmV5Location;
        error: XcmV3TraitsSendError;
        messageId: FixedBytes<32>;
      }
    >;

    /**
     * An XCM message failed to process.
     **/
    ProcessXcmError: GenericPalletEvent<
      'PolkadotXcm',
      'ProcessXcmError',
      { origin: StagingXcmV5Location; error: XcmV5TraitsError; messageId: FixedBytes<32> }
    >;

    /**
     * Query response received which does not match a registered query. This may be because a
     * matching query was never registered, it may be because it is a duplicate response, or
     * because the query timed out.
     **/
    UnexpectedResponse: GenericPalletEvent<
      'PolkadotXcm',
      'UnexpectedResponse',
      { origin: StagingXcmV5Location; queryId: bigint }
    >;

    /**
     * Query response has been received and is ready for taking with `take_response`. There is
     * no registered notification call.
     **/
    ResponseReady: GenericPalletEvent<
      'PolkadotXcm',
      'ResponseReady',
      { queryId: bigint; response: StagingXcmV5Response }
    >;

    /**
     * Query response has been received and query is removed. The registered notification has
     * been dispatched and executed successfully.
     **/
    Notified: GenericPalletEvent<
      'PolkadotXcm',
      'Notified',
      { queryId: bigint; palletIndex: number; callIndex: number }
    >;

    /**
     * Query response has been received and query is removed. The registered notification
     * could not be dispatched because the dispatch weight is greater than the maximum weight
     * originally budgeted by this runtime for the query result.
     **/
    NotifyOverweight: GenericPalletEvent<
      'PolkadotXcm',
      'NotifyOverweight',
      {
        queryId: bigint;
        palletIndex: number;
        callIndex: number;
        actualWeight: SpWeightsWeightV2Weight;
        maxBudgetedWeight: SpWeightsWeightV2Weight;
      }
    >;

    /**
     * Query response has been received and query is removed. There was a general error with
     * dispatching the notification call.
     **/
    NotifyDispatchError: GenericPalletEvent<
      'PolkadotXcm',
      'NotifyDispatchError',
      { queryId: bigint; palletIndex: number; callIndex: number }
    >;

    /**
     * Query response has been received and query is removed. The dispatch was unable to be
     * decoded into a `Call`; this might be due to dispatch function having a signature which
     * is not `(origin, QueryId, Response)`.
     **/
    NotifyDecodeFailed: GenericPalletEvent<
      'PolkadotXcm',
      'NotifyDecodeFailed',
      { queryId: bigint; palletIndex: number; callIndex: number }
    >;

    /**
     * Expected query response has been received but the origin location of the response does
     * not match that expected. The query remains registered for a later, valid, response to
     * be received and acted upon.
     **/
    InvalidResponder: GenericPalletEvent<
      'PolkadotXcm',
      'InvalidResponder',
      { origin: StagingXcmV5Location; queryId: bigint; expectedLocation?: StagingXcmV5Location | undefined }
    >;

    /**
     * Expected query response has been received but the expected origin location placed in
     * storage by this runtime previously cannot be decoded. The query remains registered.
     *
     * This is unexpected (since a location placed in storage in a previously executing
     * runtime should be readable prior to query timeout) and dangerous since the possibly
     * valid response will be dropped. Manual governance intervention is probably going to be
     * needed.
     **/
    InvalidResponderVersion: GenericPalletEvent<
      'PolkadotXcm',
      'InvalidResponderVersion',
      { origin: StagingXcmV5Location; queryId: bigint }
    >;

    /**
     * Received query response has been read and removed.
     **/
    ResponseTaken: GenericPalletEvent<'PolkadotXcm', 'ResponseTaken', { queryId: bigint }>;

    /**
     * Some assets have been placed in an asset trap.
     **/
    AssetsTrapped: GenericPalletEvent<
      'PolkadotXcm',
      'AssetsTrapped',
      { hash: H256; origin: StagingXcmV5Location; assets: XcmVersionedAssets }
    >;

    /**
     * An XCM version change notification message has been attempted to be sent.
     *
     * The cost of sending it (borne by the chain) is included.
     **/
    VersionChangeNotified: GenericPalletEvent<
      'PolkadotXcm',
      'VersionChangeNotified',
      { destination: StagingXcmV5Location; result: number; cost: StagingXcmV5AssetAssets; messageId: FixedBytes<32> }
    >;

    /**
     * The supported version of a location has been changed. This might be through an
     * automatic notification or a manual intervention.
     **/
    SupportedVersionChanged: GenericPalletEvent<
      'PolkadotXcm',
      'SupportedVersionChanged',
      { location: StagingXcmV5Location; version: number }
    >;

    /**
     * A given location which had a version change subscription was dropped owing to an error
     * sending the notification to it.
     **/
    NotifyTargetSendFail: GenericPalletEvent<
      'PolkadotXcm',
      'NotifyTargetSendFail',
      { location: StagingXcmV5Location; queryId: bigint; error: XcmV5TraitsError }
    >;

    /**
     * A given location which had a version change subscription was dropped owing to an error
     * migrating the location to our new XCM format.
     **/
    NotifyTargetMigrationFail: GenericPalletEvent<
      'PolkadotXcm',
      'NotifyTargetMigrationFail',
      { location: XcmVersionedLocation; queryId: bigint }
    >;

    /**
     * Expected query response has been received but the expected querier location placed in
     * storage by this runtime previously cannot be decoded. The query remains registered.
     *
     * This is unexpected (since a location placed in storage in a previously executing
     * runtime should be readable prior to query timeout) and dangerous since the possibly
     * valid response will be dropped. Manual governance intervention is probably going to be
     * needed.
     **/
    InvalidQuerierVersion: GenericPalletEvent<
      'PolkadotXcm',
      'InvalidQuerierVersion',
      { origin: StagingXcmV5Location; queryId: bigint }
    >;

    /**
     * Expected query response has been received but the querier location of the response does
     * not match the expected. The query remains registered for a later, valid, response to
     * be received and acted upon.
     **/
    InvalidQuerier: GenericPalletEvent<
      'PolkadotXcm',
      'InvalidQuerier',
      {
        origin: StagingXcmV5Location;
        queryId: bigint;
        expectedQuerier: StagingXcmV5Location;
        maybeActualQuerier?: StagingXcmV5Location | undefined;
      }
    >;

    /**
     * A remote has requested XCM version change notification from us and we have honored it.
     * A version information message is sent to them and its cost is included.
     **/
    VersionNotifyStarted: GenericPalletEvent<
      'PolkadotXcm',
      'VersionNotifyStarted',
      { destination: StagingXcmV5Location; cost: StagingXcmV5AssetAssets; messageId: FixedBytes<32> }
    >;

    /**
     * We have requested that a remote chain send us XCM version change notifications.
     **/
    VersionNotifyRequested: GenericPalletEvent<
      'PolkadotXcm',
      'VersionNotifyRequested',
      { destination: StagingXcmV5Location; cost: StagingXcmV5AssetAssets; messageId: FixedBytes<32> }
    >;

    /**
     * We have requested that a remote chain stops sending us XCM version change
     * notifications.
     **/
    VersionNotifyUnrequested: GenericPalletEvent<
      'PolkadotXcm',
      'VersionNotifyUnrequested',
      { destination: StagingXcmV5Location; cost: StagingXcmV5AssetAssets; messageId: FixedBytes<32> }
    >;

    /**
     * Fees were paid from a location for an operation (often for using `SendXcm`).
     **/
    FeesPaid: GenericPalletEvent<
      'PolkadotXcm',
      'FeesPaid',
      { paying: StagingXcmV5Location; fees: StagingXcmV5AssetAssets }
    >;

    /**
     * Some assets have been claimed from an asset trap
     **/
    AssetsClaimed: GenericPalletEvent<
      'PolkadotXcm',
      'AssetsClaimed',
      { hash: H256; origin: StagingXcmV5Location; assets: XcmVersionedAssets }
    >;

    /**
     * A XCM version migration finished.
     **/
    VersionMigrationFinished: GenericPalletEvent<'PolkadotXcm', 'VersionMigrationFinished', { version: number }>;

    /**
     * An `aliaser` location was authorized by `target` to alias it, authorization valid until
     * `expiry` block number.
     **/
    AliasAuthorized: GenericPalletEvent<
      'PolkadotXcm',
      'AliasAuthorized',
      { aliaser: StagingXcmV5Location; target: StagingXcmV5Location; expiry?: bigint | undefined }
    >;

    /**
     * `target` removed alias authorization for `aliaser`.
     **/
    AliasAuthorizationRemoved: GenericPalletEvent<
      'PolkadotXcm',
      'AliasAuthorizationRemoved',
      { aliaser: StagingXcmV5Location; target: StagingXcmV5Location }
    >;

    /**
     * `target` removed all alias authorizations.
     **/
    AliasesAuthorizationsRemoved: GenericPalletEvent<
      'PolkadotXcm',
      'AliasesAuthorizationsRemoved',
      { target: StagingXcmV5Location }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `XcmTransactor`'s events
   **/
  xcmTransactor: {
    /**
     * Transacted the inner call through a derivative account in a destination chain.
     **/
    TransactedDerivative: GenericPalletEvent<
      'XcmTransactor',
      'TransactedDerivative',
      { accountId: AccountId20; dest: StagingXcmV5Location; call: Bytes; index: number }
    >;

    /**
     * Transacted the call through the sovereign account in a destination chain.
     **/
    TransactedSovereign: GenericPalletEvent<
      'XcmTransactor',
      'TransactedSovereign',
      { feePayer?: AccountId20 | undefined; dest: StagingXcmV5Location; call: Bytes }
    >;

    /**
     * Transacted the call through a signed account in a destination chain.
     **/
    TransactedSigned: GenericPalletEvent<
      'XcmTransactor',
      'TransactedSigned',
      { feePayer: AccountId20; dest: StagingXcmV5Location; call: Bytes }
    >;

    /**
     * Registered a derivative index for an account id.
     **/
    RegisteredDerivative: GenericPalletEvent<
      'XcmTransactor',
      'RegisteredDerivative',
      { accountId: AccountId20; index: number }
    >;
    DeRegisteredDerivative: GenericPalletEvent<'XcmTransactor', 'DeRegisteredDerivative', { index: number }>;

    /**
     * Transact failed
     **/
    TransactFailed: GenericPalletEvent<'XcmTransactor', 'TransactFailed', { error: XcmV5TraitsError }>;

    /**
     * Changed the transact info of a location
     **/
    TransactInfoChanged: GenericPalletEvent<
      'XcmTransactor',
      'TransactInfoChanged',
      { location: StagingXcmV5Location; remoteInfo: PalletXcmTransactorRemoteTransactInfoWithMaxWeight }
    >;

    /**
     * Removed the transact info of a location
     **/
    TransactInfoRemoved: GenericPalletEvent<'XcmTransactor', 'TransactInfoRemoved', { location: StagingXcmV5Location }>;

    /**
     * Set dest fee per second
     **/
    DestFeePerSecondChanged: GenericPalletEvent<
      'XcmTransactor',
      'DestFeePerSecondChanged',
      { location: StagingXcmV5Location; feePerSecond: bigint }
    >;

    /**
     * Remove dest fee per second
     **/
    DestFeePerSecondRemoved: GenericPalletEvent<
      'XcmTransactor',
      'DestFeePerSecondRemoved',
      { location: StagingXcmV5Location }
    >;

    /**
     * HRMP manage action succesfully sent
     **/
    HrmpManagementSent: GenericPalletEvent<
      'XcmTransactor',
      'HrmpManagementSent',
      { action: PalletXcmTransactorHrmpOperation }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `EthereumXcm`'s events
   **/
  ethereumXcm: {
    /**
     * Ethereum transaction executed from XCM
     **/
    ExecutedFromXcm: GenericPalletEvent<'EthereumXcm', 'ExecutedFromXcm', { xcmMsgHash: H256; ethTxHash: H256 }>;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `MessageQueue`'s events
   **/
  messageQueue: {
    /**
     * Message discarded due to an error in the `MessageProcessor` (usually a format error).
     **/
    ProcessingFailed: GenericPalletEvent<
      'MessageQueue',
      'ProcessingFailed',
      {
        /**
         * The `blake2_256` hash of the message.
         **/
        id: H256;

        /**
         * The queue of the message.
         **/
        origin: CumulusPrimitivesCoreAggregateMessageOrigin;

        /**
         * The error that occurred.
         *
         * This error is pretty opaque. More fine-grained errors need to be emitted as events
         * by the `MessageProcessor`.
         **/
        error: FrameSupportMessagesProcessMessageError;
      }
    >;

    /**
     * Message is processed.
     **/
    Processed: GenericPalletEvent<
      'MessageQueue',
      'Processed',
      {
        /**
         * The `blake2_256` hash of the message.
         **/
        id: H256;

        /**
         * The queue of the message.
         **/
        origin: CumulusPrimitivesCoreAggregateMessageOrigin;

        /**
         * How much weight was used to process the message.
         **/
        weightUsed: SpWeightsWeightV2Weight;

        /**
         * Whether the message was processed.
         *
         * Note that this does not mean that the underlying `MessageProcessor` was internally
         * successful. It *solely* means that the MQ pallet will treat this as a success
         * condition and discard the message. Any internal error needs to be emitted as events
         * by the `MessageProcessor`.
         **/
        success: boolean;
      }
    >;

    /**
     * Message placed in overweight queue.
     **/
    OverweightEnqueued: GenericPalletEvent<
      'MessageQueue',
      'OverweightEnqueued',
      {
        /**
         * The `blake2_256` hash of the message.
         **/
        id: FixedBytes<32>;

        /**
         * The queue of the message.
         **/
        origin: CumulusPrimitivesCoreAggregateMessageOrigin;

        /**
         * The page of the message.
         **/
        pageIndex: number;

        /**
         * The index of the message within the page.
         **/
        messageIndex: number;
      }
    >;

    /**
     * This page was reaped.
     **/
    PageReaped: GenericPalletEvent<
      'MessageQueue',
      'PageReaped',
      {
        /**
         * The queue of the page.
         **/
        origin: CumulusPrimitivesCoreAggregateMessageOrigin;

        /**
         * The index of the page.
         **/
        index: number;
      }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `EvmForeignAssets`'s events
   **/
  evmForeignAssets: {
    /**
     * New asset with the asset manager is registered
     **/
    ForeignAssetCreated: GenericPalletEvent<
      'EvmForeignAssets',
      'ForeignAssetCreated',
      { contractAddress: H160; assetId: bigint; xcmLocation: StagingXcmV5Location; deposit?: bigint | undefined }
    >;

    /**
     * Changed the xcm type mapping for a given asset id
     **/
    ForeignAssetXcmLocationChanged: GenericPalletEvent<
      'EvmForeignAssets',
      'ForeignAssetXcmLocationChanged',
      { assetId: bigint; previousXcmLocation: StagingXcmV5Location; newXcmLocation: StagingXcmV5Location }
    >;
    ForeignAssetFrozen: GenericPalletEvent<
      'EvmForeignAssets',
      'ForeignAssetFrozen',
      { assetId: bigint; xcmLocation: StagingXcmV5Location }
    >;
    ForeignAssetUnfrozen: GenericPalletEvent<
      'EvmForeignAssets',
      'ForeignAssetUnfrozen',
      { assetId: bigint; xcmLocation: StagingXcmV5Location }
    >;

    /**
     * Tokens have been locked for asset creation
     **/
    TokensLocked: GenericPalletEvent<'EvmForeignAssets', 'TokensLocked', [AccountId20, bigint, U256]>;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `XcmWeightTrader`'s events
   **/
  xcmWeightTrader: {
    /**
     * New supported asset is registered
     **/
    SupportedAssetAdded: GenericPalletEvent<
      'XcmWeightTrader',
      'SupportedAssetAdded',
      { location: StagingXcmV5Location; relativePrice: bigint }
    >;

    /**
     * Changed the amount of units we are charging per execution second for a given asset
     **/
    SupportedAssetEdited: GenericPalletEvent<
      'XcmWeightTrader',
      'SupportedAssetEdited',
      { location: StagingXcmV5Location; relativePrice: bigint }
    >;

    /**
     * Pause support for a given asset
     **/
    PauseAssetSupport: GenericPalletEvent<'XcmWeightTrader', 'PauseAssetSupport', { location: StagingXcmV5Location }>;

    /**
     * Resume support for a given asset
     **/
    ResumeAssetSupport: GenericPalletEvent<'XcmWeightTrader', 'ResumeAssetSupport', { location: StagingXcmV5Location }>;

    /**
     * Supported asset type for fee payment removed
     **/
    SupportedAssetRemoved: GenericPalletEvent<
      'XcmWeightTrader',
      'SupportedAssetRemoved',
      { location: StagingXcmV5Location }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `EmergencyParaXcm`'s events
   **/
  emergencyParaXcm: {
    /**
     * The XCM incoming execution was Paused
     **/
    EnteredPausedXcmMode: GenericPalletEvent<'EmergencyParaXcm', 'EnteredPausedXcmMode', undefined>;

    /**
     * The XCM incoming execution returned to normal operation
     **/
    NormalXcmOperationResumed: GenericPalletEvent<'EmergencyParaXcm', 'NormalXcmOperationResumed', undefined>;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `MultiBlockMigrations`'s events
   **/
  multiBlockMigrations: {
    /**
     * A Runtime upgrade started.
     *
     * Its end is indicated by `UpgradeCompleted` or `UpgradeFailed`.
     **/
    UpgradeStarted: GenericPalletEvent<
      'MultiBlockMigrations',
      'UpgradeStarted',
      {
        /**
         * The number of migrations that this upgrade contains.
         *
         * This can be used to design a progress indicator in combination with counting the
         * `MigrationCompleted` and `MigrationSkipped` events.
         **/
        migrations: number;
      }
    >;

    /**
     * The current runtime upgrade completed.
     *
     * This implies that all of its migrations completed successfully as well.
     **/
    UpgradeCompleted: GenericPalletEvent<'MultiBlockMigrations', 'UpgradeCompleted', null>;

    /**
     * Runtime upgrade failed.
     *
     * This is very bad and will require governance intervention.
     **/
    UpgradeFailed: GenericPalletEvent<'MultiBlockMigrations', 'UpgradeFailed', null>;

    /**
     * A migration was skipped since it was already executed in the past.
     **/
    MigrationSkipped: GenericPalletEvent<
      'MultiBlockMigrations',
      'MigrationSkipped',
      {
        /**
         * The index of the skipped migration within the [`Config::Migrations`] list.
         **/
        index: number;
      }
    >;

    /**
     * A migration progressed.
     **/
    MigrationAdvanced: GenericPalletEvent<
      'MultiBlockMigrations',
      'MigrationAdvanced',
      {
        /**
         * The index of the migration within the [`Config::Migrations`] list.
         **/
        index: number;

        /**
         * The number of blocks that this migration took so far.
         **/
        took: number;
      }
    >;

    /**
     * A Migration completed.
     **/
    MigrationCompleted: GenericPalletEvent<
      'MultiBlockMigrations',
      'MigrationCompleted',
      {
        /**
         * The index of the migration within the [`Config::Migrations`] list.
         **/
        index: number;

        /**
         * The number of blocks that this migration took so far.
         **/
        took: number;
      }
    >;

    /**
     * A Migration failed.
     *
     * This implies that the whole upgrade failed and governance intervention is required.
     **/
    MigrationFailed: GenericPalletEvent<
      'MultiBlockMigrations',
      'MigrationFailed',
      {
        /**
         * The index of the migration within the [`Config::Migrations`] list.
         **/
        index: number;

        /**
         * The number of blocks that this migration took so far.
         **/
        took: number;
      }
    >;

    /**
     * The set of historical migrations has been cleared.
     **/
    HistoricCleared: GenericPalletEvent<
      'MultiBlockMigrations',
      'HistoricCleared',
      {
        /**
         * Should be passed to `clear_historic` in a successive call.
         **/
        nextCursor?: Bytes | undefined;
      }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `Randomness`'s events
   **/
  randomness: {
    RandomnessRequestedBabeEpoch: GenericPalletEvent<
      'Randomness',
      'RandomnessRequestedBabeEpoch',
      {
        id: bigint;
        refundAddress: H160;
        contractAddress: H160;
        fee: bigint;
        gasLimit: bigint;
        numWords: number;
        salt: H256;
        earliestEpoch: bigint;
      }
    >;
    RandomnessRequestedLocal: GenericPalletEvent<
      'Randomness',
      'RandomnessRequestedLocal',
      {
        id: bigint;
        refundAddress: H160;
        contractAddress: H160;
        fee: bigint;
        gasLimit: bigint;
        numWords: number;
        salt: H256;
        earliestBlock: number;
      }
    >;
    RequestFulfilled: GenericPalletEvent<'Randomness', 'RequestFulfilled', { id: bigint }>;
    RequestFeeIncreased: GenericPalletEvent<'Randomness', 'RequestFeeIncreased', { id: bigint; newFee: bigint }>;
    RequestExpirationExecuted: GenericPalletEvent<'Randomness', 'RequestExpirationExecuted', { id: bigint }>;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `BridgeKusamaGrandpa`'s events
   **/
  bridgeKusamaGrandpa: {
    /**
     * Best finalized chain header has been updated to the header with given number and hash.
     **/
    UpdatedBestFinalizedHeader: GenericPalletEvent<
      'BridgeKusamaGrandpa',
      'UpdatedBestFinalizedHeader',
      {
        /**
         * Number of the new best finalized header.
         **/
        number: number;

        /**
         * Hash of the new best finalized header.
         **/
        hash: H256;

        /**
         * The Grandpa info associated to the new best finalized header.
         **/
        grandpaInfo: BpHeaderChainHeaderFinalityInfo;
      }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `BridgeKusamaParachains`'s events
   **/
  bridgeKusamaParachains: {
    /**
     * The caller has provided head of parachain that the pallet is not configured to track.
     **/
    UntrackedParachainRejected: GenericPalletEvent<
      'BridgeKusamaParachains',
      'UntrackedParachainRejected',
      {
        /**
         * Identifier of the parachain that is not tracked by the pallet.
         **/
        parachain: BpPolkadotCoreParachainsParaId;
      }
    >;

    /**
     * The caller has declared that he has provided given parachain head, but it is missing
     * from the storage proof.
     **/
    MissingParachainHead: GenericPalletEvent<
      'BridgeKusamaParachains',
      'MissingParachainHead',
      {
        /**
         * Identifier of the parachain with missing head.
         **/
        parachain: BpPolkadotCoreParachainsParaId;
      }
    >;

    /**
     * The caller has provided parachain head hash that is not matching the hash read from the
     * storage proof.
     **/
    IncorrectParachainHeadHash: GenericPalletEvent<
      'BridgeKusamaParachains',
      'IncorrectParachainHeadHash',
      {
        /**
         * Identifier of the parachain with incorrect head hast.
         **/
        parachain: BpPolkadotCoreParachainsParaId;

        /**
         * Specified parachain head hash.
         **/
        parachainHeadHash: H256;

        /**
         * Actual parachain head hash.
         **/
        actualParachainHeadHash: H256;
      }
    >;

    /**
     * The caller has provided obsolete parachain head, which is already known to the pallet.
     **/
    RejectedObsoleteParachainHead: GenericPalletEvent<
      'BridgeKusamaParachains',
      'RejectedObsoleteParachainHead',
      {
        /**
         * Identifier of the parachain with obsolete head.
         **/
        parachain: BpPolkadotCoreParachainsParaId;

        /**
         * Obsolete parachain head hash.
         **/
        parachainHeadHash: H256;
      }
    >;

    /**
     * The caller has provided parachain head that exceeds the maximal configured head size.
     **/
    RejectedLargeParachainHead: GenericPalletEvent<
      'BridgeKusamaParachains',
      'RejectedLargeParachainHead',
      {
        /**
         * Identifier of the parachain with rejected head.
         **/
        parachain: BpPolkadotCoreParachainsParaId;

        /**
         * Parachain head hash.
         **/
        parachainHeadHash: H256;

        /**
         * Parachain head size.
         **/
        parachainHeadSize: number;
      }
    >;

    /**
     * Parachain head has been updated.
     **/
    UpdatedParachainHead: GenericPalletEvent<
      'BridgeKusamaParachains',
      'UpdatedParachainHead',
      {
        /**
         * Identifier of the parachain that has been updated.
         **/
        parachain: BpPolkadotCoreParachainsParaId;

        /**
         * Parachain head hash.
         **/
        parachainHeadHash: H256;
      }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `BridgeKusamaMessages`'s events
   **/
  bridgeKusamaMessages: {
    /**
     * Message has been accepted and is waiting to be delivered.
     **/
    MessageAccepted: GenericPalletEvent<
      'BridgeKusamaMessages',
      'MessageAccepted',
      {
        /**
         * Lane, which has accepted the message.
         **/
        laneId: BpMessagesLaneHashedLaneId;

        /**
         * Nonce of accepted message.
         **/
        nonce: bigint;
      }
    >;

    /**
     * Messages have been received from the bridged chain.
     **/
    MessagesReceived: GenericPalletEvent<'BridgeKusamaMessages', 'MessagesReceived', BpMessagesReceivedMessages>;

    /**
     * Messages in the inclusive range have been delivered to the bridged chain.
     **/
    MessagesDelivered: GenericPalletEvent<
      'BridgeKusamaMessages',
      'MessagesDelivered',
      {
        /**
         * Lane for which the delivery has been confirmed.
         **/
        laneId: BpMessagesLaneHashedLaneId;

        /**
         * Delivered messages.
         **/
        messages: BpMessagesDeliveredMessages;
      }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
  /**
   * Pallet `BridgeXcmOverMoonriver`'s events
   **/
  bridgeXcmOverMoonriver: {
    /**
     * The bridge between two locations has been opened.
     **/
    BridgeOpened: GenericPalletEvent<
      'BridgeXcmOverMoonriver',
      'BridgeOpened',
      {
        /**
         * Bridge identifier.
         **/
        bridgeId: BpXcmBridgeHubBridgeId;

        /**
         * Amount of deposit held.
         **/
        bridgeDeposit: bigint;

        /**
         * Universal location of local bridge endpoint.
         **/
        localEndpoint: StagingXcmV5Junctions;

        /**
         * Universal location of remote bridge endpoint.
         **/
        remoteEndpoint: StagingXcmV5Junctions;

        /**
         * Lane identifier.
         **/
        laneId: BpMessagesLaneHashedLaneId;
      }
    >;

    /**
     * Bridge is going to be closed, but not yet fully pruned from the runtime storage.
     **/
    ClosingBridge: GenericPalletEvent<
      'BridgeXcmOverMoonriver',
      'ClosingBridge',
      {
        /**
         * Bridge identifier.
         **/
        bridgeId: BpXcmBridgeHubBridgeId;

        /**
         * Lane identifier.
         **/
        laneId: BpMessagesLaneHashedLaneId;

        /**
         * Number of pruned messages during the close call.
         **/
        prunedMessages: bigint;

        /**
         * Number of enqueued messages that need to be pruned in follow up calls.
         **/
        enqueuedMessages: bigint;
      }
    >;

    /**
     * Bridge has been closed and pruned from the runtime storage. It now may be reopened
     * again by any participant.
     **/
    BridgePruned: GenericPalletEvent<
      'BridgeXcmOverMoonriver',
      'BridgePruned',
      {
        /**
         * Bridge identifier.
         **/
        bridgeId: BpXcmBridgeHubBridgeId;

        /**
         * Lane identifier.
         **/
        laneId: BpMessagesLaneHashedLaneId;

        /**
         * Amount of deposit released.
         **/
        bridgeDeposit: bigint;

        /**
         * Number of pruned messages during the close call.
         **/
        prunedMessages: bigint;
      }
    >;

    /**
     * Generic pallet event
     **/
    [prop: string]: GenericPalletEvent;
  };
}
